# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/syntax.md

---
title: Syntax
sidebar_position: 1
---

## Comments

Comments can be used to document code.
A comment is text that is not executed.

*Single-line comments* start with two slashes (`//`).
These comments can go on a line by themselves or they can go directly after a line of code.

```cadence
// This is a comment on a single line.
// Another comment line that is not executed.

let x = 1  // Here is another comment after a line of code.
```

*Multi-line comments* start with a slash and an asterisk (`/*`)
and end with an asterisk and a slash (`*/`):

```cadence
/* This is a comment which
spans multiple lines. */
```

Comments may be nested.

```cadence
/* /* this */ is a valid comment */
```

Multi-line comments are balanced.

```cadence
/* this is a // comment up to here */ this is not part of the comment */
```

### Documentation Comments
Documentation comments (also known as "doc-strings" or "doc-comment") are a special set of comments that can be
processed by tools, for example to generate human-readable documentation, or provide documentation in an IDE.

Doc-comments either start with three slashes (`///`) on each line,
or are surrounded by `/**` and `**/`.

```cadence
/// This is a documentation comment for `x`.
/// It spans multiple lines.

let x = 1
```

```cadence
/**
  This is a documentation comment
  which also spans multiple lines.
**/
```

## Identifiers

Identifiers may start with any upper or lowercase letter (A-Z, a-z)
or an underscore (`_`).
This may be followed by zero or more upper and lower case letters,
underscores, and numbers (0-9).
Identifiers may not begin with a number.

```cadence
// Valid: title-case
//
PersonID

// Valid: with underscore
//
token_name

// Valid: leading underscore and characters
//
_balance

// Valid: leading underscore and numbers
_8264

// Valid: characters and number
//
account2

// Invalid: leading number
//
1something

// Invalid: invalid character #
_#1

// Invalid: various invalid characters
//
!@#$%^&*
```

### Reserved identifiers

The following identifiers are reserved, as they are keywords of the language:

- `if`, `else`, `while`, `for`, `in`, `as`
- `break`, `continue`, `return`
- `true`, `false`, `nil`
- `let`, `var`
- `create`, `destroy`, `emit`
- `fun`, `pre`, `post`,
- `auth`, `access`
- `self`, `init`
- `contract`, `event`, `struct`, `resource`, `interface`,
  `entitlement`, `enum`, `mapping`, `attachment`, `result`
- `transaction`, `prepare`, `execute`
- `switch`, `case`, `default`
- `import`, `include`
- `require`, `requires`, `static`, `native`, `pub`, `priv`, `try`, `catch`, `finally`,
  `goto`, `const`, `export`, `throw`, `throws`, `where`, `final`, `internal`, `typealias`,
  `repeat`, `guard`, `is`

### Conventions

By convention, variables, constants, and functions have lowercase identifiers;
and types have title-case identifiers.

## Semicolons

Semicolons (;) are used as separators between declarations and statements.
A semicolon can be placed after any declaration and statement,
but can be omitted between declarations and if only one statement appears on the line.

Semicolons must be used to separate multiple statements if they appear on the same line.

```cadence
// Declare a constant, without a semicolon.
//
let a = 1

// Declare a variable, with a semicolon.
//
var b = 2;

// Declare a constant and a variable on a single line, separated by semicolons.
//
let d = 1; var e = 2
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/anti-patterns.md

---
title: Cadence Anti-Patterns
sidebar_position: 6
sidebar_label: Anti-Patterns
---

This is an opinionated list of issues that can be improved if they are found in Cadence code intended for production.

## Avoid using fully authorized account references as a function parameter

### Problem

A developer may choose to authenticate or perform operations for their users by using the users' account reference or addresses.
In order to do this, they might add a parameter to a function which has an authorized account reference type (`auth(...) &Account`),
as an authorized account reference can only be obtained by signing a transaction.

If it is a fully authorized account reference, this is problematic,
as the fully-authorized account reference allows access to some sensitive operations on the account,
for example, to write to storage, which provides the opportunity for bad actors to take advantage of.

### Example:

```cadence
...
// BAD CODE
// DO NOT COPY

// Imagine this code is in a contract that uses a `auth(Storage) &Account` parameter
// to authenticate users to transfer NFTs

// They could deploy the contract with an Ethereum-style access control list functionality

access(all)
fun transferNFT(id: UInt64, owner: auth(Storage) &Account) {
    assert(owner(id) == owner.address)

    transfer(id)
}

// But they could upgrade the function to have the same signature
// so it looks like it is doing the same thing, but they could also drain a little bit
// of FLOW from the user's vault, a totally separate piece of the account that
// should not be accessible in this function
// BAD

access(all)
fun transferNFT(id: UInt64, owner: auth(Storage) &Account) {
    assert(owner(id) == owner.address)

    transfer(id)

    // Sneakily borrow a reference to the user's Flow Token Vault
    // and withdraw a bit of FLOW
    // BAD
    let vaultRef = owner.borrow<&FlowToken.Vault>(/storage/flowTokenVault)!
    let stolenTokens <- vaultRef.withdraw(amount: 0.1)

    // deposit the stolen funds in the contract owners vault
    // BAD
    contractVault.deposit(from: <-stolenTokens)
}
...
```

### Solution

Projects should find other ways to authenticate users, such as using resources and capabilities as authentication objects.
They should also expect to perform most storage and linking operations within transaction bodies
rather than inside contract utility functions.

There are some scenarios where using an authorized account reference (`auth(...) &Account`) is necessary,
such as a cold storage multi-sig,
but those cases are rare and should only be used if it is a very restricted subset
of account functionality that is required.

## Public functions and fields should be avoided

### Problem

Be sure to keep track of access modifiers when structuring your code, and make public only what should be public.
Accidentally exposed fields can be a security hole.

### Solution

When writing your smart contract, look at every field and function and make sure
that require access through an [entitlement](./language/access-control.md#entitlements) (`access(E)`),
or use a non-public [access modifier](./language/access-control.md) like `access(self)`, `access(contract)`, or `access(account)`,
unless otherwise needed.

## Capability-Typed public fields are a security hole

This is a specific case of "Public Functions And Fields Should Be Avoided", above.

### Problem

The values of public fields can be copied. Capabilities are value types,
so if they are used as a public field, anyone can copy it from the field
and call the functions that it exposes.
This almost certainly is not what you want if a capability
has been stored as a field on a contract or resource in this way.

### Solution

For public access to a capability, place it in an accounts public area so this expectation is explicit.

## Public admin resource creation functions are unsafe

This is a specific case of "Public Functions And Fields Should Be Avoided", above.

### Problem

A public function on a contract that creates a resource can be called by any account.
If that resource provides access to admin functions then the creation function should not be public.

### Solution

To fix this, a single instance of that resource should be created in the contract's initializer,
and then a new creation function can be potentially included within the admin resource, if necessary.

### Example

```cadence
// Pseudo-code

// BAD
access(all)
contract Currency {

    access(all)
    resource Admin {

        access(all)
        fun mintTokens()
    }

    // Anyone in the network can call this function
    // And use the Admin resource to mint tokens
    access(all)
    fun createAdmin(): @Admin {
        return <-create Admin()
    }
}

// This contract makes the admin creation private and in the initializer
// so that only the one who controls the account can mint tokens
// GOOD
access(all)
contract Currency {

    access(all)
    resource Admin {

        access(all)
        fun mintTokens()

        // Only an admin can create new Admins
        access(all)
        fun createAdmin(): @Admin {
            return <-create Admin()
        }
    }

    init() {
        // Create a single admin resource
        let firstAdmin <- create Admin()

        // Store it in private account storage, so only the admin can use it
        self.account.storage.save(<-firstAdmin, to: /storage/currencyAdmin)
    }
}
```

## Do not modify smart contract state or emit events in public struct initializers

This is another example of the risks of having publicly accessible parts to your smart contract.

### Problem

Data structure definitions in Cadence currently must be declared as public so that they can be used by anyone.
Structs do not have the same restrictions that resources have on them,
which means that anyone can create a new instance of a struct without going through any authorization.

### Solution

Any contract state-modifying operations related to the creation of structs
should be contained in resources instead of the initializers of structs.

### Example

This used to be a bug in the NBA Top Shot smart contract, so we'll use that as an example.
Before, when it created a new play,
[it would initialize the play record with a struct,](https://github.com/dapperlabs/nba-smart-contracts/blob/55645478594858a6830e4ab095034068ef9753e9/contracts/TopShot.cdc#L155-L158)
which increments the number that tracks the play IDs and emits an event:

```cadence
// Simplified Code
// BAD
//
access(all)
contract TopShot {

    // The Record that is used to track every unique play ID
    access(all)
    var nextPlayID: UInt32

    access(all)
    struct Play {

        access(all)
        let playID: UInt32

        init() {

            self.playID = TopShot.nextPlayID

            // Increment the ID so that it isn't used again
            TopShot.nextPlayID = TopShot.nextPlayID + 1

            emit PlayCreated(id: self.playID, metadata: metadata)
        }
    }
}
```

This is a risk because anyone can create the `Play` struct as many times as they want,
which could increment the `nextPlayID` field to the max `UInt32` value,
effectively preventing new plays from being created. It also would emit bogus events.

This bug was fixed by
[instead updating the contract state in the admin function](https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc#L682-L685)
that creates the plays.


```cadence
// Update contract state in admin resource functions
// GOOD
//
access(all)
contract TopShot {

    // The Record that is used to track every unique play ID
    access(all)
    var nextPlayID: UInt32

    access(all)
    struct Play {

        access(all)
        let playID: UInt32

        init() {
            self.playID = TopShot.nextPlayID
        }
    }

    access(all)
    resource Admin {

        // Protected within the private admin resource
        access(all)
        fun createPlay() {
            // Create the new Play
            var newPlay = Play()

            // Increment the ID so that it isn't used again
            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)

            emit PlayCreated(id: newPlay.playID, metadata: metadata)

            // Store it in the contract storage
            TopShot.playDatas[newPlay.playID] = newPlay
        }
    }
}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/CONTRIBUTING.md

# Contributing to the cadence-lang.org website

The following is a set of guidelines for contributing to the cadence-lang.org website.
These are mostly guidelines, not rules.
Use your best judgment, and feel free to propose changes to this document in a pull request.

## Table Of Contents

[Getting Started](#project-overview)

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Your First Code Contribution](#your-first-code-contribution)
- [Pull Requests](#pull-requests)

[Additional Notes](#additional-notes)

## How Can I Contribute?

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported.
  If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible.
  When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**.
  Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples.
  If you're providing snippets in the issue,
  use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include error messages and stack traces** which show the output / crash and clearly demonstrate the problem.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens
  and under which conditions it normally happens.

Include details about your configuration and environment:

- **What is the version of the Cadence you're using**?
- **What's the name and version of the Operating System you're using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested.
  If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/).
Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**.
  Include copy/pasteable snippets which you use in those examples,
  as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Explain why this enhancement would be useful** to Cadence users.

### Your First Code Contribution

Unsure where to begin contributing to Cadence?
You can start by looking through these `good-first-issue` and `help-wanted` issues:

- [Good first issues][https://github.com/onflow/cadence/labels/good%20first%20issue]:
  issues which should only require a few lines of code, and a test or two.
- [Help wanted issues][https://github.com/onflow/cadence/labels/help%20wanted]:
  issues which should be a bit more involved than `good-first-issue` issues.

Both issue lists are sorted by total number of comments.
While not perfect, number of comments is a reasonable proxy for impact a given change will have.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users
- Engage the community in working toward the best possible Developer/User Experience
- Enable a sustainable system for the Cadence's maintainers to review contributions

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests,
or other changes before your pull request can be ultimately accepted.

## Additional Notes

Thank you for your interest in contributing!





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/events.md

---
title: Events
sidebar_position: 25
---

Events are special values that can be emitted during the execution of a program.

An event type can be declared with the `event` keyword.

```cadence
event FooEvent(x: Int, y: Int)
```

The syntax of an event declaration is similar to that of
a [function declaration](./functions.mdx#function-declarations);
events contain named parameters, each of which has an optional argument label.

Event parameters may only have a valid event parameter type.
Valid types are boolean, string, integer, arrays and dictionaries of these types,
and structures where all fields have a valid event parameter type.
Resource types are not allowed, because when a resource is used as an argument, it is moved.

Events can only be declared within a [contract](./contracts.mdx) body.
Events cannot be declared globally or within resource or struct types.

```cadence
// Invalid: An event cannot be declared globally
//
event GlobalEvent(field: Int)

access(all)
contract Events {
    // Event with explicit argument labels
    //
    event BarEvent(labelA fieldA: Int, labelB fieldB: Int)

    // Invalid: A resource type is not allowed to be used
    // because it would be moved and lost
    //
    event ResourceEvent(resourceField: @Vault)
}

```

### Emitting events

To emit an event from a program, use the `emit` statement:

```cadence
access(all)
contract Events {
    event FooEvent(x: Int, y: Int)

    // Event with argument labels
    event BarEvent(labelA fieldA: Int, labelB fieldB: Int)

    fun events() {
        emit FooEvent(x: 1, y: 2)

        // Emit event with explicit argument labels
        // Note that the emitted event will only contain the field names,
        // not the argument labels used at the invocation site.
        emit BarEvent(labelA: 1, labelB: 2)
    }
}
```

Emitting events has the following restrictions:

- Events can only be invoked in an `emit` statement.

  This means events cannot be assigned to variables or used as function parameters.

- Events can only be emitted from the location in which they are declared.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/transactions.md

---
title: Transactions
sidebar_position: 24
---

Transactions are objects that are signed with keys of one or more [accounts](./accounts/index.mdx)
and are sent to the chain to interact with it and perform state changes.

Transaction can [import](./imports.mdx) any number of types from any account using the import syntax.

```cadence
import FungibleToken from 0x01
```

A transaction is declared using the `transaction` keyword
and its contents are contained in curly braces.

The body of the transaction can declare local variables
that are valid throughout the whole of the transaction.

```cadence
transaction {
    // transaction contents
    let localVar: Int

    // ...
}
```

## Transaction parameters

Transactions can have parameters.
Transaction parameters are declared like function parameters.
The arguments for the transaction are passed along with the transaction.

Transaction parameters are accessible throughout the whole of the transaction.

```cadence
// Declare a transaction which has one parameter named `amount`
// that has the type `UFix64`
//
transaction(amount: UFix64) {

}
```

## Transaction phases

Transactions are executed in four phases:
preparation, pre-conditions, execution, and post-conditions, in that order.
The preparation and execution phases are blocks of code that execute sequentially.
The pre-conditions and post-condition are just like
[conditions in functions](./functions.mdx#function-preconditions-and-postconditions).

The following empty Cadence transaction has no logic,
but demonstrates the syntax for each phase, in the order these phases are executed:

```cadence
transaction {
    prepare(signer1: &Account, signer2: &Account) {
        // ...
    }

    pre {
        // ...
    }

    execute {
        // ...
    }

    post {
        // ...
    }
}
```

Although optional, each phase serves a specific purpose when executing a transaction
and it is recommended that developers use these phases when creating their transactions.

### Prepare phase

The `prepare` phase is used when the transaction needs access
to the accounts which signed (authorized) the transaction.

Access to the signing accounts is **only possible inside the `prepare` phase**.

For each signer of the transaction,
a [reference](./references.mdx) to the signing account is passed as an argument to the `prepare` phase.
The reference may be authorized, requesting certain [access to the account](./accounts/index.mdx#account-access).

For example, if the transaction has two signers,
the prepare **must** have two parameters of type `&Account`.

```cadence
prepare(signer1: &Account, signer2: &Account) {
    // ...
}
```

For instance, to request write access to an [account's storage](./accounts/storage.mdx),
the transaction can request an authorized reference:

```cadence
prepare(signer: auth(Storage) &Account) {
    // ...
}
```

As a best practice, only use the `prepare` phase to define and execute logic
that requires [write access](./accounts/index.mdx#performing-write-operations) to the signing accounts,
and *move all other logic elsewhere*.

Modifications to accounts can have significant implications,
so keep this phase clear of unrelated logic.
This ensures that users can easily read and understand the logic of the transaction
and how it affects their account.

The prepare phase serves a similar purpose as the
[initializer of a composite](https://developers.flow.com/next/cadence/language/composite-types#composite-type-fields).

For example, if a transaction performs a token transfer, put the withdrawal in the `prepare` phase,
as it requires access to the account storage, but perform the deposit in the `execute` phase.

### Pre-conditions

Transaction pre-conditions are just like
[pre-conditions of functions](./functions.mdx#function-preconditions-and-postconditions).

Pre-conditions are optional and are declared in a `pre` block.
They are executed after the `prepare` phase,
and are used for checking if explicit conditions hold before executing the remainder of the transaction.
The block can have zero or more conditions.

For example, a pre-condition might check the balance before transferring tokens between accounts.

```cadence
pre {
    sendingAccount.balance > 0
}
```

If any of the pre-conditions fail,
then the remainder of the transaction is not executed and it is completely reverted.

### Execute phase

The `execute` block executes the main logic of the transaction.
This phase is optional, but it is a best practice to add your main transaction logic in the section,
so it is explicit.

It is impossible to access the references to the transaction's signing accounts in the `execute` phase.

```cadence
transaction {
    prepare(signer: auth(LoadValue) &Account) {}

    execute {
        // Invalid: Cannot access the `signer` account reference, as it is not in scope
        let resource <- signer.storage.load<@Resource>(from: /storage/resource)
        destroy resource

        // Valid: Can obtain an unauthorized reference to any account
        let otherAccount = getAccount(0x3)
    }
}
```

### Post-conditions

Transaction post-conditions are just like
[post-conditions of functions](./functions.mdx#function-preconditions-and-postconditions).

Post-conditions are optional and are declared in a `post` block.
They are executed after the execution phase,
and are used to verify that the transaction logic has been executed properly.
The block can have zero or more conditions.

For example, a token transfer transaction can ensure that the final balance has a certain value:

```cadence
post {
    signer.balance == 30.0: "Balance after transaction is incorrect!"
}
```

If any of the post-conditions fail,
then the transaction fails and is completely reverted.

### Pre-conditions and post-conditions

Another function of the pre-conditions and post-conditions
is to describe the effects of a transaction on the involved accounts.
They are essential for users to verify what a transaction does before submitting it.
The conditions an easy way to introspect transactions before they are executed.

For example, the software that a user uses to sign and send a transaction
could analyze and interpret the transaction into a human-readable description, like
"This transaction will transfer 30 tokens from A to B.
The balance of A will decrease by 30 tokens and the balance of B will increase by 30 tokens."

## Summary

Transactions use phases to make the transaction's code / intent more readable.
They provide a way for developers to separate the transaction logic.
Transactions also provide a way to check the state prior / after transaction execution,
to prevent the transaction from running, or reverting changes made by the transaction if needed.

The following is a brief summary of how to use the `prepare`, `pre`, `execute`,
and `post` blocks in a transaction to implement the transaction's phases:

```cadence
transaction {
    prepare(signer1: &Account) {
        // Access signing accounts of the transaction.
        //
        // Avoid logic that does not need access to the signing accounts.
        //
        // The signing accounts can't be accessed anywhere else in the transaction.
    }

    pre {
        // Define conditions that must be true
        // for the transaction to execute.
        //
        // Define the expected state of things
        // as they should be before the transaction is executed.
    }

    execute {
        // The main transaction logic goes here, but you can access
        // any public information or resources published by any account.
    }

    post {
        // Define conditions that must be true
        // for the transaction to be committed.
        //
        // Define the expected state of things
        // as they should be after the transaction executed.
        //
        // Also used to provide information about what changes
        // the transaction will make to the signing accounts.
    }
}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/README.md

# cadence-lang.org


## Technical

cadence-lang.org uses [Docusaurus2](https://docusaurus.io).

### Running locally

Requirements:

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/en)

To run the site locally, enter the following commands into a terminal window:

```sh
git clone https://github.com/onflow/cadence-lang.org.git
cd cadence-lang.org
npm i
npm run start
open "http://localhost:3000"
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/08-marketplace-compose.md

---
title: 8. Marketplace
---

In this tutorial, we're going to create a marketplace that uses both the fungible
and non-fungible token (NFTs) contracts that we have learned about in previous tutorials.
This is only for educational purposes and is not meant to be used in production
See a production-ready marketplace in the [NFT storefront repo.](https://github.com/onflow/nft-storefront)
This contract is already deployed to testnet and mainnet and can be used by anyone for any generic NFT sale!

---

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:
<a
href="https://play.flow.com/7355d51c-066b-46be-adab-a3da6c28b645"
target="_blank"
>
https://play.flow.com/7355d51c-066b-46be-adab-a3da6c28b645
</a>
The tutorial will be asking you to take various actions to interact with this code.
[The marketplace setup guide](./07-marketplace-setup.md) shows you how to get the playground set up to do this tutorial.

:::

:::info[Action]

Instructions that require you to take action are always included in a callout box like this one.
These highlighted actions are all that you need to do to get your code running,
but reading the rest is necessary to understand the language's design.

:::

Marketplaces are a popular application of blockchain technology and smart contracts.
When there are NFTs in existence, users usually want to be able to buy and sell them with their fungible tokens.

Now that there is an example for both fungible and non-fungible tokens,
we can build a marketplace that uses both. This is referred to as **composability**:
the ability for developers to leverage shared resources, such as code or userbases,
and use them as building blocks for new applications.

Flow is designed to enable composability because of the way that interfaces, resources and capabilities are designed.

- [Interfaces](../language/interfaces.mdx) allow projects to support any generic type as long as it supports a standard set of functionality specified by an interface.
- [Resources](../language/resources.mdx) can be passed around and owned by accounts, contracts or even other resources, unlocking different use cases depending on where the resource is stored.
- [Capabilities](../language/capabilities.md) allow exposing user-defined sets of functionality through special objects that enforce strict security with Cadence's type system.

The combination of these allows developers to do more with less, re-using known safe code and design patterns
to create new, powerful, and unique interactions!

:::info[Action]

At some point before or after this tutorial, you should definitely check out the formal documentation
linked above about interfaces, resources, and capabilities. It will help complete your understanding
of these complex, but powerful features.

:::

To create a marketplace, we need to integrate the functionality of both fungible
and non-fungible tokens into a single contract that gives users control over their money and assets.
To accomplish this, we're going to take you through these steps to create a composable smart contract and get comfortable with the marketplace:

1. Ensure that your fungible token and non-fungible token contracts are deployed and set up correctly.
2. Deploy the marketplace type declarations to account `0x08`.
3. Create a marketplace object and store it in your account storage, putting an NFT up for sale and publishing a public capability for your sale.
4. Use a different account to purchase the NFT from the sale.
5. Run a script to verify that the NFT was purchased.

**Before proceeding with this tutorial**, you need to complete the [Fungible Tokens](./06-fungible-tokens.md)
and [Non-Fungible Token](./05-non-fungible-tokens-1.md) tutorials
to understand the building blocks of this smart contract.

## Marketplace Design

---

One way to implement a marketplace is to have a central smart contract that users deposit their NFTs and their price into,
and have anyone come by and be able to buy the token for that price.
This approach is reasonable, but it centralizes the process and takes away options from the owners.
We want users to be able to maintain ownership of the NFTs that they are trying to sell while they are trying to sell them.

Instead of taking this centralized approach, each user can list a sale from within their own account.

Then, users could either provide a link to their sale to an application that can list it centrally on a website,
or to a central sale aggregator smart contract if they want the entire transaction to stay on-chain.
This way, the owner of the token keeps custody of their token while it is on sale.

:::info[Action]

Before we start, we need to confirm the state of your accounts.

If you haven't already, please perform the steps in the [marketplace setup guide](./07-marketplace-setup.md)
to ensure that the Fungible Token and Non-Fungible Token contracts are deployed to account 6 and 2 and own some tokens.

Your accounts should look like this:

:::

<img src="https://storage.googleapis.com/flow-resources/documentation-assets/cadence-tuts/accounts-nft-storage.png" />

:::info[Action]

You can run the `1. Check Setup` script to ensure that your accounts are correctly set up:

:::

```cadence CheckSetupScript.cdc
// CheckSetupScript.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07

/// Allows the script to return the ownership info
/// of all the accounts
access(all) struct OwnerInfo {
  access(all) let acct6Balance: UFix64
  access(all) let acct7Balance: UFix64

  access(all) let acct6IDs: [UInt64]
  access(all) let acct7IDs: [UInt64]

  init(balance1: UFix64, balance2: UFix64, acct6IDs: [UInt64], acct7IDs: [UInt64]) {
    self.acct6Balance = balance1
    self.acct7Balance = balance2
    self.acct6IDs = acct6IDs
    self.acct7IDs = acct7IDs
  }
}

// This script checks that the accounts are set up correctly for the marketplace tutorial.
//
// Account 0x06: Vault Balance = 40, NFT.id = 1
// Account 0x07: Vault Balance = 20, No NFTs
access(all) fun main(): OwnerInfo {
    // Get the accounts' public account objects
    let acct6 = getAccount(0x06)
    let acct7 = getAccount(0x07)

    // Get references to the account's receivers
    // by getting their public capability
    // and borrowing a reference from the capability
    let acct6ReceiverRef = acct6.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x06's ExampleToken.Vault")
                     .concat(". Make sure 0x06 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let acct7ReceiverRef = acct7.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x07's ExampleToken.Vault")
                     .concat(". Make sure 0x07 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let returnArray: [UFix64] = []

    // verify that the balances are correct
    if acct6ReceiverRef.balance != 40.0 || acct7ReceiverRef.balance != 20.0 {
        panic("Wrong balances!")
    }

    // Find the public Receiver capability for their Collections
    let acct6Capability = acct6.capabilities.get<&{ExampleNFT.NFTReceiver}>(ExampleNFT.CollectionPublicPath)
    let acct7Capability = acct7.capabilities.get<&{ExampleNFT.NFTReceiver}>(ExampleNFT.CollectionPublicPath)

    // borrow references from the capabilities
    let nft1Ref = acct6Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x06's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x06 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    let nft2Ref = acct7Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x07's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x07 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    // verify that the collections are correct
    if nft1Ref.getIDs()[0] != 1 || nft2Ref.getIDs().length != 0 {
        panic("Wrong Collections!")
    }

    // Return the struct that shows the account ownership info
    return OwnerInfo(balance1: acct6ReceiverRef.balance,
                     balance2: acct7ReceiverRef.balance,
                     acct6IDs: nft1Ref.getIDs(),
                     acct7IDs: nft2Ref.getIDs())
}
```

You should see something similar to this output if your accounts are set up correctly.
They are in the same state that they would have been in if you followed
the [Fungible Tokens](./06-fungible-tokens.md)
and [Non-Fungible Tokens](./05-non-fungible-tokens-1.md) tutorials in succession:

```
"Account 6 Balance"
40.00000000
"Account 7 Balance"
20.00000000
"Account 6 NFTs"
[1]
"Account 7 NFTs"
[]
```

Now that your accounts are in the correct state, we can build a marketplace that enables the sale of NFT's between accounts.

## Setting up an NFT **Marketplace**

---

Every user who wants to sell an NFT will store an instance of a `@SaleCollection` resource in their account storage.

Time to deploy the marketplace contract:

:::info[Action]

1. Switch to the ExampleMarketplace contract (Contract 3).
2. With `ExampleMarketplace.cdc` open, select account `0x08` from the deployment modal in the bottom right and deploy.

:::

`ExampleMarketplace.cdc` should contain the following contract definition:

```cadence ExampleMarketplace.cdc
import ExampleToken from 0x06
import ExampleNFT from 0x07

// ExampleMarketplace.cdc
//
// The ExampleMarketplace contract is a very basic sample implementation of an NFT ExampleMarketplace on Flow.
//
// This contract allows users to put their NFTs up for sale. Other users
// can purchase these NFTs with fungible tokens.
//
// Learn more about marketplaces in this tutorial: https://developers.flow.com/cadence/tutorial/marketplace-compose
//
// This contract is a learning tool and is not meant to be used in production.
// See the NFTStorefront contract for a generic marketplace smart contract that
// is used by many different projects on the Flow blockchain:
//
// https://github.com/onflow/nft-storefront

access(all) contract ExampleMarketplace {

    // Event that is emitted when a new NFT is put up for sale
    access(all) event ForSale(id: UInt64, price: UFix64, owner: Address?)

    // Event that is emitted when the price of an NFT changes
    access(all) event PriceChanged(id: UInt64, newPrice: UFix64, owner: Address?)

    // Event that is emitted when a token is purchased
    access(all) event TokenPurchased(id: UInt64, price: UFix64, seller: Address?, buyer: Address?)

    // Event that is emitted when a seller withdraws their NFT from the sale
    access(all) event SaleCanceled(id: UInt64, seller: Address?)

    access(all) entitlement Owner

    // SaleCollection
    //
    // NFT Collection object that allows a user to put their NFT up for sale
    // where others can send fungible tokens to purchase it
    //
    access(all) resource SaleCollection  {

        /// A capability for the owner's collection
        access(self) var ownerCollection: Capability<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>

        // Dictionary of the prices for each NFT by ID
        access(self) var prices: {UInt64: UFix64}

        // The fungible token vault of the owner of this sale.
        // When someone buys a token, this resource can deposit
        // tokens into their account.
        access(account) let ownerVault: Capability<&{ExampleToken.Receiver}>

        init (ownerCollection: Capability<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>,
              ownerVault: Capability<&{ExampleToken.Receiver}>) {

            pre {
                // Check that the owner's collection capability is correct
                ownerCollection.check():
                    "ExampleMarketplace.SaleCollection.init: "
                    .concat("Owner's NFT Collection Capability is invalid! ")
                    .concat("Make sure the owner has set up an `ExampleNFT.Collection` ")
                    .concat("in their account and provided a valid capability")

                // Check that the fungible token vault capability is correct
                ownerVault.check():
                    "ExampleMarketplace.SaleCollection.init: "
                    .concat("Owner's Receiver Capability is invalid! ")
                    .concat("Make sure the owner has set up an `ExampleToken.Vault` ")
                    .concat("in their account and provided a valid capability")
            }
            self.ownerCollection = ownerCollection
            self.ownerVault = ownerVault
            self.prices = {}
        }

        // cancelSale gives the owner the opportunity to cancel a sale in the collection
        access(Owner) fun cancelSale(tokenID: UInt64) {
            // remove the price
            self.prices.remove(key: tokenID)
            self.prices[tokenID] = nil

            // Nothing needs to be done with the actual token because it is already in the owner's collection
        }

        // listForSale lists an NFT for sale in this collection
        access(Owner) fun listForSale(tokenID: UInt64, price: UFix64) {
            pre {
                self.ownerCollection.borrow()!.idExists(id: tokenID):
                    "ExampleMarketplace.SaleCollection.listForSale: "
                    .concat("Cannot list token ID ").concat(tokenID.toString())
                    .concat(" . This NFT ID is not owned by the seller.")
                    .concat("Make sure an ID exists in the sellers NFT Collection")
                    .concat(" before trying to list it for sale")
            }
            // store the price in the price array
            self.prices[tokenID] = price

            emit ForSale(id: tokenID, price: price, owner: self.owner?.address)
        }

        // changePrice changes the price of a token that is currently for sale
        access(Owner) fun changePrice(tokenID: UInt64, newPrice: UFix64) {
            self.prices[tokenID] = newPrice

            emit PriceChanged(id: tokenID, newPrice: newPrice, owner: self.owner?.address)
        }

        // purchase lets a user send tokens to purchase an NFT that is for sale
        access(all) fun purchase(tokenID: UInt64,
                                 recipient: Capability<&ExampleNFT.Collection>, buyTokens: @ExampleToken.Vault) {
            pre {
                self.prices[tokenID] != nil:
                    "ExampleMarketplace.SaleCollection.purchase: "
                    .concat("Cannot purchase NFT with ID ")
                    .concat(tokenID.toString())
                    .concat(" There is not an NFT with this ID available for sale! ")
                    .concat("Make sure the ID to purchase is correct.")
                buyTokens.balance >= (self.prices[tokenID] ?? 0.0):
                    "ExampleMarketplace.SaleCollection.purchase: "
                    .concat(" Cannot purchase NFT with ID ")
                    .concat(tokenID.toString())
                    .concat(" The amount provided to purchase (")
                    .concat(buyTokens.balance.toString())
                    .concat(") is less than the price of the NFT (")
                    .concat(self.prices[tokenID]!.toString())
                    .concat("). Make sure the ID to purchase is correct and ")
                    .concat("the correct amount of tokens have been used to purchase.")
                recipient.borrow != nil:
                    "ExampleMarketplace.SaleCollection.purchase: "
                    .concat(" Cannot purchase NFT with ID ")
                    .concat(tokenID.toString())
                    .concat(". The buyer's NFT Collection Capability is invalid.")
            }

            // get the value out of the optional
            let price = self.prices[tokenID]!

            self.prices[tokenID] = nil

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")

            // deposit the purchasing tokens into the owners vault
            vaultRef.deposit(from: <-buyTokens)

            // borrow a reference to the object that the receiver capability links to
            // We can force-cast the result here because it has already been checked in the pre-conditions
            let receiverReference = recipient.borrow()!

            // deposit the NFT into the buyers collection
            receiverReference.deposit(token: <-self.ownerCollection.borrow()!.withdraw(withdrawID: tokenID))

            emit TokenPurchased(id: tokenID, price: price, seller: self.owner?.address, buyer: receiverReference.owner?.address)
        }

        // idPrice returns the price of a specific token in the sale
        access(all) view fun idPrice(tokenID: UInt64): UFix64? {
            return self.prices[tokenID]
        }

        // getIDs returns an array of token IDs that are for sale
        access(all) view fun getIDs(): [UInt64] {
            return self.prices.keys
        }
    }

    // createCollection returns a new collection resource to the caller
    access(all) fun createSaleCollection(
        ownerCollection: Capability<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>,
        ownerVault: Capability<&{ExampleToken.Receiver}>
    ): @SaleCollection
    {
        return <- create SaleCollection(ownerCollection: ownerCollection, ownerVault: ownerVault)
    }
}
```

This marketplace contract has resources that function similarly to the NFT `Collection`
that was explained in [Non-Fungible Tokens](./05-non-fungible-tokens-1.md), with a few differences and additions:

- This marketplace contract has methods to add and remove NFTs, but instead of storing the NFT resource object in the sale collection,
  the user provides a capability to their main collection that allows the listed NFT to be withdrawn and transferred when it is purchased.
  When a user wants to put their NFT up for sale, they do so by providing the ID and the price to the `listForSale()` function.
  Then, another user can call the `purchase()` function, sending their `ExampleToken.Vault` that contains the currency they are using to make the purchase.
  The buyer also includes a capability to their NFT `ExampleNFT.Collection` so that the purchased token
  can be immediately deposited into their collection when the purchase is made.
- This marketplace contract stores a capability: `access(all) let ownerVault: Capability<&{FungibleToken.Receiver}>`.
  The owner of the sale saves a capability to their Fungible Token `Receiver` within the sale.
  This allows the sale resource to be able to immediately deposit the currency that was used to buy the NFT
  into the owners `Vault` when a purchase is made.
- This marketplace contract includes events. Cadence supports defining events within contracts
  that can be emitted when important actions happen. External apps can monitor these events to know the state of the smart contract.

```cadence
    // Event that is emitted when a new NFT is put up for sale
    access(all) event ForSale(id: UInt64, price: UFix64, owner: Address?)

    // Event that is emitted when the price of an NFT changes
    access(all) event PriceChanged(id: UInt64, newPrice: UFix64, owner: Address?)

    // Event that is emitted when a token is purchased
    access(all) event TokenPurchased(id: UInt64, price: UFix64, seller: Address?, buyer: Address?)

    // Event that is emitted when a seller withdraws their NFT from the sale
    access(all) event SaleCanceled(id: UInt64, seller: Address?)
```

This contract has a few new features and concepts that are important to cover:

### Events

[Events](../language/events.md) are special values that can be emitted during the execution of a program.
They usually contain information to indicate that some important action has happened in a smart contract,
such as an NFT transfer, a permission change, or many other different things.
Off-chain applications can monitor events using a Flow SDK to know what is happening on-chain without having to query a smart contract directly.

Many applications want to maintain an off-chain record of what is happening on-chain so they can have faster performance
when getting information about their users' accounts or generating analytics.

Events are declared by indicating [the access level](../language/access-control.md), `event`,
and the name and parameters of the event, like a function declaration:
```cadence
access(all) event ForSale(id: UInt64, price: UFix64, owner: Address?)
```

Events cannot modify state at all; they indicate when important actions happen in the smart contract.

Events are emitted with the `emit` keyword followed by the invocation of the event as if it were a function call.
```cadence
emit ForSale(id: tokenID, price: price, owner: self.owner?.address)
```

External applications can monitor the blockchain to take action when certain events are emitted.

### Resource-Owned Capabilities

We have covered capabilities in previous [tutorials](./04-capabilities.md),
but only the basics. Capabilities can be used for so much more!

As you hopefully understand, [capabilites](../language/capabilities.md)
are links to private objects in account storage that specify and expose
a subset of the resource they are linked to.

To create a capability, a user typically uses [the `account.capabilities.storage.issue`](../language/accounts)
method to create a link to a resource in their private storage, specifying a type to link the capability as:

```cadence
let cap = acct.capabilities.storage.issue<&ExampleNFT.Collection>(ExampleNFT.CollectionStoragePath)
```

After that, the owner can publish the capability to a public path in their account:

```cadence
acct.capabilities.publish(cap, at: ExampleNFT.CollectionPublicPath)
```

Then, users can get that capability from [the public path](../language/accounts/paths.mdx),
borrow it, and access the functionality that the owner specified.

```cadence
// Get the account object for address 0x06
let publicAccount = getAccount(0x06)

// Retrieve a Vault Receiver Capability from the account's public storage
let acct6Capability = acct.capabilities.get<&{ExampleToken.Receiver}>(
        ExampleToken.VaultPublicPath
    )

// Borrow a reference
let acct6ReceiverRef = acct6Capability.borrow()
    ?? panic("Account 0x06's Receiver Capability is invalid! ")
            .concat("Make sure the owner has set up an `ExampleToken.Vault` ")
            .concat("in their account and provided a valid capability")

// Deposit tokens
acct6ReceiverRef.deposit(from: <-tokens)
```

With the marketplace contract, we are utilizing a new feature of capabilities.
Capabilities can be stored anywhere! Lots of functionality is contained within resources,
and developers will sometimes want to be able to access some of the functionality of resources from within different resources or contracts.

We store two different capabilities in the marketplace sale collection:

```cadence
/// A capability for the owner's collection
access(self) var ownerCollection: Capability<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>

// The fungible token vault of the owner of this sale.
// When someone buys a token, this resource can deposit
// tokens into their account.
access(account) let ownerVault: Capability<&{ExampleToken.Receiver}>
```

If an object like a contract or resource owns a capability, they can borrow a reference to that capability at any time
to access that functionality without having to get it from the owner's account every time.

This is especially important if the owner wants to expose some functionality that is only intended for one person,
meaning that the link for the capability is not stored in a public path.
We do that in this example, because the sale collection stores a capability
that can access the withdraw functionality
of the `ExampleNFT.Collection` with the `ExampleNFT.Withdraw` entitlement.
It needs this because it withdraws the specified NFT in the `purchase()` method to send to the buyer.

It is important to remember that control of a capability does not equal ownership of the underlying resource.
You can use the capability to access that resource's functionality, but you can't use it to fake ownership.
You need the actual resource (identified by the prefixed `@` symbol) to prove ownership.

Additionally, these capabilities can be stored anywhere, but if a user decides that they no longer want the capability
to be used, they can revoke it by getting the controller for the capability
from their account with the `getControllers` method and delete the capability with `delete`.
Here is an example that deletes all the controllers for a specified storage path:
```cadence
let controllers = self.account.capabilities.storage.getControllers(forPath: storagePath)
for controller in controllers {
    controller.delete()
}
After this, any capabilities that use that storage path are rendered invalid.

One last piece to consider about capabilities is the decision about
when to use them instead of storing the resource directly.
This tutorial used to have the `SaleCollection` directly store the NFTs that were for sale, like so:

```cadence
access(all) resource SaleCollection {

    /// Dictionary of NFT objects for sale
    /// Maps ID to NFT resource object
    /// Not recommended
    access(self) var forSale: @{UInt64: ExampleNFT.NFT}
}
```

This is a logical way to do it, and illustrates another important concept in Cadence, that resources can own other resources!
Check out the [Kitty Hats tutorial](./10-resources-compose.md) for a little more exploration of this concept.

In this case however, nesting resources doesn't make sense. If a user decides to store their for-sale NFTs in a separate place from their main collection,
then those NFTs are not available to be shown to any app or smart contract that queries the main collection,
so it is as if the owner doesn't actually own the NFT!

In cases like this, we usually recommend using a capability to the main collection so that the main collection can remain unchanged and fully usable by
other smart contracts and apps. This also means that if a for-sale NFT gets transferred by some means other than a purchase, then you need a way to get
rid of the stale listing. That is out of the scope of this tutorial though.

Enough explaining! Lets execute some code!

## Using the Marketplace

At this point, we should have an `ExampleToken.Vault` and an `Example.NFT.Collection` in both accounts' storage.
Account `0x06` should have an NFT in their collection and the `ExampleMarketplace` contract should be deployed to `0x08`.

You can create a `SaleCollection` and list account `0x06`'s token for sale by following these steps:

:::info[Action]

1. Open Transaction 4, `Create Sale`
2. Select account `0x06` as the only signer and click the `Send` button to submit the transaction.

:::

```cadence Transaction4.cdc
// CreateSale.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07
import ExampleMarketplace from 0x08

// This transaction creates a new Sale Collection object,
// lists an NFT for sale, puts it in account storage,
// and creates a public capability to the sale so that others can buy the token.
transaction {

    prepare(acct: auth(SaveValue, StorageCapabilities) &Account) {

        // Borrow a reference to the stored Vault
        let receiver = acct.capabilities.get<&{ExampleToken.Receiver}>(ExampleToken.VaultPublicPath)

        // Create an entitled capability to the NFT Collection
        let collectionCapability = acct.capabilities.storage.issue
                                   <auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>
                                   (ExampleNFT.CollectionStoragePath)

        // Create a new Sale object,
        // initializing it with the reference to the owner's vault
        let sale <- ExampleMarketplace.createSaleCollection(ownerCollection: collectionCapability, ownerVault: receiver)

        // List the token for sale by moving it into the sale object
        sale.listForSale(tokenID: 1, price: 10.0)

        // Store the sale object in the account storage
        acct.storage.save(<-sale, to: /storage/NFTSale)

        // Create a public capability to the sale so that others can call its methods
        acct.capabilities.storage.issue<&ExampleMarketplace.SaleCollection>(/public/NFTSale, target: /storage/NFTSale)

        log("Sale Created for account 6. Selling NFT 1 for 10 tokens")
    }
}
```

This transaction:

1. Gets a `Receiver` capability on the owners `Vault`.
1. Creates a private entitled `ExampleNFT.Collection` Capability from the owner.
1. Creates the `SaleCollection`, which stores their `Vault` and `ExampleNFT.Collection` capabilities.
1. Lists the token with `ID = 1` for sale and sets its price as 10.0.
1. Stores the `SaleCollection` in their account storage and links a public capability that allows others to purchase any NFTs for sale.

Let's run a script to ensure that the sale was created correctly.

1. Open Script 2: `GetSaleIDs.cdc`
1. Click the `Execute` button to print the ID and price of the NFT that account `0x06` has for sale.

```cadence GetSaleIDs.cdc
// GetSaleIDs.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07
import ExampleMarketplace from 0x08

// This script returns the NFTs that account 0x06 has for sale.
access(all)
fun main(): [UInt64] {
    // Get the public account object for account 0x06
    let account1 = getAccount(0x06)

    // Find the public Sale reference to their Collection
    let acct6saleRef = account1.capabilities.get<&ExampleMarketplace.SaleCollection>(/public/NFTSale)>
                       .borrow()
        ?? panic("Could not borrow a reference to the SaleCollection capability for account 0x06 ")
            .concat("at path /public/NFTSale. ")
            .concat("Make sure the owner has set up the SaleCollection ")
            .concat("in their account with the Create Sale transaction")

    // Return the NFT IDs that are for sale
    return acct6saleRef.getIDs()
}
```

This script should complete and print something like this:

```
[1]
```

## Purchasing an NFT

---

The buyer can now purchase the seller's NFT by using the transaction in `Transaction2.cdc`:

:::info[Action]

1. Open Transaction 5: `PurchaseSale.cdc` file
2. Select account `0x07` as the only signer and click the `Send` button

:::

```cadence PurchaseSale.cdc
// PurchaseSale.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07
import ExampleMarketplace from 0x08

// This transaction uses the signers Vault tokens to purchase an NFT
// from the Sale collection of account 0x06.
transaction {

    // Capability to the buyer's NFT collection where they
    // will store the bought NFT
    let collectionCapability: Capability<&ExampleNFT.Collection>

    // Vault that will hold the tokens that will be used to
    // but the NFT
    let temporaryVault: @ExampleToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {

        // get the references to the buyer's fungible token Vault and NFT Collection Receiver
        self.collectionCapability = acct.capabilities.get<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)

        let vaultRef = acct.storage.borrow<&ExampleToken.Vault>(from: /storage/CadenceFungibleTokenTutorialVault)
            ?? panic("Could not borrow a reference to "
                     .concat("0x07's ExampleToken.Vault")
                     .concat(". Make sure 0x07 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

        // withdraw tokens from the buyers Vault
        self.temporaryVault <- vaultRef.withdraw(amount: 10.0)
    }

    execute {
        // get the read-only account storage of the seller
        let seller = getAccount(0x06)

        // get the reference to the seller's sale
        let saleRef = seller.capabilities.get<&ExampleMarketplace.SaleCollection>(/public/NFTSale)
                            .borrow()
            ?? panic("Could not borrow a reference to "
                     .concat("0x06's ExampleMarketplace.SaleCollection")
                     .concat(". Make sure 0x06 has set up its account ")
                     .concat("with an ExampleMarketplace SaleCollection and valid capability."))

        // purchase the NFT the seller is selling, giving them the capability
        // to your NFT collection and giving them the tokens to buy it
        saleRef.purchase(tokenID: 1, recipient: self.collectionCapability, buyTokens: <-self.temporaryVault)
    }
}
```

This transaction:

1. Gets the capability to the buyer's NFT receiver
1. Get a reference to their token vault and withdraws the sale purchase amount
1. Gets the public account object for account `0x06`
1. Gets the reference to the seller's public sale
1. Calls the `purchase` function, passing in the tokens and the `Collection` reference. Then `purchase` deposits the bought NFT directly into the buyer's collection.

## Verifying the NFT Was Purchased Correctly

---

You can run now run a script to verify that the NFT was purchased correctly because:

- account `0x06` has 50 tokens and does not have any NFTs for sale or in their collection and account
- account `0x07` has 10 tokens and an NFT with id=1

To run a script that verifies the NFT was purchased correctly, follow these steps:

:::info[Action]

1. Open Script 3: `VerifyAfterPurchase.cdc`
2. Click the `Execute` button

:::

`VerifyAfterPurchase.cdc` should contain the following code:

```cadence Script3.cdc
// VerifyAfterPurchase
import ExampleToken from 0x06
import ExampleNFT from 0x07

/// Allows the script to return the ownership info
/// of all the accounts
access(all) struct OwnerInfo {
  access(all) let acct6Balance: UFix64
  access(all) let acct7Balance: UFix64

  access(all) let acct6IDs: [UInt64]
  access(all) let acct7IDs: [UInt64]

  init(balance1: UFix64, balance2: UFix64, acct6IDs: [UInt64], acct7IDs: [UInt64]) {
    self.acct6Balance = balance1
    self.acct7Balance = balance2
    self.acct6IDs = acct6IDs
    self.acct7IDs = acct7IDs
  }
}

// This script checks that the accounts are in the correct state after purchasing a listing.
//
// Account 0x06: Vault Balance = 50, No NFTs
// Account 0x07: Vault Balance = 10, NFT.id = 1
access(all) fun main(): OwnerInfo {
    // Get the accounts' public account objects
    let acct6 = getAccount(0x06)
    let acct7 = getAccount(0x07)

    // Get references to the account's receivers
    // by getting their public capability
    // and borrowing a reference from the capability
    let acct6ReceiverRef = acct6.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x06's ExampleToken.Vault")
                     .concat(". Make sure 0x06 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let acct7ReceiverRef = acct7.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x07's ExampleToken.Vault")
                     .concat(". Make sure 0x07 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let returnArray: [UFix64] = []

    // verify that the balances are correct
    if acct6ReceiverRef.balance != 50.0 || acct7ReceiverRef.balance != 10.0 {
        panic("Wrong balances! Account 6 Balance should be 50 and Account 7 balance should be 10.")
    }

    // Find the public Receiver capability for their Collections
    let acct6Capability = acct6.capabilities.get<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)
    let acct7Capability = acct7.capabilities.get<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)

    // borrow references from the capabilities
    let nft1Ref = acct6Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x06's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x06 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    let nft2Ref = acct7Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x07's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x07 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    // verify that the collections are correct
    if nft2Ref.getIDs()[0] != 1 || nft1Ref.getIDs().length != 0 {
        panic("Wrong Collections! Account 6 should own zero NFTs and account 7 should own one.")
    }

    // Return the struct that shows the account ownership info
    return OwnerInfo(balance1: acct6ReceiverRef.balance,
                     balance2: acct7ReceiverRef.balance,
                     acct6IDs: nft1Ref.getIDs(),
                     acct7IDs: nft2Ref.getIDs())
}
```

If you did everything correctly, the transaction should succeed and it should print something similar to this:

```
"account 6 Vault Balance"
50
"account 7 Vault Balance"
10
"account 6 NFTs"
[]
"account 7 NFTs"
[1]
```

Congratulations, you have successfully implemented a simple marketplace in Cadence and used it to allow one account to buy an NFT from another!

## Scaling the Marketplace

---

A user can hold a sale in their account with these resources and transactions.
Support for a central marketplace where users can discover sales is relatively easy to implement and can build on what we already have.
If we wanted to build a central marketplace on-chain, we could use a contract that looks something like this:

```cadence CentralMarketplace.cdc
// Marketplace would be the central contract where people can post their sale
// references so that anyone can access them
access(all) contract Marketplace {
    // Data structure to store active sales
    access(all) var tokensForSale: {Address: Capability<&SaleCollection>)}

    // listSaleCollection lists a users sale reference in the array
    // and returns the index of the sale so that users can know
    // how to remove it from the marketplace
    access(all) fun listSaleCollection(collection: Capability<&SaleCollection>) {
        let saleRef = collection.borrow()
        ?? panic("Could not borrow a reference to the SaleCollection capability ")
            .concat("Make sure the owner has set up the SaleCollection ")
            .concat("in their account and provided a valid capability")

        self.tokensForSale[saleRef.owner!.address] = collection
    }

    // removeSaleCollection removes a user's sale from the array
    // of sale references
    access(all) fun removeSaleCollection(owner: Address) {
        self.tokensForSale[owner] = nil
    }

}
```

This contract isn't meant to be a working or production-ready contract, but it could be extended to make a complete central marketplace by having:

- Sellers list a capability to their `SaleCollection` in this contract
- Other functions that buyers could call to get info about all the different sales and to make purchases.

A central marketplace in an off-chain application is easier to implement because:

- The app could host the marketplace and a user would simply log in to the app and give the app its account address.
- The app could read the user's public storage and find their sale reference.
- With the sale reference, the app could get all the information they need about how to display the sales on their website.
- Any buyer could discover the sale in the app and login with their account, which gives the app access to their public references.
- When the buyer wants to buy a specific NFT, the app would automatically generate the proper transaction to purchase the NFT from the seller.

## Creating a **Marketplace for Any Generic NFT**

---

The previous examples show how a simple marketplace could be created for a specific class of NFTs.
However, users will want to have a marketplace where they can buy and sell any NFT they want, regardless of its type.
There are a few good examples of generic marketplaces on Flow right now.

- The Flow team has created a completely decentralized example of a generic marketplace in the [NFT storefront repo.](https://github.com/onflow/nft-storefront)
  This contract is already deployed to testnet and mainnet and can be used by anyone for any generic NFT sale!


## Composable Resources on Flow

---

Now that you have an understanding of how composable smart contracts and the marketplace work on Flow, you're ready to play with composable resources!
Check out the [Kitty Hats tutorial!](./10-resources-compose.md)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/CODE_OF_CONDUCT.md


# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at <community@onflow.org>.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/type-safety.md

---
title: Type Safety
sidebar_position: 9
---

The Cadence programming language is a *type-safe* language.

When assigning a new value to a variable, the value must be the same type as the variable.
For example, if a variable has type `Bool`,
it can *only* be assigned a value that has type `Bool`,
and not for example a value that has type `Int`.

```cadence
// Declare a variable that has type `Bool`.
var a = true

// Invalid: cannot assign a value that has type `Int` to a variable which has type `Bool`.
//
a = 0
```

When passing arguments to a function,
the types of the values must match the function parameters' types.
For example, if a function expects an argument that has type `Bool`,
*only* a value that has type `Bool` can be provided,
and not for example a value which has type `Int`.

```cadence
fun nand(_ a: Bool, _ b: Bool): Bool {
    return !(a && b)
}

nand(false, false)  // is `true`

// Invalid: The arguments of the function calls are integers and have type `Int`,
// but the function expects parameters booleans (type `Bool`).
//
nand(0, 0)
```

Types are **not** automatically converted.
For example, an integer is not automatically converted to a boolean,
nor is an `Int32` automatically converted to an `Int8`,
nor is an optional integer `Int?`
automatically converted to a non-optional integer `Int`,
or vice-versa.

```cadence
fun add(_ a: Int8, _ b: Int8): Int8 {
    return a + b
}

// The arguments are not declared with a specific type, but they are inferred
// to be `Int8` since the parameter types of the function `add` are `Int8`.
add(1, 2)  // is `3`

// Declare two constants which have type `Int32`.
//
let a: Int32 = 3_000_000_000
let b: Int32 = 3_000_000_000

// Invalid: cannot pass arguments which have type `Int32` to parameters which have type `Int8`.
//
add(a, b)
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/json-cadence-spec.md

---
title: JSON-Cadence Data Interchange Format
sidebar_label: JSON-Cadence format
---

> Version 0.3.1

JSON-Cadence is a data interchange format used to represent Cadence values as language-independent JSON objects.

This format includes less type information than a complete [ABI](https://en.wikipedia.org/wiki/Application_binary_interface), and instead promotes the following tenets:

- **Human-readability** - JSON-Cadence is easy to read and comprehend, which speeds up development and debugging.
- **Compatibility** - JSON is a common format with built-in support in most high-level programming languages, making it easy to parse on a variety of platforms.
- **Portability** - JSON-Cadence is self-describing and thus can be transported and decoded without accompanying type definitions (i.e. an ABI).

# Values

---

## Void

```json
{
  "type": "Void"
}
```

### Example

```json
{
  "type": "Void"
}
```

---

## Optional

```json
{
  "type": "Optional",
  "value": null | <value>
}
```

### Example

```json
// Non-nil

{
  "type": "Optional",
  "value": {
    "type": "UInt8",
    "value": "123"
  }
}

// Nil

{
  "type": "Optional",
  "value": null
}
```

---

## Bool

```json
{
  "type": "Bool",
  "value": true | false
}
```

### Example

```json
{
  "type": "Bool",
  "value": true
}
```

---

## String

```json
{
  "type": "String",
  "value": "..."
}
```

### Example

```json
{
  "type": "String",
  "value": "Hello, world!"
}
```

---

## Address

```json
{
  "type": "Address",
  "value": "0x0" // as hex-encoded string with 0x prefix
}
```

### Example

```json
{
  "type": "Address",
  "value": "0x1234"
}
```

---

## Integers

`[U]Int`, `[U]Int8`, `[U]Int16`, `[U]Int32`,`[U]Int64`,`[U]Int128`, `[U]Int256`, `Word8`, `Word16`, `Word32`, `Word64`, `Word128` or `Word256`

Although JSON supports integer literals up to 64 bits, all integer types are encoded as strings for consistency.

While the static type is not strictly required for decoding, it is provided to inform client of potential range.

```json
{
  "type": "<type>",
  "value": "<decimal string representation of integer>"
}
```

### Example

```json
{
  "type": "UInt8",
  "value": "123"
}
```

---

## Fixed Point Numbers

`[U]Fix64`

Although fixed point numbers are implemented as integers, JSON-Cadence uses a decimal string representation for readability.

```json
{
  "type": "[U]Fix64",
  "value": "<integer>.<fractional>"
}
```

### Example

```json
{
  "type": "Fix64",
  "value": "12.3"
}
```

---

## Array

```json
{
  "type": "Array",
  "value": [
    <value at index 0>,
    <value at index 1>
    // ...
  ]
}
```

### Example

```json
{
  "type": "Array",
  "value": [
    {
      "type": "Int16",
      "value": "123"
    },
    {
      "type": "String",
      "value": "test"
    },
    {
      "type": "Bool",
      "value": true
    }
  ]
}
```

---

## Dictionary

Dictionaries are encoded as a list of key-value pairs to preserve the deterministic ordering implemented by Cadence.

```json
{
  "type": "Dictionary",
  "value": [
    {
      "key": "<key>",
      "value": <value>
    },
    ...
  ]
}
```

### Example

```json
{
  "type": "Dictionary",
  "value": [
    {
      "key": {
        "type": "UInt8",
        "value": "123"
      },
      "value": {
        "type": "String",
        "value": "test"
      }
    }
  ]
  // ...
}
```

---

## Composites (Struct, Resource, Event, Contract, Enum)

Composite fields are encoded as a list of name-value pairs in the order in which they appear in the composite type declaration.

```json
{
  "type": "Struct" | "Resource" | "Event" | "Contract" | "Enum",
  "value": {
    "id": "<fully qualified type identifier>",
    "fields": [
      {
        "name": "<field name>",
        "value": <field value>
      },
      // ...
    ]
  }
}
```

### Example

```json
{
  "type": "Resource",
  "value": {
    "id": "0x3.GreatContract.GreatNFT",
    "fields": [
      {
        "name": "power",
        "value": { "type": "Int", "value": "1" }
      }
    ]
  }
}
```

---

## Path

```json
{
  "type": "Path",
  "value": {
    "domain": "storage" | "private" | "public",
    "identifier": "..."
  }
}
```

### Example

```json
{
  "type": "Path",
  "value": {
    "domain": "storage",
    "identifier": "flowTokenVault"
  }
}
```

---

## Type Value

```json
{
  "type": "Type",
  "value": {
    "staticType": <type>
  }
}
```

### Example

```json
{
  "type": "Type",
  "value": {
    "staticType": {
      "kind": "Int"
    }
  }
}
```

---

## InclusiveRange

```json
{
  "type": "InclusiveRange",
  "value": {
    "start": <start_value>,
    "end": <end_value>,
    "step": <step_value>
  }
}
```

### Example

```json
{
  "type": "InclusiveRange",
  "value": {
    "start": {
      "type": "Int256",
      "value": "10"
    },
    "end": {
      "type": "Int256",
      "value": "20"
    },
    "step": {
      "type": "Int256",
      "value": "5"
    }
  }
}
```

---

## Capability

```json
{
  "type": "Capability",
  "value": {
    "id": <Number>,
    "address": "0x0",  // as hex-encoded string with 0x prefix
    "borrowType": <type>,
  }
}
```

### Example

```json
{
  "type": "Capability",
  "value": {
    "id": "1",
    "address": "0x1",
    "borrowType": {
      "kind": "Int"
    }
  }
}
```

---

## Functions

```json
{
  "type": "Function",
  "value": {
    "functionType": <type>
  }
}
```

Function values can only be exported, they cannot be imported.

### Example

```json
{
  "type": "Function",
  "value": {
    "functionType": {
      "kind": "Function",
      "typeID": "fun():Void",
      "parameters": [],
      "return": {
        "kind": "Void"
      }
    }
  }
}
```

---

# Types

## Simple Types

These are basic types like `Int`, `String`, or `StoragePath`.

```json
{
  "kind": <kind>
}
```

Where `kind` is one of:

- `Account`
- `AccountCapabilityController`
- `AccountKey`
- `Address`
- `AnyResource`
- `AnyResourceAttachment`
- `AnyStruct`
- `AnyStructAttachment`
- `Block`
- `Bool`
- `Capability`
- `CapabilityPath`
- `Character`
- `DeployedContract`
- `DeploymentResult`
- `Fix64`
- `FixedPoint`
- `FixedSizeUnsignedInteger`
- `HashAlgorithm`
- `HashableStruct`
- `Int`
- `Int128`
- `Int16`
- `Int256`
- `Int32`
- `Int64`
- `Int8`
- `Integer`
- `Never`
- `Number`
- `Path`
- `PrivatePath`
- `PublicKey`
- `PublicPath`
- `SignatureAlgorithm`
- `SignedFixedPoint`
- `SignedInteger`
- `SignedNumber`
- `StorageCapabilityController`
- `StoragePath`
- `String`
- `Type`
- `UFix64`
- `UInt`
- `UInt128`
- `UInt16`
- `UInt256`
- `UInt32`
- `UInt64`
- `UInt8`
- `Void`
- `Word128`
- `Word16`
- `Word256`
- `Word32`
- `Word64`
- `Word8`

### Example

```json
{
  "kind": "UInt8"
}
```

---

## Optional Types

```json
{
  "kind": "Optional",
  "type": <type>
}
```

### Example

```json
{
  "kind": "Optional",
  "type": {
    "kind": "String"
  }
}
```

---

## Variable Sized Array Types

```json
{
  "kind": "VariableSizedArray",
  "type": <type>
}
```

### Example

```json
{
  "kind": "VariableSizedArray",
  "type": {
    "kind": "String"
  }
}
```

---

## Constant Sized Array Types

```json
{
  "kind": "ConstantSizedArray",
  "type": <type>,
  "size": <length of array>,
}
```

### Example

```json
{
  "kind": "ConstantSizedArray",
  "type": {
    "kind": "String"
  },
  "size": 3
}
```

---

## Dictionary Types

```json
{
  "kind": "Dictionary",
  "key": <type>,
  "value": <type>
}
```

### Example

```json
{
  "kind": "Dictionary",
  "key": {
    "kind": "String"
  },
  "value": {
    "kind": "UInt16"
  }
}
```

---

## Composite Types

```json
{
  "kind": "Struct" | "Resource" | "Event" | "Contract" | "StructInterface" | "ResourceInterface" | "ContractInterface",
  "type": "", // this field exists only to keep parity with the enum structure below; the value must be the empty string
  "typeID": "<fully qualified type ID>",
  "initializers": [
    <initializer at index 0>,
    <initializer at index 1>
    // ...
  ],
  "fields": [
    <field at index 0>,
    <field at index 1>
    // ...
  ],
}
```

### Example

```json
{
  "kind": "Resource",
  "type": "",
  "typeID": "0x3.GreatContract.GreatNFT",
  "initializers": [
    [
      {
        "label": "foo",
        "id": "bar",
        "type": {
          "kind": "String"
        }
      }
    ]
  ],
  "fields": [
    {
      "id": "foo",
      "type": {
        "kind": "String"
      }
    }
  ]
}
```

---

## Field Types

```json
{
  "id": "<name of field>",
  "type": <type>
}
```

### Example

```json
{
  "id": "foo",
  "type": {
    "kind": "String"
  }
}
```

---

## Parameter Types

```json
{
  "label": "<label>",
  "id": "<identifier>",
  "type": <type>
}
```

### Example

```json
{
  "label": "foo",
  "id": "bar",
  "type": {
    "kind": "String"
  }
}
```

---

## Initializer Types

Initializer types are encoded a list of parameters to the initializer.

```json
[
  <parameter at index 0>,
  <parameter at index 1>,
  // ...
]
```

### Example

```json
[
  {
    "label": "foo",
    "id": "bar",
    "type": {
      "kind": "String"
    }
  }
]
```

---

## Function Types

```json
{
  "kind": "Function",
  "typeID": "<function name>",
  "parameters": [
    <parameter at index 0>,
    <parameter at index 1>,
    // ...
  ],
  "purity: "view" | undefined,
  "return": <type>
}
```

### Example

```json
{
  "kind": "Function",
  "typeID": "foo",
  "parameters": [
    {
      "label": "foo",
      "id": "bar",
      "type": {
        "kind": "String"
      }
    }
  ],
  "purity": "view",
  "return": {
    "kind": "String"
  }
}
```

---

## Reference Types

```json
{
  "kind": "Reference",
  "authorization": {
    "kind": "Unauthorized" | "EntitlementMapAuthorization" | "EntitlementConjunctionSet" | "EntitlementDisjunctionSet",
    "entitlements": [
    <entitlement at index 0>,
    <entitlement at index 1>
    // ...
    ]
    },
  "type": <type>
}
```

### Example

```json
{
  "kind": "Reference",
  "authorization": {
    {
      "kind": "EntitlementMapAuthorization",
      "entitlements": [
        {
          "kind": "EntitlementMap",
          "typeID": "foo"
        }
      ]
    }
  },
  "type": {
    "kind": "String"
  }
}
```

---

## Intersection Types

```json
{
  "kind": "Intersection",
  "typeID": "<fully qualified type ID>",
  "types": [
    <type at index 0>,
    <type at index 1>,
    //...
  ]
}
```

### Example

```json
{
  "kind": "Intersection",
  "typeID": "{0x1.FungibleToken.Receiver}",
  "types": [
    {
      "kind": "ResourceInterface",
      "typeID": "0x1.FungibleToken.Receiver",
      "fields": [
        {
          "id": "uuid",
          "type": {
            "kind": "UInt64"
          }
        }
      ],
      "initializers": [],
      "type": ""
    }
  ]
}
```

---

## Capability Types

```json
{
  "kind": "Capability",
  "type": <type>
}
```

### Example

```json
{
  "kind": "Capability",
  "type": {
    "kind": "Reference",
    "authorization": {
      "kind": "Unauthorized",
      "entitlements": null
    },
    "type": {
      "kind": "String"
    }
  }
}
```

---

## Enum Types

```json
{
  "kind": "Enum",
  "type": <type>,
  "typeID": "<fully qualified type ID>",
  "initializers":[],
  "fields": [
    {
      "id": "rawValue",
      "type": <type>
    }
  ]
}
```

### Example

```json
{
  "kind": "Enum",
  "type": {
    "kind": "String"
  },
  "typeID": "0x3.GreatContract.GreatEnum",
  "initializers": [],
  "fields": [
    {
      "id": "rawValue",
      "type": {
        "kind": "String"
      }
    }
  ]
}
```

## Repeated Types

When a composite type appears more than once within the same JSON type encoding, either because it is
recursive or because it is repeated (e.g. in a composite field), the composite is instead
represented by its type ID.

### Example

```json
{
  "type": "Type",
  "value": {
    "staticType": {
      "kind": "Resource",
      "typeID": "0x3.GreatContract.NFT",
      "fields": [
        {
          "id": "foo",
          "type": {
            "kind": "Optional",
            "type": "0x3.GreatContract.NFT" // recursive NFT resource type is instead encoded as an ID
          }
        }
      ],
      "initializers": [],
      "type": ""
    }
  }
}
```

## Inclusive Range Type

```json
{
  "kind": "InclusiveRange",
  "element":  <integer_type>
}
```

### Example

```json
{
  "kind": "InclusiveRange",
  "element": {
    "kind": "Int"
  }
}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/design-patterns.md

---
title: Cadence Design Patterns
sidebar_position: 5
sidebar_label: Design Patterns
---

This is a selection of software design patterns developed by core Flow developers
while writing Cadence code for deployment to Flow Mainnet.

Many of these design patters apply to most other programming languages, but some are specific to Cadence.

[Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) are building blocks for software development.
They may provide a solution to a problem that you encounter when writing smart contracts in Cadence.
If they do not clearly fit, these patterns may not be the right solution for a given situation or problem.
They are not meant to be rules to be followed strictly, especially where a better solution presents itself.

# General

These are general patterns to follow when writing smart contracts.

## Use named value fields for constants instead of hard-coding

### Problem

Your contracts, resources, and scripts all have to refer to the same value.
A number, a string, a storage path, etc.
Entering these values manually in transactions and scripts is a potential source of error.
See [Wikipedia's page on magic numbers](https://en.wikipedia.org/wiki/Magic_number_(programming))

### Solution

Add a public (`access(all)`), constant (`let`) field, e.g. a `Path` , to the contract responsible for the value,
and set it in the contract's initializer.
Refer to that value via this public field rather than specifying it manually.

Example Snippet:

```cadence

// BAD Practice: Do not hard code storage paths
access(all)
contract NamedFields {

    access(all)
    resource Test {}

    init() {
        // BAD: Hard-coded storage path
        self.account.storage.save(<-create Test(), to: /storage/testStorage)
    }
}

// GOOD practice: Instead, use a field
//
access(all)
contract NamedFields {

    access(all)
    resource Test {}

    // GOOD: field storage path
    access(all)
    let testStoragePath: StoragePath

    init() {
        // assign and access the field here and in transactions
        self.testStoragePath = /storage/testStorage
        self.account.storage.save(<-create Test(), to: self.TestStoragePath)
    }
}

```

[Example Code](https://github.com/onflow/flow-core-contracts/blob/71ea0dfe843da873d52c6a983e7c8f44a4677b26/contracts/LockedTokens.cdc#L779)

## Script-Accessible public field/function

Data availability is important in a blockchain environment.
It is useful to publicize information about your smart contract and the assets it controls
so other smart contracts and apps can easily query it.

### Problem

Your contract, resource, or struct has a field or resource that will need to be read and used on or off-chain, often in bulk.

### Solution

Make sure that the field can be accessed from a script.
This saves the time and fees required to read a property using a transaction.
Making the field or function `access(all)` and exposing it via a `/public/` capability will allow this.

Be careful not to expose any data or functionality that should be kept private when doing so.

Example:

```cadence
// BAD: Field is private, so it cannot be read by the public
access(self)
let totalSupply: UFix64

// GOOD: Field is public, so it can be read and used by anyone
access(all)
let totalSupply: UFix64
```

## Script-Accessible report

### Problem

Your contract has a resource that you wish to access fields of.
Resources are often stored in private places and are hard to access.
Additionally, scripts cannot return resources to the external context,
so a struct must be used to hold the data.

### Solution

Return a reference to a resource if the data from a single resource is all that is needed.
Otherwise, declare a struct to hold the data that you wish to return from the script.
Write a function that fills out the fields of this struct with the data
from the resource that you wish to access.
Then call this on the resource that you wish to access the fields of in a script,
and return the struct from the script.

See [Script-Accessible public field/function](#script-accessible-public-fieldfunction), above, for how best to expose this capability.

### Example

```cadence
access(all)
contract AContract {

    access(all)
    let BResourceStoragePath: StoragePath

    access(all)
    let BResourcePublicPath: PublicPath

    init() {
        self.BResourceStoragePath = /storage/BResource
        self.BResourcePublicPath = /public/BResource
    }

    // Resource definition
    access(all)
    resource BResource {

        access(all)
        var c: UInt64

        access(all)
        var d: String


        // Generate a struct with the same fields
        // to return when a script wants to see the fields of the resource
        // without having to return the actual resource
        access(all)
        fun generateReport(): BReportStruct {
            return BReportStruct(c: self.c, d: self.d)
        }

        init(c: UInt64, d: String) {
            self.c = c
            self.d = d
        }
    }

    // Define a struct with the same fields as the resource
    access(all)
    struct BReportStruct {

        access(all)
        var c: UInt64

        access(all)
        var d: String

        init(c: UInt64, d: String) {
            self.c = c
            self.d = d
        }

    }
}
...
// Transaction
import AContract from 0xAContract

transaction {
        prepare(acct: auth(IssueStorageCapabilityController, PublishCapability) &Account) {
            //...
            let cap = acct.capabilities.storage.issue<&AContract.BResource>(AContract.BResourceStoragePath)
            acct.capabilities.publish(cap, at: AContract.BResourcePublicPath)
        }
}
// Script
import AContract from 0xAContract

// Return the struct with a script
access(all)
fun main(account: Address): AContract.BReportStruct {
    // borrow the resource
    let b = getAccount(account).capabilities
        .borrow<&AContract.BResource>(AContract.BResourcePublicPath)
    // return the struct
    return b.generateReport()
}
```

## Init singleton

### Problem

An admin resource must be created and delivered to a specified account.
There should not be a function to do this, as that would allow anyone to create an admin resource.

### Solution

Create any one-off resources in the contract's initializer
and deliver them to an address or `&Account` specified as an argument.

See how this is done in the LockedTokens contract initializer:

[LockedTokens.cdc](https://github.com/onflow/flow-core-contracts/blob/71ea0dfe843da873d52c6a983e7c8f44a4677b26/contracts/LockedTokens.cdc#L765-L780)

and in the transaction that is used to deploy it:

[admin_deploy_contract.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_deploy_contract.cdc)


## Use descriptive names for fields, paths, functions and variables

### Problem

Smart contracts often are vitally important pieces of a project and often have many other
smart contracts and applications that rely on them.
Therefore, they need to be clearly written and easy to understand.

### Solution

All fields, functions, types, variables, etc., need to have names that clearly describe what they are used for.

`account` / `accounts` is better than `array` / `element`.

`providerAccount` / `tokenRecipientAccount` is better than `acct1` / `acct2`.

`/storage/bestPracticesDocsCollectionPath` is better than `/storage/collection`

### Example

```cadence
// BAD: Unclear naming
//
access(all)
contract Tax {

    // Do not use abbreviations unless absolutely necessary
    access(all)
    var pcnt: UFix64

    // Not clear what the function is calculating or what the parameter should be
    access(all)
    fun calculate(num: UFix64): UFix64 {
        // What total is this referring to?
        let total = num + (num * self.pcnt)

        return total
    }
}

// GOOD: Clear naming
//
access(all)
contract TaxUtilities {

    // Clearly states what the field is for
    access(all)
    var taxPercentage: UFix64

    // Clearly states that this function calculates the
    // total cost after tax
    access(all)
    fun calculateTotalCostPlusTax(preTaxCost: UFix64): UFix64 {
        let postTaxCost = preTaxCost + (preTaxCost * self.taxPercentage)

        return postTaxCost
    }
}
```

## Plural names for arrays and maps are preferable

For example, use `accounts` rather than `account` for an array of accounts.

This signals that the field or variable is not scalar.
It also makes it easier to use the singular form for a variable name during iteration.

## Use transaction post-conditions when applicable

### Problem

Transactions can contain any amount of valid Cadence code and access many contracts and accounts.
The power of resources and capabilities means that there may be some behaviors of programs that are not expected.

### Solution

It is usually safe to include post-conditions in transactions to verify the intended outcome.

### Example

This could be used when purchasing an NFT to verify that the NFT was deposited in your account's collection.

```cadence
// Pseudo-code

transaction {

    access(all)
    let buyerCollectionRef: &NonFungibleToken.Collection

    prepare(acct: auth(BorrowValue) &Account) {

        // Get tokens to buy and a collection to deposit the bought NFT to
        let temporaryVault <- vaultRef.withdraw(amount: 10.0)
        let self.buyerCollectionRef = acct.storage.borrow(from: /storage/Collection)

        // purchase, supplying the buyers collection reference
        saleRef.purchase(tokenID: 1, recipient: self.buyerCollectionRef, buyTokens: <-temporaryVault)

    }
    post {
        // verify that the buyer now owns the NFT
        self.buyerCollectionRef.idExists(1) == true: "Bought NFT ID was not deposited into the buyers collection"
    }
}
```

## Avoid unnecessary load and save storage operations, prefer in-place mutations

### Problem

When modifying data in account storage, `load()` and `save()` are costly operations:
All data is unnecessarily moved out of the account, then moved back into the account.
This can quickly cause your transaction to reach its limits.

This also applies to nested, stored in fields, arrays, and dictionaries:
Moving objects out of containers and moving them back into the container,
just to modify the object, is just as costly.

For example, a collection contains a dictionary of NFTs.
There is no need to move the whole dictionary out of the field,
update the dictionary on the stack (e.g., adding or removing an NFT),
and then move the whole dictionary back to the field:
the dictionary can be updated in-place, which is easier and more efficient.
The same goes for a more complex data structure like a dictionary of nested resources:
Each resource can be updated in-place by taking a reference to the nested object instead of loading and saving.

### Solution

For making modifications to values in storage or accessing stored objects,
`borrow()` should always be used to access them instead of `load` or `save` unless absolutely necessary.
`borrow()` returns a reference to the object at the storage path instead of having to load the entire object.
This reference can be assigned to or can be used to access fields or call methods on stored objects.

Fields and value in containers, such as in arrays and dictionaries,
can be borrowed using a reference expression (`&v as &T`).

### Example

```cadence
// BAD: Loads and stores a resource to use it
//
transaction {

    prepare(acct: auth(LoadValue, SaveValue) &Account) {

        // Removes the vault from storage, a costly operation
        let vault <- acct.storage.load<@ExampleToken.Vault>(from: /storage/exampleToken)

        // Withdraws tokens
        let burnVault <- vault.withdraw(amount: 10)

        destroy burnVault

        // Saves the used vault back to storage, another costly operation
        acct.storage.save(to: /storage/exampleToken)

    }
}

// GOOD: Uses borrow instead to avoid costly operations
//
transaction {

    prepare(acct: auth(BorrowValue) &Account) {

        // Borrows a reference to the stored vault, much less costly operation
        let vault <- acct.storage.borrow<&ExampleToken.Vault>(from: /storage/exampleToken)

        let burnVault <- vault.withdraw(amount: 10)

        destroy burnVault

        // No `save` required because we only used a reference
    }
}
```

# Capabilities

## Capability bootstrapping

### Problem

An account must be given a [capability](./language/capabilities.md) to an object stored in another account.
To create (issue) the capability, the transaction must be signed by a key which has access to the target account.

To transfer / deliver the capability to the other account, the transaction also needs write access to that one.
It is not as easy to produce a single transaction which is authorized by two accounts
as it is to produce a typical transaction which is authorized by one account.

This prevents a single transaction from fetching the capability
from one account and delivering it to the other.

### Solution

The solution to the bootstrapping problem in Cadence is provided by the
[Inbox API](./language/accounts/inbox.mdx).

Account A (which we will call the provider) creates the capability they wish to send to account B
(which we will call the recipient),
and stores this capability on their account in a place where the recipient can access it
using the `Inbox.publish` function on their account.
They choose a name for the capability that the recipient can later use to identify it,
and specify the recipient's address when calling `publish`.
This call to `publish` will emit an `InboxValuePublished` event
that the recipient can listen for off-chain to know that the Capability is ready for them to claim.

The recipient then later can use the `Inbox.claim` function to securely claim the capability
from the provider's account.
They must provide the name and type with which the capability was published,
as well as the address of the provider's account
(all of this information is available in the `InboxValuePublished` event emitted on `publish`).
This will remove the capability from the provider's account and emit an `InboxValueClaimed` event
that the provider can listen for off-chain.

One important caveat to this is that the published capability is stored on the provider's account
until the recipient claims it,
so the provider can also use the `Inbox.unpublish` function to remove the capability from their account
if they no longer wish to pay for storage for it.
This also requires the name and type which the capability was published,
and emits an `InboxValueUnpublished` event that the recipient can listen for off-chain.

It is also important to note that the recipient becomes the owner of the capability object
once they have claimed it, and can thus store it or copy it anywhere they have access to.
This means providers should only publish capabilities to recipients they trust to use them properly,
or limit the type with which the capability is authorized
in order to only give recipients access to the functionality
that the provider is willing to allow them to copy.

```cadence
import "BasicNFT"

transaction(receiver: Address, name: String) {

    prepare(signer: auth(IssueStorageCapabilityController, PublishInboxCapability) &Account) {

        // Issue a capability controller for the storage path
        let capability = signer.capabilities.storage.issue<&BasicNFT.Minter>(BasicNFT.minterPath)

        // Set the name as tag so it is easy for us to remember its purpose
        let controller = signer.capabilities.storage.getController(byCapabilityID: capability.id)
                ?? panic("Cannot get the storage capability controller with ID "
                    .concat(capabilityID.toString())
                    .concat(" from the signer's account! Make sure the ID belongs to a capability that the owner controls and that it is a storage capability.")
        controller.setTag(name)

        // Publish the capability, so it can be later claimed by the receiver
        signer.inbox.publish(capability, name: name, recipient: receiver)
    }
}
```

```cadence
import "BasicNFT"

transaction(provider: Address, name: String) {

    prepare(signer: auth(ClaimInboxCapability, SaveValue) &Account) {

        // Claim the capability from our inbox
        let capability = signer.inbox.claim<&BasicNFT.Minter>(name, provider: provider)
                ?? panic("Cannot claim the storage capability controller with name "
                    .concat(name).concat(" from the provider account (").concat(provider.toString())
                    .concat("! Make sure the provider address is correct and that they have published "
                    .concat(" a capability with the desired name.")

        // Save the capability to our storage so we can later retrieve and use it
        signer.storage.save(capability, to: BasicNFT.minterPath)
    }
}
```

## Check for existing capability before publishing new one

### Problem

When publishing a capability, a capability might be already be published at the specified path.

### Solution

Check if a capability is already published at the given path.

### Example

```cadence
transaction {
    prepare(signer: auth(Capabilities) &Account) {
        let capability = signer.capabilities.storage
            .issue<&ExampleToken.Vault>(/storage/exampleTokenVault)

        let publicPath = /public/exampleTokenReceiver

        if signer.capabilities.exits(publicPath) {
            signer.capabilities.unpublish(publicPath)
        }
        signer.capabilities.publish(capability, at: publicPath)
    }
}
```

## Capability Revocation

### Problem

A capability provided by one account to a second account must able to be revoked
by the first account without the co-operation of the second.

### Solution

If the capability is a storage capability:

```cadence
transaction(capabilityID: UInt64) {
    prepare(signer: auth(StorageCapabilities) &Account) {
        let controller = signer.capabilities.storage
            .getController(byCapabilityID: capabilityID)
            ?? panic("Cannot get the storage capability controller with ID "
                    .concat(capabilityID.toString())
                    .concat(" from the signer's account! Make sure the ID belongs to a capability that the owner controls and that it is a storage capability.")
        controller.delete()
    }
}
```

If the capability is an account capability:

```cadence
transaction(capabilityID: UInt64) {
    prepare(signer: auth(AccountCapabilities) &Account) {
        let controller = signer.capabilities.account
            .getController(byCapabilityID: capabilityID)
            ?? panic("Cannot get the account capability controller with ID "
                    .concat(capabilityID.toString())
                    .concat(" from the signer's account! Make sure the ID belongs to a capability that the owner controls and that it is an account capability.")
        controller.delete()
    }
}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/05-non-fungible-tokens-2.md

---
archived: false
draft: false
title: Intermediate NFTs
description: Learn how to manage collections of NFTs in Cadence
date: 2024-09-18
meta:
  keywords:
    - tutorial
    - Flow
    - NFT
    - Non-Fungible Tokens
    - Cadence
    - Resources
    - Capabilities
    - Collection
    - Dictionary
tags:
  - reference
  - NFT
  - Non-Fungible Token
  - cadence
  - tutorial
socialImageTitle: Intermediate NFTs in Cadence
socialImageDescription: NFT social image.
---

In the [last tutorial], you implemented a simple NFT that users could mint, hold, and trade, but there was a serious flaw - each user could only hold one NFT at a time.  In this tutorial, you'll improve your implementation to allow it to be able to grant users multiple NFTs and the tools needed to manage them.

:::tip

If you're already comfortable with Cadence and have found this page looking for information on how to build production-ready NFTs, check out the [NFT Guide] and [Flow NFT Standard] repository.

:::

## Objectives

After completing this tutorial, you'll be able to:

* Implement a collection [resource] that can manage multiple NFTs on behalf of a user.
* Create an [entitlement] to limit some functionality of a [resource] to the owner.
* Handle errors more elegantly with functions that generate error messages.

## Storing Multiple NFTs in a Collection

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:
<a
href="https://play.flow.com/9da6f80f-cd79-4797-a067-47a57dc54770"
target="_blank"
>
https://play.flow.com/9da6f80f-cd79-4797-a067-47a57dc54770
</a>

:::

This tutorial continues from the last one, but we'll be doing significant refactoring.  The provided starter contains the NFT resource, but removes the code and transactions for creating NFTs and capabilities to interact with them.  You'll replace those with a more sophisticated approach that will allow collections of NFTs.

It also adds some constants for the paths we'll be using so we don't need to worry about typos as we add them to several transactions and scripts.

As you've likely noticed the setup and operations that we used in the previous tutorial are not very scalable. Users need a way to store multiple NFTs from a collection and tools to manage all of those NFTs from a single place.

Using a [dictionary] on its own to store our NFTs would solve the problem of having to use different storage paths for each NFT, but it doesn't solve all the problems.

### Resources that Own Resources

Instead, we can use a powerful feature of Cadence, resources owning other resources! We'll define a new `Collection` resource as our NFT storage place to enable more-sophisticated ways to interact with our NFTs.  This pattern comes with interesting powers and side effects.

Since the `Collection` explicitly owns the NFTs in it, the owner could transfer all of the NFTs at once by just transferring the single collection. In addition to allowing easy batch transfers, this means that if a unique NFT wants to own another unique NFT, like a CryptoKitty owning a hat accessory, the Kitty literally stores the hat in its own fields and effectively owns it.

The hat belongs to the CryptoKitty that it is stored in, and the hat can be transferred separately or along with the CryptoKitty that owns it. Cadence is a fully object-oriented language, so ownership is indicated by where an object is stored, not just an entry on a ledger.

:::danger

When the NFT `Collection` resource is destroyed with the `destroy` command, all the resources stored in the dictionary are also `destroy`ed.

:::

### NFT Collection

:::info[Action]

Add a public resource definition called `Collection` to the `IntermediateNFT` contract.  In it, add a public [dictionary] called `ownedNFTs` that maps `NFT`s to their `Uint64` id numbers.  Initialize `ownedNFTs` with an empty dictionary. 

:::

```cadence
access(all) resource Collection {
    access(all) var ownedNFTs: @{UInt64: NFT}

    init () {
        self.ownedNFTs <- {}
    }
}
```

:::tip

Cadence is an object-oriented language.  Inside of a composite type, such as a [resource], `self` refers to the instance of that type and **not** the contract itself.

:::

Dictionary definitions don't usually have the `@` symbol in the type specification, but because the `myNFTs` mapping stores resources, the whole field must become a resource type.  Therefore, you need the `@` symbol indicating that `ownedNFTs` is a resource type.

As a result, all the rules that apply to resources apply to this type.

### Utility Functions

It's helpful for a collection to be able to handle some basic operations, such as accepting an NFT into the collection, validating whether or not a token is present, or sharing a list of all token IDs.

:::info[Action]

Write a function to `deposit` a token into `ownedNFTs`:

:::

```cadence
access(all) fun deposit(token: @NFT) {
    self.ownedNFTs[token.id] <-! token
}
```

:::tip

Notice that we're using the `<-!` force assignment operator to move the token.  This will still give a runtime error if the location already has something else stored, but it won't give a typecheck error like the `<-` move operator would in this instance.

:::

:::info[Action]

Next, write a function called `idExists` that returns a `Bool` - `true` if the id is present and `false` if it is not.

Also write a function called `getIDs` that returns an array of the `UInt64` ids of all NFTs found in the collection.  Make use of the built-in `keys` function present on the dictionary type.

:::

```cadence
access(all) view fun idExists(id: UInt64): Bool {
    return self.ownedNFTs[id] != nil
}

access(all) view fun getIDs(): [UInt64] {
    return self.ownedNFTs.keys
}
```

## Withdrawing NFTs

For the NFT `Collection`, we will publish a capability to allow anyone to access the utility functions you just created - depositing NFTs into it, verifying if an NFT is in the collection, or getting the ids of all NFTs present.  We'll also need functionality to withdraw an NFT and remove it from the collection, but we obviously **don't** want anyone to be able to do that.

### Capability Security

This is where an important layer of access control comes in. Cadence utilizes [capability security], which means that for any given object, a user is allowed to access a field or method of that object if they either:

- Are the owner of the object
- Have a valid reference to that field or method (note that references can only be created from capabilities, and capabilities can only be created by the owner of the object)

When a user stores their NFT `Collection` in their account storage, it is by default not available for other users to access because it requires access to the authorized account object (`auth(Storage) &Account`) which is only accessible by a transaction that the owner authorizes and signs.

To give external accounts access to the `access(all)` fields and functions, the owner (usually with the help of a developer creating a transaction) creates a link to the object in storage.

This link creates a capability. From there, it could be passed as a parameter to a function for one-time-use, or it could be put in the `/public/` domain of the user's account so that anyone can access it.

You've done this already when you've written transactions to `issue` and `publish` capabilities.

### Using Entitlements

We do not want everyone in the network to be able to call our `withdraw` function though.

In Cadence, any reference can be freely up-casted or down-casted to any subtype or supertype that the reference conforms to. This means that if you had a reference of the type `&ExampleNFT.Collection`, this would expose all the `access(all)` functions on the `Collection`. 

This is a powerful feature that is very useful, but it means if there is any privileged functionality on a resource that has a public capability, then this functionality cannot be `access(all)`.

It needs to use [entitlements].

Entitlements enable you to restrict the scope of access at a granular level, with the option to group restrictions under similarly named entitlements. Owners of resources can then use these entitlements to grant access to the subset of actions enabled by the authorized reference.

:::tip

If you're used to Solidity, you can think of this as being similar to frameworks that enable you to use modifiers to limit some functions to specific addresses with the correct role, such as `onlyOwner`.

:::

:::info[Action]

Define an [entitlement] called `Withdraw` in your contract, at the contract level.

:::

```cadence
access(all) entitlement Withdraw
```

You've now effectively created a type of lock that can only be opened by someone with the right key - or the owner of the property, who always has access natively.

:::info[Action]

Implement a `withdraw` function.  It should:

* Only allow `access` to addresses with the `Withdraw` [entitlement].
* Accept the id of the NFT to be withdrawn as an argument
* Return an error if the NFT with that id is not present in the account's `ownedNFTs`
* Return the **actual token resource**

:::

You should end up with something similar to:

```cadence
access(Withdraw) fun withdraw(withdrawID: UInt64): @NFT {
    let token <- self.ownedNFTs.remove(key: withdrawID)
        ?? panic("Could not withdraw an ExampleNFT.NFT with id="
            .concat(withdrawID.toString())
            .concat("Verify that the collection owns the NFT ")
            .concat("with the specified ID first before withdrawing it."))

    return <-token
}
```

Providing an access scope of `access(Withdraw)` locks this functionality to only the owner that has the [resource] directly in their storage, **or** to any address possessing a reference to this resource that has the `Withdraw` entitlement.

As with other types defined in contracts, these are namespaced to the deployer and contract.  The full name of `Withdraw` would be something like `0x06.IntermediateNFT.Withdraw`.  More than one contract or account can declare separate and distinct entitlements with the same name.

### Issuing an Entitlement

The owner of an object is the only one who can sign a transaction to create an entitled capability or reference.

In the above example, if you wanted to make the withdraw function publicly accessible,
you could issue the capability as an entitled capability by specifying all the entitlements in the capability's type specification
using the `auth` keyword:

```cadence
// DANGEROUS CODE EXAMPLE - DO NOT USE
let cap = self.account.capabilities.storage.issue<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>(self.CollectionStoragePath)
self.account.capabilities.publish(cap, at: self.CollectionPublicPath)
```

Now, anyone could borrow that capability as the entitled version it was issued as:

```cadence
let entitledCollectionRef = recipient.capabilities
    .borrow<auth(ExampleNFT.Withdraw) &ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)
    ?? panic("Could not borrow a reference to the ExampleNFT.Collection")

let stolenNFT <- entitledCollectionRef.withdraw(withdrawID: 1)
```

Later tutorials will cover more nuanced methods for sharing an [entitlement].

## Error Handling

Thinking ahead, many of the transactions that we might write (or other developers composing on our contracts) will need to borrow a reference to a user's collection.  We can make everyone's lives easier by adding a function to help create that error in a nice and consistent manner.

:::info[Action]

Write a function called `collectionNotConfiguredError` that accepts an `address` and returns a descriptive error message that the collection was not found.

:::

```cadence
access(all) fun collectionNotConfiguredError(address: Address): String {
    return "Could not borrow a collection reference to recipient's IntermediateNFT.Collection"
        .concat(" from the path ")
        .concat(IntermediateNFT.CollectionPublicPath.toString())
        .concat(". Make sure account ")
        .concat(address.toString())
        .concat(" has set up its account ")
        .concat("with an IntermediateNFT Collection.")
    }
```

## Deploy the Contract

:::info[Action]

Deploy the `IntermediateNFT` contract with account `0x06`.

:::


## Creating Collections

We'll need several transactions to manage our NFT collection.  The first is one to allow users to create a collection on their account.

:::info[Action]

On your own, implement a transaction in `CreateCollection.cdc` to create and save a `Collection` in the caller's account and also `issue` and `publish` a capability for that collection.

:::

You should end up with something similar to:

```cadence
import IntermediateNFT from 0x06

transaction {
    prepare(account: auth(SaveValue, Capabilities) &Account) {
        // You may want to make sure one doesn't exist, but the native error is descriptive as well
        let collection <- IntermediateNFT.createEmptyCollection()

        account.storage.save(<-collection, to: IntermediateNFT.CollectionStoragePath)

        log("Collection created")

        let cap = account.capabilities.storage.issue<&IntermediateNFT.Collection>(IntermediateNFT.CollectionStoragePath)
        account.capabilities.publish(cap, at: IntermediateNFT.CollectionPublicPath)

        log("Capability created")
    }
}
```

:::info[Action]

Test your transaction by creating `Collections` for several accounts.  Try it with accounts that do and do **not** have `Collections` already, and verify that the correct behavior occurs.

:::

## Minting an NFT

:::info[Action]

Next, add a transaction to mint an nft and grant it to the caller.  Use the `prepare` phase to `borrow` a reference to the caller's `Collection` and store it in a transaction-level field.  Then, use `execute` to create the nft and use the `Collection`'s `deposit` function to save it in the `Collection`.

It's better practice to separate code that accesses accounts and storage to collect authorized references from the code that executes the changes to state.

:::

You can pass arguments, such as the `String` for the NFT `description` by defining parameters on the `transaction`.

Your transaction should be similar to:

```cadence
import IntermediateNFT from 0x06

transaction(description: String) {
    let receiverRef: &IntermediateNFT.Collection

    prepare(account: auth(BorrowValue) &Account) {
        self.receiverRef = account.capabilities
            .borrow<&IntermediateNFT.Collection>(IntermediateNFT.CollectionPublicPath)
            ?? panic(IntermediateNFT.collectionNotConfiguredError(address: account.address))
    }

    execute {
        let newNFT <- IntermediateNFT.mintNFT(description: description)

        self.receiverRef.deposit(token: <-newNFT)

        log("NFT Minted and deposited to minter's Collection")
    }
}
```

:::info[Action]

Test your transaction by minting several NFTs for several accounts.  Try it with accounts that do and do **not** have `Collections` and verify that the correct behavior occurs.

:::

## Printing the NFTs Owned by an Account

Remember, you can use scripts to access functionality that doesn't need authorization, such as the function to `getIDs` for all the NFTs in a `Collection`.

:::info[Action]

Write a script to `PrintNFTs` for the provided address.

:::

You can also pass arguments into the `main` function in a script.

```cadence

import IntermediateNFT from 0x06

access(all) fun main(address: Address): [UInt64] {
    let nftOwner = getAccount(address)

    let capability = nftOwner.capabilities.get<&IntermediateNFT.Collection>(IntermediateNFT.CollectionPublicPath)

    let receiverRef = nftOwner.capabilities
        .borrow<&IntermediateNFT.Collection>(IntermediateNFT.CollectionPublicPath)
        ?? panic(IntermediateNFT.collectionNotConfiguredError(address: address))


    log("Account "
      .concat(address.toString())
      .concat(" NFTs")
    )

    return receiverRef.getIDs()
}

```

## Transferring NFTs

Finally, you'll want to provide a method for users to `Transfer` NFTs to one another.  To do so, you'll need to `withdraw` the NFT from the owner's `Collection` and `deposit` it to the recipient.  

This transaction is **not** bound by the `Withdraw` capability, because the caller will be the account that has the NFT in storage, which automatically possesses full entitlement to everything in its own storage.  It also doesn't need the permission of or a signature from the recipient, because we gave the `deposit` function `access(all)` and published a public capability to it.

:::info[Action]

Start by stubbing out a transaction that accepts a `recipientAddress` and `tokenId`.  It should have a transaction-level field called `transferToken` to store the NFT temporarily, between the `prepare`, and `execute` phases. 

:::

```cadence
import IntermediateNFT from 0x06

transaction(recipientAddress: Address, tokenId: UInt64) {
    let transferToken: @IntermediateNFT.NFT

    prepare(account: auth(BorrowValue) &Account) {
        // TODO
    }

    execute {
        // TODO
    }
}
```

:::info[Action]

Next, in `prepare`, get a reference to the sender's `Collection` and use it to `move (<-)` the token out of their collection and into `transferToken`:

:::

```cadence
let collectionRef = account.storage
    .borrow<auth(IntermediateNFT.Withdraw) &IntermediateNFT.Collection>(from: IntermediateNFT.CollectionStoragePath)
    ?? panic(IntermediateNFT.collectionNotConfiguredError(address: account.address))

self.transferToken <- collectionRef.withdraw(withdrawID: tokenId)
```

:::info[Action]

Finally, get a public reference to the recipient's account, use that to get a reference to the capability for the recipient's `Collection`, and use the `deposit` function to `move (<-)` the NFT.

:::

```cadence
let recipient = getAccount(recipientAddress)

let receiverRef = recipient.capabilities
    .borrow<&IntermediateNFT.Collection>(IntermediateNFT.CollectionPublicPath)
    ?? panic(IntermediateNFT.collectionNotConfiguredError(address: recipient.address))

receiverRef.deposit(token: <-self.transferToken)

log("NFT ID transferred to account "
    .concat(recipient.address.toString()))
```

:::info[Action]

Test your transaction by transferring several NFTs for several accounts.  Try various combinations, and use the `PrintNFTs` script to make sure the NFTs move as expected.

:::


## Reviewing Intermediate NFTs

In this tutorial, you learned how to expand the functionality of your basic NFT to allow users to create collections of NFTs, then mint and trade those collections.  You also learned more about the details of [entitlements] and how you can use them to protect functionality so that only those who are supposed to be able to access something are able to.

Now that you have completed the tutorial, you should be able to:

* Implement a collection [resource] that can manage multiple NFTs on behalf of a user.
* Create an [entitlement] to limit some functionality of a [resource] to the owner.
* Handle errors more elegantly with functions that generate error messages.

In the next tutorial, you'll learn how to create fungible token collections.

<!-- Reference-style links, will not render on the page -->

[last tutorial]: ./05-non-fungible-tokens-1.md
[resource]: ../language/resources.mdx
[entitlement]: ../language/access-control.md
[dictionary]: ../language/values-and-types.mdx#dictionaries
[capability security]: ../language/capabilities.md
[entitlements]: ../language/access-control.md#entitlements




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/intersection-types.md

---
title: Intersection Types
sidebar_position: 17
---

Interface types cannot be used in type annotations directly;
instead they must be used as part of intersection types.
An intersection type represents a value that conforms to all of the interfaces listed in the intersection.

The syntax of a intersection type is `{U1, U2, ... Un}`,
where the types `U1` to `Un` are the interfaces that the type conforms to.

The members and functions of any of the set of interfaces are available.

Intersection types are useful for writing functions that work on a variety of different inputs.
For example, by using an intersection type for a parameter's type,
the function may accept any concrete value that implements all the interfaces in that intersection.
The value is restricted to the functionality of the intersection;
if the function accidentally attempts to access other functionality,
this is prevented by the static checker.

```cadence
access(all)
struct interface HasID {
    access(all)
    let id: String
}

access(all)
struct A: HasID {

    access(all)
    let id: String

    init(id: String) {
        self.id = id
    }
}

access(all)
struct B: HasID {

    access(all)
    let id: String

    init(id: String) {
        self.id = id
    }
}

// Create two instances, one of type `A`, and one of type `B`.
// Both types conform to interface `HasID`, so the structs can be assigned
// to variables with type `{HasID}`: Some resource type which only allows
// access to the functionality of resource interface `HasID`

let hasID1: {HasID} = A(id: "1")
let hasID2: {HasID} = B(id: "2")

// Declare a function named `getID` which has one parameter with type `{HasID}`.
// The type `{HasID}` is a short-hand for `AnyStruct{HasID}`:
// Some structure which only allows access to the functionality of interface `HasID`.
//
access(all)
fun getID(_ value: {HasID}): String {
    return value.id
}

let id1 = getID(hasID1)
// `id1` is "1"

let id2 = getID(hasID2)
// `id2` is "2"
```

If more than two interfaces are present in an intersection type,
any concrete value of that type must implement both of them:

```cadence
access(all)
struct interface HasMetadata {
    access(all)
    var metadata: AnyStruct
}

access(all)
struct C: HasID, HasMetadata {

    access(all)
    let id: String
    
    access(all)
    var metadata: AnyStruct

    init(id: String) {
        self.id = id
        self.metadata = []
    }

    access(all)
    fun setMetadata(_ data: AnyStruct) {
        self.metadata = data
    }
}

// valid, because `C` implements both `HasID` and `HasMetadata`.
let hasID3: {HasID, HasMetadata} = C(id: "3")

// Invalid, because `A` implements only `HasID`.
let hasID4: {HasID, HasMetadata} = A(id: "4")
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/04-capabilities.md

---
archived: false
draft: false
title: Capabilities
description: An introduction to capabilities and how they interact with resources in Cadence
date: 2024-12-11
meta:
  keywords:
    - tutorial
    - Flow
    - Cadence
    - Resources
    - Capabilities
    - Capability
tags:
  - reference
  - cadence
  - tutorial
socialImageTitle: Cadence Resources
socialImageDescription: Capability smart contract image.
---

This tutorial will build on your understanding of [accounts] and [resources]. You'll learn how to interact with resources using [capabilities] and [entitlements].

:::tip[Reminder]

In Cadence, resources are a composite type like a struct or a class, but with some **special rules**:
- Each instance of a resource can only exist in exactly one location and cannot be copied.
- Resources must be explicitly moved from one location to another when accessed.
- Resources also cannot go out of scope at the end of function execution, they must be explicitly stored somewhere or destroyed.

:::

## Objectives

After completing this tutorial, you'll be able to:

* Interact with [resources] created using transactions.
* Write transactions to create [capabilities] to extend resource access scope from the owner to anyone (`public`).
* Write and execute a script that interacts with the resource through the capability.

## Use-Cases for Capabilities and Entitlements

Let's look at why you would want to use capabilities and entitlements to expand access to resources in a real-world context. A real user's account and stored objects will contain functions and fields that need varying levels of access scope and privacy.

If you're working on an app that allows users to exchange tokens, you'll want different features available in different use cases. While you definitely want to make a feature like withdrawing tokens from an account only accessible by the owner of the tokens, your app should allow anybody to deposit tokens.

Capabilities and entitlements are what allows for this detailed control of access to owned assets. They allow a user to indicate which of the functionality of their account and owned objects should be accessible to themselves, their trusted friends, and the public.

For example, a user might want to allow a friend of theirs to use some of their money to spend, in this case, they could create an entitled capability that gives the friend access to only this part of their account, instead of having to hand over full control.

Another example is when a user authenticates a trading app for the first time, the trading app could ask the user for a capability object that allows the app to access the trading functionality of a user's account so that the app doesn't need to ask the user for a signature every time it wants to do a trade.  The user can choose to empower the app, and that app alone, for this functionality and this functionality alone.

## Accessing Resources with Capabilities

As a smart contract developer, you need explicit permission from the owner of an account to access its [storage]. Capabilities allow an account owner to grant access to specific fields and functions on objects stored in their account.

First, you'll write a transaction in which you'll issue a new capability using the `issue` function. This capability creates a link to the user's `HelloAsset` resource object. It then publishes that link to the account's public space, so others can access it.

Next, you'll write a script that anyone can use that link to borrow a [reference] to the underlying object and call the `hello()` function.

## Creating Capabilities and References to Stored Resources

:::info[Action]

Continue working with your code from the previous tutorial.  Alternately, open a fresh copy here:
<a
  href="https://play.flow.com/64287da4-50c4-4580-8b9f-5792b78d77c3"
  target="_blank"
>
  https://play.flow.com/64287da4-50c4-4580-8b9f-5792b78d77c3
</a>

:::

:::info[Action]

If you started with a fresh playground, be sure to deploy the `HelloWorld` contract with account `0x06` and call the `Create Hello` transaction, also with `0x06`.

:::

### Prepare the Account Capabilities

:::info[Action]

Create a new transaction called `Create Link`.

Import `HelloWorld` and stub out a `transaction` with a `prepare` phase.

:::

:::tip

Cadence allows for static analysis of imported contracts.  You'll get errors in the transactions and scripts that import `HelloWorld` from `0x06` if you haven't deployed that contract.

:::

```cadence create_link.cdc
import HelloWorld from 0x06

transaction {
  prepare() {
    // TODO
  }
}
```

:::info[Action]

Next, pass an `&Account` reference into `prepare` with the capabilities needed to give the `transaction` the ability to create and publish a capability.

:::

```cadence create_link.cdc
import HelloWorld from 0x06

transaction {
  prepare(account: auth(
    IssueStorageCapabilityController,
    PublishCapability
  ) &Account) {
    // TODO
  }
}
```

The [`IssueStorageCapabilityController`] allows the transaction to [issue] a new capability, which includes storing that capability to the user's account.  [`PublishCapability`] allows the transaction to [publish] a capability and make it available to other users - in this case, we'll make it public.

### Capability Based Access Control

[Capabilities] allow the owners of objects to specify what functionality of their private objects is available to others. Think of it kind of like an account's API, if you're familiar with the concept.

The account owner has private objects stored in their storage, like their collectibles or their money, but they might still want others to be able to see what collectibles they have in their account, or they want to allow anyone to access the deposit functionality for a certain asset.

Since these objects are stored in private storage by default, the owner has to authorize something to open up access to these while still retaining full control.

We create capabilities to accomplish this, and the account owner must sign a transaction to [issue] and [publish] them.

Every capability has a `borrow` method, which creates a reference to the object that the capability is linked to. This reference is used to read fields or call methods on the object they reference, **as if the owner of the reference had the actual object**.

It is important to remember that someone else who has access to a capability cannot move or destroy the object that the capability is linked to! They can only access fields that the owner has explicitly declared in the type specification and authorization-level of the [issue] method.

### Issue the Capability

Capabilities are created with the [issue] function and can be stored in variables or constants.

:::info[Action]

Issue a capability to allow access to the instance of the `HelloAsset` [resource] the `Create Hello` transaction saved in `/storage/HelloAssetTutorial`.

:::

```cadence
let capability = account
  .capabilities
  .storage
  .issue<&HelloWorld.HelloAsset>(/storage/HelloAssetTutorial)
```

:::danger

In our example capability, we had the user sign a transaction that gave public access to **everything** found in the `HelloAsset` resource!

When you're writing real transactions, follow the principle of giving minimal access.  While the capability cannot move or destroy an object, it might be able to mutate data inside of it in a way that the owner does not desire.

For example, if you added a function to allow the owner of the resource to change the greeting message, this code would open that function up to anyone and everyone!

:::

```cadence
let capability = account
  .capabilities
  .storage
  .issue<&HelloWorld.HelloAsset>(/storage/HelloAssetTutorial)
```

The capability says that whoever borrows a reference from this capability has access to the fields and methods that are specified by the type and entitlements in `<>`. The specified type has to be a subtype of the type of the object being linked to, meaning that it cannot contain any fields or functions that the linked object doesn't have.

A reference is referred to by the `&` symbol. Here, the capability references the `HelloAsset` object, so we specify `<&HelloWorld.HelloAsset>` as the type, which gives access to **everything** in the `HelloAsset` object.

The argument to the `issue` function is the path to the object in storage that is to be linked to. When a capability is issued, a [capability controller] is created for it in `account.capabilities`. This controller allows the creator of the capability to have fine-grained control over the capability.

Capabilities usually link to objects in the `/storage/` domain,
but can also be created for `Account` objects. Account capabilities will not be covered in this tutorial.

### Publish the Capability

Now that your transaction has created the capability with the [issue] function and saved it in a constant, you can use the [publish] function to store the capability in a place where it can be used by anyone.

:::info[Action]

Use [publish] function to publish the `capability` at `/public/HelloAssetTutorial`.

:::

```cadence
account.capabilities.publish(capability, at: /public/HelloAssetTutorial)
```

You should end up with a transaction similar to:

```cadence Create Link.cdc
import HelloWorld from 0x06

transaction {
  prepare(account: auth(
    IssueStorageCapabilityController,
    PublishCapability
  ) &Account) {
    let capability = account
      .capabilities
      .storage
      .issue<&HelloWorld.HelloAsset>(/storage/HelloAssetTutorial)

    account
      .capabilities
      .publish(capability, at: /public/HelloAssetTutorial)
  }
}
```

### Execute the Transaction to Publish the Capability

:::info[Action]

Ensure account `0x06` is still selected as a transaction signer.

Click the `Send` button to send the transaction.  Then, send it a second time.

:::

:::warning

This implementation will work the first time and fail the second.  The object cannot be saved because something is already at the path.

:::

As you learned in the [resources tutorial], Cadence prevents you from writing code that might accidentally overwrite an object in storage, thus mutating or even destroying a piece of your users' digital property.

:::info[action]

On your own, refactor your `Create Link` transaction to elegantly handle a scenario where an object is already stored at `/public/HelloAssetTutorial`

:::

## Using the Capability in a Script

Now that you've published the capability with `public` `access`, anyone who wants to can write transactions or scripts that make use of it.

:::info[Action]

Create a script called `GetGreeting`. Import `HelloWorld` and give it public `access`.

:::

```cadence GetGreeting.cdc
import HelloWorld from 0x06

access(all) fun main(): String {
  // TODO
}
```

You'll need a reference to the public account object for the `0x06` account to be able to access public capabilities within it.

:::info[Action]

Use `getAccount` to get a reference to account `0x06`.  Hardcode it for now.

:::

```cadence
let helloAccount = getAccount(0x06)
```

:::warning

Addresses are **not** strings and thus do **not** have quotes around them.

:::

:::info[Action]

Next, `borrow` the public capability your `Create Link` transaction saved in `/public/HelloAssetTutoral`.

Your script should return `return helloReference.hello()`.

:::

You've already borrowed something before.  Try to implement this on your own.  **Hint:** this time you're borrowing a `capability` from the account, **not** something from `storage`.  Don't forget to handle the case where the object can't be found!

You should end up with a script similar to:

```cadence GetGreeting.cdc
import HelloWorld from 0x06

access(all) fun main(): String {
    let helloAccount = getAccount(0x06)

    let helloReference = helloAccount
        .capabilities
        .borrow<&HelloWorld.HelloAsset>(/public/HelloAssetTutorial)
        ?? panic("Could not borrow a reference to the HelloAsset capability")

    return helloReference.hello()
}
```

:::info[Action]

`Execute` your script.

:::

You'll see `"Hello, World!"` logged to the console.

Note that scripts don't need any authorization and can only access public information.  You've enabled the user to make this capability public through the transaction you wrote and they signed.

At the end of the script execution, the `helloReference` value is lost, but that is ok because while it references a resource, it isn't the actual resource itself. It's ok to lose it.

## Deleting Capabilities

:::danger

While most apps will need to depend on users storing resource that allow the user to interact with the app, avoid constructing your app logic such that it depends on something in a user's storage for important metadata.  They own their storage and can delete anything in it at any time without asking anyone.

For example, if you stored the amount of debt for tokens you'd lent a user as a standalone resource in their account, they could simply delete the storage and erase the debt. Instead, store that metadata in your smart contract.

:::

The owner of an object can effectively [revoke capabilities] they have created by using the `delete` method on the Capability Controller that was created for the capability when it was issued.

Additionally, if the referenced object in storage is moved, capabilities that have been created from that storage path are invalidated.

## Reviewing Capabilities

This tutorial expanded on the idea of resources in Cadence by expanding access scope to a resource using capabilities and covering more account storage API use-cases.

You deployed a smart contract with a resource, then created a capability to grant access to that resource. With the capability, you used the `borrow` method in a script to create a reference to the capability.  You then used the reference to call the resource's `hello()` function. This is important because scripts cannot access account storage without using capabilities.

Now that you have completed the tutorial, you should be able to:

* Interact with [resources] created using transactions.
* Write transactions to create [capabilities] to extend resource access scope from the owner to anyone (`public`).
* Write and execute a script that interacts with the resource through the capability.

You're on the right track to building more complex applications with Cadence. Now is a great time to check out the [Cadence Best Practices document], [Anti-patterns document], and the first NFT tutorial!

<!-- Reference-style links, will not render on page -->

[accounts]: ../language/accounts/index.mdx
[storage]: ../language/accounts/storage.mdx
[resources]: ../language/resources.mdx
[resource]: ../language/resources.mdx
[capabilities]: ../language/capabilities.md
[Capabilities]: ../language/capabilities.md
[entitlements]: ../language/access-control.md#entitlements
[reference]: ../language/references.mdx
[`IssueStorageCapabilityController`]: ../language/accounts/capabilities.mdx#accountstoragecapabilities-and-accountaccountcapabilities
[`PublishCapability`]: /language/accounts/capabilities.mdx#accountcapabilities
[issue]: ../language/accounts/capabilities.mdx#issuing-capabilities
[publish]: ../language/accounts/capabilities.mdx#publishing-capabilities
[resources tutorial]: ./03-resources.md
[capability controller]: ../language/accounts/capabilities.mdx#accountcapabilities
[revoke capabilities]: ../language/accounts/capabilities.mdx#revoking-capabilities
[Cadence Best Practices document]: ../design-patterns.md
[Anti-patterns document]: ../anti-patterns.md




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/LICENSE.md

The source code of this site is licensed under the Apache License, Version 2.0 (LICENSE.txt).
Content is licensed under the Creative Commons Attribution 4.0 International License (CC-BY-4.0.txt).





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/index.md

---
title: Introduction to Cadence
sidebar_position: 1
sidebar_label: Introduction
---

In a blockchain environment like Flow, programs that are stored on-chain in accounts are commonly referred to as smart contracts.
A smart contract is a program that verifies and executes the performance of a contract without the need for a trusted third party.
Programs that run on blockchains are commonly referred to as smart contracts because they mediate important functionality (such as currency)
without having to rely on a central authority (like a bank).

## A New Programming Language

---

Cadence is a resource-oriented programming language that introduces new features to smart contract programming
that help developers ensure that their code is safe, secure, clear, and approachable. Some of these features are:

- Type safety and a strong static type system.
- Resource-oriented programming, a new paradigm that pairs linear types with object capabilities
to create a secure and declarative model for digital ownership by ensuring that resources (which are used to represent scarce digital assets)
can only exist in one location at a time, cannot be copied, and cannot be accidentally lost or deleted.
- Built-in pre-conditions and post-conditions for functions and transactions.
- The utilization of capability-based security, which enforces that access to objects
is restricted to only the owner of the object and those who have a valid reference to it.
This is Cadence's main form of access control.

Cadence’s syntax is inspired by popular modern general-purpose programming languages
like [Swift](https://developer.apple.com/swift/), [Kotlin](https://kotlinlang.org/), and [Rust](https://www.rust-lang.org/).
Its use of resource types maps well to that of [Move](https://medium.com/coinmonks/overview-of-move-programming-language-a860ffd8f55d),
the programming language being developed by the Diem team.

## Cadence's Programming Language Pillars

---

Cadence, a new high-level programming language, observes the following requirements:

- **Safety and Security:** Safety is the underlying reliability of any smart contract (i.e., it’s bug-free and performs its function).
Security is the prevention of attacks on the network or smart contracts (i.e., unauthorized actions by malicious actors).
Safety and security are critical in smart contracts because of the immutable nature of blockchains,
and because they often deal with high-value assets. While auditing and reviewing code will be a crucial part of smart contract development,
Cadence maximizes efficiency while maintaining the highest levels of safety and security at its foundation.
It accomplishes this via a strong static type system, design by contract, and ownership primitives inspired by linear types (which are useful when dealing with assets).
- **Clarity:** Code needs to be easy to read, and its meaning should be as unambiguous as possible.
It should also be suited for verification so that tooling can help with ensuring safety and security guarantees.
These guarantees can be achieved by making the code declarative and allowing the developer to express their intentions directly.
We make those intentions explicit by design, which, along with readability, make auditing and reviewing more efficient, at a small cost to verbosity.
- **Approachability:** Writing code and creating programs should be as approachable as possible.
Incorporating features from languages like Swift and Rust, developers should find Cadence’s syntax and semantics familiar.
Practical tooling, documentation, and examples enable developers to start creating programs quickly and effectively.
- **Developer Experience:** The developer should be supported throughout the entire development lifecycle, from initial application logic to on-chain bugfixes.
- **Intuiting Ownership with Resources:** Resources are a composite data type, similar to a struct, that expresses direct ownership of assets.
Cadence’s strong static type system ensures that resources can only exist in one location at a time and cannot be copied or lost because of a coding mistake.
Most smart contract languages currently use a ledger-style approach to record ownership,
where an asset like a fungible token is stored in the smart contract as an entry in a central ledger.
Cadence’s resources directly tie an asset’s ownership to the account that owns it by saving the resource in the account’s storage.
As a result, ownership isn’t centralized in a smart contract’s storage. Each account owns its assets,
and the assets can be transferred freely between accounts without the need for arbitration by a central smart contract.

## Addressing Challenges with Existing Languages

---

Other languages pioneered smart contract development, but they lack in areas that affect the long-term viability of next-generation applications.

### Safety

Safety is the reliability of a smart contract to perform its function as intended.
It is heavily influenced by the unchangeable-once-deployed nature of smart contracts:
Developers must take certain precautions in order to avoid introducing any potentially catastrophic vulnerabilities
prior to publishing a smart contract on the blockchain.
It is standard across many blockchains that modifying or updating a smart contract, even to fix a vulnerability, is not allowed.
Thus, any bugs that are present in the smart contract will exist forever.

For example, in 2016, an overlooked vulnerability in an Ethereum DAO smart contract (Decentralized Autonomous Organization)
saw millions of dollars siphoned from a smart contract,
eventually leading to a fork in Ethereum and two separate active blockchains (Ethereum and Ethereum Classic).

Bug fixes are only possible if a smart contract is designed to support changes,
a feature that introduces complexity and security issues.
Lengthy auditing and review processes can ensure a bug-free smart contract.
Still, they add substantial time to the already time-consuming task of getting the smart contract’s core logic working correctly.

Overlooked mistakes cause the most damaging scenarios.
It is easy to lose or duplicate monetary value or assets in existing languages because they don’t check relevant invariants
or make it harder to express them.
For example, a plain number represents a transferred amount that can be accidentally (or maliciously) multiplied or ignored.

Some languages also express behaviors that developers tend to forget about.
For example, a fixed-range type might express monetary value, without considerations for a potential overflow or underflow.
In Solidity, Ethereum's smart contract language, an overflow causes the value to wrap around, as shown [here](https://ethfiddle.com/CAp-kQrDUP).
Solidity also allows contracts to declare variables without initializing them.
If the developer forgets to add an initialization somewhere,
and then tries to read the variable somewhere else in the code expecting it to be a specific value, issues will occur.

Cadence is type safe and has a strong static type system,
which prevents important classes of erroneous or undesirable program behavior at compile-time (i.e., before the program is run on-chain).
Types are checked statically and are not implicitly converted. Cadence also improves the safety of programs by preventing arithmetic underflow and overflow,
introduces optionals to make nil-cases explicit, and always requires variables to be initialized.
This helps ensure the behavior of these smart contracts is apparent and not dependent on context.

### Security

Security, in combination with safety, ensures the successful execution of a smart contract over time
by preventing unsanctioned access and guaranteeing that only authorized actions can be performed in the protocol.
In some languages, functions are public by default, creating vulnerabilities that allow malicious users to find attack vectors.
Cadence utilizes capability-based security, which allows the type system to enforce access control based on rules that users and developers have control over.

Security is a consideration when interacting with other smart contracts. Any external call potentially allows malicious code to be executed.
For example, in Solidity, when the called function signature does not match any of the available ones, it triggers Solidity’s fallback functions.
These functions can be used in malicious ways. Language features such as multiple inheritances and overloading or dispatch can also make it difficult
to determine which code is invoked.

In Cadence, the safety and security of programs are enhanced by **Design By Contract** and **Ownership Primitives.**
Design by contract allows developers to state pre-conditions and post-conditions for functions and interfaces in a declarative manner
so that callers can be certain about the behavior of called code. Ownership primitives are inspired by linear types and increase safety when working with assets.
They ensure that valuable assets are, for example, not accidentally or maliciously lost or duplicated.

### Clarity and Approachability

Implicitness, context-dependability, and expressiveness are language-based challenges that developers often encounter.
They affect the clarity (i.e. the readability of code and the ability to determine its intended function)
and the approachability (i.e. the ability to interpret or write code) of the language and the programs built using it.
For example, in Solidity, storage must be implemented in a low-level key-value manner, which obfuscates the developer’s intentions.
Syntax confusion is another example, with “=+” being legal syntax leading to an assignment instead of a probably-intended increment.
Solidity also has features with uncommon behaviors that can lead to unintended results.
[Multiple inheritance may lead to unexpected behaviours in the program](https://medium.com/consensys-diligence/a-case-against-inheritance-in-smart-contracts-d7f2c738f78e),
and testing and auditing the code is unlikely to identify this issue.

The Ethereum blockchain’s code immutability showcases the need for considerations around extensibility and mechanisms that allow ad-hoc fixes.
Developers using custom-made approaches such as the 'data separation' approach to upgradability
may run into problems with the complexity of data structures,
while developers using ‘delegatecall-based proxies` may run into problems with the consistency of memory layouts.
Either way, these challenges compromise approachability and overall extensibility.
Cadence has [contract upgradability built in by default](./language/contract-updatability.md),
and contracts can be made immutable by removing all keys from an account.

Cadence improves the clarity and extensibility of programs by utilizing interfaces to allow extensibility, code reuse, and interoperability between contracts.
Cadence modules also have configurable and transparent upgradeability built-in to enable projects to test and iterate before making their code immutable.

Cadence allows the use of argument labels to describe the meaning of function arguments.
It also provides a rich standard library with useful data structures (e.g., dictionaries, sets) and data types for common use cases,
like fixed-point arithmetic, which helps when working with currencies.

## Intuiting Ownership with Resources

Most smart contract languages currently use a ledger-style approach to record ownership,
where an asset is stored in the smart contract as an entry in a central ledger, and this ledger is the source of truth around asset ownership.
There are many disadvantages to this design, especially when it comes to tracking the ownership of multiple assets belonging to a single account.
To find out all of the assets that an account owns, you would have to enumerate all the possible smart contracts that could potentially include this account
and search to see if the account owns these assets.

In a resource-oriented language like Cadence, resources directly tie an asset to the account that owns it
by saving the resource in the account’s storage. As a result, ownership isn’t centralized in a single, central smart contract’s storage.
Instead, each account owns and stores its own assets, and the assets can be transferred freely between accounts without the need for arbitration by a central smart contract.

Resources are inspired by linear types and increase safety when working with assets, which often have real, intrinsic value.
Resources, as enforced by Cadence’s type system, ensure that assets are correctly manipulated and not abused.

- Every resource has exactly one owner. If a resource is used as a function parameter, an initial value for a variable, or something similar, the object is not copied.
Instead, it is moved to the new location, and the old location is immediately invalidated.
- The language will report an error if ownership of a resource was not properly transferred, i.e.,
when the program attempts to introduce multiple owners for the resource or the resource ends up in a state where it does not have an owner.
For example, a resource can only be assigned to exactly one variable and cannot be passed to functions multiple times.
- Resources cannot go out of scope. If a function or transaction removes a resource from an account’s storage,
it either needs to end the transaction in an account's storage, or it needs to be explicitly and safely deleted. There is no “garbage collection” for resources.

The special status of Resource objects must be enforced by the runtime; if they were just a compiler abstraction it would be easy for malicious code to break the value guarantees.

Resources change how assets are used in a programming environment to better resemble assets in the real world.
Users store their currencies and assets in their own account, in their own wallet storage, and they can do with them as they wish.
Users can define custom logic and structures for resources that give them flexibility with how they are stored.
Additionally, because everyone stores their own assets, the calculation and charging of state rent is fair and balanced across all users in the network.

## An Interpreted Language

---

Currently, Cadence is an interpreted language, as opposed to a compiled language. This means that there is no Cadence Assembly, bytecode, compiler, or Cadence VM.

The structure of the language lends itself well to compilation (for example, static typing),
but using an interpreter for the first version allows us to refine the language features more quickly as we define them.

## Getting Started with Cadence

---

Now that you've learned about the goals and design of Cadence and Flow, you're ready to get started with the Flow emulator and tools!
Go to the [Getting Started](./tutorial/01-first-steps.md) page to work through language fundamentals and tutorials.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/06-fungible-tokens.md

---
archived: false
draft: false
title: Fungible Tokens
description: An introduction to Fungible Tokens in Cadence
date: 2024-09-18
meta:
  keywords:
    - tutorial
    - Flow
    - Fungible Tokens
    - Cadence
    - Resources
    - Capabilities
tags:
  - reference
  - Fungible Token
  - cadence
  - tutorial
socialImageTitle: Fungible Tokens in Cadence
socialImageDescription: FT social image.
---

Some of the most popular contract classes on blockchains today are fungible tokens.
These contracts create homogeneous tokens that can be transferred to other users and spent as currency (e.g., ERC-20 on Ethereum).

In traditional software and smart contracts, balances for each user are tracked by a central ledger, such as a dictionary:

```cadence
// BAD CODE EXAMPLE. DO NOT USE THIS CODE FOR YOUR PROJECT
contract LedgerToken {
    // Tracks every user's balance
    access(contract) let balances: {Address: UFix64}

    // Transfer tokens from one user to the other
    // by updating their balances in the central ledger
    access(all)
    fun transfer(from: Address, to: Address, amount: UFix64) {
        balances[from] = balances[from] - amount
        balances[to] = balances[to] + amount
    }
}
```

With Cadence, we use the new resource-oriented paradigm to implement fungible tokens and avoid using a central ledger, because there are inherent problems with using a central ledger that are detailed in [the Fungible Tokens section below].

:::warning

This tutorial implements a working fungible token, but it has been simplified for educational purposes and is not what you should use in production. 

If you've found this tutorial looking for information on how to implement a real token, see the [Flow Fungible Token standard] for the standard interface and example implementation, and the [Fungible Token Developer Guide] for a details on creating a production ready version of a Fungible Token contract.

:::

In this tutorial, we're going to deploy, store, and transfer fungible tokens.

## Objectives

After completing this tutorial, you'll be able to:

* Compare and contrast how tokens are stored in Flow Cadence compared to Ethereum.
* Utilize the `UFix64` type to allow decimals without converting back and forth with 10^18.
* Implement a vault [resource] to manage the functionality needed for fungible tokens
* Use [interfaces] to enforce the presence of specified functions and fields.
* Write transactions to transfer tokens safely from one account to another.
* Develop scripts to read account balances.
* Use preconditions and postconditions to perform checks before or after a function call completes.

## Flow Network Token

In Flow, the [native network token (FLOW)] is implemented as a normal fungible token smart contract using a smart contract similar to the one you'll build in this tutorial.

There are special transactions and hooks that allow it to be used for transaction execution fees, storage fees, and staking, but besides that, developers and users are able to treat it and use it just like any other token in the network!

## Fungible Tokens on Flow

Flow implements fungible tokens differently than other programming languages. As a result:

* Ownership is decentralized and does not rely on a central ledger
* Bugs and exploits present less risk for users and less opportunity for attackers
* There is no risk of integer underflow or overflow
* Assets cannot be duplicated, and it is very hard for them to be lost, stolen, or destroyed
* Code can be composable
* Rules can be immutable
* Code is not unintentionally made public

### Fungible tokens on Ethereum

The example below showcases how Solidity (the smart contract language for the Ethereum Blockchain, among others) implements fungible tokens, with only the code for storage and transferring tokens shown for brevity.

```solidity ERC20.sol
contract ERC20 {
    // Maps user addresses to balances, similar to a dictionary in Cadence
    mapping (address => uint256) private _balances;

    function _transfer(address sender, address recipient, uint256 amount) {
        // ensure the sender has a valid balance
        require(_balances[sender] >= amount);

        // subtract the amount from the senders ledger balance
        _balances[sender] = _balances[sender] - amount;

        // add the amount to the recipient's ledger balance
        _balances[recipient] = _balances[recipient] + amount
    }
}
```

As you can see, Solidity uses a central ledger system for its fungible tokens. There is one contract that manages the state of the tokens and every time that a user wants to do anything with their tokens, they have to interact with the central ERC20 contract. This contract handles access control for all functionality, implements all of its own correctness checks, and enforces rules for all of its users.

If there's a bug, such as accidentally making the `_transfer` function public, an attacker can immediately exploit the entire contract and the tokens owned by all users.

### Intuiting Ownership with Resources

Instead of using a central ledger system, Flow utilizes a few different concepts to provide better safety, security, and clarity for smart contract developers and users.  Primarily, tokens are stored in each user's vault, which is a [resource] similar to the collection you created to store NFTs in the previous tutorial.  

This approach simplifies access control because instead of a central contract having to check the sender of a function call, most function calls happen on resource objects stored in users' accounts, and each user natively has sole control over the resources stored in their accounts.

This approach also helps protect against potential bugs. In a Solidity contract with all the logic and state contained in a central contract, an exploit is likely to affect all users who are involved in the contract.

In Cadence, if there is a bug in the resource logic, an attacker would have to exploit the bug in each token holder's account individually, which is much more complicated and time-consuming than it is in a central ledger system.

## Constructing a Vault

Our vault will be a simplified version of the one found in the [Flow Fungible Token standard].  We'll follow some of the same practices, including using [interfaces] to standardize the properties of our vault and make it easier for other contracts to interact with it.

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:

<a
href="https://play.flow.com/359cf1a1-63cc-4774-9c09-1b63ed83379b"
target="_blank"
>
https://play.flow.com/359cf1a1-63cc-4774-9c09-1b63ed83379b
</a>

:::

In `ExampleToken.cdc`, you'll see:

```cadence ExampleToken.cdc
access(all) contract ExampleToken {

    access(all) entitlement Withdraw

    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath

   
    init() {
        self.VaultStoragePath = /storage/CadenceFungibleTokenTutorialVault
        self.VaultPublicPath = /public/CadenceFungibleTokenTutorialReceiver
    }
}
```

Before you can add your vault, you'll need to implement the various pieces it will depend on.

### Supply and Balance

The two most basic pieces of information for a fungible token are a method of tracking the balance of a given user, and the total supply for the token.  In Cadence, you'll usually want to use `UFix64` - a [fixed-point number].

Fixed-point numbers are essentially integers with a scale, represented by a decimal point.  They make it much easier to work with money-like numbers as compared to endlessly handling conversions to and from the 10^18 representation of a value.

:::info[Action]

Implement a contract-level [fixed-point number] to track the `totalSupply` of the token.

:::

```cadence
access(all) var totalSupply: UFix64
```

### Interfaces

You'll also need a place to store the `balance` of any given user's vault.  You **could** simply add a variable in the vault [resource] definition to do this and it would work just fine.  

Instead, let's use this opportunity to create some [interface]s.

In Cadence, interfaces are abstract types used to specify behavior in types that _implement_ the interface.  Using them helps compatibility and composability by breaking larger constructions down into standardized parts that can be used by more than one contract for more than one use case.  For example, the interface we'll create for `Receiver` is used by the vault, but it's also something you'd use for any other resource that needs to be able to receive tokens - such as a contract that pools a collection of tokens and splits them between several addresses.

You'll create three interfaces, to handle the three functional areas of the vault:

* A `Balance` interface for the balance of tokens stored in the vault
* A `Provider` interface that can provide tokens by withdrawing them from the vault
* A `Receiver` interface that can safely deposit tokens from one vault into another

:::info[Action]

First, create a `Balance` interface, requiring a public `UFix64` called `balance`.  It should be public.

:::

```cadence
access(all) resource interface Balance {
    access(all) var balance: UFix64
}
```

This one is pretty simple.  It just defines the type of variable anything implementing it will need to have to keep track of a token balance.

:::info[Action]

Next, create the `Provider` `interface`.  In it, define a `withdraw` function.  It should have the `Withdraw` access [entitlement], accept an argument for `amount`, and return a `Vault` resource type.  This should also be public.

To prevent an error, stub out the `Vault` resource as well.

:::

```cadence
access(all) resource interface Provider {
    access(Withdraw) fun withdraw(amount: UFix64): @Vault {}
}

access(all) resource Vault {}
```

This [interface] will require resources implementing it to have a `withdraw` function, but it doesn't provide any limitations to how that function works.  For example, it could be implemented such that the amount of tokens returned is double the withdrawn amount.  While there might be a use case for that effect, it's not what you want for a normal token standard.

You can allow for flexibility, such as allowing a `Provider` to select randomly from several vaults to determine the payer, while enforcing that the amount withdrawn is appropriate by adding a `post` condition to the function.  [Function preconditions and postconditions] can be used to restrict the inputs and outputs of a function.

In a postcondition, the special constant `result` is used to reference the `return` of the function.  They're written following the rules of [statements] and can contain multiple conditions.  Optionally, a `:` can be added after the last statement, containing an error message to be passed if the postcondition fails.

:::info[Action]

Add a `post` condition that returns a descriptive and nicely formatted error if the amount returned in the vault from the function doesn't match the `amount` passed into the function.

:::

```cadence
access(Withdraw) fun withdraw(amount: UFix64): @Vault {
    post {
        result.balance == amount:
            "ExampleToken.Provider.withdraw: Cannot withdraw tokens!"
            .concat("The balance of the withdrawn tokens (").concat(result.balance.toString())
            .concat(") is not equal to the amount requested to be withdrawn (")
            .concat(amount.toString()).concat(")")
    }
}
```

This `post` condition will be added automatically to the `withdraw` function in a resource implementing `Provider`.

:::info[Action]

Finally, implement an [interface] called `Receiver`, containing a function called `deposit` that accepts a `Vault`.

::

```cadence
access(all) resource interface Receiver {
    access(all) fun deposit(from: @Vault)
}
```

## Implementing the Vault

You're finally ready to implement the vault.

:::info[Action]

Start by declaring a type for a `Vault` that implements `Balance`, `Provider`, and `Receiver`.

:::

```cadence
access(all) resource Vault: Balance, Provider, Receiver {
    // TODO
}
```

You'll get errors:

```text
resource `ExampleToken.Vault` does not conform to resource interface `ExampleToken.Balance`. `ExampleToken.Vault` is missing definitions for members: Balance
```

And similar errors for `Provider` and `Receiver`.  Similar to inheriting from a virtual class in other languages, implementing the interfaces requires you to implement the properties from those interfaces in your resource.

:::info[Action]

Implement `balance`.  You'll also need to initialize it.  Initialize it with the `balance` passed into the `init` for the resource itself.

:::

The pattern we're setting up here let's us create vaults and give them a `balance` in one go.  Doing so is useful for several tasks, as creating a temporary `Vault` to hold a balance during a transaction also creates most of the functionality you need to do complex tasks with that balance.

For example, you might want to set up a conditional transaction that `deposit`s the balance in the vaults in different addresses based on whether or not a part of the transaction is successful.  

```cadence
access(all) var balance: UFix64

init(balance: UFix64) {
    self.balance = balance
}
```

:::info[Action]

Next, implement `withdraw` function.  It should contain a precondition that validates that the user actually possesses equal to or greater the number of tokens they are withdrawing.

:::

While this functionality is probably something we'd want in every vault, we can't put the requirement in the [interface], because the interface doesn't have access to the `balance`.

```cadence
access(Withdraw) fun withdraw(amount: UFix64): @Vault {
    pre {
        self.balance >= amount:
            "ExampleToken.Vault.withdraw: Cannot withdraw tokens! "
            .concat("The amount requested to be withdrawn (").concat(amount.toString())
            .concat(") is greater than the balance of the Vault (")
            .concat(self.balance.toString()).concat(").")
    }
    self.balance = self.balance - amount
    return <-create Vault(balance: amount)
}
```

:::info[Action]

Finally, implement the `deposit` function.  Depositing should move the entire balance from the provided vault, and then `destroy` it.

:::

```cadence
access(all) fun deposit(from: @Vault) {
    self.balance = self.balance + from.balance
    destroy from
}
```

You **must** do something with the `Vault` resource after it's moved into the function.  You can `destroy` it, because it's now empty, and you don't need it anymore.

## Vault Creation

We'll need a way to create empty vaults to onboard new users, or to create vaults for a variety of other uses.  

:::info[Action]

Add a function to `create` an empty `Vault`.

:::

```cadence
access(all) fun createEmptyVault(): @Vault {
    return <-create Vault(balance: 0.0)
}
```

We'll use this when we create a transaction to set up new users.

## Error Handling

As before, you can anticipate some of the errors that other developers building transactions and scripts that interact with your contract might encounter.  At the very least, it's likely that there will be many instances that an attempt is made to borrow a `Vault` that is not present, or lacks a capability for the caller to borrow it.

:::info[Action]

Add a function to generate a helpful error if an attempt to borrow a `Vault` fails.

:::

```cadence
access(all) fun vaultNotConfiguredError(address: Address): String {
    return "Could not borrow a collection reference to recipient's ExampleToken.Vault"
        .concat(" from the path ")
        .concat(ExampleToken.VaultPublicPath.toString())
        .concat(". Make sure account ")
        .concat(address.toString())
        .concat(" has set up its account ")
        .concat("with an ExampleToken Vault.")
}
```

## Minting

Next, you need a way to actually create, or mint, tokens.  For this example, we'll define a  `VaultMinter` resource that has the power to mint and airdrop tokens to any address that possesses a vault, or at least something with the `Receiver` [interface] for this token.
Only the owner of this resource will be able to mint tokens.

To do so, we use [capability] with a reference to the resource or interface we want to require as the type:  `Capability<&{Receiver}>`

:::info[Action]

Define a public [resource] with a public function `mintTokens` that accepts an `amount` of tokens to mint, and a `recipient` that must possess the `Receiver` [capability].

:::

```cadence
access(all) resource VaultMinter {
    access(all) fun mintTokens(amount: UFix64, recipient: Capability<&{Receiver}>) {
        let recipientRef = recipient.borrow()
        ?? panic(ExampleToken.vaultNotConfiguredError(address: recipient.address))

        ExampleToken.totalSupply = ExampleToken.totalSupply + UFix64(amount)
        recipientRef.deposit(from: <-create Vault(balance: amount))
    }
}
```

## Final Contract Setup

The last task with the contract is to update the `init` function in your contract to save yourself a little bit of time and create and create a `VaultMinter` in your account.

:::info[Action]

Update the contract `init` function to `create` and `save` an instance of `VaultMinter`:

:::

```cadence
self
.account
.storage
.save(<-create VaultMinter(),
    to: /storage/CadenceFungibleTokenTutorialMinter
)
```

After doing all of this, your contract should be similar to:

```cadence
access(all) contract ExampleToken {

    access(all) entitlement Withdraw

    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath

    access(all) var totalSupply: UFix64

    access(all) resource interface Balance {
        access(all) var balance: UFix64
    }

    access(all) resource interface Provider {
        ///
        /// @param amount the amount of tokens to withdraw from the resource
        /// @return The Vault with the withdrawn tokens
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @Vault {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    "ExampleToken.Provider.withdraw: Cannot withdraw tokens!"
                    .concat("The balance of the withdrawn tokens (").concat(result.balance.toString())
                    .concat(") is not equal to the amount requested to be withdrawn (")
                    .concat(amount.toString()).concat(")")
            }
        }
    }

    access(all) resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        /// @param from the Vault that contains the tokens to deposit
        ///
        access(all) fun deposit(from: @Vault)
    }

    access(all) resource Vault: Balance, Provider, Receiver {

        access(all) var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        access(Withdraw) fun withdraw(amount: UFix64): @Vault {
            pre {
                self.balance >= amount:
                    "ExampleToken.Vault.withdraw: Cannot withdraw tokens! "
                    .concat("The amount requested to be withdrawn (").concat(amount.toString())
                    .concat(") is greater than the balance of the Vault (")
                    .concat(self.balance.toString()).concat(").")
            }
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        access(all) fun deposit(from: @Vault) {
            self.balance = self.balance + from.balance
            destroy from
        }
    }

    access(all) fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    access(all) resource VaultMinter {
        access(all) fun mintTokens(amount: UFix64, recipient: Capability<&{Receiver}>) {
            let recipientRef = recipient.borrow()
            ?? panicpanic(ExampleToken.vaultNotConfiguredError(address: recipient.address))

            ExampleToken.totalSupply = ExampleToken.totalSupply + UFix64(amount)
            recipientRef.deposit(from: <-create Vault(balance: amount))
        }
    }

    access(all) fun vaultNotConfiguredError(address: Address): String {
        return "Could not borrow a collection reference to recipient's ExampleToken.Vault"
            .concat(" from the path ")
            .concat(ExampleToken.VaultPublicPath.toString())
            .concat(". Make sure account ")
            .concat(address.toString())
            .concat(" has set up its account ")
            .concat("with an ExampleToken Vault.")
    }

    init() {
        self.VaultStoragePath = /storage/CadenceFungibleTokenTutorialVault
        self.VaultPublicPath = /public/CadenceFungibleTokenTutorialReceiver

        self.totalSupply = 30.0

        self
        .account
        .storage
        .save(<-create VaultMinter(),
            to: /storage/CadenceFungibleTokenTutorialMinter
        )
    }
}
```

## Set Up Account Transaction

We'll now need to create several transactions and scripts to manage interactions with the vault.  The first of these is one to set up a user's account.  It needs to:

* Create an empty vault
* Save that vault in the caller's storage
* Issue a capability for the vault
* Publish that capability

You've already learned how to do everything you need for this, so you should be able to implement it on your own.

:::info[Action]

Implement the `Set Up Account` transaction.

:::

You should end up with something similar to:

```cadence
import ExampleToken from 0x06

transaction {
    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        // You may wish to check if a vault already exists here

        let vaultA <- ExampleToken.createEmptyVault()

        signer.storage.save(<-vaultA, to: ExampleToken.VaultStoragePath)

        let receiverCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            ExampleToken.VaultStoragePath
        )

        signer.capabilities.publish(receiverCap, at: ExampleToken.VaultPublicPath)
    }
}
```

## Minting Tokens

The next transaction is another one that you should be able to implement on your own.  Give it a try, and check the solution if you need to.  Your transaction should:

* Accept an `Address` for the `recipient` and an `amount`
* Store transaction-level references to the `VaultMinter` and `Receiver`
* Borrow a reference to the `VaultMinter` in the caller's storage
* Get the `recipient`'s `Receiver` capability
* Use the above to call the `mintTokens` function in the minter

:::info[Action]

Implement the `Mint Tokens` transaction.

:::

You should end up with something similar to:

```cadence
import ExampleToken from 0x06

transaction(recipient: Address, amount: UFix64) {
    let mintingRef: &ExampleToken.VaultMinter
    var receiver: Capability<&{ExampleToken.Receiver}>

    prepare(signer: auth(BorrowValue) &Account) {
        self.mintingRef = signer.storage.borrow<&ExampleToken.VaultMinter>(from: /storage/CadenceFungibleTokenTutorialMinter)
            ?? panic(ExampleToken.vaultNotConfiguredError(address: recipient))

        let recipient = getAccount(recipient)

        // Consider further error handling if this fails
        self.receiver = recipient.capabilities.get<&{ExampleToken.Receiver}>
            (ExampleToken.VaultPublicPath)

    }

    execute {
        // Mint 30 tokens and deposit them into the recipient's Vault
        self.mintingRef.mintTokens(amount: 30.0, recipient: self.receiver)

        log("30 tokens minted and deposited to account "
            .concat(self.receiver.address.toString()))
    }
}
```

:::info[Action]

Test out your minting function by attempting to mint tokens to accounts that do and do not have vaults.

:::

## Checking Account Balances

You can mint tokens now.  Probably.  But it's hard to tell if you have a bug without a way to check an accounts balance.  You can do this with a script, using techniques you've already learned.

:::info[Action]

Write a script to check the balance of an address.  It should accept an argument for an `address`. In this script,`get` and `borrow` a reference to that address's `Vault` from the `VaultPublicPath`, and return a nicely formatted string containing the `balance`.

:::

You should end up with something similar to:

```cadence
import ExampleToken from 0x06

access(all)
fun main(address: Address): String {
    let account = getAccount(address)

    let accountReceiverRef = account.capabilities.get<&{ExampleToken.Balance}>(ExampleToken.VaultPublicPath)
                            .borrow()
            ?? panic(ExampleToken.vaultNotConfiguredError(address: address))

    return("Balance for "
        .concat(address.toString())
        .concat(": ").concat(accountReceiverRef.balance.toString())
        )
}
```


## Transferring Tokens

Transferring tokens from one account to another takes a little more coordination and a more complex contract. When an account wants to send tokens to a different account, the sending account calls their own withdraw function first, which subtracts tokens from their resource's balance and temporarily creates a new resource object that holds this balance.

:::info[Action]

Initialize a transaction-level variable to hold a temporary vault. Borrow a reference for the sender's vault with the `Withdraw` entitlement and send it to the temporary vault.

:::

```cadence
import ExampleToken from 0x06

transaction(recipient: Address, amount: UFix64) {
    var temporaryVault: @ExampleToken.Vault

  prepare(signer: auth(BorrowValue) &Account) {
        let vaultRef = signer.storage.borrow<auth(ExampleToken.Withdraw) &ExampleToken.Vault>
                from: ExampleToken.VaultStoragePath)
            ?? panic(ExampleToken.vaultNotConfiguredError(address: signer.address))

        self.temporaryVault <- vaultRef.withdraw(amount: amount)
    }
}
```

The sending account then gets a reference to the recipients published capability and calls the recipient account's deposit function, which literally moves the resource instance to the other account, adds it to their balance, and then destroys the used resource.

:::info[Action]

Use the `execute` phase to `deposit` the tokens in the `temporaryVault` into the recipient's vault.

:::

```cadence
execute{
    let receiverAccount = getAccount(recipient)

    let receiverRef = receiverAccount
        .capabilities
        .borrow<&ExampleToken.Vault>(ExampleToken.VaultPublicPath)
        ?? panic(ExampleToken.vaultNotConfiguredError(address: recipient))

    receiverRef.deposit(from: <-self.temporaryVault)

    log("Withdraw/Deposit succeeded!")
}
```

The resource is destroyed by the `deposit` function.  It needs to be destroyed because Cadence enforces strict rules around resource interactions. A resource can never be left hanging in a piece of code. It either needs to be explicitly destroyed or stored in an account's storage.

This rule ensures that resources, which often represent real value, do not get lost because of a coding error.

You'll notice that the arithmetic operations aren't explicitly protected against overflow or underflow.

```cadence
self.balance = self.balance - amount
```

Cadence has built-in overflow and underflow protection, so it is not a risk. We are also using unsigned numbers in this example, so as mentioned earlier, the vault`s balance cannot go below 0.

Additionally, the requirement that an account contains a copy of the token's resource type in its storage ensures that funds cannot be lost by being sent to the wrong address.

If an address doesn't have the correct resource type imported, the transaction will revert, ensuring that transactions sent to the wrong address are not lost.

:::danger

Every Flow account is initialized with a default Flow Token Vault in order to pay for storage fees and transaction [fees].  If an address is in use, it will be able to accept Flow tokens, without a user or developer needing to take further action.  If that account becomes lost, any tokens inside will be lost as well.

:::

## Reviewing Fungible Tokens

In this tutorial, you learned how to create a simplified version of fungible tokens on Flow. You build a vault [resource] to safely store tokens inside the owner's storage, and used [interfaces] to define and enforce the properties a vault should have.  By using [interfaces], your definition is flexible and composable.  Other developers can use all or parts of these definitions to build new apps and contracts that are compatible with yours.

You also practiced writing transactions on your own, and learned some new techniques, such as writing error messages more easily, using paths stored in the contract, and separating different parts of the transaction into their appropriate sections - `prepare` and `execute`.

Now that you have completed the tutorial, you should be able to:

* Compare and contrast how tokens are stored in Flow Cadence compared to Ethereum.
* Utilize the `UFix64` type to allow decimals without converting back and forth with 10^18.
* Implement a vault [resource] to manage the functionality needed for fungible tokens
* Use [interfaces] to enforce the presence of specified functions and fields.
* Write transactions to transfer tokens safely from one account to another.
* Develop scripts to read account balances.
* Use preconditions and postconditions to perform checks before or after a function call completes.

If you're ready to try your hand at implementing a production-quality token, head over to the [Fungible Token Developer Guide].

In the next tutorial, you'll combine the techniques and patterns you've learned for the classic challenge - building an NFT marketplace!

<!-- Reference-style links, do not render on page -->

[resource]: ../language/resources.mdx
[interfaces]: ../language/interfaces.mdx
[native network token (FLOW)]: https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowToken.cdc
[Flow Fungible Token standard]: https://github.com/onflow/flow-ft
[Fungible Token Developer Guide]: https://developers.flow.com/build/guides/fungible-token
[resource]: ../language/resources.mdx
[resources]: ../language/resources.mdx
[fixed-point number]: ../language/values-and-types.mdx#fixed-point-numbers
[entitlement]: ../language/access-control.md
[Function preconditions and postconditions]: ../language/functions.mdx#function-preconditions-and-postconditions
[statements]: ../language/syntax.md#semicolons
[capability]: ../language/capabilities.md
[fees]: https://developers.flow.com/build/basics/fees.md#fees




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/index.md

---
title: The Cadence Programming Language
sidebar_label: Language Reference
---

## Introduction

The Cadence Programming Language is a new high-level programming language
intended for smart contract development.

The language's goals are, in order of importance:

- **Safety and security**:
  Provide a strong static type system, design by contract (preconditions and postconditions),
  and resources (inspired by linear types).

- **Auditability**:
  Focus on readability: Make it easy to verify what the code is doing,
  and make intentions explicit, at a small cost of verbosity.

- **Simplicity**: Focus on developer productivity and usability:
  Make it easy to write code, provide good tooling.

## Terminology

In this document, the following terminology is used to describe syntax
or behavior that is not allowed in the language:

- `Invalid` means that the invalid program will not even be allowed to run.
  The program error is detected and reported statically by the type checker.

- `Run-time error` means that the erroneous program will run,
  but bad behavior will result in the execution of the program being aborted.

## Syntax and Behavior

Much of the language's syntax is inspired by Swift, Kotlin, and TypeScript.

Much of the syntax, types, and standard library is inspired by Swift,
which popularized e.g. optionals, argument labels,
and provides safe handling of integers and strings.

Resources are based on linear types which were popularized by Rust.

Events are inspired by Solidity.

**Disclaimer:** In real Cadence code, all type definitions and code
must be declared and contained in [contracts](./contracts.mdx) or [transactions](./transactions.md),
but we omit these containers in examples for simplicity.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/cadence-migration-guide/index.md

---
title: Cadence 1.0 Migration Guide
sidebar_position: 1
sidebar_label: Cadence 1.0 Migration Guide
---

On September 4th, 2024 the Flow Mainnet upgraded to Cadence 1.0.

This migration guide offers developers guidance, actionable steps,
around updating projects to be compatible with Cadence 1.0.

The Cadence 1.0 release, introduced in the
[Crescendo](https://flow.com/upgrade/crescendo) network upgrade, is a breaking change.
Developers need to make sure all Cadence code used by their app (transactions and scripts)
to Cadence 1.0, to ensure it continues to work after the network upgrade.

Many of the improvements of Cadence 1.0 fundamentally change how Cadence works and is used.
This means it is necessary to break existing code to release this version,
which will guarantee stability going forward.

### Benefits of Cadence 1.0

Cadence 1.0 is the latest version of the Cadence smart contract programming language.
The stable release of Cadence 1.0 represents a significant milestone in the language’s maturity,
delivering a [comprehensive suite of new features and improvements](./improvements.md)
that provide new possibilities, increase speed, security and efficiency.
With Cadence 1.0, developers gain access to over 20 new features and enhancements.
Each change is thoughtfully designed to streamline workflows, reduce duplication
and improve code readability, making writing and understanding smart contracts much easier.

### Upgrading NFT and FT Contracts

In addition to changes to the Cadence programming language,
the Cadence token standards were also streamlined and improved.
Existing Cadence scripts and transactions interacting with NFTs and FTs need to be updated.
If you do not update your code, your applications is non-functional.

- [Guide for NFT Standard v2](./nft-guide.mdx)
- [Guide for FT Standard v2](./ft-guide.mdx)
- [Cadence 1.0 Improvements & New Features](./improvements.md)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/capabilities.md

---
title: Capabilities
sidebar_position: 14
---

Cadence supports [capability-based security](https://en.wikipedia.org/wiki/Capability-based_security)
through the [object-capability model](https://en.wikipedia.org/wiki/Object-capability_model).

A capability in Cadence is a value that represents the right
to access an object and perform certain operations on it.
A capability specifies _what_ can be accessed, and _how_ it can be accessed.

Capabilities are unforgeable, transferable, and revocable.

Capabilities can be storage capabilities or account capabilities:
- **Storage capabilities** grant access to [objects in account storage](./accounts/storage.mdx),
via [paths](./accounts/paths.mdx)
- **Account capabilities** grant access to [accounts](./accounts/index.mdx)

Capabilities can be borrowed to get a [reference](./references.mdx) to the stored object or the account it refers to.

Capabilities have the type `Capability<T: &Any>`.
The type parameter specifies the kind of reference that can be obtained when borrowing the capability.
The type specifies the associated set of access rights through [entitlements](./access-control.md):
the reference type of the capability can be authorized,
which grants the owner of the capability the ability to access the fields and functions of the target
which require the given entitlements.

For example, a capability which has type `Capability<auth(SaveValue) &Account>`
grants access to an account, and allows saving a value into the account.

Each capability has an ID.
The ID is unique **per account/address**.

Capabilities are created and managed through [capability controllers](./accounts/capabilities.mdx).

Capabilities are structs, so they are copyable. 
They can be used (e.g. borrowed) arbitrarily many times, as long as the target capability controller has not been deleted.

## `Capability`

```cadence
access(all)
struct Capability<T: &Any> {
    
    /// The address of the account which the capability targets.
    access(all)
    let address: Address

    /// The ID of the capability.
    access(all)
    let id: UInt64

    /// Returns a reference to the targeted object.
    ///
    /// If the capability is revoked, the function returns nil.
    ///
    /// If the capability targets an object in account storage,
    /// and and no object is stored at the target storage path,
    /// the function returns nil.
    ///
    /// If the targeted object cannot be borrowed using the given type,
    /// the function panics.
    ///
    access(all)
    view fun borrow(): T?

    /// Returns true if the capability currently targets an object
    /// that satisfies the given type, i.e. could be borrowed using the given type.
    ///
    access(all)
    view fun check(): Bool
}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/03-resources.md

---
archived: false
draft: false
title: Resources and the Move (<-) Operator
description: An introduction to resources, capabilities, and account storage in Cadence
date: 2024-12-04
meta:
  keywords:
    - tutorial
    - Flow
    - Cadence
    - Resources
    - Capabilities
tags:
  - reference
  - cadence
  - tutorial
socialImageTitle: Cadence Resources
socialImageDescription: Resource smart contract image.
---

This tutorial will build on your understanding of accounts and how to interact with them by introducing [resources].  Resources are a special type found in Cadence that are used for any virtual items, properties, or any other sort of data that are **owned** by an account.  They can **only exist in one place at a time**, which means they can be moved or borrowed, but they **cannot be copied**.

Working with resources requires you to take a few more steps to complete some tasks, but this level of explicit control makes it nearly impossible to accidentally duplicate, break, or burn an asset.

## Objectives

After completing this tutorial, you'll be able to:

* Instantiate a `resource` in a smart contract with the `create` keyword
* Save, move, and load resources using the [Account Storage API] and the [move operator] (`<-`)
* Use [`borrow`] to access and use a function in a resource
* Use the `prepare` phase of a transaction to load resources from account storage
* Set and use variables in both the `prepare` and `execute` phase
* Use the [nil-coalescing operator (`??`)] to `panic` if a resource is not found

## Resources

[Resources] are one of the most important and unique features in Cadence.  They're a composite type, like a struct or a class in other languages, but with some special rules designed to avoid many of the traditional dangers in smart contract development.  The short version is that resources can only exist in one location at a time - they cannot be copied, duplicated, or have multiple references.

Here is an example definition of a resource:

```cadence
access(all) resource Money {
    access(all) let balance: Int

    init() {
        self.balance = 0
    }
}
```

See, it looks just like a regular `struct` definition! The difference is in the behavior.

Resources are useful when you want to model **direct ownership** of an asset or an object. By **direct ownership**, we mean the ability to own an **actual object** in **your storage** that represents your asset, instead of just a password or certificate that allows you to access it somewhere else.

Traditional structs or classes from other conventional programming languages
are not an ideal way to represent direct ownership because they can be **copied**. This means a coding error can easily result in creating multiple copies of the same asset, which breaks the scarcity requirements needed for these assets to have real value.

We have to consider loss and theft at the scale of a house, a car, a bank account, or a horse.  It's worth a little bit of extra code to avoid accidentally duplicating ownership of one of these properties!

Resources solve this problem by making creation, destruction, and movement of assets explicit.

## Implementing a Contract with Resources

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:

<a
  href="https://play.flow.com/b999f656-5c3e-49fa-96f2-5b0a4032f4f1"
  target="_blank"
>
  https://play.flow.com/b999f656-5c3e-49fa-96f2-5b0a4032f4f1
</a>

`HelloWorldResource.cdc` contains the following code:

:::


```cadence HelloWorldResource.cdc
access(all) contract HelloResource {
  // TODO
}
```

### Defining a Resource

Similar to other languages, Cadence can declare type definitions within deployed contracts. A type definition is simply a description of how a particular set of data is organized. It **is not** a copy or instance of that data on its own.

Any account can import these definitions to interact with objects of those types.

The key difference between a `resource` and a `struct` or `class` is the access scope for resources:

- Each instance of a resource can only exist in exactly one location and cannot be copied.
  - Here, location refers to account storage, a temporary variable in a function, a storage field in a contract, etc.
- Resources must be explicitly moved from one location to another when accessed.
- Resources also cannot go out of scope at the end of function execution. They must be explicitly stored somewhere or explicitly destroyed.
- A resource can only be created in the scope that it is defined in. 
  - This prevents anyone from being able to create arbitrary amounts of resource objects that others have defined.

These characteristics make it impossible to accidentally lose a resource from a coding mistake.

:::info[Action]

Add a `resource` called `HelloAsset` that contains a function to return a string containing "Hello Resources!":

::

```cadence HelloResource.cdc
access(all) contract HelloResource {
    access(all) resource HelloAsset {
        // A transaction can call this function to get the "Hello Resources!"
        // message from the resource.
        access(all) view fun hello(): String {
            return "Hello Resources!"
        }
    }
}
```

A few notes on this function:
* `access(all)` makes the function publicly accessible
* `view` indicates that the function does not modify state
* The function return type is a `String`
* The function is **not** present on the contract itself and cannot be called by interacting with the contract

:::warning

If you're used to Solidity, you'll want to take note that the `view` keyword in Cadence is used in the same cases as both `view` and `pure` in Solidity.

:::

### Creating a Resource

Next, you'll create a resource with the `create` keyword and the [move operator] (`<-`).

You use the `create` keyword used to initialize a resource. Resources can only be created by the contract that defines them and **must** be created before they can be used.

The move operator `<-` is used to move a resource - you cannot use the assignment operator `=`. When you initialize them or assign then to a new variable, you use the move operator `<-` to **literally move** the resource from one location to another. The old variable or location that was holding it will no longer be valid after the move.

If you create a resource called `first_resource`:

```cadence
// Note the `@` symbol to specify that it is a resource
var first_resource: @AnyResource <- create AnyResource()
```

Then move it:

```cadence
var second_resource <- first_resource
```

The name `first_resource` is **no longer valid or usable**:

```cadence
// Bad code, will generate an error
var third_resource <- first_resource
```

:::info[Action]

Add a function called `createHelloAsset` that creates and returns a `HelloAsset` resource.

:::

```cadence HelloWorldResource.cdc
access(all) fun createHelloAsset(): @HelloAsset {
    return <-create HelloAsset()
}
```

Unlike the `hello()` function, this function **does** exist on the contract and can be called directly.  Doing so creates an instance of the `HelloAsset` resource, **moves** it through the `return` of the function to the location calling the function - the same as you'd expect for other languages.

Remember, when resources are referenced, the `@` symbol is placed at the beginning.  In the function above, the return type is a resource of the `HelloAsset` type.

:::info[Action]

Deploy this code to account `0x06` by using the `Deploy` button.

:::

## Create Hello Transaction

Now, we're going to create a transaction that calls the `createHelloAsset()` function and saves a `HelloAsset` resource to the account's storage.

:::info[Action]

Open the transaction named `Create Hello`.

:::


`Create Hello` should contain the following code:

```cadence create_hello.cdc
import HelloWorldResource from 0x06

transaction {
  // TODO
}
```

We've already imported the `HelloWorldResource` contract for you and stubbed out a `transaction`.  Unlike the transaction in Hello World, you will need to modify the user's account, which means you will need to use the `prepare` phase to access and modify the account that is going to get an instance of the resource.

### Prepare Phase

:::info[Action]

Create a `prepare` phase with the `SaveValue` authorization [entitlement] to the user's account, `create` a new instance of the `HelloAsset`, and save the new resource in the user's account.

First, inside the `transaction`, stub out the `prepare` phase with the authorization [entitlement]:

:::

```cadence
prepare(acct: auth(SaveValue) &Account) {
   // TODO
}
```

:::info[Action]

Next, use the `createHelloAsset` function in `HelloWorldResource` to `create` an instance of the resource and _move_ it into a constant:

:::

```cadence
let newHello <- HelloWorldResource.createHelloAsset()
```

### Storage Paths

In Cadence Accounts, objects are stored in [paths]. Paths represent a file system for your account, where an object can be stored at any user-defined path. Often, contracts will specify for the user where objects from that contract should be stored. This enables any code to know how to access these objects in a standard way.

Paths start with the character `/`, followed by the domain, the path separator `/`, and finally the identifier. The identifier must start with a letter and can only be followed by letters, numbers, or the underscore `_`. For example, the path `/storage/test` has the domain `storage` and the identifier `test`.

There are two valid domains: `storage` and `public`.

Paths in the storage domain have type `StoragePath`, and paths in the public domain have the type `PublicPath`. Both `StoragePath` and `PublicPath` are subtypes of `Path`.

Paths are not strings and do not have quotes around them.

:::info[Action]

Use the account reference with the `SaveValue` authorization [entitlement] to move the new resource into storage located in `/storage/HelloAssetTutorial`.

:::

```cadence
acct.storage.save(<-newHello, to: /storage/HelloAssetTutorial)
```

The first parameter in `save` is the object that is being stored, and the `to` parameter is the path that the object is being stored at. The path must be a storage path, so only the domain `/storage/` is allowed in the `to` parameter.

If there is already an object stored under the given path, the program aborts.

Remember, the Cadence type system ensures that a resource can never be accidentally lost. When moving a resource to a field, into an array, into a dictionary, or into storage, there is the possibility that the location already contains a resource.

Cadence forces the developer to explicitly handle the case of an existing resource so that it is not accidentally lost through an overwrite.

It is also very important when choosing the name of your paths to pick an identifier that is very specific and unique to your project.

Currently, account storage paths are global, so there is a chance that projects could use the same storage paths, **which could cause path conflicts**! This could be a headache for you, so choose unique path names to avoid this problem.

### Execute Phase

:::info[Action]

Use the `execute` phase to `log` a message that the resource was successfully saved:

:::

```cadence
execute {
    log("Saved Hello Resource to account.")
}
```

You should have something similar to:

```cadence
import HelloResource from 0x06

transaction {
        prepare(acct: auth(SaveValue) &Account) {
        let newHello <- HelloResource.createHelloAsset()
        acct.storage.save(<-newHello, to: /storage/HelloAssetTutorial)
    }

	execute {
        log("Saved Hello Resource to account.")
	}
}
```

This is our first transaction using the `prepare` phase!

The `prepare` phase is the only place that has access to the signing account, via [account references (`&Account`)].

Account references have access to many different methods that are used to interact with an account, such as to `save` a resource to the account's storage.

By not allowing the execute phase to access account storage and using entitlements, we can statically verify which assets and areas/paths of the signers' account a given transaction can modify.

Browser wallets and applications that submit transactions for users can use this to show what a transaction could alter, giving users information about transactions that wallets will be executing for them, and confidence that they aren't getting fed a malicious or dangerous transaction from an app or wallet.

:::info[Action]

Select account `0x06` as the only signer. Click the `Send` button to submit
the transaction.

:::

You'll see in the log:

```text
"Saved Hello Resource to account."
```

:::info[Action]

`Send` the transaction again from account `0x06`

:::

You'll now get an error, because there's already a resource in `/storage/HelloAssetTutorial`:

```text
execution error code 1: [Error Code: 1101] error caused by: 1 error occurred:
	* transaction execute failed: [Error Code: 1101] cadence runtime error: Execution failed:
error: failed to save object: path /storage/HelloAssetTutorial in account 0x0000000000000009 already stores an object
  --> 805f4e247a920635abf91969b95a63964dcba086bc364aedc552087334024656:19:8
   |
19 |         acct.storage.save(<-newHello, to: /storage/HelloAssetTutorial)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

:::info[Action]

Try removing the line of code that saves `newHello` to storage.

You'll get an error for `newHello` that says `loss of resource`. This means that you are not handling the resource properly. Remember that if you ever see this error in any of your programs, it means there is a resource somewhere that is not being explicitly stored or destroyed.

**Add the line back before you forget!**

:::

### Reviewing Storage

Now that you have executed the transaction, account `0x06` will have the newly created `HelloWorld.HelloAsset` resource stored in its storage. You can verify this by clicking on account `0x06` on the bottom left. This will open a view of the different contracts and objects in the account.

You'll see the resource you created in Account Storage:

```
{
    "value": [
        {
            "key": {
                "value": "value",
                "type": "String"
            },
            "value": {
                "value": {
                    "id": "A.0000000000000006.HelloResource.HelloAsset",
                    "fields": [
                        {
                            "value": {
                                "value": "269380348805120",
                                "type": "UInt64"
                            },
                            "name": "uuid"
                        }
                    ]
                },
                "type": "Resource"
            }
        },
        {
            "key": {
                "value": "type",
                "type": "String"
            },
            "value": {
                "value": "A.0000000000000006.HelloResource.HelloAsset",
                "type": "String"
            }
        },
        {
            "key": {
                "value": "path",
                "type": "String"
            },
            "value": {
                "value": {
                    "domain": "storage",
                    "identifier": "HelloAssetTutorial"
                },
                "type": "Path"
            }
        }
    ],
    "type": "Dictionary"
}
```

You'll also see `FlowToken` objects, and the `HelloResource` Contract.

:::info[Action]

Run the transaction from account `0x07` and compare the differences between the accounts.

:::

### Checking for Existing Storage

In real applications, you need to check the location path you are storing in to make sure both cases are handled properly.

:::info[Action]

First, update the authorization [entitlement] in the prepare phase to include `BorrowValue`:

:::

```cadence
prepare(acct: auth(BorrowValue, SaveValue) &Account) {
    // Existing code...
}
```

:::info[Action]

Next, add a `transaction`-level variable to store a result `String`:

:::

Similar to a class-level variable in other languages, these go at the top, inside the `transaction` scope, but not inside anything else. They are accessible in both the `prepare` and `execute` statements of a transaction.

```cadence
import HelloResource from 0x06

transaction {
    var result: String
    // Other code...
}
```

You'll get an error: `missing initialization of field `result` in type `Transaction`. not initialized`

In transactions, variables at the `transaction` level must be initialized in the `prepare` phase.

:::info[Action]

Initialize the `result` message and create a constant for the storage path.

:::

```cadence
self.result = "Saved Hello Resource to account."
let storagePath = /storage/HelloAssetTutorial
```

:::warning

In Cadence, storage paths are a type.  They are **not** `Strings` and are not enclosed by quotes.

:::

One way to check whether or not a storage path has an object in it is to use the built-in [`storage.check`] function with the type and path.  If the result is `true`, then there is an object in account storage that matches the type requested.  If it's `false`, there is not.

```warning

A response of `false` does **not** mean the location is empty.  If you ask for an apple and the location contains an orange, this function will return `false`.

This is not likely to occur because projects are encouraged to create storage and public paths that are very unique, but is theoretically possible if projects don't follow this best practice or if there is a malicious app that tries to store things in other projects' paths.

```

Depending on the needs of your app, you'll use this pattern to decide what to do in each case.  For this example, we'll simply use it to change the log message if the storage is in use or create and save the `HelloAsset` if it is not.

:::info[Action]

Refactor your prepare statement to check and see if the storage path is in use.  If it is, update the `result` message.  Otherwise, create and save a `HelloAsset`:

:::

```cadence
if !acct.storage.check<&HelloWorldResource.HelloAsset>(from: storagePath) {
    self.result = "Unable to save, resource already present."
} else {
    let newHello <- HelloWorldResource.createHelloAsset()
    acct.storage.save(<-newHello, to: storagePath)
}
```

When you [`check`] a resource, you must put the type of the resource to be borrowed inside the `<>` after the call to `borrow`, before the parentheses.  The `from` parameter is the storage path to the object you are borrowing.

:::info[Action]

Finally, update the `log` in execute to use `self.result` instead of the hardcoded string:

:::

```cadence
execute {
    log(self.result)
}
```

:::info[Action]

`Send` the transaction again, both with accounts that have and have not yet created and stored an instance of `HelloAsset`.

:::

Now you'll see an appropriate log whether or not a new resource was created and saved.


## Load Hello Transaction

Now we're going to use a transaction to call the `hello()` method from the `HelloAsset` resource.

:::info[Action]

Open the transaction named `Load Hello`.

:::

It's empty!

:::info[Action]

On your own, stub out a transaction that imports `HelloWorldResource` and passes in an account [reference] with the `BorrowValue` authorization entitlement.

:::

You should end up with something like this:

```cadence load_hello.cdc
import HelloWorldResource from 0x06

transaction {

    prepare(acct: auth(BorrowValue) &Account) {
        // TODO
    }
}
```

You just learned how to [`borrow`] a [reference] to a resource.  You could use an `if` statement to handle the possibility that the resource isn't there, but if you want to simply terminate execution, a common practice is to combine a `panic` statement with the [nil-coalescing operator (`??`)].

This operator executes the statement on the left side.  If that is `nil`, the right side is evaluated and returned.  In this case, the return is irrelevant, because we're going to cause a `panic` and terminate execution.

:::info[Action]

Create a variable with a [reference] to the `HelloAsset` resource stored in the user's account.  Panic if this resource is not found.

:::

```cadence
let helloAsset = acct.storage.borrow<&HelloWorldResource.HelloAsset>(from: /storage/HelloAssetTutorial)
    ?? panic("The signer does not have the HelloAsset resource stored at /storage/HelloAssetTutorial. Run the `Create Hello` Transaction to store the resource")
```

:::info[Action]

Finally, `log` the return from a call to the `hello()` function.

:::

:::warning

Borrowing a [reference] does **not** allow you to move or destroy a resource, but it **does allow** you to mutate data inside that resource via one of the resource's functions.

:::

Your transaction should be similar to:

```cadence
import HelloWorldResource from 0x06

transaction {
    prepare(acct: auth(BorrowValue, LoadValue, SaveValue) &Account) {
        let helloAsset = acct.storage.borrow<&HelloWorldResource.HelloAsset>(from: /storage/HelloAssetTutorial)
            ?? panic("The signer does not have the HelloAsset resource stored at /storage/HelloAssetTutorial. Run the `Create Hello` Transaction again to store the resource")

        log(helloAsset.hello())
    }
}
```

In Cadence, we have the resources to leave very detailed error messages. Check out the error messages in the [Non-Fungible Token Contract] and [Generic NFT Transfer transaction] in the Flow NFT GitHub repo for examples of production error messages.

:::info[Action]

Test your transaction with several accounts to evaluate all possible cases.

:::

## Reviewing the Resource Contract

In this tutorial you learned how to `create` [resources] in Cadence. You implemented a smart contract that is accessible in all scopes.  The smart contract has a resource declared that implemented a function called `hello()`, that returns the string `"Hello, World!"`.  It also declares a function that can create a resource.

Next, you implemented a transaction to create the resource and save it in the account calling it.

Finally, you used a transaction to [borrow] a [reference] to the `HelloAsset` resource from account storage and call the `hello` method

Now that you have completed the tutorial, you can:

* Instantiate a `resource` in a smart contract with the `create` keyword
* Save, move, and load resources using the [Account Storage API] and the [move operator] (`<-`)
* Use [`borrow`] to access and use a function in a resource
* Use the `prepare` phase of a transaction to load resources from account storage
* Set and use variables in both the `prepare` and `execute` phase
* Use the [nil-coalescing operator (`??`)] to `panic` if a resource is not found

<!-- Relative links.  Will not render on the page -->

[resources]: ../language/resources.mdx
[Resources]: ../language/resources.mdx
[move operator]: ../language/operators.md#move-operator--
[Account Storage API]: ../language/accounts/storage.mdx
[`storage.check`]: ../language/accounts/storage.mdx#accountstorage
[`borrow`]: ../language/accounts/storage.mdx#accessing-objects
[borrow]: ../language/accounts/storage.mdx#accessing-objects
[entitlement]: ../language/access-control#entitlements
[account references (`&Account`)]: ../language/accounts/index.mdx
[paths]: ../language/accounts/paths.mdx
[reference]: ../language/references.mdx
[nil-coalescing operator (`??`)]: ../language/operators.md#nil-coalescing-operator-
[Non-Fungible Token Contract]: https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc#L115-L121)
[Generic NFT Transfer transaction]: https://github.com/onflow/flow-nft/blob/master/transactions/generic_transfer_with_address_and_type.cdc#L46-L50





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/10-resources-compose.md

---
title: 10. Composable Resources
---

In this tutorial, we're going to walk through how resources can own other resources by creating, deploying, and moving composable NFTs.

---

:::info[Action]

This tutorial just includes example code. It does not have an associated playground project.
You are still welcome to copy this code and paste it to the playground to test it out though!

:::

Resources owning other resources is a powerful feature in the world of blockchain and smart contracts.

**Before proceeding with this tutorial**, we recommend following the instructions in [Getting Started](./01-first-steps.md), 
[Hello, World!](./02-hello-world.md),
and [Resources](./03-resources.md) to learn about the Playground and Cadence.


## Resources Owning Resources

---

The NFT collections talked about in [Non-Fungible Tokens](./05-non-fungible-tokens-1.md) are examples of resources that own other resources.
We have a resource, the NFT collection, that has ownership of the NFT resources that are stored within it.
The owner and anyone with a reference can move these resources around,
but they still belong to the collection while they are in it and the code defined in the collection has ultimate control over the resources.

When the collection is moved or destroyed, all of the NFTs inside of it are moved or destroyed with it.

If the owner of the collection transferred the whole collection resource to another user's account,
all of the tokens will move to the other user's account with it. The tokens don't stay in the original owner's account.
This is like handing someone your wallet instead of just a dollar bill. It isn't a common action, but certainly is possible.

References cannot be created for resources that are stored in other resources.
The owning resource has control over it and therefore controls the type of access that external calls have on the stored resource.

## Resources Owning Resources: An Example

---

The NFT collection is a simple example of how resources can own other resources, but innovative and more powerful versions can be made.

An important feature of CryptoKitties (and other applications on the Ethereum blockchain) is that any developer can make new experiences around the existing application.
Even though the original contract didn't include specific support for CryptoKitty accessories (like hats), an independent developer was still able to make hats that Kitties from the original contract could use.

Here is a basic example of how we can replicate this feature in Cadence:

```cadence KittyVerse.cdc
// KittyVerse.cdc
//
// The KittyVerse contract defines two types of NFTs.
// One is a KittyHat, which represents a special hat, and
// the second is the Kitty resource, which can own Kitty Hats.
//
// You can put the hats on the cats and then call a hat function
// that tips the hat and prints a fun message.
//
// This is a simple example of how Cadence supports
// extensibility for smart contracts, but the language will soon
// support even more powerful versions of this.
//

access(all) contract KittyVerse {

    // KittyHat is a special resource type that represents a hat
    access(all) resource KittyHat {

        access(all) let id: Int
        
        access(all) let name: String

        init(id: Int, name: String) {
            self.id = id
            self.name = name
        }

        // An example of a function someone might put in their hat resource
        access(all) fun tipHat(): String {
            if self.name == "Cowboy Hat" {
                return "Howdy Y'all"
            } else if self.name == "Top Hat" {
                return "Greetings, fellow aristocats!"
            }

            return "Hello"
        }
    }

    // Create a new hat
    access(all) fun createHat(id: Int, name: String): @KittyHat {
        return <-create KittyHat(id: id, name: name)
    }

    access(all) resource Kitty {

        access(all) let id: Int

        // place where the Kitty hats are stored
        access(all) var items: @{String: KittyHat}

        init(newID: Int) {
            self.id = newID
            self.items <- {}
        }

        access(all) fun getKittyItems(): @{String: KittyHat} {
            var other: @{String:KittyHat} <- {}
            self.items <-> other
            return <- other
        }

        access(all) fun setKittyItems(items: @{String: KittyHat}) {
            var other <- items
            self.items <-> other
            destroy other
        }

        access(all) fun removeKittyItem(key: String): @KittyHat? {
            var removed <- self.items.remove(key: key)
            return <- removed
        }
    }

    access(all) fun createKitty(): @Kitty {
        return <-create Kitty(newID: 1)
    }
}
```

These definitions show how a Kitty resource could own hats.

The hats are stored in a variable in the Kitty resource.

```cadence
    // place where the Kitty hats are stored
    access(all) var items: @{String: KittyHat}
```

A Kitty owner can take the hats off the Kitty and transfer them individually. Or the owner can transfer a Kitty that owns a hat, and the hat will go along with the Kitty.

Here is a transaction to create a `Kitty` and a `KittyHat`, store the hat in the Kitty, then store it in your account storage.

```cadence create_kitty.cdc
import KittyVerse from 0x06

// This transaction creates a new kitty, creates two new hats and
// puts the hats on the cat. Then it stores the kitty in account storage.
transaction {
    prepare(acct: auth(SaveValue) &Account) {

        // Create the Kitty object
        let kitty <- KittyVerse.createKitty()

        // Create the KittyHat objects
        let hat1 <- KittyVerse.createHat(id: 1, name: "Cowboy Hat")
        let hat2 <- KittyVerse.createHat(id: 2, name: "Top Hat")

        let kittyItems <- kitty.getKittyItems()

        // Put the hat on the cat!
        let oldCowboyHat <- kittyItems["Cowboy Hat"] <- hat1
        destroy oldCowboyHat
        let oldTopHat <- kittyItems["Top Hat"] <- hat2
        destroy oldTopHat

        kitty.setKittyItems(items: <-kittyItems)

        log("The cat has the hats")

        // Store the Kitty in storage
        acct.storage.save(<-kitty, to: /storage/kitty)
    }
}
```

Now we can run a transaction to move the Kitty along with its hat, remove the cowboy hat from the Kitty, then make the Kitty tip its hat.

```cadence tip_hat.cdc
import KittyVerse from 0x06

// This transaction moves a kitty out of storage, takes the cowboy hat off of the kitty,
// calls its tip hat function, and then moves it back into storage.
transaction {
    prepare(acct: auth(Storage) &Account) {

        // Move the Kitty out of storage, which also moves its hat along with it
        let kitty <- acct.storage.load<@KittyVerse.Kitty>(from: /storage/kitty)
            ?? panic("Kitty doesn't exist!")

        // Take the cowboy hat off the Kitty
        let cowboyHat <- kitty.removeKittyItem(key: "Cowboy Hat")
            ?? panic("cowboy hat doesn't exist!")

        // Tip the cowboy hat
        log(cowboyHat.tipHat())
        destroy cowboyHat

        // Tip the top hat that is on the Kitty
        log(kitty.items["Top Hat"]?.tipHat())

        // Move the Kitty to storage, which
        // also moves its hat along with it.
        acct.storage.save(<-kitty, to: /storage/kitty)
    }
}
```

If you were to run this transaction, you should see something like this output:

```
> "Howdy Y'all"
> "Greetings, fellow aristocats!"
```

Whenever the Kitty is moved, its hats are implicitly moved along with it. This is because the hats are owned by the Kitty.

## The Future is Meow! Extensibility is coming!

---

The above is a simple example of composable resources.
We had to explicitly say that a Kitty could own a Hat in this example,
but Cadence now supports more powerful ways of achieving resource extensibility
where developers can declare types that separate resources can own
even if the owning resource never specified the ownership possibility in the first place.

This feature is called [Attachments](https://cadence-lang.org/docs/language/attachments)
and you should check out the documentation to learn about this powerful feature!

Practice what you're learned in the Flow Playground!





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/why.md

---
title: Why Use Cadence?
sidebar_position: 2
---

## Security and Safety

Cadence provides security and safety guarantees that greatly simplify the development of secure smart contracts. As smart contracts often deal with valuable assets, Cadence provides the resource-oriented programming paradigm, which guarantees that assets can only exist in one location at a time, cannot be copied, and cannot be accidentally lost or deleted.
Cadence includes several language features which prevent entire classes of bugs.
These security and safety features allow smart contract developers to focus on the business logic of their contract instead of preventing accidents and attacks.

## Composability

Cadence enables composability. Resources (which are arbitrary user-defined data types) are stored directly in users’ accounts, and can flow freely between contracts: They can be passed as arguments to functions, returned from functions, or even combined in arbitrary data structures. This makes implementing business logic easier, more natural and promotes reuse of existing logic.

## Simplicity

Cadence’s syntax is inspired by popular modern general-purpose programming languages like [Swift](https://developer.apple.com/swift/), [Kotlin](https://kotlinlang.org/), and [Rust](https://www.rust-lang.org/), so developers will find the syntax and the semantics familiar.
Practical tooling, documentation, and examples enable developers to start creating programs quickly and effectively. Hundreds of developers were able to learn Cadence quickly and develop production-quality smart contracts with it shortly.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/contract-updatability.md

---
title: Contract Updatability
sidebar_position: 23
---

## Introduction
A [contract](./contracts.mdx) is a collection of data (its state) and
code (its functions) that lives in the contract storage area of an account.
When a contract is updated, it is important to make sure that the changes introduced do not lead to runtime
inconsistencies for already stored data.
Cadence maintains this state consistency by validating the contracts and all their components before an update.

## Validation Goals
The contract update validation ensures that:

- Stored data doesn't change its meaning when a contract is updated.
- Decoding and using stored data does not lead to runtime crashes.
  - For example, it is invalid to add a field because existing stored data won't have the new field.
  - Loading the existing data will result in garbage/missing values for such fields.
  - A static check of the access of the field would be valid, but the interpreter would crash when accessing the field,
    because the field has a missing/garbage value.

However, it **does not** ensure:
- Any program that imports the updated contract stays valid. e.g:
  - Updated contract may remove an existing field or may change a function signature.
  - Then any program that uses that field/function will get semantic errors.

## Updating a Contract
Changes to contracts can be introduced by adding new contracts, removing existing contracts, or updating existing
contracts. However, some of these changes may lead to data inconsistencies as stated above.

#### Valid Changes
- Adding a new contract is valid.
- Removing a contract/contract-interface that doesn't have enum declarations is valid.
- Updating a contract is valid, under the restrictions described in the below sections.

#### Invalid Changes
- Removing a contract/contract-interface that contains enum declarations is not valid.
  - Removing a contract allows adding a new contract with the same name.
  - The new contract could potentially have enum declarations with the same names as in the old contract, but with
    different structures.
  - This could change the meaning of the already stored values of those enum types.

A contract may consist of fields and other declarations such as composite types, functions, constructors, etc.
When an existing contract is updated, all its inner declarations are also validated.

### Contract Fields
When a contract is deployed, the fields of the contract are stored in an account's contract storage.
Changing the fields of a contract only changes the way the program treats the data, but does not change the already
stored data itself, which could potentially result in runtime inconsistencies as mentioned in the previous section.

See the [section about fields below](#fields) for the possible updates that can be done to the fields, and the restrictions
imposed on changing fields of a contract.

### Nested Declarations
Contracts can have nested composite type declarations such as structs, resources, interfaces, and enums.
When a contract is updated, its nested declarations are checked, because:
 - They can be used as type annotation for the fields of the same contract, directly or indirectly.
 - Any third-party contract can import the types defined in this contract and use them as type annotations.
 - Hence, changing the type definition is the same as changing the type annotation of such a field (which is also invalid,
   as described in the [section about fields fields](#fields) below).

Changes that can be done to the nested declarations, and the update restrictions are described in following sections:
 - [Structs, resources and interface](#structs-resources-and-interfaces)
 - [Enums](#enums)
 - [Functions](#functions)
 - [Events](#events)
 - [Constructors](#constructors)

## Fields
A field may belong to a contract, struct, resource, or interface.

#### Valid Changes:
- Removing a field is valid
  ```cadence
  // Existing contract

  access(all)
  contract Foo {
    
      access(all)
      var a: String

      access(all)
      var b: Int
  }


  // Updated contract

  access(all)
  contract Foo {
      access(all)
      var a: String
  }
  ```
  - It leaves data for the removed field unused at the storage, as it is no longer accessible.
  - However, it does not cause any runtime crashes.

- Changing the order of fields is valid.
  ```cadence
  // Existing contract

  access(all)
  contract Foo {

      access(all)
      var a: String

      access(all)
      var b: Int
  }


  // Updated contract

  access(all)
  contract Foo {

      access(all)
      var b: Int

      access(all)
      var a: String
  }
  ```

- Changing the access modifier of a field is valid.
  ```cadence
  // Existing contract

  access(all)
  contract Foo {
      access(all)
      var a: String
  }


  // Updated contract

  access(all)
  contract Foo {
      access(self)
      var a: String   // access modifier changed to 'access(self)'
  }
  ```

#### Invalid Changes
- Adding a new field is not valid.
  ```cadence
  // Existing contract

  access(all)
  contract Foo {
      access(all)
      var a: String
  }


  // Updated contract

  access(all)
  contract Foo {
    
      access(all)
      var a: String

      access(all)
      var b: Int      // Invalid new field
  }
  ```
    - Initializer of a contract only run once, when the contract is deployed for the first time. It does not rerun
      when the contract is updated. However, it is still required to be present in the updated contract to satisfy type checks.
    - Thus, the stored data won't have the new field, as the initializations for the newly added fields do not get
      executed.
    - Decoding stored data will result in garbage or missing values for such fields.

- Changing the type of existing field is not valid.
  ```cadence
  // Existing contract

  access(all)
  contract Foo {

      access(all)
      var a: String
  }


  // Updated contract

  access(all)
  contract Foo {

      access(all)
      var a: Int      // Invalid type change
  }
  ```
    - In an already stored contract, the field `a` would have a value of type `String`.
    - Changing the type of the field `a` to `Int`, would make the runtime read the already stored `String`
      value as an `Int`, which will result in deserialization errors.
    - Changing the field type to a subtype/supertype of the existing type is also not valid, as it would also
      potentially cause issues while decoding/encoding.
      - e.g: Changing an `Int64` field to `Int8` - Stored field could have a numeric value`624`, which exceeds the value space
        for `Int8`.
      - However, this is a limitation in the current implementation, and the future versions of Cadence may support
        changing the type of field to a subtype, by providing means to migrate existing fields.

## Structs, Resources and Interfaces

#### Valid Changes:
- Adding a new struct, resource, or interface is valid.
- Adding an interface conformance to a struct/resource is valid, since the stored data only
  stores concrete type/value, but doesn't store the conformance info.
  ```cadence
  // Existing struct

  access(all)
  struct Foo {
  }


  // Upated struct

  access(all)
  struct Foo: T {
  }
  ```
  - However, if adding a conformance also requires changing the existing structure (e.g: adding a new field that is
    enforced by the new conformance), then the other restrictions (such as [restrictions on fields](#fields)) may
    prevent performing such an update.

#### Invalid Changes:
- Removing an existing declaration is not valid.
  - Removing a declaration allows adding a new declaration with the same name, but with a different structure.
  - Any program that uses stored data belong to that type would face inconsistencies.
- Renaming a declaration is not valid. It can have the same effect as removing an existing declaration and adding
  a new one.
- Changing the type of declaration is not valid. i.e: Changing from a struct to interface, and vise versa.
  ```cadence
  // Existing struct

  access(all)
  struct Foo {
  }


  // Changed to a struct interface

  access(all)
  struct interface Foo {    // Invalid type declaration change
  }
  ```
- Removing an interface conformance of a struct/resource is not valid.
  ```cadence
  // Existing struct

  access(all)
  struct Foo: T {
  }


  // Upated struct

  access(all)
  struct Foo {
  }
  ```
  - Otherwise, types that used to conform to an interface would no longer conform to that interface, which would lead
    to type safety issues at runtime.

### Updating Members
Similar to contracts, these composite declarations: structs, resources, and interfaces also can have fields and
other nested declarations as its member.
Updating such a composite declaration would also include updating all of its members.

Below sections describes the restrictions imposed on updating the members of a struct, resource or an interface.
- [Fields](#fields)
- [Nested structs, resources and interfaces](#structs-resources-and-interfaces)
- [Enums](#enums)
- [Functions](#functions)
- [Constructors](#constructors)

## Enums

#### Valid Changes:
- Adding a new enum declaration is valid.

#### Invalid Changes:
- Removing an existing enum declaration is invalid.
  - Otherwise, it is possible to remove an existing enum and add a new enum declaration with the same name,
    but with a different structure.
  - The new structure could potentially have incompatible changes (such as changed types, changed enum-cases, etc).
- Changing the name is invalid, as it is equivalent to removing an existing enum and adding a new one.
- Changing the raw type is invalid.
  ```cadence
  // Existing enum with `Int` raw type

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum with `UInt8` raw type

  access(all)
  enum Color: UInt8 {    // Invalid change of raw type

    access(all)
    case RED

    access(all)
    case BLUE
  }
  ```
  - When the enum value is stored, the raw value associated with the enum-case gets stored.
  - If the type is changed, then deserializing could fail if the already stored values are not in the same value space
    as the updated type.

### Updating Enum Cases
Enums consist of enum-case declarations, and updating an enum may also include changing the enums cases as well.
Enum cases are represented using their raw-value at the Cadence interpreter and runtime.
Hence, any change that causes an enum-case to change its raw value is not permitted.
Otherwise, a changed raw-value could cause an already stored enum value to have a different meaning than what
it originally was (type confusion).

#### Valid Changes:
- Adding an enum-case at the end of the existing enum-cases is valid.
  ```cadence
  // Existing enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE

    access(all)
    case GREEN    // valid new enum-case at the bottom
  }
  ```
#### Invalid Changes
- Adding an enum-case at the top or in the middle of the existing enum-cases is invalid.
  ```cadence
  // Existing enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case GREEN    // invalid new enum-case in the middle

    access(all)
    case BLUE
  }
  ```
- Changing the name of an enum-case is invalid.
  ```cadence
  // Existing enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case GREEN    // invalid change of names
  }
  ```
  - Previously stored raw values for `Color.BLUE` now represents `Color.GREEN`. i.e: The stored values have changed
    their meaning, and hence not a valid change.
  - Similarly, it is possible to add a new enum with the old name `BLUE`, which gets a new raw value. Then the same
    enum-case `Color.BLUE` may have used two raw-values at runtime, before and after the change, which is also invalid.

- Removing the enum case is invalid. Removing allows one to add and remove an enum-case which has the same effect
  as renaming.
  ```cadence
  // Existing enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    // invalid removal of `case BLUE`
  }
  ```
- Changing the order of enum-cases is not permitted
  ```cadence
  // Existing enum

  access(all)
  enum Color: Int {

    access(all)
    case RED

    access(all)
    case BLUE
  }


  // Updated enum

  access(all)
  enum Color: UInt8 {

    access(all)
    case BLUE   // invalid change of order
    
    access(all)
    case RED
  }
  ```
  - Raw value of an enum is implicit, and corresponds to the defined order.
  - Changing the order of enum-cases has the same effect as changing the raw-value, which could cause storage
    inconsistencies and type-confusions as described earlier.

## Functions

Adding, changing, and deleting a function definition is always valid, as function definitions are never stored as data
(function definitions are part of the code, but not data).

- Adding a function is valid.
- Deleting a function is valid.
- Changing a function signature (parameters, return types) is valid.
- Changing a function body is valid.
- Changing the access modifiers is valid.

However, changing a *function type* may or may not be valid, depending on where it is used:
If a function type is used in the type annotation of a composite type field (direct or indirect),
then changing the function type signature is the same as changing the type annotation of that field (which is invalid).

## Events

Events are not stored on chain. Any changes made to events have no impact on the stored data.
Hence, adding, removing, and modifying events in a contract is valid.

## Constructors

Similar to functions, constructors are also not stored. Hence, any changes to constructors are valid.

## Imports

A contract may import declarations (types, functions, variables, etc.) from other programs. These imported programs are
already validated at the time of their deployment. Hence, there is no need for validating any declaration every time
they are imported.

## The `#removedType` Pragma

Under normal circumstances, it is not valid to remove a type declaration, whether a composite or an interface. 
However, a special pragma can be used when this is necessary to enable composite declarations to be "tombstoned", 
removing them from a contract and preventing any declarations from being re-added with the same name. 
This pragma cannot be used with interfaces.

To use this pragma, simply add a `#removedType(T)` line to the contract containing the type `T` you want to remove,
at the same scope as the declaration of `T`. So, for example, to remove a resource definition `R` defined like so:

```cadence
access(all) contract Foo {

  access(all) resource R {
     // definition of R ...
  }

  // other stuff ... 
}
```

change the contract to:

```cadence
access(all) contract Foo {

  #removedType(R)

  // other stuff ... 
}
```

This will prevent any type named `R` from ever being declared again as a nested declaration in `Foo`, 
preventing the security issues normally posed by removing a type. 
Specifically, when a `#removedType(T)` pragma is present at a certain scope level in a contract, 
no new type named `T` can be added at that scope. 
Additionally, once added, a `#removedType` pragma can never be removed, 
as this would allow circumventing the above restriction. 

Please note that this pragma's behavior is not necessarily final and is subject to change.




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/project-development-tips.md

---
title: Flow Smart Contract Project Development Standards
sidebar_label: Development Standards
sidebar_position: 7
description: "Learn how to effectively organize and manage a Cadence project"
---

# Smart Contract Project Development Standards

## Context

Smart Contracts are the bedrock piece of security for many important parts
of the Flow blockchain, as well as for any project that is deployed to a blockchain.

They are also the most visible technical parts of any project,
since users will be querying them for data, building other smart contracts that interact with them,
and using them as learning materials and templates for future projects.
Furthermore, when deployed they are publicly available code on the blockchain
and often also in public GitHub repos.

Therefore, the process around designing, building, testing, documenting,
and managing these projects needs to reflect the critical importance they hold in the ecosystem.

Every software project strikes a balance between effort spent on product/feature delivery
vs the many other demands of the software development lifecycle, whether testing, technical debt,
automation, refactoring, or documentation etc. Building in Web3 we face the same trade-offs,
but in a higher risk and consequence environment than what is typical for most software.
A mismanaged or untested smart contract may result in **significant** financial losses
as a result of vulnerabilities which were overlooked then exploited.
We highly recommend builders adopt these best practices to help mitigate these risks.

If they do so, they will be able to build better smart contracts, avoid potential bugs,
support user and third-party adoption of their projects, and increase their chances of success
by being a model for good software design. Additionally, the more projects that adopt
good software design and management standards normalizes this behavior,
encouraging other projects in the ecosystem to do the same which creates a healthier
and more vibrant community.

Ensuring appropriate levels of testing results in better smart contracts which have
pro-actively modeled threats and engineered against them. Ensuring appropriate levels
of standards adoption ([FungibleToken](https://github.com/onflow/flow-ft), [NFT StoreFront](https://github.com/onflow/nft-storefront), etc) by dapp
builders amplifies the network effects for all in the ecosystem. NFTs in one dapp can be
readily consumed by other dapps through on-chain events with no new integration
required. With your help and participation we can further accelerate healthy and vibrant
network effects across the Flow ecosystem!

Some of these suggestions might seem somewhat unnecessary,
but it is important to model what a project can do to manage its smart contracts the best
so that hopefully all of the other projects follow suit.

This also assumes standard software design best practices also apply.
Indeed, many of these suggestions are more general software design best practices,
but there may be others that are assumed but not included here.

### Implementing These Practices

This document serves as mostly an outline of best practices the projects should follow.
As with all best practices, teams will choose which applies to them and their work process,
however, we recommend that teams explicitly define a minimum acceptable set of standards
for themselves along with the mechanisms to ensure they are being observed.

Some teams may also have their own set of development standards that achieve a similar goal
to these. These recommendations are not meant to be the only paths to success,
so if a team disagrees with some of these and wants to do things their own way,
they are welcome to pursue that. This document just shows some generic suggestions
for teams who might not know how they want to manage their project.

## Design Process

Smart contracts usually manage a lot of value, have many users, and are difficult to upgrade
for a variety of reasons. Therefore, it is important to have a clearly defined design
process for the smart contracts before much code is written so that the team
can set themselves up for success.

Here are some recommendations for how projects can organize the foundations of their projects.

### Projects should ensure that there is strong technical leadership for their smart contracts

Developing a dapp requires a clear vision for the role of the smart contract and how it's integrated.
Security vulnerabilities may arise from bugs directly in smart contract code (and elsewhere in the system).
Asynchronous interaction vectors may lead to forms of malicious abuse,
DOS etc in a contract triggering explosive gas costs for the developer or other problems.

We recommend that engineers leading a project and deploying to mainnet have an understanding
of software and security engineering fundamentals and have been thorough
in their Cadence skills development. More in-depth resources for learning Cadence
are available [here](./index.md).

The technical leader should be someone who understands Cadence well and has written Cadence smart contracts
before. Production-level smart contracts are not the place for beginners to get their start.

It should be this person’s responsibility to lead design discussions
with product managers and the community, write most of the code and tests,
solicit reviews, make requested changes and make sure the project gets completed in a timely manner.

The leader should also understand how to sign transactions with the CLI
to deploy/upgrade smart contracts, run admin transactions, and troubleshoot problems, etc.
If something goes wrong in relation to the smart contract
that needs to be handled with a bespoke transaction, it is important that the owner
knows how to build and run transactions and scripts safely to address the issues
and/or upgrade the smart contracts.

The project should also have a clear plan of succession in case the original owner
is not available or leaves the project. It is important that there are others who
can fill in who have a clear understanding of the code and requirements so they can give good feedback,
perform effective reviews, and make changes where needed.

### Projects should maintain a well-organized open source repository for their smart contracts

As projects like NBA Topshot have shown, when a blockchain product becomes successful
others can and do to build on top of what you are doing.
Whether that is analytics, tools, or other value adds that could help grow your project ecosystem,
composability is key and that depends on open source development.
If there isn’t already an open source repo, builders should strongly consider creating one.

Builders can start from the [the Flow open source template](https://github.com/onflow/open-source-template)
and make sure all of their repo is set up with some initial documentation for what the repo is for
before any code is written. External developers and users should have an easily accessible home page
to go to to understand any given project.

The repo should also have some sort of high-level design document that lays out
the intended design and architecture of the smart contract.
The project leads should determine what is best for them to include in the document,
but some useful things to include are basic user stories, architecture of the smart contracts,
and any questions that still need to be answered about it.
    - Where applicable, diagrams should be made describing state machines, user flows, etc.
    - This document should be shared in an issue in the open source repo
    where the contracts or features are being developed,
    then later moved to the README or another important docs page.

A high level design is a key opportunity to model threats
and understand the risks of the system. The process of collaborating
and reviewing designs together helps ensure that more edge-cases are captured and addressed.
It's also a lot less effort to iterate on a design than on hundreds of lines of Cadence.

## Development Process Recommendations

### The Development process should be iterative, if possible

The project should develop an MVP first, get reviews, and test thoroughly,
then add additional features with tests. This ensures that the core features are designed
thoughtfully and makes the review process easier because they can focus on each feature
one at a time instead of being overwhelmed by a huge block of code.

### Comments and field/function descriptions are essential!

Our experience writing many Cadence smart contracts has taught us how important documentation
is. It especially matters what is documented and for whom, and in that way we are no different from
any software language. The Why is super important, if for example something - an event - that
happens in one contract leads to outcomes in a different contract. The What helps give context,
the reason for the code turning out the way it is. The How, you don't document - you've written
the code. Comments should be directed to those who will follow after you in changing the code.

Comments should be written at the same time (or even before) the code is written.
This helps the developer and reviewers understand the work-in-progress code better,
as well as the intentions of the design (for testing and reviewing).
Functions should be commented with a
    - Description
    - Parameter descriptions
    - Return value descriptions


Top Level comments and comments for types, fields, events,
and functions should use `///` (three slashes) to be recognised by the
[Cadence Documentation Generator](https://github.com/onflow/cadence-tools/tree/master/docgen).
Regular comments within functions should only use two slashes (`//`)

## Testing Recommendations

Summarized below is a list of testing related recommendations
which are noteworthy to mention for a typical smart contract project.

Popular testing frameworks to use for cadence are listed here:
Cadence: [Cadence Testing Framework](./testing-framework.mdx)
Javascript: [Flow JS Testing](https://developers.flow.com/tools/flow-js-testing/index.md)
Go: [Overflow](https://github.com/bjartek/overflow)

The same person who writes the code should also write the tests.
They have the clearest understanding of the code paths and edge cases.

Tests should be **mandatory**, not optional, even if the contract is copied from somewhere else.
There should be thorough emulator unit tests in the public repo.
[See the flow fungible token repo](https://github.com/onflow/flow-ft/tree/master/tests)
for an example of unit tests in cadence.

Every time there is a new Cadence version or emulator version,
the dependencies of the repo should be updated to make sure the tests are all still passing.

Tests should avoid being monolithic;
Individual test cases should be set up for each part of the contract to test them in isolation.
See the [`FlowEpoch` smart contract tests](https://github.com/onflow/flow-core-contracts/blob/master/lib/go/test/flow_epoch_test.go)
for examples written in Go where test cases are split
into separate blocks for different features.
There are some exceptions, like contracts that have to run through a state machine
to test different cases. Positive and negative cases need to be tested.

Integration tests should also be written to ensure that your app and/or backend can interact
properly with the smart contracts.

## Managing Project Keys and Deployments

Smart contract keys and deployments are very important and need to be treated as such.

### Private Keys should be stored securely

Private Keys for the contract and/or admin accounts should not be kept in plain text format anywhere.
Projects should determine a secure solution that works best for them to store their private keys.
We recommend storing them in a secure key store such as google KMS or something similar.

### Deployments to Testnet or Mainnet should be handled transparently

As projects become more successful, communities around them grow.
In a trustless ecosystem, that also means more of others building on your contracts.
Before deploying or upgrading a contract, it is important to maintain
clear community communications with sufficient notice, since changes will always bring added risk.
Giving community members time to review and address issues with upgrades
before they happen builds trust and confidence in projects.
Here are a few suggestions for how to manage a deployment or upgrade.

- Communicate to all stake-holders well in advance
    - Share the proposal with the community at least a week in advance (unless it is a critical bug fix)
        - Examples of places to share are your project's chat, forum, blog, email list, etc.
        - This will allow the community and other stakeholders to have plenty of time
        to view the upcoming changes and provide feedback if necessary.
    - Share the time of the deployment and the deployment transaction with branch/commit hash information to ensure the transaction itself is correct.
    - Coordinate deployment with stakeholders to make sure it is done correctly and on time.

## Responsibilities to the Community

Web3 brings tremendous possibilities for engineering applications with trustlessness
and composability in mind, with Cadence and Flow offering unique features to achieve this.
If every project treats their community and the Flow community with respect and care,
the things we can all build together will be very powerful.

### Projects should have thorough documentation

Encouraging adoption of project contracts to the broader ecosystem
raises the bar around code providing clear high-level descriptions,
with detailed and useful comments within contracts, transactions, and scripts.
The more that a project can be understood, that it adheres to standards,
and can be built upon with ease, the more likely others will build against it in turn.

Each project should have a detailed `README.md` with these sections:
    - Explanation of the project itself with links to the app
    - Addresses on various networks
    - High-level technical description of the contracts with emphasis on important types and functionality
    - Architecture diagram (if applicable)
    - Include links to tutorials if they are external
    - Flow smart contract standards that a project implements

Additionally, each contract, transaction, and script should have high-level descriptions
at the top of their files. This way, anyone in the community can easily
come in and understand what each one is doing without having to parse confusing code.

### Projects should engage with and respond to their own Community

Once a contract is deployed, the work doesn’t stop there.
Project communities require ongoing nurturing and support.
As the developer of a public project on a public blockchain,
the owners have an obligation to be helpful and responsive to the community
so that they can encourage composability and third party interactions.

- Keep issues open in the repo.
- The owner should turn on email notifications for new issue creation in the repo.
- Respond to issues quickly and clean up unimportant ones.
- Consider blog posts to share more details on technical aspects of the project and upcoming changes.

### Projects should contribute to the greater Flow and Cadence community

Flow has a vibrant and growing community of contributors around the world.
Through our mutual collaboration we've had numerous community Flow Improvement Proposals
([FLIP](https://github.com/onflow/flow/tree/master/flips)s) shipped.
If you have an interest in a particular improvement for Flow or Cadence,
we host open meetings which you are welcome to join (announced on discord)
and can participate anytime on any of the FLIPs
[already proposed](https://github.com/onflow/flow/pulls?q=is%3Aopen+is%3Apr+label%3AFLIP).

Responsible project maintainers should contribute to discussions
about important proposals (new cadence features, standard smart contracts, metadata, etc)
and generally be aware about evolving best practices and anti-pattern understandings.
Projects who contribute to these discussions are able to influence them to ensure
that the language/protocol changes are favorable to them
and the rest of the app developers in the ecosystem.
It also helps the owner to promote the project and themselves.

Resources for Best Practices:

- [cadence/design-pattern](./design-patterns.md)
- [cadence/anti-patterns](./anti-patterns.md)
- [cadence/security-best-practices](./security-best-practices.md)

Composability and extensibility should also be priorities while designing, developing,
and documenting their projects. (Documentation for these topics coming soon)


If you have any feedback about these guidelines, please create an issue in the `cadence-lang.org` repo or make a PR updating the guidelines so we can start a discussion.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/cadence-migration-guide/improvements.md

---
title: Cadence 1.0 Improvements & New Features
sidebar_position: 0
sidebar_label: Improvements & New Features
---

## 💫 New features

<details>

<summary>View Functions added ([FLIP 1056](https://github.com/onflow/flips/blob/main/cadence/20220715-cadence-purity-analysis.md))</summary>

#### 💡 Motivation

View functions enable developers to enhance the reliability and safety of their programs, facilitating a clearer understanding of the impacts of their own code and that of others.

Developers can mark their functions as `view`, which disallows the function from performing state changes. That also makes the intent of functions clear to other programmers, as it allows them to distinguish between functions that change state and ones that do not.

#### ℹ️ Description

Cadence has added support for annotating functions with the `view` keyword, which enforces that no “mutating” operations occur inside the body of the function. The `view` keyword is placed before the `fun` keyword in a function declaration or function expression.

If a function has no `view` annotation, it is considered “non-view”, and users should encounter no difference in behavior in these functions from what they are used to.

If a function does have a `view` annotation, then the following mutating operations are not allowed:

- Writing to, modifying, or destroying any resources
- Writing to or modifying any references
- Assigning to or modifying any variables that cannot be determined to have been created locally inside of the `view` function in question. In particular, this means that captured and global variables cannot be written in these functions
- Calling a non-`view` function

This feature was proposed in [FLIP 1056](https://github.com/onflow/flips/blob/main/cadence/20220715-cadence-purity-analysis.md). To learn more, please consult the FLIP and documentation.

#### 🔄 Adoption

You can adopt view functions by adding the `view` modifier to all functions that do not perform mutating operations.

#### ✨ Example

Before:
The function `getCount` of a hypothetical NFT collection returns the number of NFTs in the collection.

```cadence
access(all)
resource Collection {

  access(all)
  var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

  init () {
    self.ownedNFTs <- {}
  }

  access(all)
  fun getCount(): Int {
    returnself.ownedNFTs.length
  }

  /* ... rest of implementation ... */
}
```

After:
The function `getCount` does not perform any state changes, it only reads the length of the collection and returns it. Therefore it can be marked as `view.`

```cadence
    access(all)
    view fun getCount(): Int {
//  ^^^^ addedreturnself.ownedNFTs.length
    }
```

</details>

<details>

<summary>Interface Inheritance Added ([FLIP 40](https://github.com/onflow/flips/blob/main/cadence/20221024-interface-inheritance.md))</summary>

#### 💡 Motivation

Previously, interfaces could not inherit from other interfaces, which required developers to repeat code.
Interface inheritance allows code abstraction and code reuse.

#### ℹ️ Description and ✨ Example

Interfaces can now inherit from other interfaces of the same kind. This makes it easier for developers to structure their conformances and reduces a lot of redundant code.

For example, suppose there are two resource interfaces `Receiver` and `Vault`, and suppose all implementations of the `Vault` would also need to conform to the interface `Receiver`.

Previously, there was no way to enforce this. Anyone who implements the `Vault` would have to explicitly specify that their concrete type also implements the `Receiver`. But it was not always guaranteed that all implementations would follow this informal agreement.
With interface inheritance, the `Vault` interface can now inherit/conform to the `Receiver` interface.

```cadence
access(all)
resource interface Receiver {
  access(all)
  fun deposit(_ something:@AnyResource)
}

access(all)
resource interface Vault: Receiver {
  access(all)
  fun withdraw(_ amount: Int):@Vault
}
```

Thus, anyone implementing the `Vault` interface would also have to implement the `Receiver` interface as well.

```cadence
access(all)
resource MyVault: Vault {
  // Required!
  access(all)
  fun withdraw(_ amount: Int):@Vault {}
  // Required!
  access(all)
  fun deposit(_ something:@AnyResource) {}
}
```

This feature was proposed in [FLIP 40](https://github.com/onflow/flips/blob/main/cadence/20221024-interface-inheritance.md). To learn more, please consult the FLIP and documentation.

</details>

## ⚡ Breaking Improvements

Many of the improvements of Cadence 1.0 are fundamentally changing how Cadence works and how it is used. However, that also means it is necessary to break existing code to release this version, which will guarantee stability (no more planned breaking changes) going forward.

Once Cadence 1.0 is live, breaking changes will simply not be acceptable.

So we have, and need to use, this last chance to fix and improve Cadence, so it can deliver on its promise of being a language that provides security and safety, while also providing composability and simplicity.

We fully recognize the frustration developers feel when updates break their code, necessitating revisions. Nonetheless, we are convinced that this inconvenience is justified by the substantial enhancements to Cadence development. These improvements not only make development more effective and enjoyable but also empower developers to write and deploy immutable contracts.

The improvements were intentionally bundled into one release to avoid breaking Cadence programs multiple times.

<details>

<summary> **2024-04-24** Public Capability Acquisition No Longer Returns Optional Capabilities ([FLIP 242](https://github.com/onflow/flips/blob/main/cadence/20240123-capcon-get-capability-api-improvement.md))</summary>

**Note** This is a recent change that may not be reflected in emulated migrations or all tools yet.  Likewise, this may affect existing staged contracts which do not conform to this new requirement.  Please ensure your contracts are updated and re-staged, if necessary, to match this new requirement.

#### 💡 Motivation

In the initial implementation of the new Capability Controller API (a change that is new in Cadence 1.0, proposed in [FLIP 798](https://github.com/onflow/flips/blob/main/cadence/20220203-capability-controllers.md)), `capabilities.get<T>` would return an optional capability, `Capability<T>?`.  When the no capability was published under the requested path, or when type argument `T` was not a subtype of the runtime type of the capability published under the requested path, the capability would be `nil`.

This was a source of confusion among developers, as previously `account.getCapability<T>` did not return an optional capability, but rather one that would simply fail `capability.borrow` if the capability was invalid.

It was concluded that this new behaviour was not ideal, and that there a benefit to an invalid Capability not being `nil`, even if it is not borrowable. A `nil` capability lacked information that was previously available with an invalid capability - primarily the type and address of the capability.  Developers may have wanted to make use of this information, and react to the capability being invalid, as opposed to an uninformative `nil` value and encountering a panic scenario.

#### ℹ️ Description

The `capabilities.get<T>` function now returns an invalid capability when no capability is published under the requested path, or when the type argument `T` is not a subtype of the runtime type of the capability published under the requested path.

This capability has the following properties:

- Always return `false` when `Capability<T>.check` is called.
- Always return `nil` when `Capability<T>.borrow` is called.
- Have an ID of `0`.
- Have a runtime type that is the same as the type requested in the type argument of `capabilities.get<T>`.
<br />

#### 🔄 Adoption

If you have not updated your code to Cadence 1.0 yet, you will need to follow the same guidelines for updating to the Capability Controller API as you would have before, but will need to handle the new invalid capability type instead of an optional capability.

If you have already updated your code to use `capabilities.get<T>`, and are handling the capability as an optional type, you may need to update your code to handle the new non-optional invalid capability type instead.

#### ✨ Example

**Before:**

```cadence
let capability = account.capabilities.get<&MyNFT.Collection>(/public/NFTCollection)
if capability == nil {
    // Handle the case where the capability is nil
}
```

**After:**

```cadence
let capability = account.capabilities.get<&MyNFT.Collection>(/public/NFTCollection)
if !capability.check() {
    // Handle the case where the capability is invalid
}
```

</details>

<details>

<summary>**2024-04-23** Matching Access Modifiers for Interface Implementation Members are now Required ([FLIP 262](https://github.com/onflow/flips/blob/main/cadence/20240415-remove-non-public-entitled-interface-members.md))</summary>

**Note** This is a recent change that may not be reflected in emulated migrations or all tools yet.  Likewise, this may affect existing staged contracts which do not conform to this new requirement.  Please ensure your contracts are updated and re-staged, if necessary, to match this new requirement.

#### 💡 Motivation

Previously, the access modifier of a member in a type conforming to / implementing an interface
could not be more restrictive than the access modifier of the member in the interface.
That meant an implementation may have choosen to use a more permissive access modifier than the interface.

This may have been surprising to developers, as they may have assumed that the access modifier of the member
in the interface was a _requirement_ / _maximum_, not just a minimum, especially when using
a non-public / non-entitled access modifier (e.g. `access(contract)`, `access(account)`).

Requiring access modifiers of members in the implementation to match the access modifiers
of members given in the interface, helps avoid confusion and potential footguns.

#### ℹ️ Description

If an interface member has an access modifier, a composite type that conforms to it / implements
the interface must use exactly the same access modifier.

#### 🔄 Adoption

Update the access modifiers of members in composite types that conform to / implement interfaces if they do not match the access modifiers of the members in the interface.

#### ✨ Example

**Before:**

```cadence
access(all)
resource interface I {
  access(account)
  fun foo()
}

access(all)
resource R: I {
  access(all)
  fun foo() {}
}
```

**After:**

```cadence
access(all)
resource interface I {
  access(account)
  fun foo()
}

access(all)
resource R: I {
  access(account)
  fun foo() {}
}
```

</details>

<details>

<summary>Conditions No Longer Allow State Changes ([FLIP 1056](https://github.com/onflow/flips/blob/main/cadence/20220715-cadence-purity-analysis.md))</summary>

#### 💡 Motivation

In the current version of Cadence, pre-conditions and post-conditions may perform state changes, e.g. by calling a function that performs a mutation. This may result in unexpected behavior, which might lead to bugs.

To make conditions predictable, they are no longer allowed to perform state changes.

#### ℹ️ Description

Pre-conditions and post-conditions are now considered `view` contexts, meaning that any operations that would be prevented inside of a `view` function are also not permitted in a pre-condition or post-condition.

This is to prevent underhanded code wherein a user modifies global or contract state inside of a condition, where they are meant to simply be asserting properties of that state.

In particular, since only expressions were permitted inside conditions already, this means that if users wish to call any functions in conditions, these functions must now be made `view` functions.

This improvement was proposed in [FLIP 1056](https://github.com/onflow/flips/blob/main/cadence/20220715-cadence-purity-analysis.md). To learn more, please consult the FLIP and documentation.

#### 🔄 Adoption

Conditions which perform mutations will now result in the error “Impure operation performed in view context”.
Adjust the code in the condition so it does not perform mutations.

The condition may be considered mutating, because it calls a mutating, i.e. non-`view` function. It might be possible to mark the called function as `view`, and the body of the function may need to get updated in turn.

#### ✨ Example

**Before:**

The function `withdraw` of a hypothetical NFT collection interface allows the withdrawal of an NFT with a specific ID. In its post-condition, the function states that at the end of the function, the collection should have exactly one fewer item than at the beginning of the function.

```cadence
access(all)
resource interface Collection {

  access(all)
  fun getCount(): Int

  access(all)
  fun withdraw(id: UInt64):@NFT {
    post {
      getCount() == before(getCount()) - 1
    }
  }

  /* ... rest of interface ... */
}
```

**After:**

The calls to `getCount` in the post-condition are not allowed and result in the error “Impure operation performed in view context”, because the `getCount` function is considered a mutating function, as it does not have the `view` modifier.

Here, as the `getCount` function only performs a read-only operation and does not change any state, it can be marked as `view`.

```cadence
    access(all)
    view fun getCount(): Int
//  ^^^^
```

</details>

<details>

<summary>Missing or Incorrect Argument Labels Get Reported</summary>

#### 💡 Motivation

Previously, missing or incorrect argument labels of function calls were not reported. This had the potential to confuse developers or readers of programs, and could potentially lead to bugs.

#### ℹ️ Description

Function calls with missing argument labels are now reported with the error message “missing argument label”, and function calls with incorrect argument labels are now reported with the error message “incorrect argument label”.

#### 🔄 Adoption

- Function calls with missing argument labels should be updated to include the required argument labels.
- Function calls with incorrect argument labels should be fixed by providing the correct argument labels.

#### ✨ Example

Contract `TestContract` deployed at address `0x1`:

```cadence
access(all)
contract TestContract {

  access(all)
  structTestStruct {

  access(all)
  let a: Int

  access(all)
  let b: String

  init(first: Int, second: String) {
    self.a = first
    self.b = second
    }
  }
}
```

**Incorrect program**:

The initializer of `TestContract.TestStruct` expects the argument labels `first` and `second`.

However, the call of the initializer provides the incorrect argument label `wrong` for the first argument, and is missing the label for the second argument.

```cadence
// Script
import TestContract from 0x1

access(all)
fun main() {
  TestContract.TestStruct(wrong: 123, "abc")
}
```

This now results in the following errors:

```
error: incorrect argument label
  --> script:4:34
   |
 4 |           TestContract.TestStruct(wrong: 123, "abc")
   |                                   ^^^^^ expected `first`, got `wrong`

error: missing argument label: `second`
  --> script:4:46
   |
 4 |           TestContract.TestStruct(wrong: 123, "abc")
   |                                               ^^^^^
```

**Corrected program**:

```cadence
// Script
import TestContract from 0x1

access(all)
fun main() {
  TestContract.TestStruct(first: 123, second: "abc")
}
```

We would like to thank community member @justjoolz for reporting this bug.

</details>

<details>

<summary>Incorrect Operators In Reference Expressions Get Reported ([FLIP 941](https://github.com/onflow/flips/blob/main/cadence/20220516-reference-creation-semantics.md))</summary>

#### 💡 Motivation

Previously, incorrect operators in reference expressions were not reported.

This had the potential to confuse developers or readers of programs, and could potentially lead to bugs.

#### ℹ️ Description

The syntax for reference expressions is `&v as &T`, which represents taking a reference to value `v` as type `T`.
Reference expressions that used other operators, such as `as?` and `as!`, e.g. `&v as! &T`, were incorrect and were previously not reported as an error.

The syntax for reference expressions improved to just `&v`. The type of the resulting reference must still be provided explicitly.
If the type is not explicitly provided, the error “cannot infer type from reference expression: requires an explicit type annotation” is reported.

For example, existing expressions like `&v as &T` provide an explicit type, as they statically assert the type using `as &T`. Such expressions thus keep working and do *not* have to be changed.

Another way to provide the type for the reference is by explicitly typing the target of the expression, for example, in a variable declaration, e.g. via `let ref: &T = &v`.

This improvement was proposed in [FLIP 941](https://github.com/onflow/flips/blob/main/cadence/20220516-reference-creation-semantics.md). To learn more, please consult the FLIP and documentation.

#### 🔄 Adoption

Reference expressions which use an operator other than `as` need to be changed to use the `as` operator.
In cases where the type is already explicit, the static type assertion (`as &T`) can be removed.

#### ✨ Example

**Incorrect program**:
The reference expression uses the incorrect operator `as!`.

```cadence
let number = 1
let ref = &number as! &Int
```

This now results in the following error:

```bash
error: cannot infer type from reference expression: requires an explicit type annotation
 --> test:3:17
  |
3 |let ref = &number as! &Int
  |           ^
```

**Corrected program**:

```cadence
let number = 1
let ref = &number as &Int
```

Alternatively, the same code can now also be written as follows:

```cadence
let number = 1
let ref: &Int = &number
```

</details>

<details>

<summary>Tightening Of Naming Rules</summary>

#### 💡 Motivation

Previously, Cadence allowed language keywords (e.g. `continue`, `for`, etc.) to be used as names. For example, the following program was allowed:

```cadence
fun continue(import: Int, break: String) { ... }
```

This had the potential to confuse developers or readers of programs, and could potentially lead to bugs.

#### ℹ️ Description

Most language keywords are no longer allowed to be used as names.
Some keywords are still allowed to be used as names, as they have limited significance within the language. These allowed keywords are as follows:

- `from`: only used in import statements `import foo from ...`
- `account`: used in access modifiers `access(account) let ...`
- `all`: used in access modifier `access(all) let ...`
- `view`: used as modifier for function declarations and expressions `view fun foo()...`, let `f = view fun () ...`
  Any other keywords will raise an error during parsing, such as:

```cadence
let break: Int = 0
//  ^ error: expected identifier after start of variable declaration, got keyword break
```

#### 🔄 Adoption

Names which use language keywords must be renamed.

#### ✨ Example

**Before:**
A variable is named after a language keyword.

```cadence
let contract = signer.borrow<&MyContract>(name: "MyContract")
//  ^ error: expected identifier after start of variable declaration, got keyword contract
```

**After:**
The variable is renamed to avoid the clash with the language keyword.

```cadence
let myContract = signer.borrow<&MyContract>(name: "MyContract")
```

</details>

<details>

<summary>Result of `toBigEndianBytes()` for `U?Int(128|256)` Fixed</summary>

#### 💡 Motivation

Previously, the implementation of `.toBigEndianBytes()` was incorrect for the large integer types `Int128`, `Int256`, `UInt128`, and `UInt256`.

This had the potential to confuse developers or readers of programs, and could potentially lead to bugs.

#### ℹ️ Description

Calling the `toBigEndianBytes` function on smaller sized integer types returns the exact number of bytes that fit into the type, left-padded with zeros. For instance, `Int64(1).toBigEndianBytes()` returns an array of 8 bytes, as the size of `Int64` is 64 bits, 8 bytes.

Previously, the `toBigEndianBytes` function erroneously returned variable-length byte arrays without padding for the large integer types `Int128`, `Int256`, `UInt128`, and `UInt256`. This was inconsistent with the smaller fixed-size numeric types, such as `Int8`, and `Int32`.

To fix this inconsistency, `Int128` and `UInt128` now always return arrays of 16 bytes, while `Int256` and `UInt256` return 32 bytes.

#### ✨ Example

```cadence
let someNum: UInt128 = 123456789
let someBytes: [UInt8] = someNum.toBigEndianBytes()
// OLD behavior;
// someBytes = [7, 91, 205, 21]
// NEW behavior:
// someBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 91, 205, 21]
```

#### 🔄 Adoption

Programs that use `toBigEndianBytes` directly, or indirectly by depending on other programs, should be checked for how the result of the function is used. It might be necessary to adjust the code to restore existing behavior.

If a program relied on the previous behavior of truncating the leading zeros, then the old behavior can be recovered by first converting to a variable-length type, `Int` or `UInt`, as the `toBigEndianBytes` function retains the variable-length byte representations, i.e. the result has no padding bytes.

```cadence
let someNum: UInt128 = 123456789
let someBytes: [UInt8] = UInt(someNum).toBigEndianBytes()
// someBytes = [7, 91, 205, 21]
```

</details>

<details>

<summary>Syntax for Function Types Improved ([FLIP 43](https://github.com/onflow/flips/blob/main/cadence/20221018-change-fun-type-syntax.md))</summary>

#### 💡 Motivation

Previously, function types were expressed using a different syntax from function declarations or expressions. The previous syntax was unintuitive for developers, making it hard to write and read code that used function types.

#### ℹ️ Description and ✨ examples

Function types are now expressed using the `fun` keyword, just like expressions and declarations. This improves readability and makes function types more obvious.

For example, given the following function declaration:

```cadence
fun foo(n: Int8, s: String): Int16 { /* ... */ }
```

The function `foo` now has the type `fun(Int8, String): Int16`.
The `:` token is right-associative, so functions that return other functions can have their types written without nested parentheses:

```cadence
fun curriedAdd(_ x: Int): fun(Int): Int {
  return fun(_ y: Int): Int {
    return x+ y
  }
}
// function `curriedAdd` has the type `fun(Int): fun(Int): Int`
```

To further bring the syntax for function types closer to the syntax of function declarations expressions, it is now possible to omit the return type, in which case the return type defaults to `Void`.

```cadence
fun logTwice(_ value: AnyStruct) {// Return type is implicitly `Void`
  log(value)
  log(value)
}

// The function types of these variables are equivalent
let logTwice1: fun(AnyStruct): Void = logTwice
let logTwice2: fun(AnyStruct) = logTwice
```

As a bonus consequence, it is now allowed for any type to be parenthesized. This is useful for complex type signatures, or for expressing optional functions:

```cadence
// A function that returns an optional Int16
let optFun1: fun (Int8): Int16? =
  fun (_: Int8): Int? { return nil }

// An optional function that returns an Int16
let optFun2: (fun (Int8): Int16)? = nil
```

This improvement was proposed in [FLIP 43](https://github.com/onflow/flips/blob/main/cadence/20221018-change-fun-type-syntax.md).

#### 🔄 Adoption

Programs that use the old function type syntax need to be updated by replacing the surrounding parentheses of function types with the `fun` keyword.

**Before:**

```cadence
let baz: ((Int8, String): Int16) = foo
      // ^                     ^
      // surrounding parentheses of function type
```

**After:**

```cadence
let baz: fun (Int8, String): Int16 = foo
```

</details>

<details>

<summary>Entitlements and Safe Down-casting ([FLIP 54](https://github.com/onflow/flips/blob/main/cadence/20221214-auth-remodel.md) & [FLIP 94](https://github.com/onflow/flips/blob/main/cadence/20230623-entitlement-improvements.md))</summary>

#### 💡 Motivation

Previously, Cadence’s main access-control mechanism, restricted reference types, has been a source of confusion and mistakes for contract developers.

Developers new to Cadence often were surprised and did not understand why access-restricted functions, like the `withdraw` function of the fungible token `Vault` resource type, were declared as `pub`, making the function publicly accessible – access would later be restricted through a restricted type.

It was too easy to accidentally give out a `Capability` with a more permissible type than intended, leading to security problems.
Additionally, because what fields and functions were available to a reference depended on what the type of the reference was, references could not be downcast, leading to ergonomic issues.

#### ℹ️ Description

Access control has improved significantly.
When giving another user a reference or `Capability` to a value you own, the fields and functions that the user can access is determined by the type of the reference or `Capability`.

Previously, access to a value of type `T`, e.g. via a reference `&T`, would give access to all fields and functions of `T`. Access could be restricted, by using a restricted type. For example, a restricted reference `&T{I}` could only access members that were `pub` on `I`. Since references could not be downcast, any members defined on `T` but not on `I` were unavailable to this reference, even if they were `pub`.

Access control is now handled using a new feature called Entitlements, as originally proposed across [FLIP 54](https://github.com/onflow/flips/blob/main/cadence/20221214-auth-remodel.md) and [FLIP 94](https://github.com/onflow/flips/blob/main/cadence/20230623-entitlement-improvements.md).

A reference can now be “entitled” to certain facets of an object. For example, the reference `auth(Withdraw) &Vault` is entitled to access fields and functions of `Vault` which require the `Withdraw` entitlement.

Entitlements can be are declared using the new `entitlement` syntax.

Members can be made to require entitlements using the access modifier syntax `access(E)`, where `E` is an entitlement that the user must posses.

For example:

```cadence
entitlement Withdraw

access(Withdraw)
fun withdraw(amount: UFix64): @Vault
```

References can now always be down-casted, the standalone `auth` modifier is not necessary anymore, and got removed.

For example, the reference `&{Provider}` can now be downcast to `&Vault`, so access control is now handled entirely through entitlements, rather than types.

To learn more, please refer to the [documentation](https://cadence-lang.org/docs/1.0/language/access-control#entitlements).

#### 🔄 Adoption

The access modifiers of fields and functions need to be carefully audited and updated.

Fields and functions that have the `pub` access modifier are now callable by anyone with any reference to that type. If access to the member should be restricted, the `pub` access modifier needs to be replaced with an entitlement access modifier.

When creating a `Capability` or a reference to a value, **it must be carefully considered which entitlements are provided to the recipient of that `Capability` or reference** – only the entitlements which are necessary and not more should be include in the `auth` modifier of the reference type.

#### ✨ Example

**Before:**
The `Vault` resource was originally written like so:

```cadence
access(all)
resource interface Provider {
  access(all)
  funwithdraw(amount:UFix64): @Vault {
  // ...
  }
}

access(all)
resource Vault: Provider, Receiver, Balance {
  access(all)
  fun withdraw(amount:UFix64): @Vault {
  // ...
  }

  access(all)
  fun deposit(from: @Vault) {
  // ...
  }

  access(all)
  var balance: UFix64
}
```

**After:**
The `Vault` resource might now be written like this:

```cadence
access(all) entitlement Withdraw

access(all)
resource interface Provider {
  access(Withdraw)
  funwithdraw(amount:UFix64): @Vault {
  // ...
  }
}

access(all)
resource Vault: Provider, Receiver, Balance {

  access(Withdraw)// withdrawal requires permission
  fun withdraw(amount:UFix64): @Vault {
  // ...
  }

  access(all)
  fun deposit(from: @Vault) {
  // ...
  }

  access(all)
  var balance: UFix64
}
```

Here, the `access(Withdraw)` syntax means that a reference to `Vault` must possess the `Withdraw` entitlement in order to be allowed to call the `withdraw` function, which can be given when a reference or `Capability` is created by using a new syntax: `auth(Withdraw) &Vault`.

This would allow developers to safely downcast `&{Provider}` references to `&Vault` references if they want to access functions like `deposit` and `balance`, without enabling them to call `withdraw`.

</details>

<details>

<summary>Removal of `pub` and `priv` Access Modifiers ([FLIP 84](https://github.com/onflow/flips/blob/main/cadence/20230505-remove-priv-and-pub.md))</summary>

#### 💡 Motivation

With the previously mentioned entitlements feature, which uses `access(E)` syntax to denote entitled access, the `pub`, `priv` and `pub(set)` modifiers became the only access modifiers that did not use the `access` syntax.

This made the syntax inconsistent, making it harder to read and understand programs.

In addition, `pub` and `priv` already had alternatives/equivalents: `access(all)` and `access(self)`.

#### ℹ️ Description

The `pub`, `priv` and `pub(set)` access modifiers are being removed from the language, in favor of their more explicit `access(all)` and `access(self)` equivalents (for `pub` and `priv`, respectively).

This makes access modifiers more uniform and better match the new entitlements syntax.

This improvement was originally proposed in [FLIP 84](https://github.com/onflow/flips/blob/main/cadence/20230505-remove-priv-and-pub.md).

#### 🔄 Adoption

Users should replace any `pub` modifiers with `access(all)`, and any `priv` modifiers with `access(self)`.

Fields that were defined as `pub(set)` will no longer be publicly assignable, and no access modifier now exists that replicates this old behavior. If the field should stay publicly assignable, a `access(all)` setter function that updates the field needs to be added, and users have to switch to using it instead of directly assigning to the field.

#### ✨ Example

**Before:**
Types and members could be declared with `pub` and `priv`:

```cadence
pub resource interface Collection {
  pub fun getCount(): Int

  priv fun myPrivateFunction()

  pub(set) let settableInt: Int

  /* ... rest of interface ... */
}
```

**After:**
The same behavior can be achieved with `access(all)` and `access(self)`

```cadence
access(all)
resource interface Collection {

  access(all)
  fun getCount(): Int

  access(self)
  fun myPrivateFunction()

  access(all)
  let settableInt: Int

  // Add a public setter method, replacing pub(set)
  access(all)
  fun setIntValue(_ i:Int): Int

  /* ... rest of interface ... */
}
```

</details>

<details>

<summary>Replacement of Restricted Types with Intersection Types ([FLIP 85](https://github.com/onflow/flips/blob/main/cadence/20230505-remove-restricted-types.md))</summary>

#### 💡 Motivation

With the improvements to access control enabled by entitlements and safe down-casting, the restricted type feature is redundant.

#### ℹ️ Description

Restricted types have been removed. All types, including references, can now be down-casted, restricted types are no longer used for access control.

At the same time intersection types got introduced. Intersection types have the syntax `{I1, I2, ... In}`, where all elements of the set of types (`I1, I2, ... In`) are interface types. A value is part of the intersection type if it conforms to all the interfaces in the intersection type’s interface set. This functionality is equivalent to restricted types that restricted `AnyStruct` and `AnyResource.`

This improvement was proposed in [FLIP 85](https://github.com/onflow/flips/blob/main/cadence/20230505-remove-restricted-types.md). To learn more, please consult the FLIP and documentation.

#### 🔄 Adoption

Code that relies on the restriction behavior of restricted types can be safely changed to just use the concrete type directly, as entitlements will make this safe. For example, `&Vault{Balance}` can be replaced with just `&Vault`, as access to `&Vault` only provides access to safe operations, like getting the balance – **privileged operations, like withdrawal, need additional entitlements.**

Code that uses `AnyStruct` or `AnyResource` explicitly as the restricted type, e.g. in a reference, `&AnyResource{I}`, needs to remove the use of `AnyStruct` / `AnyResource`. Code that already uses the syntax `&{I}` can stay as-is.

#### ✨ Example

**Before:**

This function accepted a reference to a `T` value, but restricted what functions were allowed to be called on it to those defined on the `X`, `Y`, and `Z` interfaces.

```cadence
access(all)
resource interface X {
  access(all)
  fun foo()
}

access(all)
resource interface Y {
  access(all)
  fun bar()
}

access(all)
resource interface Z {
  access(all)
  fun baz()
}

access(all)
resource T: X, Y, Z {
  // implement interfaces
  access(all)
  fun qux() {
  // ...
  }
}

access(all)
fun exampleFun(param: &T{X, Y, Z}) {
  // `param` cannot call `qux` here, because it is restricted to
  // `X`, `Y` and `Z`.
}
```

**After:**
This function can be safely rewritten as:

```cadence
access(all)
resource interface X {
  access(all)
  fun foo()
}

access(all)
resource interface Y {
  access(all)
  fun bar()
}

resource interface Z {
  access(all)
  fun baz()
}

access(all)
entitlement Q

access(all)
resource T: X, Y, Z {
  // implement interfaces
  access(Q)
  fun qux() {
  // ...
  }
}

access(all)
fun exampleFun(param: &T) {
  // `param` still cannot call `qux` here, because it lacks entitlement `Q`
}
```

Any functions on `T` that the author of `T` does not want users to be able to call publicly should be defined with entitlements, and thus will not be accessible to the unauthorized `param` reference, like with `qux` above.

</details>

<details>

<summary>Account Access Got Improved ([FLIP 92](https://github.com/onflow/flips/blob/main/cadence/20230525-account-type.md))</summary>

#### 💡 Motivation

Previously, access to accounts was granted wholesale: Users would sign a transaction, authorizing the code of the transaction to perform any kind of operation, for example, write to storage, but also add keys or contracts.

Users had to trust that a transaction would only perform supposed access, e.g. storage access to withdraw tokens, but still had to grant full access, which would allow the transaction to perform other operations.

Dapp developers who require users to sign transactions should be able to request the minimum amount of access to perform the intended operation, i.e. developers should be able to follow the principle of least privilege (PoLA).

This allows users to trust the transaction and Dapp.

#### ℹ️ Description

Previously, access to accounts was provided through the built-in types `AuthAccount` and `PublicAccount`: `AuthAccount` provided full *write* access to an account, whereas `PublicAccount` only provided *read* access.

With the introduction of entitlements, this access is now expressed using entitlements and references, and only a single `Account` type is necessary. In addition, storage related functionality were moved to the field `Account.storage`.

Access to administrative account operations, such as writing to storage, adding keys, or adding contracts, is now gated by both coarse grained entitlements (e.g. `Storage`, which grants access to all storage related functions, and `Keys`, which grants access to all key management functions), as well as fine-grained entitlements (e.g. `SaveValue` to save a value to storage, or `AddKey` to add a new key to the account).

Transactions can now request the particular entitlements necessary to perform the operations in the transaction.

This improvement was proposed in [FLIP 92](https://github.com/onflow/flips/blob/main/cadence/20230525-account-type.md). To learn more, consult the FLIP and the documentation.

#### 🔄 Adoption

Code that previously used `PublicAccount` can simply be replaced with an unauthorized account reference, `&Account.`

Code that previously used `AuthAccount` must be replaced with an authorized account reference. Depending on what functionality of the account is accessed, the appropriate entitlements have to be specified.

For example, if the `save` function of `AuthAccount` was used before, the function call must be replaced with `storage.save`, and the `SaveValue` or `Storage` entitlement is required.

#### ✨ Example

**Before:**

The transactions wants to save a value to storage. It must request access to the whole account, even though it does not need access beyond writing to storage.

```cadence
transaction {
  prepare(signer: AuthAccount) {
    signer.save("Test", to: /storage/test)
  }
}
```

**After:**

The transaction requests the fine-grained account entitlement `SaveValue`, which allows the transaction to call the `save` function.

```cadence
transaction {
  prepare(signer: auth(SaveValue)&Account) {
    signer.storage.save("Test", to: /storage/test)
  }
}
```

If the transaction attempts to perform other operations, such as adding a new key, it is rejected:

```cadence
transaction {
  prepare(signer: auth(SaveValue)&Account) {
    signer.storage.save("Test", to: /storage/test)
    signer.keys.add(/* ... */)
    //          ^^^ Error: Cannot call function, requires `AddKey` or `Keys` entitlement
  }
}
```

</details>

<details>

<summary>Deprecated Key Management API Got Removed</summary>

#### 💡 Motivation

Cadence provides two key management APIs:

- The original, low-level API, which worked with RLP-encoded keys
- The improved, high-level API, which works with convenient data types like `PublicKey`, `HashAlgorithm`, and `SignatureAlgorithm`
  The improved API was introduced, as the original API was difficult to use and error-prone.
  The original API was deprecated in early 2022.

#### ℹ️ Description

The original account key management API, got removed. Instead, the improved key management API should be used.
To learn more,

#### 🔄 Adoption

Replace uses of the original account key management API functions with equivalents of the improved API:

| Removed | Replacement |
| --------------------------- | ------------------- |
| AuthAccount.addPublicKey | Account.keys.add |
| AuthAccount.removePublicKey | Account.keys.revoke |

To learn more, please refer to the [documentation](https://developers.flow.com/cadence/language/accounts#account-keys).

#### ✨ Example

**Before:**

```cadence
transaction(encodedPublicKey: [UInt8]) {
  prepare(signer: AuthAccount) {
    signer.addPublicKey(encodedPublicKey)
  }
}
```

**After:**

```cadence
transaction(publicKey: [UInt8]) {
  prepare(signer: auth(Keys) &Account) {
    signer.keys.add(
      publicKey: PublicKey(
        publicKey: publicKey,
        signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
      ),
      hashAlgorithm: HashAlgorithm.SHA3_256,
      weight: 100.0
    )
  }
}
```

</details>

<details>

<summary>Resource Tracking for Optional Bindings Improved</summary>

#### 💡 Motivation

Previously, resource tracking for optional bindings (”if-let statements”) was implemented incorrectly, leading to errors for valid code.
This required developers to add workarounds to their code.

#### ℹ️ Description

Resource tracking for optional bindings (”if-let statements”) was fixed.

For example, the following program used to be invalid, reporting a resource loss error for `optR`:

```cadence
resource R {}
fun asOpt(_ r: @R): @R? {
  return <-r
}

fun test() {
  let r <- create R()
  let optR <- asOpt(<-r)
  if let r2 <- optR {
      destroy r2
  }
}
```

This program is now considered valid.

#### 🔄 Adoption

New programs do not need workarounds anymore, and can be written naturally.

Programs that previously resolved the incorrect resource loss error with a workaround, for example by invalidating the resource also in the else-branch or after the if-statement, are now invalid:

```cadence
fun test() {
  let r <- createR()
  let optR <-asOpt(<-r)
  if let r2 <- optR {
    destroy r2
  } else {
    destroy optR
    // unnecessary, but added to avoid error
  }
}
```

The unnecessary workaround needs to be removed.

</details>

<details>

<summary>Definite Return Analysis Got Improved</summary>

#### 💡 Motivation

Definite return analysis determines if a function always exits, in all possible execution paths, e.g. through a `return` statement, or by calling a function that never returns, like `panic`.

This analysis was incomplete and required developers to add workarounds to their code.

#### ℹ️ Description

The definite return analysis got significantly improved.

This means that the following program is now accepted: both branches of the if-statement exit, one using a `return` statement, the other using a function that never returns, `panic`:

```cadence
resource R {}

fun mint(id: UInt64):@R {
  if id > 100 {
    return <- create R()
  } else {
    panic("bad id")
  }
}
```

The program above was previously rejected with a “missing return statement” error – even though we can convince ourselves that the function will exit in both branches of the if-statement, and that any code after the if-statement is unreachable, the type checker was not able to detect that – it now does.

#### 🔄 Adoption

New programs do not need workarounds anymore, and can be written naturally.
Programs that previously resolved the incorrect error with a workaround, for example by adding an additional exit at the end of the function, are now invalid:

```cadence
resource R {}

fun mint(id: UInt64):@R {
  if id > 100 {
    return <- create R()
  } else {
    panic("bad id")
  }

  // unnecessary, but added to avoid error
  panic("unreachable")
}
```

The improved type checker now detects and reports the unreachable code after the if-statement as an error:

```bash
error: unreachable statement
--> test.cdc:12:4
  |
12|  panic("unreachable")
  |  ^^^^^^^^^^^^^^^^^^^^
exit status 1
```

To make the code valid, simply remove the unreachable code.

</details>

<details>

<summary>Semantics for Variables in For-Loop Statements Got Improved ([FLIP 13](https://github.com/onflow/flips/blob/main/cadence/20221011-for-loop-semantics.md))</summary>

#### 💡 Motivation

Previously, the iteration variable of `for-in` loops was re-assigned on each iteration.

Even though this is a common behavior in many programming languages, it is surprising behavior and a source of bugs.

The behavior was improved to the often assumed/expected behavior of a new iteration variable being introduced for each iteration, which reduces the likelihood for a bug.

#### ℹ️ Description

The behavior of `for-in` loops improved, so that a new iteration variable is introduced for each iteration.

This change only affects few programs, as the behavior change is only noticeable if the program captures the iteration variable in a function value (closure).

This improvement was proposed in [FLIP 13](https://github.com/onflow/flips/blob/main/cadence/20221011-for-loop-semantics.md). To learn more, consult the FLIP and documentation.

#### ✨ Example

Previously, `values` would result in `[3, 3, 3]`, which might be surprising and unexpected. This is because `x` was *reassigned* the current array element on each iteration, leading to each function in `fs` returning the last element of the array.

```cadence
// Capture the values of the array [1, 2, 3]
let fs: [((): Int)] = []
for x in [1, 2, 3] {
  // Create a list of functions that return the array value
  fs.append(fun (): Int {
    return x
  })
}

// Evaluate each function and gather all array values
let values: [Int] = []
for f in fs {
  values.append(f())
}
```

</details>

<details>

<summary>References to Resource-Kinded Values Get Invalidated When the Referenced Values Are Moved ([FLIP 1043](https://github.com/onflow/flips/blob/main/cadence/20220708-resource-reference-invalidation.md))</summary>

#### 💡 Motivation

Previously, when a reference is taken to a resource, that reference remains valid even if the resource was moved, for example when created and moved into an account, or moved from one account into another.

In other words, references to resources stayed alive forever. This could be a potential safety foot-gun, where one could gain/give/retain unintended access to resources through references.

#### ℹ️ Description

References are now invalidated if the referenced resource is moved after the reference was taken. The reference is invalidated upon the first move, regardless of the origin and the destination.

This feature was proposed in [FLIP 1043](https://github.com/onflow/flips/blob/main/cadence/20220708-resource-reference-invalidation.md). To learn more, please consult the FLIP and documentation.

#### ✨ Example

```cadence
// Create a resource.
let r <-createR()

// And take a reference.
let ref = &r as &R

// Then move the resource into an account.
account.save(<-r, to: /storage/r)

// Update the reference.
ref.id = 2

```

Old behavior:

```cadence

// This will also update the referenced resource in the account.
ref.id = 2

```

The above operation will now result in a static error.

```cadence

// Trying to update/access the reference will produce a static error:
//     "invalid reference: referenced resource may have been moved or destroyed"
ref.id = 2

```

However, not all scenarios can be detected statically. e.g:

```cadence
fun test(ref: &R) {
  ref.id = 2
}
```

In the above function, it is not possible to determine whether the resource to which the reference was taken has been moved or not. Therefore, such cases are checked at run-time, and a run-time error will occur if the resource has been moved.

#### 🔄 Adoption

Review code that uses references to resources, and check for cases where the referenced resource is moved. Such code may now be reported as invalid, or result in the program being aborted with an error when a reference to a moved resource is de-referenced.

</details>

<details>

<summary>Capability Controller API Replaced Existing Linking-based Capability API ([FLIP 798](https://github.com/onflow/flips/blob/main/cadence/20220203-capability-controllers.md))</summary>

#### 💡 Motivation

Cadence encourages a capability-based security model. Capabilities are themselves a new concept that most Cadence programmers need to understand.

The existing API for capabilities was centered around “links” and “linking”, and the associated concepts of the public and private storage domains, led to capabilities being even confusing and awkward to use.
An better API is easier to understand and easier to work with.

#### ℹ️ Description

The existing linking-based capability API has been replaced by a more powerful and easier to use API based on the notion of Capability Controllers. The new API makes the creation of new and the revocation of existing capabilities simpler.

This improvement was proposed in [FLIP 798](https://github.com/onflow/flips/blob/main/cadence/20220203-capability-controllers.md). To learn more, consult the FLIP and the documentation.

#### 🔄 Adoption

Existing uses of the linking-based capability API must be replaced with the new Capability Controller API.

| Removed                                   | Replacement                                                     |
| ----------------------------------------- | --------------------------------------------------------------- |
| `AuthAccount.link`, with private path       | `Account.capabilities.storage.issue`                             |
| `AuthAccount.link`, with public path        | `Account.capabilities.storage.issue` and `Account.capabilities.publish` |
| `AuthAccount.linkAccount`                   | `AuthAccount.capabilities.account.issue`                         |
| `AuthAccount.unlink`, with private path     | - Get capability controller: `Account.capabilities.storage/account.get` <br /> - Revoke controller: `Storage/AccountCapabilityController.delete` |
| `AuthAccount.unlink`, with public path      | - Get capability controller: `Account.capabilities.storage/account.get` <br /> - Revoke controller: `Storage/AccountCapabilityController.delete` <br /> - Unpublish capability: `Account.capabilities.unpublish` |
| `AuthAccount/PublicAccount.getCapability`   | `Account.capabilities.get`                                        |
| `AuthAccount/PublicAccount.getCapability` with followed borrow | `Account.capabilities.borrow`                            |
| `AuthAccount.getLinkTarget`                 | N/A                                                             |


#### ✨ Example

Assume there is a `Counter` resource which stores a count, and it implements an interface `HasCount` which is used to allow read access to the count.

```cadence
access(all)
resource interface HasCount {
  access(all)
  count: Int
}

access(all)
resource Counter: HasCount {
  access(all)
  var count: Int

  init(count: Int) {
    self.count = count
  }
}
```

Granting access, before:

```cadence
transaction {
  prepare(signer: AuthAccount) {
    signer.save(
      <-create Counter(count: 42),
      to: /storage/counter
    )
    signer.link<&{HasCount}>(
      /public/hasCount,
      target: /storage/counter
    )
  }
}
```

Granting access, after:

```cadence
transaction {
  prepare(signer: auth(Storage, Capabilities)&Account) {
    signer.save(
      <-create Counter(count: 42),
      to: /storage/counter
    )
    let cap = signer.capabilities.storage.issue<&{HasCount}>(
      /storage/counter
    )
    signer.capabilities.publish(cap, at: /public/hasCount)
  }
}
```

Getting access, before:

```cadence
access(all)
fun main(): Int {
  let counterRef = getAccount(0x1)
    .getCapabilities<&{HasCount}>(/public/hasCount)
    .borrow()!
  return counterRef.count
}
```

Getting access, after:

```cadence
access(all)
fun main(): Int {
  let counterRef = getAccount(0x1)
    .capabilities
    .borrow<&{HasCount}>(/public/hasCount)!
  return counterRef.count
}
```

</details>

<details>

<summary>External Mutation Improvement ([FLIP 89](https://github.com/onflow/flips/blob/main/cadence/20230517-member-access-semnatics.md) & [FLIP 86](https://github.com/onflow/flips/blob/main/cadence/20230519-built-in-mutability-entitlements.md))</summary>

#### 💡 Motivation

A previous version of Cadence (“Secure Cadence”), attempted to prevent a common safety foot-gun: Developers might use the `let` keyword for a container-typed field, assuming it would be immutable.

Though Secure Cadence implements the [Cadence mutability restrictions FLIP](https://github.com/onflow/flips/blob/main/cadence/20211129-cadence-mutability-restrictions.md), it did not fully solve the problem / prevent the foot-gun and there were still ways to mutate such fields, so a proper solution was devised.

To learn more about the problem and motivation to solve it, please read the associated [Vision](https://github.com/onflow/flips/blob/main/cadence/vision/mutability-restrictions.md) document.

#### ℹ️ Description

The mutability of containers (updating a field of a composite value, key of a map, or index of an array) through references has changed:
When a field/element is accessed through a reference, a reference to the accessed inner object is returned, instead of the actual object. These returned references are unauthorized by default, and the author of the object (struct/resource/etc.) can control what operations are permitted on these returned references by using entitlements and entitlement mappings.
This improvement was proposed in two FLIPs:

- [FLIP 89: Change Member Access Semantics](https://github.com/onflow/flips/blob/main/cadence/20230517-member-access-semnatics.md)
- [FLIP 86: Introduce Built-in Mutability Entitlements 1](https://github.com/onflow/flips/blob/main/cadence/20230519-built-in-mutability-entitlements.md)

To learn more, please consult the FLIPs and the documentation.

#### 🔄 Adoption

As mentioned in the previous section, the most notable change in this improvement is that, when a field/element is accessed through a reference, a reference to the accessed inner object is returned, instead of the actual object. So developers would need to change their code to:

- Work with references, instead of the actual object, when accessing nested objects through a reference.
- Use proper entitlements for fields when they declare their own `struct` and `resource` types.

<br />

#### ✨ Example

Consider the below resource collection:

```cadence
pub resource MasterCollection {
  pub let kittyCollection: @Collection
  pub let topshotCollection: @Collection
}

pub resource Collection {
  pub(set)
  var id: String

  access(all)
  var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

  access(all)
  fun deposit(token:@NonFungibleToken.NFT) {... }
}
```

Earlier, it was possible to mutate the inner collections, even if someone only had a reference to the `MasterCollection`. e.g:

```cadence
var masterCollectionRef:&MasterCollection =... // Directly updating the field
masterCollectionRef.kittyCollection.id = "NewID"

// Calling a mutating function
masterCollectionRef.kittyCollection.deposit(<-nft)

// Updating via the referencelet ownedNFTsRef=&masterCollectionRef.kittyCollection.ownedNFTs as &{UInt64: NonFungibleToken.NFT}
destroy ownedNFTsRef.insert(key: 1234, <-nft)

```

Once this change is introduced, the above collection can be re-written as below:

```cadence
pub resource MasterCollection {
  access(KittyCollectorMapping)
  let kittyCollection: @Collection

  access(TopshotCollectorMapping)
  let topshotCollection: @Collection
}

pub resource Collection {
  pub(set)
  var id: String

  access(Identity)
  var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

  access(Insert)
  fun deposit(token:@NonFungibleToken.NFT) { /* ... */ }
}

// Entitlements and mappings for `kittyCollection`

entitlement KittyCollector

entitlement mapping KittyCollectorMapping {
  KittyCollector -> Insert
  KittyCollector -> Remove
}

// Entitlements and mappings for `topshotCollection`

entitlement TopshotCollector

entitlement mapping TopshotCollectorMapping {
  TopshotCollector -> Insert
  TopshotCollector -> Remove
}
```

Then for a reference with no entitlements, none of the previously mentioned operations would be allowed:

```cadence
var masterCollectionRef:&MasterCollection <- ... // Error: Cannot update the field. Doesn't have sufficient entitlements.
masterCollectionRef.kittyCollection.id = "NewID"

// Error: Cannot directly update the dictionary. Doesn't have sufficient entitlements.
destroy masterCollectionRef.kittyCollection.ownedNFTs.insert(key: 1234,<-nft)
destroy masterCollectionRef.ownedNFTs.remove(key: 1234)

// Error: Cannot call mutating function. Doesn't have sufficient entitlements.
masterCollectionRef.kittyCollection.deposit(<-nft)

// Error: `masterCollectionRef.kittyCollection.ownedNFTs` is already a non-auth reference.// Thus cannot update the dictionary. Doesn't have sufficient entitlements.
let ownedNFTsRef = &masterCollectionRef.kittyCollection.ownedNFTsas&{UInt64: NonFungibleToken.NFT}
destroy ownedNFTsRef.insert(key: 1234, <-nft)
```

To perform these operations on the reference, one would need to have obtained a reference with proper entitlements:

```cadence
var masterCollectionRef: auth{KittyCollector} &MasterCollection <- ... // Directly updating the field
masterCollectionRef.kittyCollection.id = "NewID"

// Updating the dictionary
destroy masterCollectionRef.kittyCollection.ownedNFTs.insert(key: 1234, <-nft)
destroy masterCollectionRef.kittyCollection.ownedNFTs.remove(key: 1234)

// Calling a mutating function
masterCollectionRef.kittyCollection.deposit(<-nft)
```

</details>

<details>

<summary>Removal Of Nested Type Requirements ([FLIP 118](https://github.com/onflow/flips/blob/main/cadence/20230711-remove-type-requirements.md))</summary>

#### 💡 Motivation

[Nested Type Requirements 3](https://docs.onflow.org/cadence/language/interfaces/#nested-type-requirements) were a fairly advanced concept of the language.

Just like an interface could require a conforming type to provide a certain field or function, it could also have required the conforming type to provide a nested type.

This is an uncommon feature in other programming languages and hard to understand.

In addition, the value of nested type requirements was never realized. While it was previously used in the FT and NFT contracts, the addition of other language features like interface inheritance and events being emittable from interfaces, there were no more uses case compelling enough to justify a feature of this complexity.

#### ℹ️ Description

Contract interfaces can no longer declare any concrete types (`struct`, `resource` or `enum`) in their declarations, as this would create a type requirement. `event` declarations are still allowed, but these create an `event` type limited to the scope of that contract interface; this `event` is not inherited by any implementing contracts. Nested interface declarations are still permitted, however.

This improvement was proposed in [FLIP 118](https://github.com/onflow/flips/blob/main/cadence/20230711-remove-type-requirements.md).

#### 🔄 Adoption

Any existing code that made use of the type requirements feature should be rewritten not to use this feature.

</details>

<details>

<summary>Event Definition And Emission In Interfaces ([FLIP 111](https://github.com/onflow/flips/blob/main/cadence/20230417-events-emitted-from-interfaces.md))</summary>

#### 💡 Motivation

In order to support the removal of nested type requirements, events have been made define-able and emit-able from contract interfaces, as events were among the only common uses of the type requirements feature.

#### ℹ️ Description

Contract interfaces may now define event types, and these events can be emitted from function conditions and default implementations in those contract interfaces.

This improvement was proposed in [FLIP 111](https://github.com/onflow/flips/blob/main/cadence/20230417-events-emitted-from-interfaces.md).

#### 🔄 Adoption

Contract interfaces that previously used type requirements to enforce that concrete contracts which implement the interface should also declare a specific event, should instead define and emit that event in the interface.

#### ✨ Example

**Before:**

A contract interface like the one below (`SomeInterface`) used a type requirement to enforce that contracts which implement the interface also define a certain event (`Foo`):

```cadence
contract interface SomeInterface {
  event Foo()
//^^^^^^^^^^^ type requirement

  fun inheritedFunction()
}

contract MyContract: SomeInterface {
  event Foo()
//^^^^^^^^^^^ type definition to satisfy type requirement

  fun inheritedFunction() {
//  ...
    emit Foo()
  }
}
```

**After:**

This can be rewritten to emit the event directly from the interface, so that any contracts that implement `Intf` will always emit `Foo` when `inheritedFunction` is called:

```cadence
contract interface Intf {
  event Foo()
//^^^^^^^^^^^ type definition

  fun inheritedFunction() {
    pre {
      emit Foo()
    }
  }
}
```

</details>

<details>

<summary>Force Destruction of Resources ([FLIP 131](https://github.com/onflow/flips/pull/131))</summary>

#### 💡 Motivation

It was previously possible to panic in the body of a resource or attachment’s `destroy` method, effectively preventing the destruction or removal of that resource from an account. This could be used as an attack vector by handing people undesirable resources or hydrating resources to make them extremely large or otherwise contain undesirable content.

#### ℹ️ Description

Contracts may no longer define `destroy` functions on their resources, and are no longer required to explicitly handle the destruction of resource fields. These will instead be implicitly destroyed whenever a resource is destroyed.
Additionally, developers may define a `ResourceDestroyed` event in the body of a resource definition using default arguments, which will be lazily evaluated and then emitted whenever a resource of that type is destroyed.
This improvement was proposed in [FLIP 131](https://github.com/onflow/flips/pull/131).

#### 🔄 Adoption

Contracts that previously used destroy methods will need to remove them, and potentially define a ResourceDestroyed event to track destruction if necessary.

#### ✨ Example

A pair of resources previously written as:

```cadence
event E(id: Int)

resource SubResource {
  let id: Int
  init(id: Int) {
    self.id = id
  }

  destroy() {
    emit E(id: self.id)
  }
}

resource R {
  let subR: @SubResource

  init(id: Int) {
    self.subR <- create SubResource(id: id)
  }

  destroy() {
    destroy self.subR
  }
}
```

can now be equivalently written as:

```cadence
resource SubResource {
  event ResourceDestroyed(id: Int = self.id)
  let id: Int

  init(id: Int) {
    self.id = id
  }
}

resource R {
  let subR: @SubResource

  init(id: Int) {
    self.subR <- create SubResource(id: id)
  }
}
```

</details>

<details>

<summary>New `domainSeparationTag` parameter added to `Crypto.KeyList.verify`</summary>

#### 💡 Motivation

`KeyList`’s `verify` function used to hardcode the domain separation tag (`"FLOW-V0.0-user"`) used to verify each signature from the list. This forced users to use the same domain tag and didn’t allow them to scope their signatures to specific use-cases and applications. Moreover, the `verify` function didn’t mirror the `PublicKey` signature verification behaviour which accepts a domain tag parameter.

#### ℹ️ Description

`KeyList`’s `verify` function requires an extra parameter to specify the domain separation tag used to verify the input signatures. The tag is is a single `string` parameter and is used with all signatures. This mirrors the behaviour of the simple public key [signature verification](https://cadence-lang.org/docs/1.0/language/crypto#signature-verification).

#### 🔄 Adoption

Contracts that use `KeyList` need to update the calls to `verify` by adding the new domain separation tag parameter. Using the tag as `"FLOW-V0.0-user"` would keep the exact same behaviour as before the breaking change. Applications may also define a new domain tag for their specific use-case and use it when generating valid signatures, for added security against signature replays. Check the [signature verification doc](https://cadence-lang.org/docs/1.0/language/crypto#signature-verification) and specifically [hashing with a tag](https://cadence-lang.org/docs/1.0/language/crypto#hashing-with-a-domain-tag) for details on how to generate valid signatures with a tag.

#### ✨ Example

A previous call to `KeyList`’s `verify` is written as:

```cadence
let isValid = keyList.verify(
  signatureSet: signatureSet,
  signedData: signedData
)
```

can now be equivalently written as:

```cadence
let isValid = keyList.verify(
  signatureSet: signatureSet,
  signedData: signedData,
  domainSeparationTag: "FLOW-V0.0-user"
)
```

Instead of the existing hardcoded domain separation tag, a new domain tag can be defined, but it has to be also used when generating valid signatures, e.g. `"my_app_custom_domain_tag"`.

</details>

## FT / NFT Standard changes

In addition to the upcoming language changes, the Cadence 1.0 upgrade also includes breaking changes to core contracts - such as the FungibleToken and NonFungibleToken standards. All Fungible & Non-Fungible Token contracts will need to be updated to the new standard.

These interfaces are being upgraded to allow for multiple tokens per contract, fix some issues with the original standards, and introduce other various improvements suggested by the community.

- Original Proposal: [http://forum.flow.com/t/streamlined-token-standards-proposal/3075](http://forum.flow.com/t/streamlined-token-standards-proposal/3075)
- Fungible Token Changes PR: [WIP: V2 FungibleToken Standard by joshuahannan · Pull Request #77 · onflow/flow-ft · GitHub 5](https://github.com/onflow/flow-ft/pull/77)
- NFT Changes PR: [https://github.com/onflow/flow-nft/pull/126 8](https://github.com/onflow/flow-nft/pull/126)

It will involve upgrading your token contracts with changes to events, function signatures, resource interface conformances, and other small changes.

There are some existing guides for upgrading your token contracts to the new standard:

- [Upgrading Fungible Token Contracts](./ft-guide.mdx)
- [Upgrading Non-Fungible Token Contracts](./nft-guide.mdx)

## More Resources

If you have any questions or need help with the upgrade, feel free to reach out to the Flow team on the [Flow Discord](https://discord.gg/flowblockchain).

Help is also available during the [Cadence 1.0 Office Hours](https://calendar.google.com/calendar/ical/c_47978f5cd9da636cadc6b8473102b5092c1a865dd010558393ecb7f9fd0c9ad0%40group.calendar.google.com/public/basic.ics) each week at 10:00am PST on the Flow Developer Discord.




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/constants-and-variables.md

---
title: Constants and Variable Declarations
sidebar_position: 2
---

Constants and variables are declarations that bind
a value and [type](./type-safety.md) to an identifier.
Constants are initialized with a value and cannot be reassigned afterwards.
Variables are initialized with a value and can be reassigned later.
Declarations can be created in any scope, including the global scope.

Constant means that the *identifier's* association is constant,
not the *value* itself –
the value may still be changed if it is mutable.

Constants are declared using the `let` keyword. Variables are declared
using the `var` keyword.
The keywords are followed by the identifier,
an optional [type annotation](./type-annotations.md), an equals sign `=`,
and the initial value.

```cadence
// Declare a constant named `a`.
//
let a = 1

// Invalid: re-assigning to a constant.
//
a = 2

// Declare a variable named `b`.
//
var b = 3

// Assign a new value to the variable named `b`.
//
b = 4
```

Variables and constants **must** be initialized.

```cadence
// Invalid: the constant has no initial value.
//
let a
```

The names of the variable or constant
declarations in each scope must be unique.
Declaring another variable or constant with a name that is already
declared in the current scope is invalid, regardless of kind or type.

```cadence
// Declare a constant named `a`.
//
let a = 1

// Invalid: cannot re-declare a constant with name `a`,
// as it is already used in this scope.
//
let a = 2

// Declare a variable named `b`.
//
var b = 3

// Invalid: cannot re-declare a variable with name `b`,
// as it is already used in this scope.
//
var b = 4

// Invalid: cannot declare a variable with the name `a`,
// as it is already used in this scope,
// and it is declared as a constant.
//
var a = 5
```

However, variables can be redeclared in sub-scopes.

```cadence
// Declare a constant named `a`.
//
let a = 1

if true {
    // Declare a constant with the same name `a`.
    // This is valid because it is in a sub-scope.
    // This variable is not visible to the outer scope.

    let a = 2
}

// `a` is `1`
```

A variable cannot be used as its own initial value.

```cadence
// Invalid: Use of variable in its own initial value.
let a = a
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/environment-information.md

---
title: Environment Information
sidebar_position: 29
---

## Transaction Information

To get the addresses of the signers of a transaction,
use the `address` field of each signing `Account`
that is passed to the transaction's `prepare` phase.

There is currently no API that allows getting other transaction information.
Please let us know if your use-case demands it by request this feature in an issue.

## Block Information

To get information about a block, the functions `getCurrentBlock` and `getBlock` can be used:

-
    ```cadence
    view fun getCurrentBlock(): Block
    ```

  Returns the current block, i.e. the block which contains the currently executed transaction.

-
    ```cadence
    view fun getBlock(at: UInt64): Block?
    ```

  Returns the block at the given height.
  If the block exists within the accessible range defined by `flow.DefaultTransactionExpiry - 10` (`590` blocks), it is returned successfully.
  If the block at the given height does not exist or is outside the default transaction expiration range of `590` blocks below the current sealed block, the function returns `nil`.

The `Block` type contains the identifier, height, and timestamp:

```cadence
access(all)
struct Block {
    /// The ID of the block.
    ///
    /// It is essentially the hash of the block.
    ///
    access(all)
    let id: [UInt8; 32]

    /// The height of the block.
    ///
    /// If the blockchain is viewed as a tree with the genesis block at the root,
    // the height of a node is the number of edges between the node and the genesis block
    ///
    access(all)
    let height: UInt64

    /// The view of the block.
    ///
    /// It is a detail of the consensus algorithm. It is a monotonically increasing integer
    /// and counts rounds in the consensus algorithm. It is reset to zero at each spork.
    ///
    access(all)
    let view: UInt64

    /// The timestamp of the block.
    ///
    /// Unix timestamp of when the proposer claims it constructed the block.
    ///
    /// NOTE: It is included by the proposer, there are no guarantees on how much the time stamp can deviate from the true time the block was published.
    /// Consider observing blocks’ status changes off-chain yourself to get a more reliable value.
    ///
    access(all)
    let timestamp: UFix64
}
```






---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/09-voting.md

---
title: 9. Voting Contract
---

In this tutorial, we're going to deploy a contract that allows users to vote on multiple proposals that a voting administrator controls.

---

:::info

Open the starter code for this tutorial in the Flow Playground:
<a
href="https://play.flow.com/e8e2af39-370d-4a52-9f0b-bfb3b12c7eff"
target="_blank"
>
https://play.flow.com/e8e2af39-370d-4a52-9f0b-bfb3b12c7eff
</a>
The tutorial will be asking you to take various actions to interact with this code.

:::

:::info[Action]

Instructions that require you to take action are always included in a callout box like this one.
These highlighted actions are all that you need to do to get your code running,
but reading the rest is necessary to understand the language's design.

:::

With the advent of blockchain technology and smart contracts,
it has become popular to try to create decentralized voting mechanisms that allow large groups of users to vote completely on chain.
This tutorial will provide a trivial example for how this might be achieved by using a resource-oriented programming model.

We'll take you through these steps to get comfortable with the Voting contract.

1. Deploy the contract to account `0x06`
2. Create proposals for users to vote on
3. Use a transaction with multiple signers to directly transfer the `Ballot` resource to another account.
4. Record and cast your vote in the central Voting contract
5. Read the results of the vote

Before proceeding with this tutorial, we highly recommend following the instructions in [Getting Started](./01-first-steps.md)
and [Hello, World!](./02-hello-world.md) to learn how to use the Playground tools and to learn the fundamentals of Cadence.

## A Voting Contract in Cadence

In this contract, a Ballot is represented as a resource.

An administrator can give Ballots to other accounts, then those accounts mark which proposals they vote for
and submit the Ballot to the central smart contract to have their votes recorded.

Using a [resource](../language/resources.mdx) type is logical for this application, because if a user wants to delegate their vote,
they can send that Ballot to another account, and the use case of voting ballots benefits from the uniqueness and existence guarantees
inherent to resources.

## Write the Contract

Time to see the contract we'll be working with:

:::info[Action]

1. Open Contract 1 - the `ApprovalVoting` contract.

:::

The contract should have the following contents:

```cadence ApprovalVoting.cdc
/*
*
*   In this example, we want to create a simple approval voting contract
*   where a polling place issues ballots to addresses.
*
*   The run a vote, the Admin deploys the smart contract,
*   then initializes the proposals
*   using the initialize_proposals.cdc transaction.
*   The array of proposals cannot be modified after it has been initialized.
*
*   Then they will give ballots to users by
*   using the issue_ballot.cdc transaction.
*
*   Every user with a ballot is allowed to approve any number of proposals.
*   A user can choose their votes and cast them
*   with the cast_vote.cdc transaction.
*
*.  See if you can code it yourself!
*
*/

access(all)
contract ApprovalVoting {

    // Field: An array of strings representing proposals to be approved

    // Field: A dictionary mapping the proposal index to the number of votes per proposal

    // Entitlement: Admin entitlement that restricts the privileged fields
    // of the Admin resource

    // Resource: Ballot resource that is issued to users.
    // When a user gets a Ballot object, they call the `vote` function
    // to include their votes for each proposal, and then cast it in the smart contract
    // using the `cast` function to have their vote included in the polling
    // Remember to track which proposals a user has voted yes for in the Ballot resource
    // and remember to include proper pre and post conditions to ensure that no mistakes are made
    // when a user submits their vote
    access(all) resource Ballot {

    }

    // Resource: Administrator of the voting process
    // initialize the proposals and to provide a function for voters
    // to get a ballot resource
    // Remember to include proper conditions for each function!
    // Also make sure that the privileged fields are secured with entitlements!
    access(all) resource Administrator {
        
    }

    // Public function: A user can create a capability to their ballot resource
    // and send it to this function so its votes are tallied
    // Remember to include a provision so that a ballot can only be cast once!

    // initialize the contract fields by setting the proposals and votes to empty
    // and create a new Admin resource to put in storage
    init() {
        
    }
}

```

Now is your chance to write some of your own Cadence code!
See if you can follow the instructions in the comments of the contract
to write your own approval voting contract.
Instructions for transactions are also included in the sample transactions.
Once you're done, share your project with the Flow community in the Flow discord! :)

## Deploy the Contract

:::info[Action]

1. In the bottom right deployment modal, press the arrow to expand and make sure account `0x06` is selected as the signer.
2. Click the Deploy button to deploy it to account `0x06`

:::

## Perform Voting

Performing the common actions in this voting contract only takes three types of transactions.

1. Initialize Proposals
2. Send `Ballot` to a voter
3. Cast Vote

We have a transaction for each step that we provide a skeleton of for you.
With the `ApprovalVoting` contract deployed to account `0x06`:

:::info[Action]

1. Open Transaction 1 which should have `Create Proposals`
2. Submit the transaction with account `0x06` selected as the only signer.

:::

```cadence CreateProposals.cdc
import ApprovalVoting from 0x06

// This transaction allows the administrator of the Voting contract
// to create new proposals for voting and save them to the smart contract

transaction {
    // Fill in auth() with the correct entitlements you need!
    prepare(admin: auth()) {

        // borrow a reference to the admin Resource
        // remember to use descriptive error messages!

        // Call the initializeProposals function
        // to create the proposals array as an array of strings
        // Maybe we could create two proposals for the local basketball league:
        // ["Longer Shot Clock", "Trampolines instead of hardwood floors"]

        // Issue and public a public capability to the Administrator resource
        // so that voters can get their ballots!
    }

    post {
        // Verify that the proposals were initialized properly
    }

}
```

This transaction allows the `Administrator` of the contract to create new proposals for voting and save them to the smart contract. They do this by calling the `initializeProposals` function on their stored `Administrator` resource, giving it two new proposals to vote on.
We use the `post` block to ensure that there were two proposals created, like we wished for.

Next, the `Administrator` needs to hand out `Ballot`s to the voters. There isn't an easy `deposit` function this time for them to send a `Ballot` to another account, so how would they do it?

## Putting Resource Creation in public capabilities

Unlike our other tutorial contracts, the Approval Voting contract
puts its Ballot creation function in a resource instead of as a public function in a contract.
This way, the admin can control who can and cannot create a Ballot resource.
There are also ways to consolidate all of the voting logic into the Admin resource
so that there can be multiple sets of proposals being voted on at the same time
without having to deploy a new contract for each one!

Here, we're just exposing the create ballot function through a public capability
for simplicity, so lets use the transaction for a voter to create a ballot.

:::info[Action]

1. Open the `Create Ballot` transaction.
2. Select account `0x07` as a signer.
3. Submit the transaction by clicking the `Send` button

:::

```cadence CreateBallot.cdc

import ApprovalVoting from 0x06

// This transaction allows a user
// to create a new ballot and store it in their account
// by calling the public function on the Admin resource
// through its public capability

transaction {
    // fill in the correct entitlements!
    prepare(voter: auth() &Account) {

        // Get the administrator's public account object
        // and borrow a reference to their Administrator resource

        // create a new Ballot by calling the issueBallot
        // function of the admin Reference

        // store that ballot in the voter's account storage
    }
}

```

After this transaction, account `0x07` should now have a `Ballot` resource
object in its account storage. You can confirm this by selecting `0x07`
from the lower-left sidebar and seeing `Ballot` resource listed under the `Storage` field.

## Casting a Vote

Now that account `0x07` has a `Ballot` in their storage, they can cast their vote.
To do this, they will call the `vote` method on their stored resource,
then cast that `Ballot` by passing it to the `cast` function in the main smart contract.

:::info[Action]

1. Open the `Cast Ballot` transaction.
2. Select account `0x07` as the only transaction signer.
3. Click the `send` button to submit the transaction.

:::

```cadence CastBallot.cdc
import ApprovalVoting from 0x06

// This transaction allows a voter to select the votes they would like to make
// and cast that vote by using the cast vote function
// of the ApprovalVoting smart contract

transaction {
    // fill in the correct entitlements!
    prepare(voter: auth() &Account) {

        // Borrow a reference to the Ballot resource in the Voter's storage
        
        // Vote on the proposal

        // Issue a capability to the Ballot resource in the voter's storage

        // Cast the vote by submitting it to the smart contract
    }

    post {
        // verify that the votes were cast properly
    }
}
```

In this transaction, the user votes for one of the proposals by submitting
their votes on their own ballot and then sending the capability.

## Reading the result of the vote

At any time, anyone could read the current tally of votes by directly reading the fields of the contract. You can use a script to do that, since it does not need to modify storage.

:::info[Action]

1. Open the `Get Votes` script.
2. Click the `execute` button to run the script.

:::

```cadence GetVotes.cdc
import ApprovalVoting from 0x06

// This script allows anyone to read the tallied votes for each proposal
//

// Fill in a return type that can properly represent the number of votes
// for each proposal
// This might need a custom struct to represent the data
access(all) fun main(): {

    // Access the public fields of the contract to get
    // the proposal names and vote counts

    // return them to the calling context

}
```

The return type should reflect the number of votes that were cast for each proposal
with the `Cast Vote` transaction.

## Other Voting possibilities

This contract was a very simple example of voting in Cadence.
It clearly couldn't be used for a real-world voting situation,
but hopefully you can see what kind of features could be added to it to ensure practicality and security.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/type-annotations.md

---
title: Type Annotations
sidebar_position: 3
---

When declaring a constant or variable,
an optional *type annotation* can be provided,
to make it explicit what type the declaration has.

If no type annotation is provided, the type of the declaration is
[inferred from the initial value](./type-inference.md).

For function parameters a type annotation must be provided.

```cadence
// Declare a variable named `boolVarWithAnnotation`, which has an explicit type annotation.
//
// `Bool` is the type of booleans.
//
var boolVarWithAnnotation: Bool = false

// Declare a constant named `integerWithoutAnnotation`, which has no type annotation
// and for which the type is inferred to be `Int`, the type of arbitrary-precision integers.
//
// This is based on the initial value which is an integer literal.
// Integer literals are always inferred to be of type `Int`.
//
let integerWithoutAnnotation = 1

// Declare a constant named `smallIntegerWithAnnotation`, which has an explicit type annotation.
// Because of the explicit type annotation, the type is not inferred.
// This declaration is valid because the integer literal `1` fits into the range of the type `Int8`,
// the type of 8-bit signed integers.
//
let smallIntegerWithAnnotation: Int8 = 1
```

If a type annotation is provided, the initial value must be of this type.
All new values assigned to variables must match its type.
This type safety is explained in more detail in a [separate section](./type-safety.md).

```cadence
// Invalid: declare a variable with an explicit type `Bool`,
// but the initial value has type `Int`.
//
let booleanConstant: Bool = 1

// Declare a variable that has the inferred type `Bool`.
//
var booleanVariable = false

// Invalid: assign a value with type `Int` to a variable which has the inferred type `Bool`.
//
booleanVariable = 1
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/contract-upgrades.md

---
title: Contract Upgrades with Incompatible Changes
---

### Problem

I have an incompatible upgrade for a contract. How can I deploy this?

### Solution

Please don't perform incompatible upgrades between contract versions in the same account.
There is too much that can go wrong.

You can make [compatible upgrades](./language/contract-updatability.md) and then run a post-upgrade function on the new contract code if needed.

If you must replace your contract rather than update it,
the simplest solution is to add or increase a suffix on any named paths in the contract code
(e.g. `/public/MyProjectVault` becomes `/public/MyProjectVault002`) in addition to making the incompatible changes,
then create a new account and deploy the updated contract there.

⚠️ Flow identifies types relative to addresses, so you will also need to provide _upgrade transactions_ to exchange the old contract's resources for the new contract's ones. Make sure to inform users as soon as possible when and how they will need to perform this task.

If you absolutely must keep the old address when making an incompatible upgrade, then you do so at your own risk. Make sure you perform the following actions in this exact order:

1. Delete any resources used in the contract account, e.g. an Admin resource.
2. Delete the contract from the account.
3. Deploy the new contract to the account.

⚠️ Note that if any user accounts contain `structs` or `resources` from the _old_ version of the contract that have been replaced with incompatible versions in the new one, **they will not load and will cause transactions that attempt to access them to crash**. For this reason, once any users have received `structs` or `resources` from the contract, this method of making an incompatible upgrade should not be attempted!





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/solidity-to-cadence.md

---
title: Cadence Guide for Solidity Developers
sidebar_label: Cadence Guide for Solidity Developers
sidebar_position: 8
---
Cadence introduces a different way to approach smart contract development which may feel unfamiliar to Solidity
developers. There are fundamental mindset and platform differences, and also several new language features that have no
real equivalent in Solidity. This guide outlines high level design and conceptual aspects of Flow and Cadence that are
essential to understand, platform and integration differences, as well as detailed guidance on how to perform certain
common Solidity development tasks using Cadence idioms. We also provide details on how best to leverage Cadence's unique
features and how to avoid common pitfalls that may come up while transitioning.

# Conceptual foundations for Cadence

A fundamental difference to get used to when adjusting to Cadence from Solidity is mindset. Security and
interoperability on Ethereum are designed around addresses (or more specifically the account associated with an
address), resulting in all contracts having to carefully track and evaluate access and authorizations.

<img src="https://storage.googleapis.com/flow-resources/documentation-assets/solidity-to-cadence/ethereum-ownership.png"
width="450" align="right"/>

Transactions are based on who authorized them, which is provided as `msg.sender` in the transaction context. User to
contract, or contract to contract interactions must be explicitly coded to ensure the appropriate approvals have been
made before interacting with a contract. The contract based nature of storage means that user ownership in Ethereum is
represented in a mapping, for example from owner to balance, or token ID to owner. Put another way, ownership is tracked
in ledger records similar to a person's bank balance. Crypto wallets help combine balances from multiple token types
into a convenient view for the user.

Cadence introduces new primitives and distinct functionalities, namely Resources and Capabilities, that are designed
around Flow's account model. Resources are first-class language types which are unique, non-copyable, and which cannot
be discarded. These properties make Resources ideal for representing digital assets like currency or tokens that are
always limited in numbers. Resources are always stored in account storage and contracts control access to them using
Capabilities. Capabilities are another special type that secure protected resources without the need for tracking
addresses. Cadence makes working with these straightforward and intuitive to those familiar with object-oriented
programming languages.

Newcomers to Cadence should ensure they understand the following major concepts before development.

## Flow account model

<img src="https://storage.googleapis.com/flow-resources/documentation-assets/solidity-to-cadence/account-structure.png"
     width="300" align="right"/>

The [Flow account model](https://developers.flow.com/build/basics/accounts.md) in Cadence combines storage for the keys
and code (”smart contracts”) associated with an account with storage for the assets owned by that account. That’s right:
In Cadence, your tokens are stored in your account, and not in a smart contract. Of course, smart contracts still define
these assets and how they behave, but those assets can be securely stored in a user’s account through the magic of
Resources.


There is only one account type in Cadence also with an account address, similar to an Externally-Owned-Account (EOA)
address in Ethereum. However, unlike Ethereum contract-accounts, accounts in Cadence also store contract code. Accounts
realize ownership on Flow in being the container where keys, Resources, and contracts are stored on-chain.


## Account

`Account` is the type that provides access to an account.

The `getAccount` function allows getting access to the publicly available functions and fields of an account. For
example, this allows querying an accounts balance.

An authorized `Account` reference provides access and allows the management of, for instance, the account's storage,
keys configuration, and contract code. An authorized `Account` reference can only be acquired by signing a transaction.
Capabilities ensure that resources held in an account can be safely shared/accessed.

## Resources

Resources are unique, [linear-types](https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems) which
can never be copied or implicitly discarded, only moved between accounts. If, during development, a function fails to
store a Resource obtained from an account in the function scope, semantic checks will flag an error. The run-time
enforces the same strict rules in terms of allowed operations. Therefore, contract functions which do not properly
handle Resources in scope before exiting will abort, reverting them to the original storage. These features of Resources
make them perfect for representing tokens, both fungible and non-fungible. Ownership is tracked by where they are
stored, and the assets can’t be duplicated or accidentally lost since the language itself enforces correctness.

Flow encourages storing of data and compute on-chain and Resource-types makes this easier than ever. Since Resources are
always stored in accounts, any data and code that exists in Resource instances is seamlessly managed on-chain without
any explicit handling needed.

## Capability-based access

Remote access to stored objects can be managed via [Capabilities](./language/capabilities.md). This means that if an
account wants to be able to access another account's stored objects, it must have been provided with a valid Capability
to that object. Capabilities can be either public or private. An account can share a public Capability if it wants to
give all other accounts access. (For example, it’s common for an account to accept fungible token deposits from all
sources via a public Capability.) Alternatively, an account can grant private Capabilities to specific accounts in order
to provide access to restricted functionality. For example, an NFT project often controls minting through an
“administrator Capability” that grants specific accounts with the power to mint new tokens.

## Contract standards

There are numerous widely-used contract standards established to benefit the ecosystem, for example [Fungible
Token](https://developers.flow.com/build/flow.md#flow-token)(FT) and [Non-Fungible
Token](https://developers.flow.com/build/flow#overview)(NFT) standards which are conceptually equivalent to Ethereum's
ERC-20 and ERC-721 standards. Cadence's object-oriented design means standards apply through contract sub-types such as
Resources, Resource interfaces, or other types declared in the contract standard. Standards can define and limit
behaviour and/or set conditions which implementations of the standard cannot violate.

Detailed information about available standards and other core contracts can be found in [Introduction to
Flow](https://developers.flow.com/build/flow.md).

### NFT standard and metadata

Solidity must manage NFT metadata off-chain and NFTs typically link to IPFS JSON from on-chain.

The Cadence NFT standard provides in-built support for metadata with specific types called
[views](https://developers.flow.com/build/flow.md#flow-nft#overview#nft-metadata). Views can be added to NFTs when
minted and will always be available as part of the NFT. While metadata is stored on-chain, graphics and video content
are stored off-chain. Cadence provides [utility
views](https://developers.flow.com/build/flow.md#flow-nft#overview#list-of-common-views) for both HTTP and IPFS based
media storage which remain linked to your NFT.

Using NFT metadata views is a requirement to get listed in the [Flow NFT Catalog](https://www.flow-nft-catalog.com/).
Projects are encouraged leverage the NFT catalog since wallets and other ecosystem partners can seamlessly integrate new
collections added there with no input from project creators.

NFT metadata on Flow opens the door to exciting new possibilities that help builders innovate. Check out this recent
[case study](https://flow.com/post/flovatar-nft-flow-blockchain-case-study) where a community partner leveraged SVG
based metadata to make combined 2D + 3D versions of their PFPs, all on-chain inside the NFTs metadata!

# Security and access control

Decentralized application development places significant focus on security and access and can fairly be described as
security engineering. Understanding how Resources, Capabilities and the account model solve this may not be obvious when
viewed from a Solidity perspective.

## msg.sender considered harmful

The first question that every Solidity developer asks when they start programming in Cadence is:

**"How do I get the account who authorized the transaction?"**

In Ethereum this account is referred to as `msg.sender` and informs the program flow in a function depending on who
authorized it. Doing so is key to access and security, and is the basis of identity and ownership on Ethereum.

Cadence does not have `msg.sender` and there is no transaction-level way for Cadence code to uniquely identify the
calling account. Even if there was a way to access it, Cadence supports [multi-sig](#multi-key-multi-signature-support)
transactions, meaning that a list of all the signers' accounts would be returned, making it impossible to identify a
single authorizer.

<img
     src="https://storage.googleapis.com/flow-resources/documentation-assets/solidity-to-cadence/access-based-security.png"
     width="225" align="right" alt="Solidity access applies to the subject and possessed and validated by the protected
     resource"/>

The reason `msg.sender` is both unsupported and strongly advised against is because Cadence uses Capabilities for access
rather than addresses. The mindset change that developers need to adjust to is that a capability must first be obtained
by the authorizing account (called provider or signer in Cadence) from the contract that will require it, which then
enables the requesting account to access the protected function or Resource. This means the contract never needs to know
who the signer is before proceeding because the capability **IS** the authorization.

<img
     src="https://storage.googleapis.com/flow-resources/documentation-assets/solidity-to-cadence/capability-based-security.png"
     width="245" align="left" alt="In Cadence, the subject must possess the Capability to access the protected
     resource"/>

The [capability-based security](https://en.wikipedia.org/wiki/Capability-based_security) model frames access in the
opposite direction than the [access-based security](https://en.wikipedia.org/wiki/Access-control_list) model.


## Access control using Capabilities

Solidity lacks specific types or other primitives to aid with permission management. Developers have to inline guards to
`require` at every function entry-point, thus validating the `msg.sender` of the transaction.

[Capabilities](./language/capabilities.md) are defined by linking storage paths (namespaces for contract storage) to
protected objects and then making that linked capability available to other accounts.

Any account can get access to an account's public Capabilities. Public capabilities are created using public paths, i.e.
they have the domain `public`. For example, all accounts have a default public capability linked to the
`FlowToken.Vault` Resource. This vault is exposed as a public [unentitled](../docs/language/access-control.md#entitlements)
capability allowing any account to `borrow()` a
reference to the Vault to make a `deposit()`. Since only the unentitled functions defined under the
[`FungibleToken.Vault`](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc#L167) interface are
interface are exposed, the borrower of the vault reference cannot call `withdraw()` since the method requires a `Withdraw` entitled
reference on the underlying vault.

Accounts can share private capabilities but must be specifically issued by the authorizing account. After
[issuing](../docs/language/accounts/capabilities.mdx#issuing-capabilities), they can be obtained from authorised account
objects (`Account`) but not public accounts (`PublicAccount`). To share a private Capability with another account, the
owning account must `publish` it to another account which places in the [account inbox](./language/accounts/inbox.mdx)
(not to be mistaken with `capabilities.publish`). The recipient can later claim the Capability from the account inbox
using then `claim` function.

Public Capabilities can be `unpublished` and any Capability can also be
[revoked](./design-patterns.md#capability-revocation) by the creating account.

To aid automation, events are emitted for `publish`, `claim` and `unpublish` actions completed for a Capability.

Detailed information can be found in [Capabilities](./language/capabilities.md).

## Hygiene factors for protecting value

While capabilities grant account access to a protected resource, it's still necessary to impose controls on value
accessed through them. For example, if your use-case requires delegating access to a `FlowToken.Vault` to `withdraw()`
funds, it's important to limit the amount. Tokens implementing FT/NFT standards are the primary type of value being
exchanged by accounts on Flow. The standard provides the primitives needed to implement capability limiting
best-practices.

### Token isolation

All FTs reside in a `Vault` Resource and each different FT will exist as a separate `Vault` in an account. Similarly,
all NFTs implement a `Collection` Resource, in which those NFTs held by an account for that collection are stored.

Whenever access to the `withdraw()` function has to be delegated to another account, the simplest way to limit how many
tokens of a given type can be withdrawn is to create a new `Vault` Resource for that token type and move a smaller
amount of the tokens in the main token `Vault`. A capability is then linked to that `Vault` instance before being made
available to another account.

A similar pattern can be used for NFTs, where a new `Collection` Resource can be created into which only those NFTs
which should be exposed are moved. A capability is then linked to that `Collection` instance before being made available
to another account.

### Bespoke control strategies

For more complex use-cases one might create a new Resource that implements the relevant interfaces to match those of the
protected Resource(s) which it wraps. The code for the new Resource can then enforce limits as required and control how
and when delegation to the underlying resource occurs. One such example is the community-developed
[`ScopedFTProviders`](https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedFTProviders.cdc) and
[`ScoptedNFTProviders`](https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedNFTProviders.cdc) utility
contracts.

## Admin roles

Compared to Solidity, creating an admin role in Cadence requires a little more code, all of which is encapsulated within
a Resource. The admin object design can be highly customized and employ Capabilities and
[entitlements](../docs/language/access-control.md#entitlements) for fine-grained control such as limiting access to
individual functions, on a per-account basis if required. The complexity needed for admin roles may vary, for example,
larger organizations may require more complex role-based-access schemes. The use of a Resource in this context is key -
the instance can't be copied and the account with the first edition mint of the admin serves as the root-admin. The
admin can be implemented to mint additional admin Resource instances, which only the root-admin can grant to selected
user accounts via a Capability. Conveniently, because the admin role is only accessible via a Capability it's easy to
manage with [Capability Revocation](./design-patterns.md#capability-revocation).

The admin role originates from the [init singleton pattern](./design-patterns.md#init-singleton) and uses the
[Capability Bootstrapping](./design-patterns.md#capability-bootstrapping) pattern for making the Capability available to
other accounts.

An example admin role implementation is available in [Cadence cookbook](https://cookbook.onflow.org/?preview=13).

### Role-based access

Implementing role-based-access can be achieved by defining roles as Resources managed by the root-admin account. Roles
can provide limited access to functions which guard other protected resources, with access levels and/or what is exposed
varying from role to role. The root-admin can grant accounts access to individual roles through a private capability.
Functions that the roles are permitted to invoke may be scoped as `access(contract)` to enforce that they can only be
called by code paths in the root-admin contract.

# Other best practices and conventions

Certain well established best practices for Solidity may not apply or are handled differently.

## Check effects interactions

Solidity contracts must use the [check effect
interaction](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) because functions are public
by default and address-based access means that guards must exist when program flow concedes control to an external
contract. There are two reasons why this is significantly less of a problem in Cadence. Functions are private by default
and the language provides a range of [access scopes](./language/access-control.md). More importantly, 'risks associated
with ceding control to an external contract' is an Ethereum phenomenon; the risk no longer applies. This is primarily
because Cadence contracts are not static singletons, so control is never lost to another contract during the scope of a
transaction.

## Guard Check

Solidity uses `revert`, `require` & `assert` to validate inputs. `require` is a product of the address-based nature of
Solidity which Capabilities replace. `revert` is similar to Cadence's `panic` in that a transaction is aborted. Cadence
provides an `assert` operator which mirrors `assert` in Solidity.

## Modifiers

Modifiers are extensively used in Solidity when enforcing pre-checks within a function. This is a powerful language
feature. However, modifiers can also mutate state which introduces risks to program control flow.

Cadence uses `pre` and `post` blocks to validate input values or the function execution outputs. Notably, `pre` and
`post` block prohibit changing of state and may only enforce conditions.

Another difference is that modifiers in Solidity can be re-used within the contract multiple times. Cadence `pre` &
`post` blocks are associated to individual functions only, reducing the likelihood of errors but which results in a
small amount of code duplication.

## Error handling

Solidity offers try/catch block to handle errors, however, there is presently no equivalent in Cadence.

# Integration differences

## Scripts and transactions

Another major difference between Cadence and Solidity is that deployed contracts are not the only code being executed in
the VM. Cadence offers scripts, of which a subset are transactions, and both permit arbitrary code. Scripts or
transactions are not deployed on-chain and always exist off-chain, however, they are the top-level code payload being
executed by the execution runtime. Clients send scripts and transactions through the Flow Access API gRPC or REST
endpoints, returning results to clients when applicable. Scripts and transactions enable more efficient and powerful
ways to integrate dapps with the underlying blockchain, where contracts can more purely be thought of as services or
components, with scripts or transactions becoming the dapp-specific API interface for chain interactions.

Scripts are read-only in nature, requiring only a `main` function declaration and which perform
[queries](https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance.cdc) against chain state, eg:

```jsx
// This script reads the balance field of an account's ExampleToken Balance
import FungibleToken from "../../contracts/FungibleToken.cdc"
import ExampleToken from "../../contracts/ExampleToken.cdc"

access(all)
fun main(account: Address): UFix64 {
    let acct = getAccount(account)
    let vaultRef = acct.capabilities
        .borrow<&ExampleToken.Vault>(ExampleToken.VaultPublicPath)
        ?? panic("Could not borrow Balance reference to the Vault")

    return vaultRef.balance
}
```

[Transactions](https://github.com/onflow/flow-ft/tree/master/transactions) are an ACID (Atomic, Consistent, Isolated and
Durable) version of scripts having only `prepare` and `execute` functions that either succeed in full and mutate chain
state as described, or otherwise fail and mutate nothing. They also support setting of `pre` and `post` conditions. In
the example transaction below `ExampleToken`s are deposited into multiple `receiver` vaults for each address in the
input map.

```jsx
import FungibleToken from "../contracts/FungibleToken.cdc"
import ExampleToken from "../contracts/ExampleToken.cdc"

/// Transfers tokens to a list of addresses specified in the `addressAmountMap` parameter
transaction(addressAmountMap: {Address: UFix64}) {

    // The Vault resource that holds the tokens that are being transferred
    let vaultRef: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {

        // Get a reference to the signer's stored ExampleToken vault
        self.vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(
            from: ExampleToken.VaultStoragePath
       )     ?? panic("The signer does not store an ExampleToken.Vault object at the path "
                    .concat(ExampleToken.VaultStoragePath.toString())
                    .concat(". The signer must initialize their account with this vault first!"))
    }

    execute {

        for address in addressAmountMap.keys {

            // Withdraw tokens from the signer's stored vault
            let sentVault <- self.vaultRef.withdraw(amount: addressAmountMap[address]!)

            // Get the recipient's public account object
            let recipient = getAccount(address)

            // Get a reference to the recipient's Receiver
            let receiverRef = recipient.capabilities
                .borrow<&{FungibleToken.Receiver}>(ExampleToken.ReceiverPublicPath)
                ?? panic("Could not borrow receiver reference to the recipient's Vault")

            // Deposit the withdrawn tokens in the recipient's receiver
            receiverRef.deposit(from: <-sentVault)

        }
    }
}
```

Transactions can encompass an arbitrary number withdrawals/deposits, across multiple FTs, sending to multiple addresses,
or other more complex variations, all of which will succeed or fail in their entirety given their ACID properties.

## Contract imports and dynamic contract borrowing

Contracts in Ethereum are similar to static singletons in that interactions happen directly between users and the
functions declared on the contract instance itself. The object-oriented nature of Cadence means that contracts are more
accurately viewed as imported dependencies. The imported contract makes its object graph available for the code at
runtime. Rather than interacting with a contract singleton instance, account interactions to access capabilities are the
primary integration entry point, allowing the user to interact with the returned objects.

Dynamic borrowing of a contract inlines the loading of a contract based on its contract address. The loaded contract can
be cast to the contract standard interface to which it conforms to (eg: NFT standard) and then interacted with in the
same way were it statically imported. Consider the implications of this for composability of contracts..

Detailed information about deploying, updating, removing or borrowing contracts can be found in
[Contracts](./language/contracts.mdx)

## Multi-key, multi-signature support

Solidity supports only one kind of multi-signature scheme where n out of m (assuming m >= n) approvals need to be
obtained to execute the transaction from the multi-signature smart contract. The most used multi-signature smart
contract in the Ethereum ecosystem is the gnosis [safe
contract](https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol). However, Solidity lacks support
for signature aggregation or BLS signature schemes.

Cadence offers a wide range of options to implement various multi-signature schemes.

- Inherent support for multi-sign transactions.
- Resource transfer scheme.
- Inherent support of the BLS signature scheme.

Flow account keys have assigned weights, where a 1000 unit weight is the cumulative weight needed from signing keys to
execute a transaction successfully. One can divide weights arbitrarily across multiple keys and distribute those partial
weighted keys to authorized signers. When signing the transaction, all signers must sign the transaction together in a
short period of time in order for the cumulative weight to reach 1000 units.

See [BLS Signature scheme](./language/crypto.mdx#bls-multi-signature) for a detailed overview of the inherent support of
BLS signatures.

### Resource transfer scheme

The main limitation of multi-sig transactions is that signatures must all be made for the transaction within a
relatively short time window. If this window is missed, the transaction will abort. The resource transfer scheme is very
similar to the Solidity multi-signature smart contract. A Resource is created that has the functionality to proxy the
execution of a fund transfer. This Resource is handed from one signer to the next to collect signatures. Once the
threshold of required signatures is met the transaction is executed. The main drawback with this approach is that does
not support execution of arbitrary functionality.

# Other platform differences

The following differences unrelated to implementing Cadence contracts are useful to understand in the context of
application design.

## Events

Flow uses [events](./language/events.md) extensively to provide real-time signals to off-chain systems about particular
actions that occurred during a transaction. The main difference on Flow is that events remain part of the history and
are not purged from storage. Events can be populated with arbitrary data that will assist consumers of the event.
Builders are encouraged to leverage events for seamless UX as users perform transactions.

## Contract upgradeability

Flow supports limited upgradability of Cadence contracts which is most helpful during development. The following
function shows how an account owner can update a contract. Upgrades are analyzed for prohibited changes once uploaded
for upgrade. Upgradeability is still an early phase feature, which will continue to improve over time.

```solidity
fun update(name: String, code: [UInt8]): DeployedContract
```

To enforce immutability once a contract is tested and ready to deploy, account owners can optionally revoke keys from
the account containing the contract.

Detailed information about the cadence upgradeability is available in [Contract
updatability](./language/contract-updatability).

## Account key formulation

In EVM-based chains, an address is derived from a cryptographically generated public key and can have a single private
key, supporting one type of signature curve, i.e. ECDSA. They are not verifiable off-chain and typos/truncation in an
address may result in funds being lost.

Flow account addresses have a special format and are verifiable off-chain. Verifying address format validity can be done
using an error detection algorithm based on linear code. While this does not also confirm that an address is active
on-chain the extra verifiability is a useful safeguard.

## Contract size constraints

Solidity developers will be well aware of the [EIP-170](https://eips.ethereum.org/EIPS/eip-170) deployable contract
bytecode size limit of 24KB. This can burden builders who need to optimize contract bytecode size, sometimes even
requiring a re-design of contracts to break it into smaller contract parts.

By contrast, Cadence has no inherent or defined smart contract size limit. However, it is restricted by the transaction
size limit which is 1.5MB. With very rare exceptions, it’s unlikely that this limit would pose a problem to those
developing Cadence contracts. Should it be needed, there is a known way to deploy a contract exceeding 1.5 MB which we
will document at a later time.

# Low level language differences

## Arithmetic

Historically, Solidity, smart contracts lost millions of dollars because of improper handling of arithmetic
under/overflows. Contemporary Solidity versions offer inbuilt handling of under/overflow for arithmetic operations.

Cadence implements [saturating math](https://en.wikipedia.org/wiki/Saturation_arithmetic) that avoids
overflow/underflow.

## Optional support

[Optional bindings](./language/control-flow.md) provide in-built conditional handling of nil values. Regular data types
in Cadence must always have a value and cannot be nil. Optionals enable variables / constants that might contain a
certain type or a nil value Optionals have two cases: either there is a value, or there is nothing; they fork program
flow similar to `if nil; else; end;`.

## Iterable Dictionaries

Solidity offers the mapping type, however, it is not iterable. Because of that dApp developers have to maintain
off-chain tracking to have access to keys. This also pushes builders to create custom datatypes like `EnumerableMap`
which adds to gas costs.

Cadence offers the [Dictionary](./language/control-flow.md) type, an unordered collection of key-value associations
which is iterable.

## Rich support for type utility functions

Cadence offers numerous native-type utility functions to simplify development. For example, the String type provides:
- utf8
- length
- concat()
- slice()
- split()
- replaceAll()
- join()
- decodeHex()
- encodeHex()
- fromCharacters()
- fromUTF8()
- toLower()

## Argument labelling

Argument labels in Cadence help to disambiguate input values. They make code more readable and explicit. They also
eliminate confusion around the order of arguments when working with the same type. They must be included in the function
call. This restriction can be skipped if the label is preceded by `_ ` on its declaration.

Eg: `fun foo(balance: UFix64)` called as `self.foo(balance: 30.0)`

`fun foo( _balance: UFix64)` can be called as `self.foo(balance: 30.0)` or as `self.foo(30.0)`

One thing to note about argument labelling is that function overloading is not currently supported in Cadence. This
means that functions with the same name but different argument labels are not allowed, a feature which is available in
Solidity.

## Additional resources

- Cadence or Solidity: [On-Chain Token Transfer Deep
  Dive](https://flow.com/engineering-blogs/flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum)
- Implementing the [Bored Ape Yacht
  Club](https://flow.com/post/implementing-the-bored-ape-yacht-club-smart-contract-in-cadence) smart contract in Cadence
- Quicknode's Account Abstraction on the Flow Blockchain: [Comparing AA on Ethereum vs
  Flow](https://www.quicknode.com/guides/other-chains/flow/account-abstraction-on-flow#account-abstraction-on-ethereum-vs-flow)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/07-marketplace-setup.md

---
title: 7. Marketplace Setup
---

:::warning

We're in the process of updating the Cadence tutorial series.  This tutorial, and the ones following, have **not** yet been updated.

Check back, or follow us on socials.  These will be updated soon!

:::

In this tutorial, we're going to create a marketplace that uses both the fungible
and non-fungible token (NFTs) contracts that we have learned about in previous tutorials.
This page requires you to execute a series of transactions to setup your accounts to complete the Marketplace tutorial.
The next page contains the main content of the tutorial.

When you are done with the tutorial, check out the [NFTStorefront repo](https://github.com/onflow/nft-storefront)
for an example of a production ready marketplace that you can use right now on testnet or mainnet!

---

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:
<a
  href="https://play.flow.com/7355d51c-066b-46be-adab-a3da6c28b645"
  target="_blank"
>
  https://play.flow.com/7355d51c-066b-46be-adab-a3da6c28b645
</a>
The tutorial will be asking you to take various actions to interact with this code.

:::

If you have already completed the Marketplace tutorial, please move on to [Composable Resources: Kitty Hats](./10-resources-compose.md).

This guide will help you quickly get the playground to the state you need to complete the Marketplace tutorial.
The marketplace tutorial uses the Fungible Token and Non-Fungible token contracts
to allow users to buy and sell NFTs with fungible tokens.

---

:::info[Action]

Some of the code in these setup instructions has intentional errors built into it.
You should understand enough about Cadence to be able to fix these tutorials on your own.
All of the errors involve concepts that you have learned in previous tutorials

:::

1. Open the `ExampleToken` contract. This is the same contract from the fungible token tutorial.
2. Deploy the `ExampleToken` code to account `0x06`.
3. Switch to the `ExampleNFT` contract (Contract 2)
4. Deploy the NFT code to account `0x07` by selecting it as the deploying signer.
5. Run the transaction in "Setup 6". This is the `SetupAccount6Transaction.cdc` file.
   Use account `0x06` as the only signer to set up account `0x06`'s storage.

```cadence SetupAccount6Transaction.cdc
// SetupAccount6Transaction.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07

// This transaction sets up account 0x06 for the marketplace tutorial
// by publishing a Vault reference and creating an empty NFT Collection.
transaction {
  prepare(acct: auth(SaveValue) &Account) {
        // Create a public Receiver capability to the Vault
    let receiverCap = acct.capabilities.storage.issue<&{ExampleToken.Receiver}>(
        /storage/CadenceFungibleTokenTutorialVault
    )
    acct.capabilities.publish(receiverCap, at: /public/CadenceFungibleTokenTutorialReceiver)

    // store the empty NFT Collection in account storage
    acct.storage.save(<-ExampleNFT.createEmptyCollection(nftType: nil), to: ExampleNFT.CollectionStoragePath)

    log("Collection created for account 2")

    // create a public capability for the Collection
    let cap = acct.capabilities.storage.issue<&ExampleNFT.Collection>(ExampleNFT.CollectionStoragePath)
    acct.capabilities.publish(cap, at: ExampleNFT.CollectionStoragePath)
  }
}
```

7. Run the second transaction, "Setup 7". This is the `SetupAccount7Transaction.cdc` file.
Use account `0x07` as the only signer to set up account `0x07`'s storage.

```cadence SetupAccount7Transaction.cdc
// SetupAccount7Transaction.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07

// This transaction adds an empty Vault to account 0x07
// and mints an NFT with id=1 that is deposited into
// the NFT collection on account 0x06.
transaction {

  // Private reference to this account's minter resource
  let minterRef: &ExampleNFT.NFTMinter

  prepare(acct: auth(BorrowValue, SaveValue, StorageCapabilities, PublishCapability) &Account) {
    // create a new vault instance
    let vaultA <- ExampleToken.createEmptyVault()

    // Store the vault in the account storage
    acct.storage.save(<-vaultA, to: ExampleToken.VaultStoragePath)

    // Create a public Receiver capability to the Vault
    let receiverCap = acct.capabilities.storage.issue<&ExampleToken.Vault>(
        ExampleToken.VaultStoragePath
    )
    acct.capabilities.publish(receiverCap, at: ExampleToken.VaultPublicPath)
  }
  execute {
    // Get the recipient's public account object
    let recipient = getAccount(0x06)

    // Get the Collection reference for the receiver
    // getting the public capability and borrowing a reference from it
    let receiverRef = recipient.capabilities
        .borrow<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)
        ?? panic("Could not borrow a collection reference to 0x06's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x06 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    // Mint an NFT and deposit it into account 0x06's collection
    receiverRef.deposit(token: <-ExampleNFT.mintNFT())
  }
}
```

8. Run the transaction in "Setup 6". This is the `SetupAccount6TransactionMinting.cdc` file.
   Use account `0x06` as the only signer to mint fungible tokens for account 6 and 7.

```cadence SetupAccount6TransactionMinting.cdc
// SetupAccount6TransactionMinting.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07

// This transaction mints tokens for both accounts using
// the minter stored on account 0x06.
transaction {

  // Public Vault Receiver References for both accounts
  let acct6Capability: Capability<&{ExampleToken.Receiver}>
  let acct7Capability: Capability<&{ExampleToken.Receiver}>

  // Private minter references for this account to mint tokens
  let minterRef: &ExampleToken.VaultMinter

  prepare(acct: auth(SaveValue, StorageCapabilities, BorrowValue) &Account) {
    // Get the public object for account 0x07
    let account7 = getAccount(0x07)

    // Retrieve public Vault Receiver references for both accounts
    self.acct6Capability = acct.capabilities.get<&{ExampleToken.Receiver}>(/public/CadenceFungibleTokenTutorialReceiver)
    self.acct7Capability = account7.capabilities.get<&{ExampleToken.Receiver}>(/public/CadenceFungibleTokenTutorialReceiver)

    // Get the stored Minter reference for account 0x06
    self.minterRef = acct.storage.borrow<&ExampleToken.VaultMinter>(from: /storage/CadenceFungibleTokenTutorialMinter)
        ?? panic("Could not borrow owner's vault minter reference")
  }

  execute {
    // Mint tokens for both accounts
    self.minterRef.mintTokens(amount: 20.0, recipient: self.acct7Capability)
    self.minterRef.mintTokens(amount: 10.0, recipient: self.acct6Capability)
  }
}
```

9. Run the script `CheckSetupScript.cdc` file in Script 1 to ensure everything is set up.

```cadence CheckSetupScript.cdc
// CheckSetupScript.cdc

import ExampleToken from 0x06
import ExampleNFT from 0x07

/// Allows the script to return the ownership info
/// of all the accounts
access(all) struct OwnerInfo {
  access(all) let acct6Balance: UFix64
  access(all) let acct7Balance: UFix64

  access(all) let acct6IDs: [UInt64]
  access(all) let acct7IDs: [UInt64]

  init(balance1: UFix64, balance2: UFix64, acct6IDs: [UInt64], acct7IDs: [UInt64]) {
    self.acct6Balance = balance1
    self.acct7Balance = balance2
    self.acct6IDs = acct6IDs
    self.acct7IDs = acct7IDs
  }
}

// This script checks that the accounts are set up correctly for the marketplace tutorial.
//
// Account 0x06: Vault Balance = 40, NFT.id = 1
// Account 0x07: Vault Balance = 20, No NFTs
access(all) fun main(): OwnerInfo {
    // Get the accounts' public account objects
    let acct6 = getAccount(0x06)
    let acct7 = getAccount(0x07)

    // Get references to the account's receivers
    // by getting their public capability
    // and borrowing a reference from the capability
    let acct6ReceiverRef = acct6.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x06's ExampleToken.Vault")
                     .concat(". Make sure 0x06 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let acct7ReceiverRef = acct7.capabilities.get<&{ExampleToken.Balance}>
                          (/public/CadenceFungibleTokenTutorialReceiver)
                          .borrow()
            ?? panic("Could not borrow a balance reference to "
                     .concat("0x07's ExampleToken.Vault")
                     .concat(". Make sure 0x07 has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

    let returnArray: [UFix64] = []

    // verify that the balances are correct
    if acct6ReceiverRef.balance != 40.0 || acct7ReceiverRef.balance != 20.0 {
        panic("Wrong balances!")
    }

    // Find the public Receiver capability for their Collections
    let acct6Capability = acct6.capabilities.get<&{ExampleNFT.NFTReceiver}>(ExampleNFT.CollectionPublicPath)
    let acct7Capability = acct7.capabilities.get<&{ExampleNFT.NFTReceiver}>(ExampleNFT.CollectionPublicPath)

    // borrow references from the capabilities
    let nft1Ref = acct6Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x06's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x06 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    let nft2Ref = acct7Capability.borrow()
        ?? panic("Could not borrow a collection reference to 0x07's ExampleNFT.Collection"
                 .concat(" from the path ")
                 .concat(ExampleNFT.CollectionPublicPath.toString())
                 .concat(". Make sure account 0x07 has set up its account ")
                 .concat("with an ExampleNFT Collection."))

    // verify that the collections are correct
    if nft1Ref.getIDs()[0] != 1 || nft2Ref.getIDs().length != 0 {
        panic("Wrong Collections!")
    }

    // Return the struct that shows the account ownership info
    return OwnerInfo(balance1: acct6ReceiverRef.balance,
                     balance2: acct7ReceiverRef.balance,
                     acct6IDs: nft1Ref.getIDs(),
                     acct7IDs: nft2Ref.getIDs())
}
```

10. The script should not panic and you should see something like this output

```
"Account 6 Balance"
40.00000000
"Account 7 Balance"
20.00000000
"Account 6 NFTs"
[1]
"Account 7 NFTs"
[]
```

---

With your playground now in the correct state, you're ready to continue with the next tutorial.

You do not need to open a new playground session for the marketplace tutorial. You can just continue using this one.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/05-non-fungible-tokens-1.md

---
archived: false
draft: false
title: Basic NFT
description: An introduction to a simplified version of NFTs on Cadence.
date: 2024-09-17
meta:
  keywords:
    - tutorial
    - Flow
    - NFT
    - Non-Fungible Tokens
    - Cadence
    - Resources
    - Capabilities
tags:
  - reference
  - NFT
  - Non-Fungible Token
  - cadence
  - tutorial
socialImageTitle: Non-Fungible Tokens in Cadence
socialImageDescription: NFT social image.
---

In this tutorial, we're going to deploy, store, and transfer **Non-Fungible Tokens (NFTs)**.  The NFT is an integral part of blockchain technology. An NFT is a digital asset that represents ownership of something unique and indivisible.  Unlike fungible tokens, which operate more like money, you can't divide an NFT, and the owner is likely to be upset if you were to swap one for another without their consent. Examples of NFTs include: [CryptoKitties], [Top Shot Moments], tickets to a really fun concert, or even real property such as a horse or a house!

Production-quality NFTs on Flow implement the [Flow NFT Standard], which defines a basic set of properties for NFTs on Flow.

This tutorial will teach you a basic method of creating simple NFTs to illustrate important language concepts, but will not use the full NFT Standard for the sake of simplicity.

:::tip

If you're already comfortable with Cadence and have found this page looking for information on how to build production-ready NFTs, check out the [NFT Guide] and [Flow NFT Standard] repository.

:::

## Objectives

After completing this tutorial, you'll be able to:

* Deploy a basic NFT contract and type definitions.
* Create an NFT object and store it in a user's account storage.
* Write a transaction to mint an NFT and create a capability so others can view it.
* Transfer an NFT from one account to another.
* Use a script to see if an NFT is stored in an account.
* Implement and utilize a dictionary in Cadence.

## NFTs on Cadence

Instead of being represented in a central ledger, like in most smart contract languages, Cadence represents each NFT as a **[resource] object that users store in their accounts**. This strategy is a response to the lessons learned by the Flow team (the Chief Architect of Flow is the original proposer and co-author of the [ERC-721 NFT standard]).

It allows NFTs to benefit from the resource ownership rules that are enforced by the [type system] - resources can only have a single owner, they cannot be duplicated, and they cannot be lost due to accidental or malicious programming errors. These protections ensure that owners know that their NFT is safe and can represent an asset that has real value, and helps prevent developers from breaking this trust with easy-to-make programming mistakes.

When users on Flow want to transact with each other, they can do so peer-to-peer, without having to interact with a central NFT contract, by calling resource-defined methods in both users' accounts.

NFTs in a real-world context make it possible to trade assets and prove who the owner of an asset is. On Flow, NFTs are interoperable - so the NFTs in an account can be used in different smart contracts and app contexts.

## The Simplest Possible NFT

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:

<a href="https://play.flow.com/ea3aadb6-1ce6-4734-9792-e8fd334af7dc"
  target="_blank">
  https://play.flow.com/ea3aadb6-1ce6-4734-9792-e8fd334af7dc
</a>

:::

At the core, NFTs are simply a way to create true ownership of unique digital property. The simplest possible implementation is a resource with a unique id number.

:::info[Action]

Implement a simple NFT by creating a [resource] with a constant `id` that is assigned in `init`.  The `id` should be public.

:::

```cadence
access(all) resource NFT {

    access(all) let id: UInt64

    init(initID: UInt64) {
        self.id = initID
    }
}
```

### Adding Basic Metadata

An NFT is also usually expected to include some metadata like a name, description, traits, or a picture. Historically, most of this metadata has been stored off-chain, and the on-chain token only contains a URL or something similar that points to the off-chain metadata.

In Flow, this is possible, but you can and normally should store all the metadata associated with a token directly on-chain.  Unlike many other blockchain networks, **you do not need to consider string storage or manipulation as particularly expensive.**

:::tip

This tutorial will stick to a simplified implementation.  Check out the [the NFT metadata guide] if you want to learn how to do this in production.

:::

:::info[Action]

Add a public `metadata` variable to your NFT.  For now, it can be a simple `String` to `String` [dictionary].  Update the `init` to also initialize a `description` in your metadata.

:::

It should now look similar to:

```cadence
access(all) resource NFT {
    access(all) let id: UInt64
    access(all) var metadata: {String: String}

    init(initID: UInt64, initDescription: String) {
        self.id = initID
        self.metadata = {"description": initDescription}
    }
}
```

### Creating the NFT

As with any complex type in any language, now that you've created the definition for the type, you need to add a way to instantiate new instances of that type - these instances are the NFTs.  This simple NFT type must be initialized with an id number and a `String` description.

Traditionally, NFTs are provided with id numbers that indicate the order in which they were minted.  To handle this, you can use a simple counter.

:::info[Action]

First, add a public, contract-level field to keep track of the last assigned id number.

:::

```cadence
access(contract) var counter: UInt64
```

You're going to immediately get an error in the editor with `counter`.  Contract-level fields must be initialized in the `init` function.

:::info[Action]

Add an `init` function to the `BasicNFT` contract and initialize `counter` to zero.

:::

```cadence
init() {
    self.counter = 0
}
```

:::info[Action]

Next, add a public function to increment the counter and `create` and `return` an `NFT` with a provided description.

:::

:::warning

We're creating a **public** function that allows **anyone** to provide **any** string.  Take care when building real apps that will be exposed to humanity.

:::

```cadence
access(all) fun mintNFT(description: String): @NFT {
    self.counter = self.counter + 1
    return <- create NFT(initID: self.counter, initDescription: description)
}
```

Remember, when you work with a [resource], you must use the [move operator] (`<-`) to **move** it from one location to another.

## Adding an NFT Your Account

You've gone through the trouble of creating this NFT contract - you deserve the first NFT!  

:::info[Action]

Protect yourself from snipers by updating the `init` function to give yourself the first `NFT`.  You'll need to mint it and save it to your account storage. 

:::

```cadence
self
    .account
    .storage
    .save(<-self.mintNFT(description: "First one for me!"), to: /storage/BasicNFTPath)
```

### NFT Capability

Saving the NFT to your account will give you one, but it will be locked away where no apps can see or access it.  You've just learned how to create capabilities in the previous tutorial.  You can use the same techniques here to create a capability to give others the ability to access the NFT.

:::warning

In Cadence, users own and control their data.  A user can destroy a capability such as this whenever they choose.  If you want complete control over NFTs or other data, you'd need to store it directly in the contract.

Most of the time, you probably won't want to do this because it will limit what your users can do with their own property without your permission.  You don't want to end up in a situation where your users would buy more of your umbrellas to use for shade on sunny days, except you've made it so that they only open when it's raining.

:::

Cadence contracts are deployed to the account of the deployer.  As a result, the contract is in the deployer's storage, and the contract itself has read and write access to the storage of the account that they are deployed to by using the built-in [`self.account`] field. This is an [account reference] (`&Account`), authorized and entitled to access and manage all aspects of the account, such as account storage, capabilities, keys, and contracts.

You can access any of the account functions with `self.account`.

:::info[Action]

Update the `init` function to create and publish a [capability] allowing public access to the NFT.

:::

```cadence
let capability = self
    .account
    .capabilities
    .storage
    .issue<&NFT>(/storage/BasicNFTPath)

self
    .account
    .capabilities
    .publish(capability, at: /public/BasicNFTPath)
```

:::danger

The capability you are creating gives everyone full access to all properties of the resource.  It does **not** allow other users or developers to move or destroy the resource and is thus harmless.

However, if the resource contained functions to mutate data within the token, this capability would **allow anyone to call it and mutate the data!**

:::

You might be tempted to add this code to to `mintNFT` so that you can reuse it for anyone who wants to mint the NFT and automatically create the related capability.

The code will work, but it will **not** function the way you're probably expecting it to.  In the context of being called from a function inside a contract, `self.account` refers to the account of the contract deployer, not the caller of the function.  That's you!

Adding `self.account.save` or `self.account.publish` to `mintNFT` will allow anyone to attempt to mint and publish capabilities to **your** account, so don't do it!

:::danger

Passing a [fully-authorized account reference] as a function parameter is a dangerous anti-pattern.

::::

### Deploy and Test

:::info[Action]

Deploy the contract and check the storage for account `0x06`.

:::

You'll be able to find your NFT in the storage for `0x06`:

```text
"value": {
    "value": {
        "id": "A.0000000000000006.BasicNFT.NFT",
        "fields": [
            {
                "value": {
                    "value": "41781441855488",
                    "type": "UInt64"
                },
                "name": "uuid"
            },
            {
                "value": {
                    "value": "1",
                    "type": "UInt64"
                },
                "name": "id"
            },
            {
                "value": {
                    "value": [
                        {
                            "key": {
                                "value": "description",
                                "type": "String"
                            },
                            "value": {
                                "value": "First one for me!",
                                "type": "String"
                            }
                        }
                    ],
                    "type": "Dictionary"
                },
                "name": "metadata"
            }
        ]
    },
    "type": "Resource"
}
```

## Get the Number of an NFT Owned by a User

We can see the NFT from the storage view for each account, but it's much more useful to write a script or transaction that can do that for any account.  You can follow a similar technique as the last tutorial and create a script to use the capability.

:::info[Action]

Add a script called `GetNFTNumber` that returns the id number of the nft owned by an address.  It should accept the `Address` of the account you wish to check as an argument

:::

Try to do this on your own.  You should end up with something similar to:


```cadence
import BasicNFT from 0x06

access(all) fun main(address: Address): UInt64 {
  let account = getAccount(address)

  let nftReference = account
    .capabilities
    .borrow<&BasicNFT.NFT>(/public/BasicNFTPath)
    ?? panic("Could not borrow a reference\n")

    return nftReference.id
}
```


## Minting With a Transaction

You usually don't want a contract with just one NFT given to the account holder.  One strategy is to allow anyone who wants to mint an NFT.  To do this, you can simply create a transaction that calls the `mintNFT` function you added to your contract, and adds the capability for others to view the NFT.

:::info[Action]

Create a transaction called `MintNFT.cdc` that mints an NFT for the caller with the `description` they provide.  You'll need entitlements to borrow values, save values, and issue and publish capabilities.

First, verify that the NFT isn't already stored in the location used by the contract.

:::

```cadence MintNFT.cdc
import BasicNFT from 0x06

transaction {
    prepare(acct: auth(
        BorrowValue,
        SaveValue,
        IssueStorageCapabilityController,
        PublishCapability
        ) &Account) {
        if acct.storage.borrow<&BasicNFT.NFT>(from: /storage/BasicNFTPath) != nil {
            panic("This user has a token already!")
        }
        // TODO
    }
}
```

:::info[Action]

Next, use the `mintNFT` function to create an NFT, then save than NFT in the user's account storage.

:::


```cadence
account.storage
    .save(<-BasicNFT.mintNFT(description: "Hi there!"), to: /storage/BasicNFTPath)
```

:::info[Action]

Finally, create and publish a capability to access the NFT.

:::

```cadence
let capability = account
    .capabilities
    .storage
    .issue<&BasicNFT.NFT>(/storage/BasicNFTPath)

account
    .capabilities
    .publish(capability, at: /public/BasicNFTPath)
```

:::info[Action]

Call the `MintNFT` transaction from account `0x06`

:::

It will fail because you minted an NFT with `0x06` when you deployed the contract.

:::info[Action]

Now, call `MintNFT` from account `0x07`.  Then, `Execute` the `GetNFTNumber` script for account `0x07`.

:::

You'll see the NFT number `2` returned in the log.


## Performing a Basic Transfer

Users, independently or with the help of other developers, have the inherent ability to delete or transfer any resources in their accounts, including those created by your contracts.

:::info[Action]

Open the `Basic Transfer` transaction.

:::

We've stubbed out the beginnings of a transfer transaction for you.  Note that we're preparing account references for not one, but **two** accounts - the sender and the recipient.

```cadence Basic Transfer.cdc
import BasicNFT from 0x06

transaction {
    prepare(
        signer1: auth(LoadValue) &Account,
        signer2: auth(SaveValue) &Account
    ) {
        // TODO
    }
}
```

While a transaction is open, you can select one or more accounts to sign a transaction. This is because, in Flow, multiple accounts can sign the same transaction, giving access to their private storage.


:::info[Action]

Write a transaction to execute the transfer. You'll need to `load()` the NFT from `signer1`'s storage and `save()` it into `signer2`'s storage.

:::


```cadence
import BasicNFT from 0x06

transaction {
    prepare(
        signer1: auth(LoadValue) &Account,
        signer2: auth(SaveValue) &Account
    ) {
        let nft <- signer1.storage.load<@BasicNFT.NFT>(from: /storage/BasicNFTPath)
            ?? panic("Could not load NFT from the first signer's storage")

        // WARNING:  Incomplete code, see below
        signer2.storage.save(<-nft, to: /storage/BasicNFTPath)
    }
}
```

:::info[Action]

Select both account `0x06` and account `0x08` as the signers. Make sure account `0x06` is the first signer.

Click the "Send" button to send the transaction.

Verify the NFT is in account storage for account `0x08`.

:::

What about using your nifty script to check if a user has an NFT?


:::info[Action]

Run `GetNFTNumber` to check account `0x08`.

:::

**You'll get an error here.**  The reason is that you haven't created or published a capability on account `0x08`.  You can do this as a part of your transaction, but remember that it isn't required.  Another dev, or sophisticated user, could do the transfer **without** publishing a capability.

:::info[Action]

On your own, refactor your transaction to publish a capability in the new owner's account.

You're also not making sure that the recipient doesn't already have an NFT in the storage location, so go ahead and add that check as well.

:::

### Capabilities Referencing Moved Objects

What about the capability you published for account `0x06` to access the NFT?  What happens to that?

:::info[Action]

Run `GetNFTNumber` for account `0x06`. 

:::

**You'll get an error** here as well, but this is expected.  Capabilities that reference an object in storage return `nil` if that storage path is empty.

:::danger

The capability itself is not deleted.  If you move an object of the same type back to the storage location reference by the capability, the capability **will** function again.

:::

## Reviewing Basic NFTs

In this tutorial, you learned how to create a basic NFT with minimal functionality.  Your NFT can be held, viewed, and transferred, though it does **not** adhere to the official standard, doesn't allow anyone to own more than one, and is missing other features.

Now that you have completed the tutorial, you should be able to:

* Deploy a basic NFT contract and type definitions.
* Create an NFT object and store it in a user's account storage.
* Write a transaction to mint an NFT and create a capability so others can view it.
* Transfer an NFT from one account to another.
* Use a script to see if an NFT is stored in an account.

In the next tutorial, you'll learn how to make more complete NFTs that allow each user to possess many NFTs from your collection.

---

<!-- Reference-style links, does not render on page -->

[NFT Guide]: https://developers.flow.com/build/guides/nft
[CryptoKitties]: https://www.cryptokitties.co/
[Top Shot Moments]: https://nbatopshot.com/
[resource]: ../language/resources.mdx
[ERC-721 NFT standard]: https://github.com/ethereum/eips/issues/721
[type system]: ../language/values-and-types.mdx
[Flow NFT Standard]: https://github.com/onflow/flow-nft
[the NFT metadata guide]: https://developers.flow.com/build/advanced-concepts/metadata-views
[dictionary]: ../language/values-and-types.mdx#dictionary-types
[move operator]: ../language/operators.md#move-operator--
[`self.account`]: ../language/contracts.mdx
[account reference]: ../language/accounts/index.mdx
[capability]: ../language/capabilities.md
[fully-authorized account reference]: ../anti-patterns.md#avoid-using-fully-authorized-account-references-as-a-function-parameter




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/operators.md

---
title: Operators
sidebar_position: 5
---

Operators are special symbols that perform a computation
for one or more values.
They are either unary, binary, or ternary.

- Unary operators perform an operation for a single value.
  The unary operator symbol appears before the value.

- Binary operators operate on two values.
    The binary operator symbol appears between the two values (infix).

- Ternary operators operate on three values.
  The first operator symbol appears between the first and second value,
  the second operator symbol appears between the second and third value (infix).

## Assignment Operator (`=`)

The binary assignment operator `=` can be used
to assign a new value to a variable.
It is only allowed in a statement and is not allowed in expressions.

```cadence
var a = 1
a = 2
// `a` is `2`


var b = 3
var c = 4

// Invalid: The assignment operation cannot be used in an expression.
a = b = c

// Instead, the intended assignment must be written in multiple statements.
b = c
a = b
```

Assignments to constants are invalid.

```cadence
let a = 1
// Invalid: Assignments are only for variables, not constants.
a = 2
```

The left-hand side of the assignment operand must be an identifier.
For arrays and dictionaries, this identifier can be followed
by one or more index or access expressions.

```cadence
// Declare an array of integers.
let numbers = [1, 2]

// Change the first element of the array.
//
numbers[0] = 3

// `numbers` is `[3, 2]`
```

```cadence
// Declare an array of arrays of integers.
let arrays = [[1, 2], [3, 4]]

// Change the first element in the second array
//
arrays[1][0] = 5

// `arrays` is `[[1, 2], [5, 4]]`
```

```cadence
let dictionaries = {
  true: {1: 2},
  false: {3: 4}
}

dictionaries[false][3] = 0

// `dictionaries` is `{
//   true: {1: 2},
//   false: {3: 0}
//}`
```

## Move Operator (`<-`)

The move operator (`<-`) is unique to Cadence and is used to move [resource types](./resources.mdx) from one location to another.  It works similar to the assignment operator (`=`) you're used to from most programming languages, except that the data in the location on the right side of the statement is **destroyed** by the operation.

```cadence
// Declare a resource named `SomeResource`, with a variable integer field.

access(all)
resource SomeResource {
    
    access(all)
    var value: Int

    init(value: Int) {
        self.value = value
    }
}

// Declare a constant with value of resource type `SomeResource`.

let a: @SomeResource <- create SomeResource(value: 5)

// *Move* the resource value to a new constant.

let b <- a

// Invalid Line Below: Cannot use constant `a` anymore as the resource that it
// referred to was moved to constant `b`.

a.value

// Constant `b` owns the resource.

b.value // equals 5
```

## Force-assignment Operator (`<-!`)

The force-assignment operator (`<-!`) assigns a resource-typed value
to an optional-typed variable if the variable is nil.
If the variable being assigned to is non-nil,
the execution of the program aborts.

The force-assignment operator is only used for [resource types](./resources.mdx).

## Swapping Operator (`<->`)

The binary swap operator `<->` can be used
to exchange the values of two variables.
It is only allowed in a statement and is not allowed in expressions.

```cadence
var a = 1
var b = 2
a <-> b
// `a` is `2`
// `b` is `1`

var c = 3

// Invalid: The swap operation cannot be used in an expression.
a <-> b <-> c

// Instead, the intended swap must be written in multiple statements.
b <-> c
a <-> b
```

Both sides of the swap operation must be variable,
assignment to constants is invalid.

```cadence
var a = 1
let b = 2

// Invalid: Swapping is only possible for variables, not constants.
a <-> b
```

Both sides of the swap operation must be an identifier,
followed by one or more index or access expressions.

## Arithmetic Operators

The unary pefix operator  `-` negates an integer:

```cadence
let a = 1
-a  // is `-1`
```

There are four binary arithmetic operators:

- Addition: `+`
- Subtraction: `-`
- Multiplication: `*`
- Division: `/`
- Remainder: `%`

```cadence
let a = 1 + 2
// `a` is `3`
```

The arguments for the operators need to be of the same type.
The result is always the same type as the arguments.

The division and remainder operators abort the program when the divisor is zero.

Arithmetic operations on the signed integer types
`Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `Int256`,
and on the unsigned integer types
`UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128`, `UInt256`,
do not cause values to overflow or underflow.

```cadence
let a: UInt8 = 255

// Run-time error: The result `256` does not fit in the range of `UInt8`,
// thus a fatal overflow error is raised and the program aborts
//
let b = a + 1
```

```cadence
let a: Int8 = 100
let b: Int8 = 100

// Run-time error: The result `10000` does not fit in the range of `Int8`,
// thus a fatal overflow error is raised and the program aborts
//
let c = a * b
```

```cadence
let a: Int8 = -128

// Run-time error: The result `128` does not fit in the range of `Int8`,
// thus a fatal overflow error is raised and the program aborts
//
let b = -a
```

Arithmetic operations on the unsigned integer types
`Word8`, `Word16`, `Word32`, `Word64`
may cause values to overflow or underflow.

For example, the maximum value of an unsigned 8-bit integer is 255 (binary 11111111).
Adding 1 results in an overflow, truncation to 8 bits, and the value 0.

```cadence
//    11111111 = 255
// +         1
// = 100000000 = 0
```

```cadence
let a: Word8 = 255
a + 1 // is `0`
```

Similarly, for the minimum value 0,
subtracting 1 wraps around and results in the maximum value 255.

```cadence
//    00000000
// -         1
// =  11111111 = 255
```

```cadence
let b: Word8 = 0
b - 1  // is `255`
```

### Arithmetics on number super-types

Arithmetic operators are not supported for number supertypes
(`Number`, `SignedNumber`, `FixedPoint`, `SignedFixedPoint`, `Integer`, `SignedInteger`),
as they may or may not succeed at run-time.

```cadence
let x: Integer = 3 as Int8
let y: Integer = 4 as Int8

let z: Integer = x + y    // Static error
```

Values of these types need to be cast to the desired type before performing the arithmetic operation.

```cadence
let z: Integer = (x as! Int8) + (y as! Int8)
```

## Logical Operators

Logical operators work with the boolean values `true` and `false`.

- Logical NOT: `!a`

  This unary prefix operator logically negates a boolean:

  ```cadence
  let a = true
  !a  // is `false`
  ```

- Logical AND: `a && b`

  ```cadence
  true && true  // is `true`

  true && false  // is `false`

  false && true  // is `false`

  false && false  // is `false`
  ```

  If the left-hand side is false, the right-hand side is not evaluated.

- Logical OR: `a || b`

  ```cadence
  true || true  // is `true`

  true || false  // is `true`

  false || true  // is `true`

  false || false // is `false`
  ```

  If the left-hand side is true, the right-hand side is not evaluated.

## Comparison Operators

Comparison operators work with boolean and integer values.

- Equality: `==`, is supported for booleans, numbers, addresses, strings, characters, enums, paths, `Type` values, references, and `Void` values (`()`). Variable-sized arrays, fixed-size arrays, dictionaries, and optionals also support equality tests if their inner types do.

  Both sides of the equality operator may be optional, even of different levels,
  so it is for example possible to compare a non-optional with a double-optional (`??`).

  ```cadence
  1 == 1  // is `true`

  1 == 2  // is `false`
  ```

  ```cadence
  true == true  // is `true`

  true == false  // is `false`
  ```

  ```cadence
  let x: Int? = 1
  x == nil  // is `false`
  ```

  ```cadence
  let x: Int = 1
  x == nil  // is `false`
  ```

  ```cadence
  // Comparisons of different levels of optionals are possible.
  let x: Int? = 2
  let y: Int?? = nil
  x == y  // is `false`
  ```

  ```cadence
  // Comparisons of different levels of optionals are possible.
  let x: Int? = 2
  let y: Int?? = 2
  x == y  // is `true`
  ```

  ```cadence
  // Equality tests of arrays are possible if their inner types are equatable.
  let xs: [Int] = [1, 2, 3]
  let ys: [Int] = [1, 2, 3]
  xs == ys // is `true`

  let xss: [[Int]] = [xs, xs, xs]
  let yss: [[Int]] = [ys, ys, ys]
  xss == yss // is `true`
  ```

  ```cadence
  // Equality also applies to fixed-size arrays. If their lengths differ, the result is a type error.
  let xs: [Int; 2] = [1, 2]
  let ys: [Int; 2] = [0 + 1, 1 + 1]
  xs == ys // is `true`
  ```

  ```cadence
  // Equality tests of dictionaries are possible if the key and value types are equatable.
  let d1 = {"abc": 1, "def": 2}
  let d2 = {"abc": 1, "def": 2}
  d1 == d2 // is `true`

  let d3 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}
  let d4 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}
  d3 == d4 // is `true`
  ```

- Inequality: `!=`, is supported for booleans, numbers, addresses, strings, characters, enums, paths, `Type` values, references, and `Void` values (`()`).
  Variable-sized arrays, fixed-size arrays, dictionaries, and optionals also support inequality tests if their inner types do.

  Both sides of the inequality operator may be optional, even of different levels,
  so it is for example possible to compare a non-optional with a double-optional (`??`).

  ```cadence
  1 != 1  // is `false`

  1 != 2  // is `true`
  ```

  ```cadence
  true != true  // is `false`

  true != false  // is `true`
  ```

  ```cadence
  let x: Int? = 1
  x != nil  // is `true`
  ```

  ```cadence
  let x: Int = 1
  x != nil  // is `true`
  ```

  ```cadence
  // Comparisons of different levels of optionals are possible.
  let x: Int? = 2
  let y: Int?? = nil
  x != y  // is `true`
  ```

  ```cadence
  // Comparisons of different levels of optionals are possible.
  let x: Int? = 2
  let y: Int?? = 2
  x != y  // is `false`
  ```

  ```cadence
  // Inequality tests of arrays are possible if their inner types are equatable.
  let xs: [Int] = [1, 2, 3]
  let ys: [Int] = [4, 5, 6]
  xs != ys // is `true`
  ```

  ```cadence
  // Inequality also applies to fixed-size arrays. If their lengths differ, the result is a type error.
  let xs: [Int; 2] = [1, 2]
  let ys: [Int; 2] = [1, 2]
  xs != ys // is `false`
  ```

  ```cadence
  // Inequality tests of dictionaries are possible if the key and value types are equatable.
  let d1 = {"abc": 1, "def": 2}
  let d2 = {"abc": 1, "def": 500}
  d1 != d2 // is `true`

  let d3 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}
  let d4 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}
  d3 != d4 // is `false`
  ```

- Less than: `<`, for integers, booleans, characters and strings

  ```cadence
  1 < 1  // is `false`

  1 < 2  // is `true`

  2 < 1  // is `false`

  false < true // is `true`

  true < true  // is `false`

  "a" < "b"    // is `true`

  "z" < "a"    // is `false`

  "a" < "A"    // is `false`

  "" < ""      // is `false`

  "" < "a"     // is `true`

  "az" < "b"   // is `true`

  "xAB" < "Xab"  // is `false`
  ```

- Less or equal than: `<=`, for integers, booleans, characters and strings

  ```cadence
  1 <= 1  // is `true`

  1 <= 2  // is `true`

  2 <= 1  // is `false`

  false <= true // is `true`

  true <= true  // is `true`

  true <= false // is `false`

  "c"  <= "a"   // is `false`

  "z"  <= "z"   // is `true`

  "a" <= "A"    // is `false`

  "" <= ""      // is `true`

  "" <= "a"     // is `true`

  "az" <= "b"   // is `true`

  "xAB" <= "Xab"  // is `false`
  ```

- Greater than: `>`, for integers, booleans, characters and strings

  ```cadence
  1 > 1  // is `false`

  1 > 2  // is `false`

  2 > 1  // is `true`

  false > true // is `false`

  true > true  // is `false`

  true > false // is `true`

  "c"  > "a"   // is `true`

  "g"  > "g"   // is `false`

  "a" > "A"    // is `true`

  "" > ""      // is `false`

  "" > "a"     // is `false`

  "az" > "b"   // is `false`

  "xAB" > "Xab"  // is `true`
  ```

- Greater or equal than: `>=`, for integers, booleans, characters and strings

  ```cadence
  1 >= 1  // is `true`

  1 >= 2  // is `false`

  2 >= 1  // is `true`

  false >= true // is `false`

  true >= true  // is `true`

  true >= false // is `true`

  "c"  >= "a"   // is `true`

  "q"  >= "q"   // is `true`

  "a" >= "A"    // is `true`

  "" >= ""      // is `true`

  "" >= "a"     // is `true`

  "az" >= "b"   // is `true`

  "xAB" >= "Xab"  // is `false`
  ```

### Comparing number super-types

Similar to arithmetic operators, comparison operators are also not supported for number supertypes
(`Number`, `SignedNumber` `FixedPoint`, `SignedFixedPoint`, `Integer`, `SignedInteger`),
as they may or may not succeed at run-time.

```cadence
let x: Integer = 3 as Int8
let y: Integer = 4 as Int8

let z: Bool = x > y    // Static error
```

Values of these types need to be cast to the desired type before performing the arithmetic operation.

```cadence
let z: Bool = (x as! Int8) > (y as! Int8)
```

## Bitwise Operators

Bitwise operators enable the manipulation of individual bits of unsigned and signed integers.
They're often used in low-level programming.

- Bitwise AND: `a & b`

  Returns a new integer whose bits are 1 only if the bits were 1 in *both* input integers:

  ```cadence
  let firstFiveBits = 0b11111000
  let lastFiveBits  = 0b00011111
  let middleTwoBits = firstFiveBits & lastFiveBits  // is 0b00011000
  ```

- Bitwise OR: `a | b`

  Returns a new integer whose bits are 1 only if the bits were 1 in *either* input integers:

  ```cadence
  let someBits = 0b10110010
  let moreBits = 0b01011110
  let combinedbits = someBits | moreBits  // is 0b11111110
  ```

- Bitwise XOR: `a ^ b`

  Returns a new integer whose bits are 1 where the input bits are different,
  and are 0 where the input bits are the same:

  ```cadence
  let firstBits = 0b00010100
  let otherBits = 0b00000101
  let outputBits = firstBits ^ otherBits  // is 0b00010001
  ```

### Bitwise Shifting Operators

- Bitwise LEFT SHIFT: `a << b`

  Returns a new integer with all bits moved to the left by a certain number of places.

  ```cadence
  let someBits = 4  // is 0b00000100
  let shiftedBits = someBits << 2   // is 0b00010000
  ```

- Bitwise RIGHT SHIFT: `a >> b`

  Returns a new integer with all bits moved to the right by a certain number of places.

  ```cadence
  let someBits = 8  // is 0b00001000
  let shiftedBits = someBits >> 2   // is 0b00000010
  ```

For unsigned integers, the bitwise shifting operators perform [logical shifting](https://en.wikipedia.org/wiki/Logical_shift),
for signed integers, they perform [arithmetic shifting](https://en.wikipedia.org/wiki/Arithmetic_shift).
Also note that for `a << b` or `a >> b`, `b` must fit into a 64-bit integer.

## Ternary Conditional Operator

There is only one ternary conditional operator, the ternary conditional operator (`a ? b : c`).

It behaves like an if-statement, but is an expression:
If the first operator value is true, the second operator value is returned.
If the first operator value is false, the third value is returned.

The first value must be a boolean (must have the type `Bool`).
The second value and third value can be of any type.
The result type is the least common supertype of the second and third value.

```cadence
let x = 1 > 2 ? 3 : 4
// `x` is `4` and has type `Int`

let y = 1 > 2 ? nil : 3
// `y` is `3` and has type `Int?`
```

## Casting Operators

### Static Casting Operator (`as`)

The static casting operator `as` can be used to statically type cast a value to a type.

If the static type of the value is a subtype of the given type (the "target" type),
the operator returns the value as the given type.

The cast is performed statically, i.e. when the program is type-checked.
Only the static type of the value is considered, not the run-time type of the value.

This means it is not possible to downcast using this operator.
Consider using the [conditional downcasting operator `as?`](#conditional-downcasting-operator-as) instead.

```cadence
// Declare a constant named `integer` which has type `Int`.
//
let integer: Int = 1

// Statically cast the value of `integer` to the supertype `Number`.
// The cast succeeds, because the type of the variable `integer`,
// the type `Int`, is a subtype of type `Number`.
// This is an upcast.
//
let number = integer as Number
// `number` is `1` and has type `Number`

// Declare a constant named `something` which has type `AnyStruct`,
// with an initial value which has type `Int`.
//
let something: AnyStruct = 1

// Statically cast the value of `something` to `Int`.
// This is invalid, the cast fails, because the static type of the value is type `AnyStruct`,
// which is not a subtype of type `Int`.
//
let result = something as Int
```

### Conditional Downcasting Operator (`as?`)

The conditional downcasting operator `as?` can be used to dynamically type cast a value to a type.
The operator returns an optional.
If the value has a run-time type that is a subtype of the target type
the operator returns the value as the target type,
otherwise the result is `nil`.

The cast is performed at run-time, i.e. when the program is executed,
not statically, i.e. when the program is checked.

```cadence
// Declare a constant named `something` which has type `AnyStruct`,
// with an initial value which has type `Int`.
//
let something: AnyStruct = 1

// Conditionally downcast the value of `something` to `Int`.
// The cast succeeds, because the value has type `Int`.
//
let number = something as? Int
// `number` is `1` and has type `Int?`

// Conditionally downcast the value of `something` to `Bool`.
// The cast fails, because the value has type `Int`,
// and `Bool` is not a subtype of `Int`.
//
let boolean = something as? Bool
// `boolean` is `nil` and has type `Bool?`
```

Downcasting works for concrete types, but also works e.g. for nested types (e.g. arrays), interfaces, optionals, etc.

```cadence
// Declare a constant named `values` which has type `[AnyStruct]`,
// i.e. an array of arbitrarily typed values.
//
let values: [AnyStruct] = [1, true]

let first = values[0] as? Int
// `first` is `1` and has type `Int?`

let second = values[1] as? Bool
// `second` is `true` and has type `Bool?`
```

### Force-downcasting Operator (`as!`)

The force-downcasting operator `as!` behaves like the
[conditional downcasting operator `as?`](#conditional-downcasting-operator-as).
However, if the cast succeeds, it returns a value of the given type instead of an optional,
and if the cast fails, it aborts the program instead of returning `nil`,

```cadence
// Declare a constant named `something` which has type `AnyStruct`,
// with an initial value which has type `Int`.
//
let something: AnyStruct = 1

// Force-downcast the value of `something` to `Int`.
// The cast succeeds, because the value has type `Int`.
//
let number = something as! Int
// `number` is `1` and has type `Int`

// Force-downcast the value of `something` to `Bool`.
// The cast fails, because the value has type `Int`,
// and `Bool` is not a subtype of `Int`.
//
let boolean = something as! Bool
// Run-time error
```

## Optional Operators

### Nil-Coalescing Operator (`??`)

The nil-coalescing operator `??` returns
the value inside an optional if it contains a value,
or returns an alternative value if the optional has no value,
i.e., the optional value is `nil`.

If the left-hand side is non-nil, the right-hand side is not evaluated.

```cadence
// Declare a constant which has an optional integer type
//
let a: Int? = nil

// Declare a constant with a non-optional integer type,
// which is initialized to `a` if it is non-nil, or 42 otherwise.
//
let b: Int = a ?? 42
// `b` is 42, as `a` is nil
```

The nil-coalescing operator can only be applied
to values which have an optional type.

```cadence
// Declare a constant with a non-optional integer type.
//
let a = 1

// Invalid: nil-coalescing operator is applied to a value which has a non-optional type
// (a has the non-optional type `Int`).
//
let b = a ?? 2
```

```cadence
// Invalid: nil-coalescing operator is applied to a value which has a non-optional type
// (the integer literal is of type `Int`).
//
let c = 1 ?? 2
```

The type of the right-hand side of the operator (the alternative value) must be a subtype
of the type of left-hand side, i.e. the right-hand side of the operator must
be the non-optional or optional type matching the type of the left-hand side.

```cadence
// Declare a constant with an optional integer type.
//
let a: Int? = nil
let b: Int? = 1
let c = a ?? b
// `c` is `1` and has type `Int?`

// Invalid: nil-coalescing operator is applied to a value of type `Int?`,
// but the alternative has type `Bool`.
//
let d = a ?? false
```

### Force Unwrap Operator (`!`)

The force-unwrap operator (`!`) returns
the value inside an optional if it contains a value,
or panics and aborts the execution if the optional has no value,
i.e., the optional value is `nil`.

```cadence
// Declare a constant which has an optional integer type
//
let a: Int? = nil

// Declare a constant with a non-optional integer type,
// which is initialized to `a` if `a` is non-nil.
// If `a` is nil, the program aborts.
//
let b: Int = a!
// The program aborts because `a` is nil.

// Declare another optional integer constant
let c: Int? = 3

// Declare a non-optional integer
// which is initialized to `c` if `c` is non-nil.
// If `c` is nil, the program aborts.
let d: Int = c!
// `d` is initialized to 3 because c isn't nil.

```

The force-unwrap operator can only be applied
to values which have an optional type.

```cadence
// Declare a constant with a non-optional integer type.
//
let a = 1

// Invalid: force-unwrap operator is applied to a value which has a
// non-optional type (`a` has the non-optional type `Int`).
//
let b = a!
```

```cadence
// Invalid: The force-unwrap operator is applied
// to a value which has a non-optional type
// (the integer literal is of type `Int`).
//
let c = 1!
```


## Precedence and Associativity

Operators have the following precedences, highest to lowest:

- Unary precedence: `-`, `!`, `<-`
- Cast precedence: `as`, `as?`, `as!`
- Multiplication precedence: `*`, `/`, `%`
- Addition precedence: `+`, `-`
- Bitwise shift precedence: `<<`, `>>`
- Bitwise conjunction precedence: `&`
- Bitwise exclusive disjunction precedence: `^`
- Bitwise disjunction precedence: `|`
- Nil-Coalescing precedence: `??`
- Relational precedence: `<`, `<=`, `>`, `>=`
- Equality precedence: `==`, `!=`
- Logical conjunction precedence: `&&`
- Logical disjunction precedence: `||`
- Ternary precedence: `? :`

All operators are left-associative, except for the following operators which are right-associative:
- Ternary operator
- Nil-coalescing operator

Expressions can be wrapped in parentheses to override precedence conventions,
i.e. an alternate order should be indicated, or when the default order should be emphasized
e.g. to avoid confusion.
For example, `(2 + 3) * 4` forces addition to precede multiplication,
and `5 + (6 * 7)` reinforces the default order.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/02-hello-world.md

---
archived: false
draft: false
title: Hello World
description: A smart contract tutorial for Cadence.
date: 2024-11-26
meta:
  keywords:
    - tutorial
    - Flow
    - Cadence
    - Hello World
tags:
  - reference
  - cadence
  - tutorial
socialImageTitle: Hello World
socialImageDescription: Write your own Hello World smart contract in Cadence.
---

It's time to write your own "Hello World" contract.  In this instance, the contract will:

1. Create and initialize a smart contract with a single field of type `String`.
1. Initialize the field with the phrase "Hello, World!".
1. Create a function in the contract that returns our greeting.

We will deploy this contract in an account, use a transaction to interact with the contract, and finally, explore the role of signers in a transaction.

## Objectives

After completing this tutorial, you'll be able to:

* Declare a public Cadence smart contract.
* Initialize a public `String` variable. 
* Write simple transactions and scripts in Cadence.
* Describe the role of signers in a Cadence transaction.

## Implementing Hello World

:::info[Action]

Open the starter code for this tutorial in the Flow Playground:

<a
  href="https://play.flow.com/e559739d-603e-40d5-b2f1-b9957051cdc4"
  target="_blank"
>
  https://play.flow.com/e559739d-603e-40d5-b2f1-b9957051cdc4
</a>

:::

It's empty!

:::info[Action]

Begin by declaring your contract.

:::

```cadence
access(all) contract HelloWorld {
  // Todo
}
```

### Declare a Contract-Level Constant

The line `access(all) contract HelloWorld ` declares a contract with [Access Control] that is accessible in all scopes - or public.

:::info[Action]

Add a public constant `String` field to store your greeting.  

:::

```cadence
// Incomplete code example
// An error is expected here, see below

// Declare a public (access(all)) field of type String.
access(all) let greeting: String
```

:::warning

Cadence follows the same pattern as Swift where the `let` keyword is used to declare a constant. The `var` keyword is used to declare a variable.

:::

As before, you're using the `access` keyword to set the scope to `all` and make the constant public.  The `let` keyword declares a state constant named `greeting`, and the [type annotation] declares it as a `String`.

You've probably noticed the error that your code is `` missing initializer for field `greeting` in type `HelloWorld` ``

[Composite Types], which includes contracts, have a special initializer function that is run exactly once, upon object creation.  It's optional, but constants declared at the contract level must have a value set in the initializer.

:::info[Action]

Add an initializer and initialize your `greeting`.

:::

```cadence
// The initializer is required if the contract contains any fields.
init() {
  self.greeting = "Hello, World!"
}
```

### Add a View Function

You've created a contract and initialized the `"Hello, World!"` `String`.  The next step is to:

:::info[Action]

Implement a `view` function to return the `greeting` constant.

:::

```cadence
// Public function that returns our friendly greeting!
access(all) view fun hello(): String {
    return self.greeting
}
```

Once again, the access level is public.  Anyone who imports this contract into their own contract, transaction, or script can read the public fields, use the public types, and call the public contract functions - the ones that have `access(all)` specified.

The `view` annotation indicates that the function is permitted to view, but not modify blockchain state.

## Accounts

Each user has an account controlled by one or more private keys with configurable weight. This means that support for accounts/wallets with [multiple controllers] is built into the protocol by default.

An account is divided into several areas:
* _Contracts_
* _Account Storage_
* _Capabilities_
* _Keys_

### Contract Area

The first area is the [contract area], or `account.contracts`.

This is the area that stores smart contracts deployed to the account.  These contracts contain type definitions, fields, and functions that relate to common functionality. There is no limit to the number of smart contracts an account can store.

:::tip

Much of the functionality that you'd find in a Solidity smart contract is instead written in [transactions] or scripts for Cadence apps.  These exist outside the smart contract, which means you don't need to anticipate absolutely everything you might want to do or view before deploying the contract.

:::

The information in the contract area cannot be directly accessed in a transaction unless the transaction imports the contract or returns (reads) a copy of the code deployed to an account.

The owner of an account can directly add or update contracts that are deployed to it.

:::warning[Important]

On Flow Cadence, **smart contracts _are_ upgradeable**.  If you make a mistake, you can often [update] it, constrained by some rules, in a public and transparent manner.

:::

### Account Storage

The second area is where you'll find [account storage], or `account.storage`.  This area is where an account stores the objects that it owns. This is an important differentiator between Cadence and other languages, because in other languages, assets that accounts own are usually stored in the centralized smart contract ledger that defines the assets. 

:::warning[Important]

In Cadence, **each account stores its assets as objects directly in its own account storage, like how you store your own possessions in your own house in real life**!

:::

The account storage section also stores code that declares the capabilities for controlling how these stored objects can be accessed. We'll cover account storage and capabilities in more detail in a later tutorial.

In this tutorial, we'll use the account with the address `0x06` to store our `HelloWorld` contract.

### Capabilities

[Capabilities], or `account.capabilities`, are a part of the security model in Cadence.  They represent the right to access parts or all of an object and perform operations on it.  For example, a user might possess a vault that holds fungible tokens.  For it, they'll have a capability that allows anyone to deposit tokens into the vault, and may choose to grant the capability to withdraw tokens to their broker's account.

### Keys

[Keys], or `account.keys`, are used to sign [transactions].  In Cadence, an account can have many keys. These keys can be shared or revoked, providing native version of [account abstraction] that is extremely powerful.  For example, you can use it [build an app] that pulls NFTs in an embedded wallet in one app into that user's browser wallet and use them in your app.

## Deploying the HelloWorld Contract

:::info[Action]

Make sure that the account `0x06` tab is selected and that the
`HelloWorld.cdc` file is in the editor.

Click the deploy button to deploy the contents of the editor to account `0x06`.

:::

![Deploy Contract](deploybox.png)

You should see a log in the output area indicating that the deployment succeeded.

```text
Deployed Contract To: 0x06
```

You'll also see the name of the contract in the selected account tab underneath the number for the account. This indicates that the `HelloWorld` contract has been deployed to the account.

You can always look at this tab to verify which contracts are in which accounts.

## Transactions

A [Transaction] in Flow is defined as an arbitrary-sized block of Cadence code that is authorized by one or more accounts.

When an account authorizes a transaction, the code in that transaction has access to the authorizers' private storage.

An account authorizes a transaction by performing a cryptographic signature on the transaction with the account's private key, which should only be accessible to the account owner.

In addition to being able to access the authorizer's private assets, transactions can also read and call functions in public contracts, and access public functions in other users' accounts.

For this tutorial, we'll use a transaction to call our `hello()` function.

:::info[Action]

Open the `CallHello` file in the `Transactions` folder.

:::

First, you'll need to import the **deployed instance** of `HelloWorld` from account `0x06`. If you haven't deployed the smart contract from the account, the transaction won't have access to it and the import will fail.

:::info[Action]

Add an `import` at the top of the file.

:::

```cadence
import HelloWorld from 0x06
```

This imports the entire contract code from `HelloWorld`, including type definitions and public functions, so that the transaction can use them to interact with the `HelloWorld` contract in account `0x06`.

To import any smart contract from any account, you can use this format:

```cadence
// Replace {ContractName} with the name of the contract you want to import
// and {Address} with the account you want to import it from
import {ContractName} from {Address}
```

Transactions are written in Cadence and are declared with the `transaction` keyword.

:::info[Action]

Declare an empty `transaction`.

:::

```cadence
transaction {
  // TODO
}
```

### Transaction Process

Transactions are divided into two main phases, `prepare` and `execute`.

The [`prepare`] phase is required and is used to identify the account(s) that will sign the transaction.  It's also used when the transaction needs to access the account(s) that signed the transaction. The latter is not needed for this simple transaction.

:::info[Action]

Add an empty `prepare` statement to your transaction.

:::

```cadence
prepare(acct: &Account) {
  // Nothing is needed here for now
}
```

The `execute` phase is the main body of a transaction. It can call functions on external contracts and objects and perform operations on data that was initialized in the transaction.

:::info[Action]

Add an `execute` block to your transaction and use it to `log` the output of the `hello()` function from the imported `HelloWorld` contract to the console.

:::

```cadence
execute {
  log(HelloWorld.hello())
}
```

In this example, the `execute` phase calls `HelloWorld.hello()`. This executes the `hello()` function in the `HelloWorld` contract
and logs the result(`log(HelloWorld.hello())`) to the console.

:::info[Action]

In the box at the bottom right of the editor, select Account `0x06` as the transaction signer.

Click the `Send` button to submit the transaction

:::

You should see something like this in the transaction results at the bottom of the screen:

```text
16:46:56
Simple Transaction
[1]
Cadence log: "Hello, World!"
```

Congratulations, you just executed your first Cadence transaction with the account `0x06` as the signer!

In this tutorial, you'll get the same result if you use different signers for the transaction but later tutorials will use more complex examples that have different results depending on the signer.

## Conclusion

This tutorial covered an introduction to Cadence, including terms like accounts, transactions, and signers. We implemented a smart contract that is accessible in all scopes. The smart contract had a `String` field initialized with the value `Hello, World!` and a function to return (read) this value.

Next, we deployed this contract in an account and implemented a transaction to call the function in the smart contract and log the result to the console. Finally, we used the account `0x06` as the signer for this transaction.

Now that you have completed the tutorial, you can:

* Declare a public Cadence smart contract.
* Initialize a public `String` variable. 
* Write simple transactions in Cadence.
* Describe the role of signers in a Cadence transaction.

<!-- Relative links.  Will not render on the page -->

[Cadence]: ../index.md
[Access Control]: ../language/access-control.md
[variable]: ../language/constants-and-variables.md
[type annotation]: ../language/type-annotations.md
[Composite Types]: ../language/composite-types.mdx
[multiple controllers]: https://www.coindesk.comwhat-is-a-multisignature-crypto-wallet
[contract area]: ../language/accounts/contracts
[update]: ../language/contract-updatability.md
[account storage]: ../language/accounts/storage.mdx
[Capabilities]: ../language/capabilities.md
[Keys]: ../language/accounts/keys.mdx
[account abstraction]: https://ethereum.org/en/roadmap/account-abstraction
[build an app]: https://developers.flow.com/build/guides/account-linking-with-dapper
[Transaction]: ../language/transactions.md
[transactions]: ../language/transactions.md
[`prepare`]: ../language/transactions.md#prepare-phase
[Cadence types]: ../language/values-and-types.mdx





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/type-hierarchy.md

---
title: Type Hierarchy
sidebar_position: 31
---

![Cadence type hierarchy](type-hierarchy.png)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/enumerations.md

---
title: Enumerations
sidebar_position: 16
---

Enumerations are sets of symbolic names bound to unique, constant values,
which can be compared by identity.

## Enum Declaration

Enums are declared using the `enum` keyword,
followed by the name of the enum, the raw type after a colon,
and the requirements, which must be enclosed in opening and closing braces.

The raw type must be an integer subtype, e.g. `UInt8` or `Int128`.

Enum cases are declared using the `case` keyword,
followed by the name of the enum case.

Enum cases must be unique.
Each enum case has a raw value, the index of the case in all cases.

The raw value of an enum case can be accessed through the `rawValue` field.

The enum cases can be accessed by using the name as a field on the enum,
or by using the enum constructor,
which requires providing the raw value as an argument.
The enum constructor returns the enum case with the given raw value,
if any, or `nil` if no such case exists.

Enum cases can be compared using the equality operators `==` and `!=`.

```cadence
// Declare an enum named `Color` which has the raw value type `UInt8`,
// and declare three enum cases: `red`, `green`, and `blue`
//
access(all)
enum Color: UInt8 {

    access(all)
    case red

    access(all)
    case green
    
    access(all)
    case blue
}
// Declare a variable which has the enum type `Color` and initialize
// it to the enum case `blue` of the enum
let blue: Color = Color.blue
// Get the raw value of the enum case `blue`.
// As it is the third case, so it has index 2
//
blue.rawValue // is `2`
// Get the `green` enum case of the enum `Color` by using the enum
// constructor and providing the raw value of the enum case `green`, 1,
// as the enum case `green` is the second case, so it has index 1
//
let green: Color? = Color(rawValue: 1)  // is `Color.green`
// Get the enum case of the enum `Color` that has the raw value 5.
// As there are only three cases, the maximum raw value / index is 2.
//
let nothing = Color(rawValue: 5)  // is `nil`
// Enum cases can be compared
Color.red == Color.red  // is `true`
Color(rawValue: 1) == Color.green  // is `true`
// Different enum cases are not the same
Color.red != Color.blue  // is `true`
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/run-time-types.md

---
title: Run-time Types
sidebar_position: 27
---

Types can be represented at run-time.
To create a type value, use the constructor function `Type<T>()`, which accepts the static type as a type argument.

This is similar to e.g. `T.self` in Swift, `T::class`/`KClass<T>` in Kotlin, and `T.class`/`Class<T>` in Java.

For example, to represent the type `Int` at run-time:

```cadence
let intType: Type = Type<Int>()
```

This works for both built-in and user-defined types. For example, to get the type value for a resource:

```cadence
resource Collectible {}

let collectibleType = Type<@Collectible>()

// `collectibleType` has type `Type`
```

Type values are comparable.

```cadence

Type<Int>() == Type<Int>()

Type<Int>() != Type<String>()
```

The method `view fun isSubtype(of: Type): Bool` can be used to compare the run-time types of values.

```cadence
Type<Int>().isSubtype(of: Type<Int>()) // true

Type<Int>().isSubtype(of: Type<String>()) // false

Type<Int>().isSubtype(of: Type<Int?>()) // true
```

To get the run-time type's fully qualified type identifier, use the `let identifier: String` field:

```cadence
let type = Type<Int>()
type.identifier  // is "Int"
```

```cadence
// in account 0x1

struct Test {}

let type = Type<Test>()
type.identifier  // is "A.0000000000000001.Test"
```

### Getting the Type from a Value

The method `view fun getType(): Type` can be used to get the runtime type of a value.

```cadence
let something = "hello"

let type: Type = something.getType()
// `type` is `Type<String>()`
```

This method returns the **concrete run-time type** of the object, **not** the static type.

```cadence
// Declare a variable named `something` that has the *static* type `AnyResource`
// and has a resource of type `Collectible`
//
let something: @AnyResource <- create Collectible()

// The resource's concrete run-time type is `Collectible`
//
let type: Type = something.getType()
// `type` is `Type<@Collectible>()`
```

### Constructing a Run-time Type

Run-time types can also be constructed from type identifier strings using built-in constructor functions.

```cadence
view fun CompositeType(_ identifier: String): Type?
view fun InterfaceType(_ identifier: String): Type?
view fun IntersectionType(types: [String]): Type?
```

Given a type identifier (or a list of identifiers for interfaces
in the case of `IntersectionType`), these functions will look up nominal types and
produce their run-time equivalents. If the provided identifiers do not correspond
to any types, or (in the case of `IntersectionType`) the provided combination of
identifiers would not type-check statically, these functions will produce `nil`.

```cadence
struct Test: I {}
struct interface I {}
let type: Type = CompositeType("A.0000000000000001.Test")
// `type` is `Type<Test>`

let type2: Type = IntersectionType(
    restrictions: ["A.0000000000000001.I"]
)
// `type2` is `Type<{I}>`
```

Other built-in functions will construct compound types from other run-types.

```cadence
view fun OptionalType(_ type: Type): Type
view fun VariableSizedArrayType(_ type: Type): Type
view fun ConstantSizedArrayType(type: Type, size: Int): Type
view fun FunctionType(parameters: [Type], return: Type): Type
// returns `nil` if `key` is not valid dictionary key type
view fun DictionaryType(key: Type, value: Type): Type?
// returns `nil` if `type` is not a reference type
view fun CapabilityType(_ type: Type): Type?
view fun ReferenceType(entitlements: [String], type: Type): Type?
```

### Asserting the Type of a Value

The method `view fun isInstance(_ type: Type): Bool` can be used to check if a value has a certain type,
using the concrete run-time type, and considering subtyping rules,

```cadence
// Declare a variable named `collectible` that has the *static* type `Collectible`
// and has a resource of type `Collectible`
//
let collectible: @Collectible <- create Collectible()

// The resource is an instance of type `Collectible`,
// because the concrete run-time type is `Collectible`
//
collectible.isInstance(Type<@Collectible>())  // is `true`

// The resource is an instance of type `AnyResource`,
// because the concrete run-time type `Collectible` is a subtype of `AnyResource`
//
collectible.isInstance(Type<@AnyResource>())  // is `true`

// The resource is *not* an instance of type `String`,
// because the concrete run-time type `Collectible` is *not* a subtype of `String`
//
collectible.isInstance(Type<String>())  // is `false`
```

Note that the **concrete run-time type** of the object is used, **not** the static type.

```cadence
// Declare a variable named `something` that has the *static* type `AnyResource`
// and has a resource of type `Collectible`
//
let something: @AnyResource <- create Collectible()

// The resource is an instance of type `Collectible`,
// because the concrete run-time type is `Collectible`
//
something.isInstance(Type<@Collectible>())  // is `true`

// The resource is an instance of type `AnyResource`,
// because the concrete run-time type `Collectible` is a subtype of `AnyResource`
//
something.isInstance(Type<@AnyResource>())  // is `true`

// The resource is *not* an instance of type `String`,
// because the concrete run-time type `Collectible` is *not* a subtype of `String`
//
something.isInstance(Type<String>())  // is `false`
```

For example, this allows implementing a marketplace sale resource:

```cadence
access(all)
resource SimpleSale {

    /// The resource for sale.
    /// Once the resource is sold, the field becomes `nil`.
    ///
    access(all)
    var resourceForSale: @AnyResource?

    /// The price that is wanted for the purchase of the resource.
    ///
    access(all)
    let priceForResource: UFix64

    /// The type of currency that is required for the purchase.
    ///
    access(all)
    let requiredCurrency: Type
    access(all)
    let paymentReceiver: Capability<&{FungibleToken.Receiver}>

    /// `paymentReceiver` is the capability that will be borrowed
    /// once a valid purchase is made.
    /// It is expected to target a resource that allows depositing the paid amount
    /// (a vault which has the type in `requiredCurrency`).
    ///
    init(
        resourceForSale: @AnyResource,
        priceForResource: UFix64,
        requiredCurrency: Type,
        paymentReceiver: Capability<&{FungibleToken.Receiver}>
    ) {
        self.resourceForSale <- resourceForSale
        self.priceForResource = priceForResource
        self.requiredCurrency = requiredCurrency
        self.paymentReceiver = paymentReceiver
    }

    /// buyObject allows purchasing the resource for sale by providing
    /// the required funds.
    /// If the purchase succeeds, the resource for sale is returned.
    /// If the purchase fails, the program aborts.
    ///
    access(all)
    fun buyObject(with funds: @FungibleToken.Vault): @AnyResource {
        pre {
            // Ensure the resource is still up for sale
            self.resourceForSale != nil: "The resource has already been sold"
            // Ensure the paid funds have the right amount
            funds.balance >= self.priceForResource: "Payment has insufficient amount"
            // Ensure the paid currency is correct
            funds.isInstance(self.requiredCurrency): "Incorrect payment currency"
        }

        // Transfer the paid funds to the payment receiver
        // by borrowing the payment receiver capability of this sale resource
        // and depositing the payment into it

        let receiver = self.paymentReceiver.borrow()
            ?? panic("failed to borrow payment receiver capability")

        receiver.deposit(from: <-funds)
        let resourceForSale <- self.resourceForSale <- nil
        return <-resourceForSale
    }
}
```






---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/core-events.md

---
title: Core Events
sidebar_position: 26
---

Core events are events emitted directly from the FVM (Flow Virtual Machine).
The events have the same name on all networks and do not follow the standard naming (they have no address).

Refer to the [public key section](./crypto.mdx#public-keys) for more details on the information provided for account key events.

### Account Created

Event that is emitted when a new account gets created.

Event name: `flow.AccountCreated`

```cadence
access(all)
event AccountCreated(address: Address)
```

| Field             | Type      | Description                              |
| ----------------- | --------- | ---------------------------------------- |
| `address`         | `Address` | The address of the newly created account |


### Account Key Added

Event that is emitted when a key gets added to an account.

Event name: `flow.AccountKeyAdded`

```cadence
access(all)
event AccountKeyAdded(
    address: Address,
    publicKey: PublicKey,
    weight: UFix64,
    hashAlgorithm: HashAlgorithm,
    keyIndex: Int
)
```

| Field           | Type            | Description                                    |
|-----------------|-----------------|------------------------------------------------|
| `address`       | `Address`       | The address of the account the key is added to |
| `publicKey`     | `PublicKey`     | The public key added to the account            |
| `weight`        | `UFix64`        | Weight of the new account key                  |
| `hashAlgorithm` | `HashAlgorithm` | HashAlgorithm of the new account key           |
| `keyIndex`      | `Int`           | Index of the new account key                   |

### Account Key Removed

Event that is emitted when a key gets removed from an account.

Event name: `flow.AccountKeyRemoved`

```cadence
access(all)
event AccountKeyRemoved(
    address: Address,
    publicKey: PublicKey
)
```

| Field       | Type      | Description                                        |
|-------------|-----------|----------------------------------------------------|
| `address`   | `Address` | The address of the account the key is removed from |
| `publicKey` | `Int`     | Index of public key removed from the account       |

### Account Contract Added

Event that is emitted when a contract gets deployed to an account.

Event name: `flow.AccountContractAdded`

```cadence
access(all)
event AccountContractAdded(
    address: Address,
    codeHash: [UInt8],
    contract: String
)
```

| Field       | Type   | Description                                                  |
| ----------- | ------ | ------------------------------------------------------------ |
| `address`   | `Address` | The address of the account the contract gets deployed to  |
| `codeHash`  | `[UInt8]` | Hash of the contract source code                          |
| `contract`  | `String`  | The name of the the contract                              |

### Account Contract Updated

Event that is emitted when a contract gets updated on an account.

Event name: `flow.AccountContractUpdated`

```cadence
access(all)
event AccountContractUpdated(
    address: Address,
    codeHash: [UInt8],
    contract: String
)
```

| Field       | Type      | Description                                              |
| ----------- | --------- | -------------------------------------------------------- |
| `address`   | `Address` | The address of the account where the updated contract is deployed  |
| `codeHash`  | `[UInt8]` | Hash of the contract source code                         |
| `contract`  | `String`  | The name of the the contract                             |


### Account Contract Removed

Event that is emitted when a contract gets removed from an account.

Event name: `flow.AccountContractRemoved`

```cadence
access(all)
event AccountContractRemoved(
    address: Address,
    codeHash: [UInt8],
    contract: String
)
```

| Field       | Type      | Description                                               |
| ----------- | --------- | --------------------------------------------------------- |
| `address`   | `Address` | The address of the account the contract gets removed from |
| `codeHash`  | `[UInt8]` | Hash of the contract source code                          |
| `contract`  | `String`  | The name of the the contract                              |

### Inbox Value Published

Event that is emitted when a Capability is published from an account.

Event name: `flow.InboxValuePublished`

```cadence
access(all)
event InboxValuePublished(provider: Address, recipient: Address, name: String, type: Type)
```

| Field             | Type      | Description                                  |
| ----------------- | --------- | -------------------------------------------- |
| `provider`        | `Address` | The address of the publishing account        |
| `recipient`       | `Address` | The address of the intended recipient        |
| `name`            | `String`  | The name associated with the published value |
| `type`            | `Type`    | The type of the published value              |

To reduce the potential for spam,
we recommend that user agents that display events do not display this event as-is to their users,
and allow users to restrict whom they see events from.

### Inbox Value Unpublished

Event that is emitted when a Capability is unpublished from an account.

Event name: `flow.InboxValueUnpublished`

```cadence
access(all)
event InboxValueUnpublished(provider: Address, name: String)
```

| Field           | Type      | Description                                  |
| --------------- | --------- | -------------------------------------------- |
| `provider`      | `Address` | The address of the publishing account        |
| `name`          | `String`  | The name associated with the published value |

To reduce the potential for spam,
we recommend that user agents that display events do not display this event as-is to their users,
and allow users to restrict whom they see events from.

### Inbox Value Claimed

Event that is emitted when a Capability is claimed by an account.

Event name: `flow.InboxValueClaimed`

```cadence
access(all)
event InboxValueClaimed(provider: Address, recipient: Address, name: String)
```

| Field           | Type      | Description                                  |
| --------------- | --------- | -------------------------------------------- |
| `provider`      | `Address` | The address of the publishing account        |
| `recipient`     | `Address` | The address of the claiming recipient        |
| `name`          | `String`  | The name associated with the published value |

To reduce the potential for spam,
we recommend that user agents that display events do not display this event as-is to their users,
and allow users to restrict whom they see events from.




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/control-flow.md

---
title: Control Flow
sidebar_position: 7
---

Control flow statements control the flow of execution in a function.

## Conditional branching: if-statement

If-statements allow a certain piece of code to be executed only when a given condition is true.

The if-statement starts with the `if` keyword, followed by the condition,
and the code that should be executed if the condition is true
inside opening and closing braces.
The condition expression must be boolean.
The braces are required and not optional.
Parentheses around the condition are optional.

```cadence
let a = 0
var b = 0

if a == 0 {
   b = 1
}

// Parentheses can be used around the condition, but are not required.
if (a != 0) {
   b = 2
}

// `b` is `1`
```

An additional, optional else-clause can be added to execute another piece of code
when the condition is false.
The else-clause is introduced by the `else` keyword followed by braces
that contain the code that should be executed.

```cadence
let a = 0
var b = 0

if a == 1 {
   b = 1
} else {
   b = 2
}

// `b` is `2`
```

The else-clause can contain another if-statement, i.e., if-statements can be chained together.
In this case the braces can be omitted.

```cadence
let a = 0
var b = 0

if a == 1 {
   b = 1
} else if a == 2 {
   b = 2
} else {
   b = 3
}

// `b` is `3`

if a == 1 {
   b = 1
} else {
    if a == 0 {
        b = 2
    }
}

// `b` is `2`
```

## Optional Binding

Optional binding allows getting the value inside an optional.
It is a variant of the if-statement.

If the optional contains a value, the first branch is executed
and a temporary constant or variable is declared and set to the value contained in the optional;
otherwise, the else branch (if any) is executed.

Optional bindings are declared using the `if` keyword like an if-statement,
but instead of the boolean test value, it is followed by the `let` or `var` keywords,
to either introduce a constant or variable, followed by a name,
the equal sign (`=`), and the optional value.

```cadence
let maybeNumber: Int? = 1

if let number = maybeNumber {
    // This branch is executed as `maybeNumber` is not `nil`.
    // The constant `number` is `1` and has type `Int`.
} else {
    // This branch is *not* executed as `maybeNumber` is not `nil`
}
```

```cadence
let noNumber: Int? = nil

if let number = noNumber {
    // This branch is *not* executed as `noNumber` is `nil`.
} else {
    // This branch is executed as `noNumber` is `nil`.
    // The constant `number` is *not* available.
}
```

## Switch

Switch-statements compare a value against several possible values of the same type, in order.
When an equal value is found, the associated block of code is executed.

The switch-statement starts with the `switch` keyword, followed by the tested value,
followed by the cases inside opening and closing braces.
The test expression must be equatable.
The braces are required and not optional.

Each case is a separate branch of code execution
and starts with the `case` keyword,
followed by a possible value, a colon (`:`),
and the block of code that should be executed
if the case's value is equal to the tested value.

The block of code associated with a switch case
[does not implicitly fall through](#no-implicit-fallthrough),
and must contain at least one statement.
Empty blocks are invalid.

An optional default case may be given by using the `default` keyword.
The block of code of the default case is executed
when none of the previous case tests succeeded.
It must always appear last.

```cadence
fun word(_ n: Int): String {
    // Test the value of the parameter `n`
    switch n {
    case 1:
        // If the value of variable `n` is equal to `1`,
        // then return the string "one"
        return "one"
    case 2:
        // If the value of variable `n` is equal to `2`,
        // then return the string "two"
        return "two"
    default:
        // If the value of variable `n` is neither equal to `1` nor to `2`,
        // then return the string "other"
        return "other"
    }
}

word(1)  // returns "one"
word(2)  // returns "two"
word(3)  // returns "other"
word(4)  // returns "other"
```

### Duplicate cases

Cases are tested in order, so if a case is duplicated,
the block of code associated with the first case that succeeds is executed.

```cadence
fun test(_ n: Int): String {
    // Test the value of the parameter `n`
    switch n {
    case 1:
        // If the value of variable `n` is equal to `1`,
        // then return the string "one"
        return "one"
    case 1:
        // If the value of variable `n` is equal to `1`,
        // then return the string "also one".
        // This is a duplicate case for the one above.
        return "also one"
    default:
        // If the value of variable `n` is neither equal to `1` nor to `2`,
        // then return the string "other"
        return "other"
    }
}

word(1) // returns "one", not "also one"
```

### `break`

The block of code associated with a switch case may contain a `break` statement.
It ends the execution of the switch statement immediately
and transfers control to the code after the switch statement

### No Implicit Fallthrough

Unlike switch statements in some other languages,
switch statements in Cadence do not "fall through":
execution of the switch statement finishes as soon as the block of code
associated with the first matching case is completed.
No explicit `break` statement is required.

This makes the switch statement safer and easier to use,
avoiding the accidental execution of more than one switch case.

Some other languages implicitly fall through
to the block of code associated with the next case,
so it is common to write cases with an empty block
to handle multiple values in the same way.

To prevent developers from writing switch statements
that assume this behaviour, blocks must have at least one statement.
Empty blocks are invalid.

```cadence
fun words(_ n: Int): [String] {
    // Declare a variable named `result`, an array of strings,
    // which stores the result
    let result: [String] = []

    // Test the value of the parameter `n`
    switch n {
    case 1:
        // If the value of variable `n` is equal to `1`,
        // then append the string "one" to the result array
        result.append("one")
    case 2:
        // If the value of variable `n` is equal to `2`,
        // then append the string "two" to the result array
        result.append("two")
    default:
        // If the value of variable `n` is neither equal to `1` nor to `2`,
        // then append the string "other" to the result array
        result.append("other")
    }
    return result
}

words(1)  // returns `["one"]`
words(2)  // returns `["two"]`
words(3)  // returns `["other"]`
words(4)  // returns `["other"]`
```

## Looping

### while-statement

While-statements allow a certain piece of code to be executed repeatedly,
as long as a condition remains true.

The while-statement starts with the `while` keyword, followed by the condition,
and the code that should be repeatedly
executed if the condition is true inside opening and closing braces.
The condition must be boolean and the braces are required.

The while-statement will first evaluate the condition.
If it is true, the piece of code is executed and the evaluation of the condition is repeated.
If the condition is false, the piece of code is not executed
and the execution of the whole while-statement is finished.
Thus, the piece of code is executed zero or more times.

```cadence
var a = 0
while a < 5 {
    a = a + 1
}

// `a` is `5`
```

### For-in statement

For-in statements allow a certain piece of code to be executed repeatedly for
each element in an array.

The for-in statement starts with the `for` keyword, followed by the name of
the element that is used in each iteration of the loop,
followed by the `in` keyword, and then followed by the array
that is being iterated through in the loop.

Then, the code that should be repeatedly executed in each iteration of the loop
is enclosed in curly braces.

If there are no elements in the data structure, the code in the loop will not
be executed at all. Otherwise, the code will execute as many times
as there are elements in the array.

```cadence
let array = ["Hello", "World", "Foo", "Bar"]

for element in array {
    log(element)
}

// The loop would log:
// "Hello"
// "World"
// "Foo"
// "Bar"
```

Optionally, developers may include an additional variable preceding the element name,
separated by a comma.
When present, this variable contains the current
index of the array being iterated through
during each repeated execution (starting from 0).

```cadence
let array = ["Hello", "World", "Foo", "Bar"]

for index, element in array {
    log(index)
}

// The loop would log:
// 0
// 1
// 2
// 3
```

To iterate over a dictionary's entries (keys and values),
use a for-in loop over the dictionary's keys and get the value for each key:

```cadence
let dictionary = {"one": 1, "two": 2}
for key in dictionary.keys {
    let value = dictionary[key]!
    log(key)
    log(value)
}

// The loop would log:
// "one"
// 1
// "two"
// 2
```

Alternatively, dictionaries carry a method `forEachKey` that avoids allocating an intermediate array for keys:

```cadence
let dictionary = {"one": 1, "two": 2, "three": 3}
dictionary.forEachKey(fun (key: String): Bool {
    let value = dictionary[key]
    log(key)
    log(value)

    return key != "two" // stop iteration if this returns false
})
```

### Ranges in Loops

An [`InclusiveRange` value](#../values-and-types/InclusiveRange) can be used in a for-in statement in place of an array or dictionary. In this case, 
the loop will iterate over all the values contained in the range, beginning with `range.start` and ending with `range.end`. E.g. 

```cadence
let range: InclusiveRange<UInt> = InclusiveRange(1, 100, step: 2)
var elements : [UInt] = []
for element in range {
    elements.append(element)
}
// after this loop, `elements` contains all the odd integers from 1 to 99
```

Note that in this example, even though `100` is the end of the `range`, it is not included in the loop because it cannot be reached with the given `start` and `step`.

The above loop is equivalent to: 

```cadence
let range: InclusiveRange<UInt> = InclusiveRange(1, 100, step: 2)
var elements : [UInt] = []
var index = range.start
while index <= range.end {
    elements.append(element)
    index = index + range.step
}
// after this loop, `elements` contains all the odd integers from 1 to 99
```

In general, a for-in loop over an increasing range (a positive `step`) is equivalent to:

```cadence
var index = range.start
while index <= range.end {
    // loop body
    index = index + range.step
}
```

While a for-in loop over a decreasing range (a negative `step`) is equivalent to: 

```cadence
var index = range.start
while index >= range.end {
    // loop body
    index = index + range.step // `range.step` here is negative, so this decreases `index`
}
```

Both can be equivalently rewritten to:

```cadence
var index = range.start
while range.contains(index) {
    // loop body
    index = index + range.step
}
```

### `continue` and `break`

In for-loops and while-loops, the `continue` statement can be used to stop
the current iteration of a loop and start the next iteration.

```cadence
var i = 0
var x = 0
while i < 10 {
    i = i + 1
    if i < 3 {
        continue
    }
    x = x + 1
}
// `x` is `8`


let array = [2, 2, 3]
var sum = 0
for element in array {
    if element == 2 {
        continue
    }
    sum = sum + element
}

// `sum` is `3`

```

The `break` statement can be used to stop the execution
of a for-loop or a while-loop.

```cadence
var x = 0
while x < 10 {
    x = x + 1
    if x == 5 {
        break
    }
}
// `x` is `5`


let array = [1, 2, 3]
var sum = 0
for element in array {
    if element == 2 {
        break
    }
    sum = sum + element
}

// `sum` is `1`
```

## Immediate function return: return-statement

The return-statement causes a function to return immediately,
i.e., any code after the return-statement is not executed.
The return-statement starts with the `return` keyword
and is followed by an optional expression that should be the return value of the function call.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/security-best-practices.md

---
title: Cadence Security Best Practices
sidebar_label: Security Best Practices
sidebar_position: 7
---

This is an opinionated list of best practices Cadence developers should follow to write more secure Cadence code.

Some practices listed below might overlap with advice in the [Cadence Anti-Patterns](./design-patterns.md) section, which is a recommended read as well.

## References

[References](./language/references.mdx) are ephemeral values and cannot be stored. If persistence is required, store a capability and borrow it when needed.

When exposing functionality, provide the least access necessary. When creating an authorized reference,
create it with only the minimal set of entitlements required to achieve the desired functionality.

## Account Storage

Don't trust a users' [account storage](./language/accounts/storage.mdx).
Users have full control over their data and may reorganize it as they see fit.
Users may store values in any path, so paths may store values of "unexpected" types.
These values may be instances of types in contracts that the user deployed.

Always [borrow](./language/accounts/capabilities.mdx) with the specific type that is expected.
Or, check if the value is an instance of the expected type.

## Authorized account references

Access to an authorized account reference (`auth(...) &Account`) gives access to entitled operations,
for example the account's storage, keys, and contracts.

Therefore, avoid passing an entitled account reference to a function,
and when defining a function,
only specify an account reference parameter with the fine-grained entitlements required to perform the necessary operations.

It is preferable to use capabilities over direct account storage access when exposing account data.
Using capabilities allows the revocation of access and limits the access to a single value with a certain set of functionality.

## Capabilities

Don't issue and publish capabilities unless really necessary.
Anyone can access capabilities that are published.
If public access is needed, follow the [principle of least privilege/authority](https://en.wikipedia.org/wiki/Principle_of_least_privilege):
Make sure that the capability type only grants access to the fields and functions that should be exposed, and nothing else.
Ideally, create a capability with a reference type that is unauthorized.

If an entitlement is necessary to access the field or function,
ensure it is only used for the particular field or function,
and not also by other fields and functions.
If needed, introduce a new, fine-grained entitlement.

When publishing a capability, a capability might already be present.
It is a good practice to check if a capability already exists with `get` before creating it.
This function will return `nil` if the capability does not exist.

If it is necessary to handle the case where borrowing a capability might fail, the `account.check` function can be used to verify that the target exists and has a valid type.

Ensure capabilities cannot be accessed by unauthorized parties. For example, capabilities should not be accessible through a public field, including public dictionaries or arrays. Exposing a capability in such a way allows anyone to borrow it and perform all actions that the capability allows.

## Transactions

Audits of Cadence code should also include [transactions](./language/transactions.md), as they may contain arbitrary code, just, like in contracts. In addition, they are given full access to the accounts of the transaction’s signers, i.e. the transaction is allowed to manipulate the signers’ account storage, contracts, and keys.

Signing a transaction gives access to the operations accessible by the entitlements specified in the parameter types of the `prepare` block.

For example, the account reference type `auth(Storage) &Auth` is authorized is perform any storage operation.

When signing a transaction, audit which entitlements are requested.

When authoring a transaction,
follow the [principle of least privilege/authority](https://en.wikipedia.org/wiki/Principle_of_least_privilege),
and only request the least and most fine-grained account entitlements necessary to perform the operations of the transactions.

## Types

Use [intersection types and interfaces](./language/intersection-types.md). Always use the most specific type possible, following the principle of least privilege. Types should always be as restrictive as possible, especially for resource types.

If given a less-specific type, cast to the more specific type that is expected. For example, when implementing the fungible token standard, a user may deposit any fungible token, so the implementation should cast to the expected concrete fungible token type.

## Access Control

Declaring a field as [`access(all)`](./language/access-control.md) only protects from replacing the field’s value, but the value itself can still be mutated if it is mutable. Remember that containers, like dictionaries, and arrays, are mutable.

Prefer non-public access to a mutable state. That state may also be nested. For example, a child may still be mutated even if its parent exposes it through a field with non-settable access.

Do not use the `access(all)` modifier on fields unless necessary.
Prefer `access(self)`, or `access(contract)` and `access(account)` when other types in the contract or account need to have access,
and entitlement-based access for other cases.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/type-inference.md

---
title: Type Inference
sidebar_position: 10
---

If a variable or constant declaration is not annotated explicitly with a type,
the declaration's type is inferred from the initial value.

### Basic Literals
Decimal integer literals and hex literals are inferred to type `Int`.

```cadence
let a = 1
// `a` has type `Int`

let b = -45
// `b` has type `Int`

let c = 0x02
// `c` has type `Int`
```

Unsigned fixed-point literals are inferred to type `UFix64`.
Signed fixed-point literals are inferred to type `Fix64`.

```cadence
let a = 1.2
// `a` has type `UFix64`

let b = -1.2
// `b` has type `Fix64`
```

Similarly, for other basic literals, the types are inferred in the following manner:

| Literal Kind      | Example           | Inferred Type (x) |
|:-----------------:|:-----------------:|:-----------------:|
| String literal    | `let x = "hello"` |  String           |
| Boolean literal   | `let x = true`    |  Bool             |
| Nil literal       | `let x = nil`     |  Never?           |


### Array Literals
Array literals are inferred based on the elements of the literal, and to be variable-size.
The inferred element type is the _least common super-type_ of all elements.

```cadence
let integers = [1, 2]
// `integers` has type `[Int]`

let int8Array = [Int8(1), Int8(2)]
// `int8Array` has type `[Int8]`

let mixedIntegers = [UInt(65), 6, 275, Int128(13423)]
// `mixedIntegers` has type `[Integer]`

let nilableIntegers = [1, nil, 2, 3, nil]
// `nilableIntegers` has type `[Int?]`

let mixed = [1, true, 2, false]
// `mixed` has type `[AnyStruct]`
```

### Dictionary Literals
Dictionary literals are inferred based on the keys and values of the literal.
The inferred type of keys and values is the _least common super-type_ of all keys and values, respectively.

```cadence
let booleans = {
    1: true,
    2: false
}
// `booleans` has type `{Int: Bool}`

let mixed = {
    Int8(1): true,
    Int64(2): "hello"
}
// `mixed` has type `{Integer: AnyStruct}`

// Invalid: mixed keys
//
let invalidMixed = {
    1: true,
    false: 2
}
// The least common super-type of the keys is `AnyStruct`.
// But it is not a valid type for dictionary keys.
```

### Ternary Expression
Ternary expression type is inferred  to be the least common super-type of the second and third operands.
```cadence
let a = true ? 1 : 2
// `a` has type `Int`

let b = true ? 1 : nil
// `b` has type `Int?`

let c = true ? 5 : (false ? "hello" : nil)
// `c` has type `AnyStruct`
```

### Functions
Functions are inferred based on the parameter types and the return type.

```cadence
let add = (a: Int8, b: Int8): Int {
    return a + b
}

// `add` has type `fun(Int8, Int8): Int`
```

Type inference is performed for each expression / statement, and not across statements.

## Ambiguities
There are cases where types cannot be inferred.
In these cases explicit type annotations are required.

```cadence
// Invalid: not possible to infer type based on array literal's elements.
//
let array = []

// Instead, specify the array type and the concrete element type, e.g. `Int`.
//
let array: [Int] = []

// Or, use a simple-cast to annotate the expression with a type.
let array = [] as [Int]
```

```cadence
// Invalid: not possible to infer type based on dictionary literal's keys and values.
//
let dictionary = {}

// Instead, specify the dictionary type and the concrete key
// and value types, e.g. `String` and `Int`.
//
let dictionary: {String: Int} = {}

// Or, use a simple-cast to annotate the expression with a type.
let dictionary = {} as {String: Int}
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/ExampleToken.cdc

```
/// ExampleToken.cdc
///
/// The ExampleToken contract is a sample implementation of a fungible token on Flow.
///
/// Fungible tokens behave like everyday currencies -- they can be minted, transferred or
/// traded for digital goods.
///
/// This is a basic implementation of a Fungible Token and is NOT meant to be used in production
/// See the Flow Fungible Token standard for real examples: https://github.com/onflow/flow-ft

access(all) contract ExampleToken {

    access(all) entitlement Withdraw

    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath

    access(all) var totalSupply: UFix64

    /// Balance
    ///
    /// The interface that provides a standard field
    /// for representing balance
    ///
    access(all) resource interface Balance {
        access(all) var balance: UFix64
    }

    /// Provider
    ///
    /// The interface that enforces the requirements for withdrawing
    /// tokens from the implementing type.
    ///
    /// It does not enforce requirements on `balance` here,
    /// because it leaves open the possibility of creating custom providers
    /// that do not necessarily need their own balance.
    ///
    access(all) resource interface Provider {

        /// withdraw subtracts tokens from the implementing resource
        /// and returns a Vault with the removed tokens.
        ///
        /// The function's access level is `access(Withdraw)`
        /// So in order to access it, one would either need the object itself
        /// or an entitled reference with `Withdraw`.
        ///
        /// @param amount the amount of tokens to withdraw from the resource
        /// @return The Vault with the withdrawn tokens
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @Vault {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    "ExampleToken.Provider.withdraw: Cannot withdraw tokens!"
                    .concat("The balance of the withdrawn tokens (").concat(result.balance.toString())
                    .concat(") is not equal to the amount requested to be withdrawn (")
                    .concat(amount.toString()).concat(")")
            }
        }
    }

    /// Receiver
    ///
    /// The interface that enforces the requirements for depositing
    /// tokens into the implementing type.
    ///
    /// We do not include a condition that checks the balance because
    /// we want to give users the ability to make custom receivers that
    /// can do custom things with the tokens, like split them up and
    /// send them to different places.
    ///
    access(all) resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        /// @param from the Vault that contains the tokens to deposit
        ///
        access(all) fun deposit(from: @Vault)
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault are governed by the pre and post conditions
    /// in the interfaces when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource or constructor function needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: Balance, Provider, Receiver {

		/// keeps track of the total balance of the account's tokens
        access(all) var balance: UFix64

        /// initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// withdraw
        ///
        /// Function that takes an integer amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the money that is being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @Vault {
            pre {
                self.balance >= amount:
                    "ExampleToken.Vault.withdraw: Cannot withdraw tokens! "
                    .concat("The amount requested to be withdrawn (").concat(amount.toString())
                    .concat(") is greater than the balance of the Vault (")
                    .concat(self.balance.toString()).concat(").")
            }
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        access(all) fun deposit(from: @Vault) {
            self.balance = self.balance + from.balance
            destroy from
        }
    }

    /// createEmptyVault
    ///
    access(all) fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

	// VaultMinter
    //
    // Resource object that an admin can control to mint new tokens
    access(all) resource VaultMinter {

		// Function that mints new tokens and deposits into an account's vault
		// using their `{Receiver}` reference.
        // We say `&{Receiver}` to say that the recipient can be any resource
        // as long as it implements the Receiver interface
        access(all) fun mintTokens(amount: UFix64, recipient: Capability<&{Receiver}>) {
            let recipientRef = recipient.borrow()
            ?? panic("ExampleToken.VaultMinter.mintTokens: Could not borrow a receiver reference to "
                     .concat("the specified recipient's ExampleToken.Vault")
                     .concat(". Make sure the account has set up its account ")
                     .concat("with an ExampleToken Vault and valid capability."))

            ExampleToken.totalSupply = ExampleToken.totalSupply + UFix64(amount)
            recipientRef.deposit(from: <-create Vault(balance: amount))
        }
    }

    /// The init function for the contract. All fields in the contract must
    /// be initialized at deployment. This is just an example of what
    /// an implementation could do in the init function. The numbers are arbitrary.
    init() {
        self.VaultStoragePath = /storage/CadenceFungibleTokenTutorialVault
        self.VaultPublicPath = /public/CadenceFungibleTokenTutorialReceiver

        self.totalSupply = 30.0

        // create the Vault with the initial balance and put it in storage
        // account.save saves an object to the specified `to` path
        // The path is a literal path that consists of a domain and identifier
        // The domain must be `storage`, `private`, or `public`
        // the identifier can be any name
        let vault <- create Vault(balance: self.totalSupply)
        self.account.storage.save(<-vault, to: self.VaultStoragePath)

        // Create a new VaultMinter resource and store it in account storage
        self.account.storage.save(<-create VaultMinter(), to: /storage/CadenceFungibleTokenTutorialMinter)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/tutorial/01-first-steps.md

---
archived: false
draft: false
title: First Steps
date: 2024-11-26
meta:
  keywords:
    - tutorial
    - Flow
    - Cadence
    - Hello World
tags:
  - reference
  - cadence
  - tutorial
socialImageTitle: Cadence First Steps
socialImageDescription: Take your first steps to learn the Cadence smart contract programming language.
---

Welcome to our series of guides that will get you up to speed on [Cadence] as quickly as possible!  In this program, you'll jump right into making meaningful projects.  Don't worry, we'll point you to the important parts of the language reference as each concept is introduced!

This series makes use of the [Flow Playground] - an online IDE that enables you to easily write and test Cadence code in a simulated environment.

:::tip

If you already know Solidity, you might want to review the [Cadence Guide for Solidity Developers].  It compares the two languages and points out the most impactful differences from the perspective of a Solidity dev.

:::

## Objectives

After completing this tutorial, you'll be able to:

* Write, deploy, and interact with Cadence code in the Flow Playground.
* Select and utilize accounts in the Flow Playground.
* Run Cadence transactions and scripts from the playground.
* Explore the contracts and storage associated with test accounts.


:::info[Action]

Instructions that require you to take action are always included in a call out box like this one.

:::

## The Flow Developer Playground

![Flow Playground](flow-playground.png)

The [Flow Playground] includes an in-browser editor and Flow emulator that you can use to experiment with Flow Cadence.  Using the Flow Playground, you can write Cadence smart contracts, deploy them to a local Flow emulated blockchain, and submit transactions.

It has been primarily tested and optimized for Google Chrome, but other browsers will should work as well.

The playground comes pre-loaded with contract and transaction templates that correspond to each of the tutorials in this series.  At the top of the page, you'll find it in a call out like this one:

:::info[Action]

Open the starter code for this tutorial in the Flow Playground: <br />
<a
  href="https://play.flow.com/367d1462-f291-481f-aa14-02bb5ce3e897"
  target="_blank"
>
  https://play.flow.com/367d1462-f291-481f-aa14-02bb5ce3e897
</a>

:::

When you click on one of these links, the tutorial code will open in a new tab and the contracts, transactions, and scripts will be loaded into the templates in the Playground for you to use. You will need to navigate between the editor and this tutorial to read instructions and make changes to your code.

## What is a smart contract?

In regular terms, a contract is an agreement between two parties for some exchange of information or assets. Normally, the terms of a contract are supervised and enforced by a trusted third party, such as a bank or a lawyer.

A smart contract is a computer program stored in a blockchain that verifies and executes the performance of a contract without the need for any trusted third party.  The code itself is public and will perform all operations in an open, repeatable, and testable manner.

Programs that run on blockchains are commonly referred to as smart contracts because they facilitate important functions, such as managing digital currency, without relying on a central authority like a bank.

Flow can run smart contracts written in [Cadence].  It can also run older contracts written in Solidity, on the [Flow EVM].  These guides focus on learning Cadence.

## Accounts

Accounts are the primary conduit for user interaction with on-chain code and assets.  Users authorize transactions with their accounts and store their owned assets in their account storage.

:::warning

Flow is different from most other blockchains in that contracts, assets, and information owned by a user or associated with their wallet address **are stored in the user's account**.  

:::

We've used the `warning` label to get your attention, but this is a **good thing**!  In most other chains, a coding error that accidentally changes a single number in a ledger can destroy, change, or duplicate ownership of an asset or assets.  It's like a medieval shop with a bunch of paper IOUs having a gust of wind blow through vs. having the gold in your pocket.

The model of ownership in Cadence makes this kind of loss nearly impossible.

The Flow playground comes with pre-created accounts that you can use for testing and experimentation.

They're listed in the `Accounts` section on the bottom left part of the playground window.

![Playground Intro](playground-intro.png)

:::info[Action]

Click on a few of the accounts.  They're empty when first created, but you'll see contracts and storage data here as you go through the tutorials.

:::

![Account View](playground-account-view.png)

## Contracts

The playground organizes contract source files under `Contracts` folder in the nav panel on the left side of the window.  Until deployed, these are source files that are not associated with an account or address.

The default contract in a new playground session is a simple `HelloWorld` contract.

When you have Cadence code open in the account editor that contains a contract, you can click the deploy button in the bottom-right of the screen to deploy that contract to the currently selected account.

![Deploy Contract](deploybox.png)

:::info[Action]

Click the button to `Deploy` the contract.

:::

After a few seconds, the contract will deploy. 

:::info[Action]

Select `0x06-Default` in the `Accounts` list.

:::


You'll see the name of the contract and the block height it was deployed at in the list of `Deployed Contracts`.  You'll also see that there are `FlowToken` objects listed in the `Account Storage` section. Every Flow account is created with the ability to manage Flow Tokens.

![Full Storage View](full-storage.png)

## Scripts

In Cadence, scripts are simple, transaction-like snippets of code that you can use to **read** onchain data that is public.

:::info[Action]

Open the `GetGreeting` script and `Execute` it.

:::

This script loads the instance of the `HelloWorld` contract you deployed with account `0x06` and returns the result of calling the `hello` function, which is the value stored onchain in the contract's `greeting` field.

You'll see the `result` logged in the console.

## Transactions

Cadence transactions are also written in Cadence.

In the `Transactions` folder, you'll find an example of one.

:::info[Action]

Open the `ChangeGreeting` transaction, enter a new `greeting`, and `Send` it. 

:::

Doing so executes a transaction to call `changeGreeting` and update the value in `greeting` for this specific instance of `HelloWorld`, deployed by address `0x06`.

Once the transaction completes, you'll see the output in the `Log` at the bottom of the window.

:::info[Action]

Open the `GetGreeting` script and `Execute` it again.

:::

You'll now see your new greeting returned in the log!

## Say Hello, World!

You're now ready to write your own contract and say "Hello World!"

Now that you have completed the tutorial, you can:

* Write, deploy, and interact with Cadence code in the Flow Playground.
* Select and utilize accounts in the Flow Playground.
* Run Cadence transactions and scripts from the playground.
* Explore the contracts and storage associated with test accounts.

<!-- Relative links.  Will not render on the page -->

[Cadence]: ../index.md
[Flow Playground]: https://play.flow.com
[Cadence Guide for Solidity Developers]: ../solidity-to-cadence.md
[Flow EVM]: https://developers.flow.com/evm/about
[Account Model]: ../docs/language/accounts/




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/access-control.md

---
title: Access control
sidebar_position: 13
---

Access control allows making certain parts of a program accessible/visible
and making other parts inaccessible/invisible.

In Cadence, access control consists of:

1. Access control on objects in account storage,
  using [capability security](./capabilities.md).

  A user is not able to access an object
  unless they own the object or have a reference to that object.
  This means that nothing is truly public by default.

  Other accounts can not read or write the objects in an account
  unless the owner of the account has granted them access
  by providing references to the objects.

  This kind of access control is covered in the pages
  on [capabilities](./capabilities.md)
  and [capability management](./accounts/capabilities.mdx).

2. Access control within contracts and objects,
  using access modifiers (`access` keyword).

This page covers the second part of access control,
using access modifiers.

All declarations, such as [function](./functions.mdx), [composite types](./composite-types.mdx), and fields,
must be prefixed with an access modifier, using the `access` keyword.

The access modifier determines where the declaration is accessible/visible.
Fields can only be assigned to and mutated from within the same or inner scope.

For example, to make a function publicly accessible (`access(all)` is explained below):

```
access(all)
fun test() {}
```

There are five levels of access control:

- **Public access** means the declaration is accessible/visible in all scopes.
  This includes the current scope, inner scopes, and the outer scopes.

  A declaration is made publicly accessible using the `access(all)` modifier.

  For example, a public field in a type can be accessed
  on an instance of the type in an outer scope.

- **Entitled access** means the declaration is only accessible/visible
  to the owner of the object, or to [references](./references.mdx)
  that are authorized to the required [entitlements](#entitlements).

  A declaration is made accessible through entitlements by using the `access(E)` syntax,
  where `E` is a set of one or more entitlements,
  or a single [entitlement mapping](#entitlement-mappings).

  A reference is considered authorized to an entitlement
  if that entitlement appears in the `auth` portion of the reference type.

  For example, an `access(E, F)` field on a resource `R` can only be accessed by an owned (`@R`-typed) value,
  or a reference to `R` that is authorized to the `E` and `F` entitlements (`auth(E, F) &R`).

- **Account access** means the declaration is only accessible/visible
  in the scope of the entire account where it is defined.
  This means that other contracts in the account are able to access it.

  A declaration is made accessible by code in the same account,
  for example other contracts, by using the `access(account)` keyword.

- **Contract access** means the declaration is only accessible/visible
  in the scope of the contract that defined it.
  This means that other declarations that are defined in the same contract can access it,
  but not other contracts in the same account.

  A declaration is made accessible by code in the same contract
  by using the `access(contract)` keyword.

- **Private access** means the declaration is only accessible/visible
  in the current and inner scopes.

  A declaration is made accessible by code in the same containing type
  by using the `access(self)` keyword.

  For example, an `access(self)` field can only be accessed
  by functions of the type is part of, not by code in an outer scope.

To summarize the behavior for variable declarations, constant declarations, and fields:

| Declaration kind | Access modifier    | Accessible in                                        | Assignable in     | Mutable in        |
|:-----------------|:-------------------|:-----------------------------------------------------|:------------------|:------------------|
| `let`            | `access(self)`     | Current and inner                                    | *None*            | Current and inner |
| `let`            | `access(contract)` | Current, inner, and containing contract              | *None*            | Current and inner |
| `let`            | `access(account)`  | Current, inner, and other contracts in same account  | *None*            | Current and inner |
| `let`            | `access(all)`      | **All**                                              | *None*            | Current and inner |
| `let`            | `access(E)`        | **All** with required entitlements                   | *None*            | Current and inner |
| `var`            | `access(self)`     | Current and inner                                    | Current and inner | Current and inner |
| `var`            | `access(contract)` | Current, inner, and containing contract              | Current and inner | Current and inner |
| `var`            | `access(account)`  | Current, inner, and other contracts in same account  | Current and inner | Current and inner |
| `var`            | `access(all)`      | **All**                                              | Current and inner | Current and inner |
| `var`            | `access(E)`        | **All** with required entitlements                   | Current and inner | Current and inner |

Declarations of [composite types](./composite-types.mdx) must be public.
However, even though the declarations/types are publicly visible,
resources can only be created, and events can only be emitted
from inside the contract they are declared in.

```cadence
// Declare a private constant, inaccessible/invisible in outer scope.
//
access(self)
let a = 1

// Declare a public constant, accessible/visible in all scopes.
//
access(all)
let b = 2
```

```cadence
// Declare a public struct, accessible/visible in all scopes.
//
access(all)
struct SomeStruct {

    // Declare a private constant field which is only readable
    // in the current and inner scopes.
    //
    access(self)
    let a: Int

    // Declare a public constant field which is readable in all scopes.
    //
    access(all)
    let b: Int

    // Declare a private variable field which is only readable
    // and writable in the current and inner scopes.
    //
    access(self)
    var c: Int

    // Declare a public variable field which is not settable,
    // so it is only writable in the current and inner scopes,
    // and readable in all scopes.
    //
    access(all)
    var d: Int

    // Arrays and dictionaries declared without (set) cannot be
    // mutated in external scopes
    access(all)
    let arr: [Int]

    // The initializer is omitted for brevity.

    // Declare a private function which is only callable
    // in the current and inner scopes.
    //
    access(self)
    fun privateTest() {
        // ...
    }

    // Declare a public function which is callable in all scopes.
    //
    access(all)
    fun publicTest() {
        // ...
    }

    // The initializer is omitted for brevity.

}

let some = SomeStruct()

// Invalid: cannot read private constant field in outer scope.
//
some.a

// Invalid: cannot set private constant field in outer scope.
//
some.a = 1

// Valid: can read public constant field in outer scope.
//
some.b

// Invalid: cannot set public constant field in outer scope.
//
some.b = 2

// Invalid: cannot read private variable field in outer scope.
//
some.c

// Invalid: cannot set private variable field in outer scope.
//
some.c = 3

// Valid: can read public variable field in outer scope.
//
some.d

// Invalid: cannot set public variable field in outer scope.
//
some.d = 4

// Invalid: cannot mutate a public field in outer scope.
//
some.f.append(0)

// Invalid: cannot mutate a public field in outer scope.
//
some.f[3] = 1

// Valid: can call non-mutating methods on a public field in outer scope
some.f.contains(0)
```

## Entitlements

Entitlements provide granular access control to each member of a composite.
Entitlements are declared using the syntax `entitlement E`,
where `E` is the name of the entitlement.

For example, the following code declares two entitlements called `E` and `F`:

```cadence
entitlement E
entitlement F
```

Entitlements can be imported from other contracts and used the same way as other types.
When using entitlements defined in another contract, the same qualified name syntax is used as for other types:

```cadence
contract C {
    entitlement E
}
```

Outside of `C`, `E` is used with `C.E` syntax.

Entitlements exist in the same namespace as types, so if a contract declares a resource called `R`,
it is impossible to declare an entitlement that is also called `R`.

Entitlements can be used in access modifiers of composite members (fields and functions)
to specify which references to those composites are allowed to access those members.

An access modifier can include more than one entitlement,
joined with either an `|`, to indicate disjunction ("or"),
or a `,`, to indicate conjunction ("and").
The two kinds of separators cannot be combined in the same set.

For example:

```cadence
access(all)
resource SomeResource {

  // requires a reference to have an `E` entitlement to read this field
  access(E)
  let a: Int

  // requires a reference to have either an `E` OR an `F` entitlement to read this field.
  access(E | F)
  let b: Int

   // requires a reference to have both an `E` AND an `F` entitlement to read this field
  access(E, F)
  let c: Int

  // intializers omitted for brevity
  // ...
}
```

Assuming the following constants exist,
which have owned or [reference](./references.mdx) types:

```cadence
let r: @SomeResource = // ...
let refE: auth(E) &SomeResource = // ...
let refF: auth(F) &SomeResource = // ...
let refEF: auth(E, F) &SomeResource = // ...
let refEOrF: auth(E | F) &SomeResource = // ...
```

The references can be used as follows:

```cadence
// valid, because `r` is owned and thus is "fully entitled"
r.a
// valid, because `r` is owned and thus is "fully entitled"
r.b
// valid, because `r` is owned and thus is "fully entitled"
r.c

// valid, because `refE` has an `E` entitlement as required
refE.a
// valid, because `refE` has one of the two required entitlements
refE.b
// invalid, because `refE` only has one of the two required entitlements
refE.c

// invalid, because `refF` has an `E` entitlement, not an `F`
refF.a
// valid, because `refF` has one of the two required entitlements
refF.b
// invalid, because `refF` only has one of the two required entitlements
refF.c

// valid, because `refEF` has an `E` entitlement
refEF.a
// valid, because `refEF` has both of the two required entitlements
refEF.b
// valid, because `refEF` has both of the two required entitlements
refEF.c

// invalid, because `refEOrF` might not have an `E` entitlement (it may have `F` instead)
refEOrF.a
// valid, because `refEOrF` has one of the two entitlements necessary
refEOrF.b
// invalid, because `refEOrF` is only known to have one of the two required entitlements
refEOrF.c
```

Note particularly in this example how the owned value `r` can access all entitled members on `SomeResource`.
Owned values are not affected by entitled declarations. 

Further details about authorized references can be found [here](./references.mdx#authorized-references).

### Entitlement mappings

Entitlement mappings are a way to statically declare how entitlements are propagated
from parents to child objects in a nesting hierarchy.

When objects have fields that are child objects, 
entitlement mappings can be used
to grant access to the inner object based on the entitlements of the reference to the parent object.

Consider the following example,
which uses entitlements to control access to an inner resource:

```cadence
entitlement OuterEntitlement
entitlement InnerEntitlement

resource InnerResource {

    access(all)
    fun foo() { ... }

    access(InnerEntitlement)
    fun bar() { ... }
}

resource OuterResource {
    access(self)
    let childResource: @InnerResource

    init(childResource: @InnerResource) {
        self.childResource <- childResource
    }

    // The parent resource has to provide two accessor functions
    // which return a reference to the inner resource.
    //
    // If the reference to the outer resource is unauthorized
    // and does not have the OuterEntitlement entitlement,
    // the outer resource allows getting an unauthorized reference
    // to the inner resource.
    //
    // If the reference to the outer resource is authorized
    // and it has the OuterEntitlement entitlement,
    // the outer resource allows getting an authorized reference
    // to the inner resource.

    access(all)
    fun getPubRef(): &InnerResource {
        return &self.childResource as &InnerResource
    }

    access(OuterEntitlement)
    fun getEntitledRef(): auth(InnerEntitlement) &InnerResource {
        return &self.childResource as auth(InnerEntitlement) &InnerResource
    }
}
```

With this pattern, it is possible to store a `InnerResource` in an `OuterResource`,
and create different ways to access that nested resource depending on the entitlement one possesses.

An unauthorized reference to `OuterResource` can only be used to call the `getPubRef` function,
and thus can only obtain an unauthorized reference to `InnerResource`.
That reference to the `InnerResource` then only allows calling the function `foo`, which is publicly accessible,
but not function `bar`, as it needs the `InnerEntitlement` entitlement, which is not granted.

However an `OuterEntitlement`-authorized reference to the `OuterResource` can be used to call the `getEntitledRef` function,
which returns a `InnerEntitlement`-authorized reference to `InnerResource`,
which in turn can be used to call function `bar`.

This pattern is functional, but it is unfortunate that the accessor functions to `InnerResource` have to be "duplicated".

Entitlement mappings should be used to avoid this duplication. 

Entitlement mappings are declared using the syntax:

```cadence
entitlement mapping M {
    // ...
}
```

Where `M` is the name of the mapping.

The body of the mapping contains zero or more rules of the form `A -> B`,
where `A` and `B` are entitlements.
Each rule declares that, given a reference with the entitlement on the left,
a reference with the entitlement on the right is produced.

An entitlement mapping thus defines a function from an input set of entitlements (called the domain)
to an output set (called the range or the image).

Using entitlement mappings, the above example could be more concisely written as:

```cadence
entitlement OuterEntitlement
entitlement InnerEntitlement

// Specify a mapping for entitlements called `OuterToInnerMap`,
// which maps the entitlement `OuterEntitlement` to the entitlement `InnerEntitlement`.
entitlement mapping OuterToInnerMap {
    OuterEntitlement -> InnerEntitlement
}

resource InnerResource {
  
    access(all)
    fun foo() { ... }

    access(InnerEntitlement)
    fun bar() { ... }
}

resource OuterResource {
    // Use the entitlement mapping `OuterToInnerMap`.
    //
    // This declares that when the field `childResource` is accessed
    // using a reference authorized with the entitlement `OuterEntitlement`,
    // then a reference with the entitlement `InnerEntitlement` is returned.
    //
    // This is equivalent to the two accessor functions
    // that were necessary in the previous example.
    //
    access(mapping OuterToInnerMap)
    let childResource: @InnerResource

    init(childResource: @InnerResource) {
        self.childResource <- childResource
    }

    // No accessor functions are needed.
}

// given some value `r` of type `@OuterResource`

let pubRef = &r as &OuterResource
let pubInnerRef = pubRef.childResource // has type `&InnerResource`

let entitledRef = &r as auth(OuterEntitlement) &OuterResource
let entitledInnerRef = entitledRef.childResource  // has type `auth(InnerEntitlement) &InnerResource`,
    // as `OuterEntitlement` is defined to map to `InnerEntitlement`.

// `r` is an owned value, and is thus considered "fully-entitled" to `OuterResource`,
// so this access yields a value authorized to the entire image of `OuterToInnerMap`,
// in this case `InnerEntitlement`, and thus can call `bar`
r.childResource.bar()
```

Entitlement mappings can be used either in accessor functions (as in the example above),
or in fields whose types are either references, or containers (composite types, dictionaries, and arrays).

Entitlement mappings need not be 1:1.
It is valid to define a mapping where many inputs map to the same output,
or where one input maps to many outputs.

Entitlement mappings preserve the "kind" of the set they are mapping.
That is, mapping a conjunction ("and") set produces a conjunction set,
and mapping a disjunction ("or") set produces a disjunction set.

Because entitlement separators cannot be combined in the same set,
attempting to map disjunction ("or") sets through certain complex mappings can result in a type error.

For example, given the following entitlement mapping:

```cadence
entitlement mapping M {
  A -> B
  A -> C
  D -> E
}
```

Attempting to map `(A | D)` through `M` will fail,
since `A` should map to `(B, C)` and `D` should map to `E`,
but these two outputs cannot be combined into a disjunction ("or") set.

A good example for how entitlement mappings can be used is the [`Account` type](./accounts/index.mdx).

### The `Identity` entitlement mapping

`Identity` is a special built-in entitlement mapping that maps every input to itself as the output.
Any entitlement set passed through the `Identity` map will come out unchanged in the output.

For instance:

```cadence
entitlement X

resource InnerResource {
    // ...
}

resource OuterResource {
    access(mapping Identity)
    let childResource: @InnerResource

    access(mapping Identity)
    getChildResource(): auth(mapping Identity) &InnerResource {
        return &self.childResource
    }

    init(childResource: @InnerResource) {
        self.childResource <- childResource
    }
}

fun example(outerRef: auth(X) &OuterResource) {
    let innerRef = outerRef.childResource // `innerRef` has type `auth(X) &InnerResource`,
        // as `outerRef` was authorized with entitlement `X`
}
```

One important point to note about the `Identity` mapping, however,
is that its full output range is unknown, and theoretically infinite.
Because of that,
accessing an `Identity`-mapped field or function with an owned value will yield an empty output set.

For example, calling `getChildResource()` on an owned `OuterResource` value,
will produce an unauthorized `&InnerResource` reference.

### Mapping composition

Entitlement mappings can be composed.
In the definition of an entitlement mapping,
it is possible to include the definition of one or more other mappings,
to copy over their mapping relations.

An entitlement mapping is included into another entitlement mapping using the `include M` syntax,
where `M` is the name of the entitlement mapping to be included.

In general, an `include M` statement in the definition of an entitlement mapping `N`
is equivalent to simply copy-pasting all the relations defined in `M` into `N`'s definition.

Support for `include` is provided primarily to reduce code-reuse and promote composition.

For example:

```cadence
entitlement mapping M {
  X -> Y
  Y -> Z
}

entitlement mapping N {
  E -> F
}

entitlement mapping P {
  include M
  include N
  F -> G
}
```

The entitlement mapping `P` includes all of the relations defined in `M` and `N`,
along with the additional relations defined in its own definition.

It is also possible to include the `Identity` mapping.
Any mapping `M` that includes the `Identity` mapping will map its input set to itself,
along with any additional relations defined in the mapping,
or in other included mappings.

For instance:

```cadence
entitlement mapping M {
    include Identity
    X -> Y
}
```

The mapping `M` maps the entitlement set `(X)` to `(X, Y)`,
and `(Y)` to `(Y)`.

Includes that produce a cyclical mapping are rejected by the type-checker.

### Built-in mutability entitlements

A prominent use-case of entitlements is to control access to object based on mutability.

For example, in a composite, the author would want to control the access to certain fields to be read-only,
and some fields to be mutable, etc.

In order to support this, the following built-in entitlements can be used:
- `Insert`
- `Remove`
- `Mutate`

These are primarily used by the built-in [array](./values-and-types.mdx#arrays)
and [dictionary](./values-and-types.mdx#dictionaries) functions,
but are available to be used in access modifiers of any declaration.

While Cadence does not support entitlement composition or inheritance,
the `Mutate` entitlement is intended to be used as an equivalent form
to the conjunction of the `(Insert, Remove)` entitlement set.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/cadence-lang.org/blob/main/docs/language/scope.md

---
title: Scope
sidebar_position: 8
---

Every function and block (`{` ... `}`) introduces a new scope for declarations.
Each function and block can refer to declarations in its scope or any of the outer scopes.

```cadence
let x = 10

fun f(): Int {
    let y = 10
    return x + y
}

f()  // is `20`

// Invalid: the identifier `y` is not in scope.
//
y
```

```cadence
fun doubleAndAddOne(_ n: Int): Int {
    fun double(_ x: Int) {
        return x * 2
    }
    return double(n) + 1
}

// Invalid: the identifier `double` is not in scope.
//
double(1)
```

Each scope can introduce new declarations, i.e., the outer declaration is shadowed.

```cadence
let x = 2

fun test(): Int {
    let x = 3
    return x
}

test()  // is `3`
```

Scope is lexical, not dynamic.

```cadence
let x = 10

fun f(): Int {
   return x
}

fun g(): Int {
   let x = 20
   return f()
}

g()  // is `10`, not `20`
```

Declarations are **not** moved to the top of the enclosing function (hoisted).

```cadence
let x = 2

fun f(): Int {
    if x == 0 {
        let x = 3
        return x
    }
    return x
}
f()  // is `2`
```






---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_stake_requirements.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(role: UInt8): UFix64 {
    let req = FlowIDTableStaking.getMinimumStakeRequirements()

    return req[role]!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_deploy_contract.cdc

```
import Crypto

transaction(contractName: String, code: String, publicKeys: [Crypto.KeyListEntry]) {
    
    prepare(admin: auth(Storage, BorrowValue) &Account) {
        let lockedTokens = Account(payer: admin)
        lockedTokens.contracts.add(name: contractName, code: code.decodeHex(), admin)

        for key in publicKeys {
            lockedTokens.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/scripts/get_storage_fee_min.cdc

```
import "FlowStorageFees"

access(all) fun main(): UFix64 {
    return FlowStorageFees.minimumStorageReservation
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/remove_node.cdc

```
import "FlowIDTableStaking"

// This transaction removes an existing node from the identity table

transaction(id: String) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.removeAndRefundNodeRecord(id)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/end_epoch_change_payout.cdc

```
import "FlowIDTableStaking"

// This transaction effectively ends the epoch and starts a new one.
//
// It combines the end_staking and move_tokens transactions
// which ends the staking auction, which refunds nodes with insufficient stake
// and moves tokens between buckets

transaction(ids: {String: Bool}, newPayout: UFix64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {

        self.adminRef.setEpochTokenPayout(newPayout)

        self.adminRef.setApprovedList(ids)

        self.adminRef.endStakingAuction()

        self.adminRef.moveTokens(newEpochCounter: 2)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/admin/force_stop_dkg.cdc

```
import "FlowDKG"

transaction {

    let dkgAdmin: &FlowDKG.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgAdmin = signer.storage.borrow<&FlowDKG.Admin>(from: FlowDKG.AdminStoragePath)
            ?? panic("Could not borrow DKG Admin reference")
    }

    execute {
        self.dkgAdmin.forceEndDKG()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/randomBeaconHistory/scripts/get_backfiller_max_entries.cdc

```
import "RandomBeaconHistory"

access(all) fun main(backfillerAddress: Address): UInt64? {
    let backfiller = getAuthAccount<auth(BorrowValue) &Account>(backfillerAddress).storage.borrow<&RandomBeaconHistory.Backfiller>(from: /storage/randomBeaconHistoryBackfiller)
    return backfiller?.getMaxEntriesPerCall() ?? nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_open_access_node_slots.cdc

```
import "FlowIDTableStaking"

/// This transaction sets the open node slots for access nodes
/// Open node slots are the number of slots that are open
/// each epoch, regardless of how many nodes joined in the previous epoch.
/// They are refreshed each epoch

transaction(openAccessSlots: UInt16) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {

        var openSlotDictionary: {UInt8: UInt16} = {}

        openSlotDictionary.insert(key: 5, openAccessSlots)

        self.adminRef.setOpenNodeSlots(openSlots: openSlotDictionary)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_info_from_address.cdc

```
import "FlowIDTableStaking"

// This script gets all the info about a delegator and returns it

access(all) fun main(address: Address): FlowIDTableStaking.DelegatorInfo {

    let delegator = getAccount(address)
        .capabilities.borrow<&{FlowIDTableStaking.NodeDelegatorPublic}>(/public/flowStakingDelegator)
        ?? panic("Could not borrow reference to delegator object")

    return FlowIDTableStaking.DelegatorInfo(nodeID: delegator.nodeID, delegatorID: delegator.id)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/withdraw_rewarded_tokens.cdc

```
import "LockedTokens"
import "FlowToken"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder
    let vaultRef: &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")

        self.vaultRef = account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FlowToken value")
    }

    execute {
        let delegatorProxy = self.holderRef.borrowDelegator()

        delegatorProxy.withdrawRewardedTokens(amount: amount)
        self.vaultRef.deposit(from: <-self.holderRef.withdraw(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/custody_create_account_with_lease_account.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

/// Transaction that a custody provider would sign
/// to create a shared account and an unlocked
/// account for a user

transaction(
    fullAdminPublicKey: Crypto.KeyListEntry, // Weight: 1000
    fullUserPublicKey: Crypto.KeyListEntry, // Weight: 1000
)  {

    prepare(custodyProvider: auth(BorrowValue) &Account) {

        let sharedAccount = Account(payer: custodyProvider)
        let userAccount = Account(payer: custodyProvider)

        sharedAccount.keys.add(publicKey: fullAdminPublicKey.publicKey, hashAlgorithm: fullAdminPublicKey.hashAlgorithm, weight: fullAdminPublicKey.weight)

        userAccount.keys.add(publicKey: fullUserPublicKey.publicKey, hashAlgorithm: fullUserPublicKey.hashAlgorithm, weight: fullUserPublicKey.weight)

        let vaultCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)

        let lockedTokenManager <- LockedTokens.createLockedTokenManager(vault: vaultCapability)

        sharedAccount.storage.save(<-lockedTokenManager, to: LockedTokens.LockedTokenManagerStoragePath)

        let tokenManagerCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let tokenHolder <- LockedTokens.createTokenHolder(lockedAddress: sharedAccount.address, tokenManager: tokenManagerCapability)

        userAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let tokenHolderCap = userAccount.capabilities.storage.issue<&LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        userAccount.capabilities.publish(tokenHolderCap, at: LockedTokens.LockedAccountInfoPublicPath)

        let tokenAdminCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let lockedAccountCreator = custodyProvider.storage
            .borrow<auth(LockedTokens.AccountCreator) &LockedTokens.LockedAccountCreator>(from: LockedTokens.LockedAccountCreatorStoragePath)
            ?? panic("Could not borrow locked account creator")

        lockedAccountCreator.addAccount(
            sharedAccountAddress: sharedAccount.address,
            unlockedAccountAddress: userAccount.address,
            tokenAdmin: tokenAdminCapability
        )

        // Override the default FlowToken receiver.
        sharedAccount.capabilities.unpublish(/public/flowTokenReceiver)

        // create new receiver that marks received tokens as unlocked.
        let lockedTokensManagerCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(LockedTokens.LockedTokenManagerStoragePath)
        sharedAccount.capabilities.publish(
            lockedTokensManagerCap,
            at: /public/flowTokenReceiver
        )

        // put normal receiver in a separate unique path.
        let tokenReceiverCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(/storage/flowTokenVault)
        sharedAccount.capabilities.publish(
            tokenReceiverCap,
            at: /public/lockedFlowTokenReceiver
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/get_unlock_limit.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): UFix64 {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getUnlockLimit()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_thresholds.cdc

```
import "FlowDKG"

access(all) struct Thresholds {
    access(all) let native: UInt64
    access(all) let safe: UInt64
    access(all) let safePercentage: UFix64

    init() {
        self.native = FlowDKG.getNativeSuccessThreshold()
        self.safe = FlowDKG.getSafeSuccessThreshold()
        self.safePercentage = FlowDKG.getSafeThresholdPercentage() ?? 0.0
    }
}

access(all) fun main(): Thresholds {
    return Thresholds()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_all_delegator_info.cdc

```
import "FlowStakingCollection"
import "FlowIDTableStaking"

/// Gets an array of all the delegator metadata for delegators stored in the staking collection

access(all) fun main(address: Address): [FlowIDTableStaking.DelegatorInfo] {
    return FlowStakingCollection.getAllDelegatorInfo(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_node_final_submission.cdc

```
import "FlowDKG"

access(all) fun main(nodeID: String): FlowDKG.ResultSubmission {
    return FlowDKG.getNodeFinalSubmission(nodeID)!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/randomBeaconHistory/scripts/get_source_of_randomness_page.cdc

```
import "RandomBeaconHistory"

/// Retrieves the source of randomness for the requested block height from the RandomBeaconHistory contract.
///
access(all) fun main(page: UInt64, perPage: UInt64): RandomBeaconHistory.RandomSourceHistoryPage {
    return RandomBeaconHistory.getRandomSourceHistoryPage(page, perPage: perPage)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster_node_weights.cdc

```
import "FlowClusterQC"

access(all) fun main(clusterIndex: UInt16): {String: UInt64} {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].nodeWeights

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/stake_new_tokens.cdc

```
import "FlowToken"
import "FungibleToken"
import "LockedTokens"
import "StakingProxy"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")

        self.vaultRef = account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow flow token vault reference")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        let lockedBalance = self.holderRef.getLockedAccountBalance()

        if amount <= lockedBalance {

            stakerProxy.stakeNewTokens(amount: amount)

        } else if ((amount - lockedBalance) <= self.vaultRef.balance) {

            self.holderRef.deposit(from: <-self.vaultRef.withdraw(amount: amount - lockedBalance))

            stakerProxy.stakeNewTokens(amount: amount)
            
        } else {
            panic("Not enough tokens to stake!")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/admin/publish_admin.cdc

```
import "FlowDKG"

// This transaction is only for testing!
transaction {

    prepare(signer: auth(Capabilities) &Account) {
        let adminCap = signer.capabilities.storage.issue<&FlowDKG.Admin>(FlowDKG.AdminStoragePath)
        signer.capabilities.publish(adminCap, at: /public/dkgAdmin)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_approved_but_not_staked_nodes.cdc

```
import "FlowIDTableStaking"

// This script returns the list of nodes that are on the approved list but do not currently have tokens staked above the minimum requirement.
access(all) fun main(): [String] {
    let approvedIDs = FlowIDTableStaking.getApprovedList()
    let stakedIDs = FlowIDTableStaking.getStakedNodeIDs()

    let stakedIDsMap: {String: Bool} = {}
    for stakedID in stakedIDs {
        stakedIDsMap[stakedID] = true
    }

    let extraNodeIDs: [String] = []
    for approvedID in approvedIDs {
        if stakedIDsMap[approvedID] != true {
            extraNodeIDs.append(approvedID)
        }
    }
    return extraNodeIDs
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_next_version_update_sequence.cdc

```
import "NodeVersionBeacon"

/// Gets the next sequence number for the table updated event
access(all) fun main(): UInt64 {
    return NodeVersionBeacon.getNextVersionBeaconSequence()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_clusters.cdc

```
import "FlowEpoch"

transaction(newNumClusters: UInt16) {
    prepare(signer: auth(BorrowValue) &Account) {

        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateNumCollectorClusters(newNumClusters)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/register_delegator.cdc

```
import "FlowIDTableStaking"
import "FlowToken"
import "FungibleToken"

transaction(nodeID: String, amount: UFix64) {

    prepare(acct: auth(Storage, Capabilities) &Account) {

        let flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

        // Create a new delegator object for the node
        let newDelegator <- FlowIDTableStaking.registerNewDelegator(nodeID: nodeID, tokensCommitted: <-flowTokenRef.withdraw(amount: amount))

        // Store the delegator object
        acct.storage.save(<-newDelegator, to: FlowIDTableStaking.DelegatorStoragePath)

        let delegatorCap = acct.capabilities.storage.issue<&{FlowIDTableStaking.NodeDelegatorPublic}>(FlowIDTableStaking.DelegatorStoragePath)
        acct.capabilities.publish(delegatorCap, at: /public/flowStakingDelegator)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/CODE_OF_CONDUCT.md

# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at os@dapperlabs.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/set_automatic_rewards.cdc

```
import "FlowEpoch"

transaction(automaticRewardsEnabled: Bool) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateAutomaticRewardsEnabled(automaticRewardsEnabled)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/scale_rewards_test.cdc

```
import "FlowIDTableStaking"

transaction {

    prepare(acct: &Account) {
        let rewardsBreakdown = FlowIDTableStaking.RewardsBreakdown(nodeID: "000000001")

        rewardsBreakdown.setNodeRewards(1000.0)
        rewardsBreakdown.setDelegatorReward(delegatorID: 1 as UInt32, rewards: 100.0)

        rewardsBreakdown.scaleAllRewards(scalingFactor: 0.5)
        assert(
            rewardsBreakdown.nodeRewards == 500.0,
            message: "wrong node rewards scale"
        )

        let delegatorRewards = rewardsBreakdown.delegatorRewards[1 as UInt32]!

        assert(
            delegatorRewards == 50.0,
            message: "wrong delegator rewards scale"
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_phase.cdc

```
import "FlowEpoch"

access(all) fun main(): UInt8 {
    return FlowEpoch.currentEpochPhase.rawValue
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/pay_rewards.cdc

```
import "FlowIDTableStaking"

// This transaction pays rewards to all the staked nodes

transaction {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        let summary = self.adminRef.calculateRewards()
        self.adminRef.payRewards(forEpochCounter: 1, rewardsSummary: summary)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_unstaking_request.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of unstaking tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensRequestedToUnstake
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/remove_staking_proxy.cdc

```
import "StakingProxy"

transaction(nodeID: String) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: paStakingProxy.NodeOperatorCapabilityStoragePathth)

        proxyHolder.removeStakingProxy(nodeID: nodeID)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/stake_new_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"
import "FungibleToken"

transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    let flowTokenRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")

        self.flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")
    }

    execute {
        self.stakerRef.stakeNewTokens(<-self.flowTokenRef.withdraw(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_role.cdc

```
import "FlowIDTableStaking"

// This script returns the role of a node

access(all) fun main(nodeID: String): UInt8 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.role
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_unstaking_request.cdc

```
import "FlowIDTableStaking"

// This script returns the requested unstaking amount for a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensRequestedToUnstake
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/admin/set_safe_threshold.cdc

```
import "FlowDKG"

transaction(newThresholdPercentage: UFix64?) {

    let dkgAdmin: &FlowDKG.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgAdmin = signer.storage.borrow<&FlowDKG.Admin>(from: FlowDKG.AdminStoragePath)
            ?? panic("Could not borrow DKG Admin reference")
    }

    execute {
        self.dkgAdmin.setSafeSuccessThreshold(newThresholdPercentage: newThresholdPercentage)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_is_account_creation_restricted.cdc

```
import "FlowServiceAccount"

access(all) fun main(): Bool {
    return FlowServiceAccount.isAccountCreationRestricted()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/admin/stop_dkg.cdc

```
import "FlowDKG"

transaction {

    let dkgAdmin: &FlowDKG.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgAdmin = signer.storage.borrow<&FlowDKG.Admin>(from: FlowDKG.AdminStoragePath)
            ?? panic("Could not borrow DKG Admin reference")
    }

    execute {
        self.dkgAdmin.endDKG()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_current_view.cdc

```
// Returns the view of the current block

access(all) fun main(): UInt64 {
    let currentBlock = getCurrentBlock()
    return currentBlock.view
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_table.cdc

```
import "FlowIDTableStaking"

// This script returns the current identity table length

access(all) fun main(): [String] {
    return FlowIDTableStaking.getNodeIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/check_shared_registration.cdc

```
import "FungibleToken"
import "FlowToken"

import "LockedTokens"

transaction(lockedAccount: Address) {

    prepare(signer: auth(BorrowValue) &Account) {

        let adminRef = signer.storage.borrow<&LockedTokens.TokenAdminCollection>(from: LockedTokens.LockedTokenAdminCollectionStoragePath)
            ?? panic("Could not borrow a reference to the locked token admin collection")

        assert (
            adminRef.getAccount(address: lockedAccount) != nil,
            message: "The specified account is not a locked account! Cannot send locked tokens"
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_account_fee.cdc

```
import "FlowServiceAccount"

access(all) fun main(): UFix64 {
    return FlowServiceAccount.accountCreationFee
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_slot_limits.cdc

```
import "FlowIDTableStaking"

// This script returns the slot limits for node roles

access(all) fun main(role: UInt8): UInt16 {
    let slotLimit = FlowIDTableStaking.getRoleSlotLimits()[role]
        ?? panic("Could not find slot limit for the specified role")

    return slotLimit
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/CONTRIBUTING.md

# Contributing to the Flow Core Contracts

The following is a set of guidelines for contributing to the Flow core contracts. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request.

#### Table Of Contents

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Pull Requests](#pull-requests)

[Styleguides](#styleguides)

- [Git Commit Messages](#git-commit-messages)

[Additional Notes](#additional-notes)


## How Can I Contribute?

You are free to contribute however you want! You can submit a bug report in an issue, suggest an enhancment, or even just make a PR for us to review. We just ask that you are clear in your communication and documentation of all your work so we can understand how you are trying to help.

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported. If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible. When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include screenshots and animated GIFs** which show you following the described steps and clearly demonstrate the problem. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

- **What's the name and version of the OS you're using**?
- **What's the name and version of the flow-cli that you are using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**. Include copy/pasteable snippets which you use in those examples, as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Include screenshots and animated GIFs**. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.
- **Explain why this enhancement would be useful** to be included in the standard.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

Before contributing, make sure to examine the project to get familiar with the patterns and style already being used.

### Git Commit Messages

- Use the present tense ("Add feature" not "Added feature")
- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
- Limit the first line to 72 characters or less
- Reference issues and pull requests liberally after the first line


### Additional Notes

Thank you for your interest in contributing to the Flow smart contracts!




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_request_unstaking.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the Delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to delegator")

    }

    execute {

        self.delegatorRef.requestUnstaking(amount: amount)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/create_machine_account.cdc

```
import Crypto
import "FlowStakingCollection"

/// Creates a machine account for a node that is already in the staking collection
/// and adds public keys to the new account

transaction(nodeID: String, 
            machineAccountKey: String, 
            machineAccountKeySignatureAlgorithm: UInt8, 
            machineAccountKeyHashAlgorithm: UInt8) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        pre {
			machineAccountKeySignatureAlgorithm == 1 || machineAccountKeySignatureAlgorithm == 2:
                "Cannot create machine account: Must provide a signature algorithm raw value that corresponds to "
                .concat("one of the available signature algorithms for Flow keys.")
                .concat("You provided ").concat(machineAccountKeySignatureAlgorithm.toString())
                .concat(" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).")
			machineAccountKeyHashAlgorithm == 1 || machineAccountKeyHashAlgorithm == 3:
                "Cannot create machine account: Must provide a hash algorithm raw value that corresponds to "
                .concat("one of of the available hash algorithms for Flow keys.")
                .concat("You provided ").concat(machineAccountKeyHashAlgorithm.toString())
                .concat(" but the options are either 1 (SHA2_256) or 3 (SHA3_256).")
		}

        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))

        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {
            let sigAlgo = SignatureAlgorithm(rawValue: machineAccountKeySignatureAlgorithm)!

            let hashAlgo = HashAlgorithm(rawValue: machineAccountKeyHashAlgorithm)!
            
            let publicKey = PublicKey(
			    publicKey: machineAccountKey.decodeHex(),
			    signatureAlgorithm: sigAlgo
		    )
            machineAccount.keys.add(publicKey: publicKey, hashAlgorithm: hashAlgo, weight: 1000.0)
        } else {
            panic("Could not create a machine account for the node")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/get_delegator_id.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): UInt32 {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getDelegatorID()!
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/add_approved_and_limits.cdc

```
import "FlowIDTableStaking"

/// This transaction adds node IDs to the list of approved nodes in
/// the ID table. 
/// It also increases slot limits
/// by the number of nodes who are added
///
/// If any of the provided nodes already exist in the ID table, this
/// transaction will not revert (idempotent)

transaction(newApprovedIDs: [String]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
		let existingApprovedIDs = FlowIDTableStaking.getApprovedList()
			?? panic("Could not load approved list")

		let slotLimits = FlowIDTableStaking.getRoleSlotLimits()

		// add any new node ID which doesn't already exist in the approve list
		// and increase the candidate node limits and slot limits by 1
		// for each corresponding node added
		for newNodeID in newApprovedIDs {
			if existingApprovedIDs[newNodeID] != nil {
    			continue
			}

			let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: newNodeID)

			slotLimits[nodeInfo.role] = slotLimits[nodeInfo.role]! + 1

			existingApprovedIDs[newNodeID] = true
		}

		// set the approved list to the union of existing and new node IDs
        self.adminRef.setApprovedList(existingApprovedIDs)

		// Set new slot limits
		self.adminRef.setSlotLimits(slotLimits: slotLimits)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_candidate_nodes.cdc

```
import "FlowIDTableStaking"

// This script returns the list of candidate nodes
// for the upcoming epoch
access(all) fun main(): {UInt8: {String: Bool}} {
    return FlowIDTableStaking.getCandidateNodeList()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/custody_create_only_lease_account.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

/// Transaction that a custody provider would sign
/// to create a shared account for a user who already
/// has their unlocked account created
///
/// The unlocked account has to sign the transaction also

transaction(
    fullAdminPublicKey: Crypto.KeyListEntry, // Weight: 1000
)  {

    prepare(custodyProvider: auth(BorrowValue) &Account, userAccount: auth(Storage, Capabilities) &Account) {

        let sharedAccount = Account(payer: custodyProvider)

        sharedAccount.keys.add(publicKey: fullAdminPublicKey.publicKey, hashAlgorithm: fullAdminPublicKey.hashAlgorithm, weight: fullAdminPublicKey.weight)

        let vaultCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)

        let lockedTokenManager <- LockedTokens.createLockedTokenManager(vault: vaultCapability)

        sharedAccount.storage.save(<-lockedTokenManager, to: LockedTokens.LockedTokenManagerStoragePath)

        let tokenManagerCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let tokenHolder <- LockedTokens.createTokenHolder(
            lockedAddress: sharedAccount.address,
            tokenManager: tokenManagerCapability
        )

        userAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let tokenHolderCap = userAccount.capabilities.storage.issue<&LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        userAccount.capabilities.publish(tokenHolderCap, at: LockedTokens.LockedAccountInfoPublicPath)

        let tokenAdminCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let lockedAccountCreator = custodyProvider.storage
            .borrow<auth(LockedTokens.AccountCreator) &LockedTokens.LockedAccountCreator>(from: LockedTokens.LockedAccountCreatorStoragePath)
            ?? panic("Could not borrow locked account creator")

        lockedAccountCreator.addAccount(
            sharedAccountAddress: sharedAccount.address,
            unlockedAccountAddress: userAccount.address,
            tokenAdmin: tokenAdminCapability
        )

        // Override the default FlowToken receiver.
        sharedAccount.capabilities.unpublish(/public/flowTokenReceiver)

        // create new receiver that marks received tokens as unlocked.
        let lockedTokensManagerCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(LockedTokens.LockedTokenManagerStoragePath)
        sharedAccount.capabilities.publish(
            lockedTokensManagerCap,
            at: /public/flowTokenReceiver
        )

        // put normal receiver in a separate unique path.
        let tokenReceiverCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(/storage/flowTokenVault)
        sharedAccount.capabilities.publish(
            tokenReceiverCap,
            at: /public/lockedFlowTokenReceiver
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_non_operational.cdc

```
import "FlowIDTableStaking"

// This transaction sets the list of nodes who are non operational
// and whose rewards will be withheld

transaction(ids: [String]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        let nodeList: {String: UFix64} = {}
        for id in ids {
            nodeList[id] = 0.0
        }

        self.adminRef.setNonOperationalNodesList(nodeList)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/stake_unstaked_tokens.cdc

```
import "LockedTokens"
import "StakingProxy"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.stakeUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/scripts/get_accounts_capacity_for_transaction_storage_check.cdc

```
import "FlowStorageFees"

access(all) fun main(accountAddresses: [Address], payer: Address, maxTxFees: UFix64): [UFix64] {
    return FlowStorageFees.getAccountsCapacityForTransactionStorageCheck(
        accountAddresses: accountAddresses, 
        payer: payer, 
        maxTxFees: maxTxFees)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/withdraw_tokens.cdc

```
import "FungibleToken"
import "FlowToken"
import "LockedTokens"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder
    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        self.holderRef = acct.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Cannot withdraw locked tokens! The signer of the transaction "
                    .concat("does not have an associated locked account, ")
                    .concat("so there are no locked tokens to withdraw."))

        self.vaultRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("The signer does not store a FlowToken Vault object at the path "
                    .concat("/storage/flowTokenVault. ")
                    .concat("The signer must initialize their account with this vault first!"))
    }

    execute {
        self.vaultRef.deposit(from: <-self.holderRef.withdraw(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/transfer_node.cdc

```
import "FlowStakingCollection"

// Transfers a NodeStaker object from an authorizers account
// and adds the NodeStaker to another accounts Staking Collection
// identified by the to Address.

transaction(nodeID: String, to: Address) {
    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection
    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.
        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {
            panic(FlowStakingCollection.getCollectionMissingError(to))
        }

        // Get a reference to the authorizers StakingCollection
        self.fromStakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))

        // Get the PublicAccount of the account to transfer the NodeStaker to. 
        let toAccount = getAccount(to)

        // Borrow a capability to the public methods available on the receivers StakingCollection.
        self.toStakingCollectionCap = toAccount.capabilities
            .borrow<&FlowStakingCollection.StakingCollection>(FlowStakingCollection.StakingCollectionPublicPath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(to))

        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]
            ?? panic("Could not get machine account info from the signer's account for the node ID "
                    .concat(nodeID).concat(". Make sure that the node has configured a machine account ")
                    .concat("and has it registered in the staking collection."))

        // Remove the NodeStaker from the authorizers StakingCollection.
        let nodeStaker <- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)

        // Deposit the NodeStaker to the receivers StakingCollection.
        self.toStakingCollectionCap.addNodeObject(<- nodeStaker!, machineAccountInfo: machineAccountInfo)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/update_networking_address.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(newAddress: String) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.updateNetworkingAddress(newAddress)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/deposit_locked_tokens.cdc

```
import "FungibleToken"
import "FlowToken"

import "LockedTokens"

transaction(to: Address, amount: UFix64) {

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(admin: auth(BorrowValue) &Account) {

        // Get a reference to the admin's stored vault
        let vaultRef = admin.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
			?? panic("Could not borrow reference to the owner's Vault!")

        let adminRef = admin.storage
            .borrow<&LockedTokens.TokenAdminCollection>(
                from: LockedTokens.LockedTokenAdminCollectionStoragePath
            )
            ?? panic("Could not borrow a reference to the locked token admin collection")

        assert(
            adminRef.getAccount(address: to) != nil,
            message: "The specified account is not a locked account! Cannot send locked tokens"
        )

        // Withdraw tokens from the admin's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient
            .capabilities.borrow<&{FungibleToken.Receiver}>(
                /public/lockedFlowTokenReceiver
            )
			?? panic("Could not borrow receiver reference to the recipient's locked Vault")

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_is_account_creator.cdc

```
import "FlowServiceAccount"

access(all) fun main(address: Address): Bool {
    return FlowServiceAccount.isAccountCreator(address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/capability_end_epoch.cdc

```
import "FlowIDTableStaking"

// This transaction uses a staking admin capability
// to pay rewards, end the staking auction, and end the epoch.
//
// It combines the pay_rewards, end_staking and move_tokens transactions
// which ends the staking auction, which refunds nodes with insufficient stake
// and moves tokens between buckets
// It also sets a new token payout for the next epoch

transaction(ids: {String: Bool}, newPayout: UFix64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(CopyValue) &Account) {
        let adminCapability = acct.storage.copy<Capability>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not get capability from account storage")

        // borrow a reference to the admin object
        self.adminRef = adminCapability.borrow<&FlowIDTableStaking.Admin>()
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {

        let rewardsSummary = self.adminRef.calculateRewards()
        self.adminRef.payRewards(forEpochCounter: 1, rewardsSummary: rewardsSummary)

        self.adminRef.setEpochTokenPayout(newPayout)

        self.adminRef.setApprovedList(ids)

        self.adminRef.endStakingAuction()

        self.adminRef.moveTokens(newEpochCounter: 2)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_staked.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensStaked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_clusters.cdc

```
import "FlowClusterQC"

// Script to return an array of Collector Clusters with all of their metadata

access(all) fun main(clusterIndex: UInt16): [FlowClusterQC.Cluster] {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex]

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_node_is_registered.cdc

```
import "FlowDKG"

access(all) fun main(nodeID: String): Bool {
    return FlowDKG.participantIsRegistered(nodeID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster.cdc

```
import "FlowClusterQC"

access(all) fun main(clusterIndex: UInt16): FlowClusterQC.Cluster {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex]

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_rewarded_tokens.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of rewarded tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensRewarded
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/custody_create_only_shared_account.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

/// Transaction that a custody provider would sign
/// to create a shared account for a user who already
/// has their unlocked account created
///
/// The unlocked account has to sign the transaction also

transaction(
    partialAdminPublicKey: Crypto.KeyListEntry, // Weight: 100
    partialUserPublicKey: Crypto.KeyListEntry, // Weight: 900
)  {

    prepare(custodyProvider: auth(BorrowValue) &Account, userAccount: auth(Storage, Capabilities) &Account) {

        let sharedAccount = Account(payer: custodyProvider)

        sharedAccount.keys.add(publicKey: partialAdminPublicKey.publicKey, hashAlgorithm: partialAdminPublicKey.hashAlgorithm, weight: partialAdminPublicKey.weight)
        sharedAccount.keys.add(publicKey: partialUserPublicKey.publicKey, hashAlgorithm: partialUserPublicKey.hashAlgorithm, weight: partialUserPublicKey.weight)

        let vaultCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)

        let lockedTokenManager <- LockedTokens.createLockedTokenManager(vault: vaultCapability)

        sharedAccount.storage.save(<-lockedTokenManager, to: LockedTokens.LockedTokenManagerStoragePath)

        let tokenManagerCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let tokenHolder <- LockedTokens.createTokenHolder(
            lockedAddress: sharedAccount.address,
            tokenManager: tokenManagerCapability
        )

        userAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let tokenHolderCap = userAccount.capabilities.storage.issue<&LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        userAccount.capabilities.publish(tokenHolderCap, at: LockedTokens.LockedAccountInfoPublicPath)

        let tokenAdminCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let lockedAccountCreator = custodyProvider.storage
            .borrow<auth(LockedTokens.AccountCreator) &LockedTokens.LockedAccountCreator>(from: LockedTokens.LockedAccountCreatorStoragePath)
            ?? panic("Could not borrow locked account creator")

        lockedAccountCreator.addAccount(
            sharedAccountAddress: sharedAccount.address,
            unlockedAccountAddress: userAccount.address,
            tokenAdmin: tokenAdminCapability
        )

        // Override the default FlowToken receiver.
        sharedAccount.capabilities.unpublish(/public/flowTokenReceiver)

        // create new receiver that marks received tokens as unlocked.
        let lockedTokensManagerCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(LockedTokens.LockedTokenManagerStoragePath)
        sharedAccount.capabilities.publish(
            lockedTokensManagerCap,
            at: /public/flowTokenReceiver
        )

        // put normal receiver in a separate unique path.
        let tokenReceiverCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(/storage/flowTokenVault)
        sharedAccount.capabilities.publish(
            tokenReceiverCap,
            at: /public/lockedFlowTokenReceiver
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/set_protocol_state_version.cdc

```
import "NodeVersionBeacon"

/// Transaction that allows NodeVersionAdmin to specify a new protocol state version.
/// The new version will become active at view `activeView` if:
///  - newProtocolVersion is one greater than the current protocol version
///  - the service event is processed and applied to the protocol state within a block `B` 
///    such that `B.view + ∆ < activeView`, for a protocol-defined safety threshold ∆.
/// Service events not meeting these conditions are discarded.

transaction(newProtocolVersion: UInt64, activeView: UInt64) {

  let adminRef: &NodeVersionBeacon.Admin

  prepare(acct: auth(BorrowValue) &Account) {
    // Borrow a reference to the NodeVersionAdmin implementing resource
    self.adminRef = acct.storage.borrow<&NodeVersionBeacon.Admin>(from: NodeVersionBeacon.AdminStoragePath)
      ?? panic("Couldn't borrow NodeVersionBeacon.Admin Resource")
  }

  execute {
    self.adminRef.emitProtocolStateVersionUpgrade(newProtocolVersion: newProtocolVersion, activeView: activeView)
  }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/heartbeat.cdc

```
import "NodeVersionBeacon"

// Calls the method that emits the table with the incoming versions
transaction() {

    let NodeVersionBeaconHeartbeatRef: &NodeVersionBeacon.Heartbeat

    prepare(acct: auth(BorrowValue) &Account) {
        // Borrow a reference to the NodeVersionAdmin resource
        self.NodeVersionBeaconHeartbeatRef = acct.storage.borrow<&NodeVersionBeacon.Heartbeat>
          (from: NodeVersionBeacon.HeartbeatStoragePath)
          ?? panic("Couldn't borrow NodeVersionBeacon.Heartbeat Resource")
    }   
    execute {
        self.NodeVersionBeaconHeartbeatRef.heartbeat()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/change_cut.cdc

```
import "FlowIDTableStaking"

// This transaction changes the flow token reward cut that nodes take from delegators

transaction(newCutPercentage: UFix64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setCutPercentage(newCutPercentage)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_current_node_version.cdc

```
import "NodeVersionBeacon"

/// Gets the current version defined in the contract's versionTable
access(all) fun main(): NodeVersionBeacon.Semver {
    return NodeVersionBeacon.getCurrentVersionBoundary().version
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/transfer_fees_admin.cdc

```
import "FlowFees"

transaction {

    prepare(owner: auth(LoadValue) &Account, receiver: auth(SaveValue) &Account) {

        // Link the staking admin capability to a private place
        let feesAdmin <- owner.storage.load<@FlowFees.Administrator>(from: /storage/flowFeesAdmin)!

        // Save the capability to the receiver's account storage
        receiver.storage.save(<-feesAdmin, to: /storage/flowFeesAdmin)
    }

}
 

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_networking_key.cdc

```
import "FlowIDTableStaking"

// This script returns the networking key of a node

access(all) fun main(nodeID: String): String {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.networkingKey
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_all_node_info.cdc

```
import "FlowStakingCollection"
import "FlowIDTableStaking"

/// Gets an array of all the node metadata for nodes stored in the staking collection

access(all) fun main(address: Address): [FlowIDTableStaking.NodeInfo] {
    return FlowStakingCollection.getAllNodeInfo(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_current_table.cdc

```
import "FlowIDTableStaking"

// This script returns the current identity table length

access(all) fun main(): [String] {
    return FlowIDTableStaking.getStakedNodeIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_timing_config.cdc

```
import "FlowEpoch"

access(all) fun main(): FlowEpoch.EpochTimingConfig {
    return FlowEpoch.getEpochTimingConfig()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_deposit_account_creator.cdc

```
import "LockedTokens"

/// token admin signs this transaction to deposit a capability
/// into a custody provider's account that allows them to add
/// accounts to the record

transaction(custodyProviderAddress: Address) {

    prepare(admin: auth(BorrowValue, Capabilities) &Account) {

        let capabilityReceiver = getAccount(custodyProviderAddress)
            .capabilities.borrow<&LockedTokens.LockedAccountCreator>(
                LockedTokens.LockedAccountCreatorPublicPath
            )
            ?? panic("Could not borrow capability receiver reference")

        let tokenAdminCollection = admin.capabilities.storage.issue<auth(LockedTokens.AccountCreator) &LockedTokens.TokenAdminCollection>(
            LockedTokens.LockedTokenAdminCollectionStoragePath
        )!

        capabilityReceiver.addCapability(cap: tokenAdminCollection)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_tx_fee_parameters.cdc

```
import "FlowFees"

access(all) fun main(): FlowFees.FeeParameters {
    return FlowFees.getFeeParameters()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_staking_key.cdc

```
import "FlowIDTableStaking"

// This script returns the staking Key of a node

access(all) fun main(nodeID: String): String {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.stakingKey
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/node/register_dkg_participant.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"
import "FlowDKG"

transaction() {

    prepare(signer: auth(Storage) &Account) {

        let nodeRef = signer.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow node reference from storage path")

        let dkgParticipant <- FlowEpoch.getDKGParticipant(nodeStaker: nodeRef)

        signer.storage.save(<-dkgParticipant, to: FlowDKG.ParticipantStoragePath)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_proposed_table.cdc

```
import "FlowIDTableStaking"

// This script returns the current identity table length

access(all) fun main(): [String] {
    return FlowIDTableStaking.getProposedNodeIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_info.cdc

```
import "FlowIDTableStaking"

// This script gets all the info about a node and returns it

access(all) fun main(nodeID: String): FlowIDTableStaking.NodeInfo {
    return FlowIDTableStaking.NodeInfo(nodeID: nodeID)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/remove_invalid_nodes.cdc

```
import "FlowIDTableStaking"

// This transaction ends the staking auction, which refunds nodes 
// with insufficient stake

transaction(ids: {String: Bool}) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setApprovedList(ids)
        self.adminRef.removeInvalidNodes()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/scripts/get_storage_fee_conversion.cdc

```
import "FlowStorageFees"

access(all) fun main(): UFix64 {
    return FlowStorageFees.storageMegaBytesPerReservedFLOW
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/delete_version_boundary.cdc

```
import "NodeVersionBeacon"

/// Transaction that allows NodeVersionAdmin to delete the
/// version boundary mapping in the versionTable at the specified
/// block height parameter

transaction(blockHeightBoundaryToDelete: UInt64) {

  let NodeVersionBeaconAdminRef: &NodeVersionBeacon.Admin

  prepare(acct: auth(BorrowValue) &Account) {
    // Borrow a reference to the NodeVersionAdmin resource
    self.NodeVersionBeaconAdminRef = acct.storage.borrow<&NodeVersionBeacon.Admin>
      (from: NodeVersionBeacon.AdminStoragePath)
      ?? panic("Couldn't borrow NodeVersionBeaconAdmin Resource")
  }

  execute {
    // Delete the version from the version table at the specified block height boundary
    self.NodeVersionBeaconAdminRef.deleteVersionBoundary(blockHeight: blockHeightBoundaryToDelete)
  }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/request_unstake.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.stakerRef.requestUnstaking(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStakingCollection.cdc

```
/*

    FlowStakingCollection

    This contract defines a collection for staking and delegating objects
    which allows users to stake and delegate for as many nodes as they want in a single account.
    It is compatible with the locked token account setup.

    See the onflow/flow-core-contracts README for more high level information about the staking collection.

 */

import "FungibleToken"
import "FlowToken"
import "FlowIDTableStaking"
import "LockedTokens"
import "FlowStorageFees"
import "FlowClusterQC"
import "FlowDKG"
import "FlowEpoch"
import "Burner"

access(all) contract FlowStakingCollection {

    /// Account paths
    access(all) let StakingCollectionStoragePath: StoragePath
    access(all) let StakingCollectionPrivatePath: PrivatePath
    access(all) let StakingCollectionPublicPath: PublicPath

    /// Events
    access(all) event NodeAddedToStakingCollection(nodeID: String, role: UInt8, amountCommitted: UFix64, address: Address?)
    access(all) event DelegatorAddedToStakingCollection(nodeID: String, delegatorID: UInt32, amountCommitted: UFix64, address: Address?)

    access(all) event NodeRemovedFromStakingCollection(nodeID: String, role: UInt8, address: Address?)
    access(all) event DelegatorRemovedFromStakingCollection(nodeID: String, delegatorID: UInt32, address: Address?)

    access(all) event MachineAccountCreated(nodeID: String, role: UInt8, address: Address)

    /// Struct that stores delegator ID info
    access(all) struct DelegatorIDs {
        access(all) let delegatorNodeID: String
        access(all) let delegatorID: UInt32

        view init(nodeID: String, delegatorID: UInt32) {
            self.delegatorNodeID = nodeID
            self.delegatorID = delegatorID
        }
    }

    /// Contains information about a node's machine Account
    /// which is a secondary account that is only meant to hold
    /// the QC or DKG object and FLOW to automatically pay for transaction fees
    /// related to QC or DKG operations.
    access(all) struct MachineAccountInfo {
        access(all) let nodeID: String
        access(all) let role: UInt8
        // Capability to the FLOW Vault to allow the owner
        // to withdraw or deposit to their machine account if needed
        access(contract) let machineAccountVaultProvider: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>

        init(nodeID: String, role: UInt8, machineAccountVaultProvider: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>) {
            pre {
                machineAccountVaultProvider.check():
                    "FlowStakingCollection.MachineAccountInfo.init: Invalid Flow Token Vault Provider."
            }
            self.nodeID = nodeID
            self.role = role
            self.machineAccountVaultProvider = machineAccountVaultProvider
        }

        // Gets the address of the machine account
        access(all) view fun getAddress(): Address {
            return self.machineAccountVaultProvider.borrow()!.owner!.address
        }
    }

    /// Public interface that users can publish for their staking collection
    /// so that others can query their staking info
    access(all) resource interface StakingCollectionPublic {
        access(all) var lockedTokensUsed: UFix64
        access(all) var unlockedTokensUsed: UFix64
        access(all) fun addNodeObject(_ node: @FlowIDTableStaking.NodeStaker, machineAccountInfo: MachineAccountInfo?)
        access(all) fun addDelegatorObject(_ delegator: @FlowIDTableStaking.NodeDelegator)
        access(all) view fun doesStakeExist(nodeID: String, delegatorID: UInt32?): Bool
        access(all) fun getNodeIDs(): [String]
        access(all) fun getDelegatorIDs(): [DelegatorIDs]
        access(all) fun getAllNodeInfo(): [FlowIDTableStaking.NodeInfo]
        access(all) fun getAllDelegatorInfo(): [FlowIDTableStaking.DelegatorInfo]
        access(all) fun getMachineAccounts(): {String: MachineAccountInfo}
    }

    access(all) entitlement CollectionOwner

    /// The resource that stakers store in their accounts to store
    /// all their staking objects and capability to the locked account object
    /// Keeps track of how many locked and unlocked tokens are staked
    /// so it knows which tokens to give to the user when they deposit and withdraw
    /// different types of tokens
    /// 
    /// WARNING: If you destroy a staking collection with the `destroy` command,
    /// you will lose access to all your nodes and delegators that the staking collection
    /// manages. If you want to destroy it, you must either transfer your node to a different account
    /// unstake all your tokens and withdraw
    /// your unstaked tokens and rewards first before destroying.
    /// Then use the `destroyStakingCollection` method to destroy it
    access(all) resource StakingCollection: StakingCollectionPublic, Burner.Burnable {

        /// unlocked vault
        access(self) var unlockedVault: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>

        /// locked vault
        /// will be nil if the account has no corresponding locked account
        access(self) var lockedVault: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>?

        /// Stores staking objects for nodes and delegators
        /// Can only use one delegator per node ID
        /// need to be private for now because they could be using locked tokens
        access(self) var nodeStakers: @{String: FlowIDTableStaking.NodeStaker}
        access(self) var nodeDelegators: @{String: FlowIDTableStaking.NodeDelegator}

        /// Capabilty to the TokenHolder object in the unlocked account
        /// Accounts without a locked account will not store this, it will be nil
        access(self) var tokenHolder: Capability<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>?

        /// Tracks how many locked and unlocked tokens the staker is using for all their nodes and/or delegators
        /// When committing new tokens, locked tokens are used first, followed by unlocked tokens
        /// When withdrawing tokens, unlocked tokens are withdrawn first, followed by locked tokens
        access(all) var lockedTokensUsed: UFix64
        access(all) var unlockedTokensUsed: UFix64

        /// Tracks the machine accounts associated with nodes
        access(self) var machineAccounts: {String: MachineAccountInfo}

        init(
            unlockedVault: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,
            tokenHolder: Capability<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>?
        ) {
            pre {
                unlockedVault.check():
                    "FlowStakingCollection.StakingCollection.init: Cannot Initialize a Staking Collection! "
                    .concat("The provided FlowToken Vault capability with withdraw entitlements is invalid.")
            }
            self.unlockedVault = unlockedVault

            self.nodeStakers <- {}
            self.nodeDelegators <- {}

            self.lockedTokensUsed = 0.0
            self.unlockedTokensUsed = 0.0

            // If the account has a locked account, initialize its token holder
            // and locked vault capability
            if let tokenHolderObj = tokenHolder {
                self.tokenHolder = tokenHolder

                // borrow the main token manager object from the locked account 
                // to get access to the locked vault capability
                let lockedTokenManager = tokenHolderObj.borrow()!.borrowTokenManager()
                self.lockedVault = lockedTokenManager.vault
            } else {
                self.tokenHolder = nil
                self.lockedVault = nil
            }

            self.machineAccounts = {}
        }

        /// Gets a standard error message to show when the requested staker
        /// is not controlled by the staking collection
        ///
        /// @param nodeID: The ID of the requested node
        /// @param delegatorID: The ID of the requested delegator
        ///
        /// @return String: The full error message to print
        access(all) view fun getStakerDoesntExistInCollectionError(funcName: String, nodeID: String, delegatorID: UInt32?): String {
            // Construct the function name for the beginning of the error
            let errorBeginning = "FlowStakingCollection.StakingCollection.".concat(funcName).concat(": ")
            
            // The error message is different if it is a delegator vs a node
            if let delegator = delegatorID {
                return errorBeginning.concat("The specified delegator with node ID ")
                    .concat(nodeID).concat(" and delegatorID ").concat(delegator.toString())
                    .concat(" does not exist in the owner's collection. ")
                    .concat("Make sure that the IDs you entered correspond to a delegator that is controlled by this staking collection.")
            } else {
                return errorBeginning.concat("The specified node with ID ")
                    .concat(nodeID).concat(" does not exist in the owner's collection. ")
                    .concat("Make sure that the ID you entered corresponds to a node that is controlled by this staking collection.")
            }
        }

        /// Called when the collection is destroyed via `Burner.burn()`
        access(contract) fun burnCallback() {

            let nodeIDs = self.getNodeIDs()
            let delegatorIDs = self.getDelegatorIDs()

            for nodeID in nodeIDs {
                self.closeStake(nodeID: nodeID, delegatorID: nil)
            }

            for delegatorID in delegatorIDs {
                self.closeStake(nodeID: delegatorID.delegatorNodeID, delegatorID: delegatorID.delegatorID)
            }
        }

        /// Called when committing tokens for staking. Gets tokens from either or both vaults
        /// Uses locked tokens first, then unlocked if any more are still needed
        access(self) fun getTokens(amount: UFix64): @{FungibleToken.Vault} {

            let unlockedVault = self.unlockedVault.borrow()!
            let unlockedBalance = unlockedVault.balance - FlowStorageFees.minimumStorageReservation

            // If there is a locked account, use the locked vault first
            if self.lockedVault != nil {

                let lockedVault = self.lockedVault!.borrow()!
                let lockedBalance = lockedVault.balance - FlowStorageFees.minimumStorageReservation

                assert(
                    amount <= lockedBalance + unlockedBalance,
                    message: "FlowStakingCollection.StakingCollection.getTokens: Cannot get tokens to stake! "
                            .concat("The amount of FLOW requested to use, ")
                            .concat(amount.toString()).concat(", is more than the sum of ")
                            .concat("locked and unlocked FLOW, ").concat((lockedBalance+unlockedBalance).toString())
                            .concat(", in the owner's accounts.")
                )

                // If all the tokens can be removed from locked, withdraw and return them
                if (amount <= lockedBalance) {
                    self.lockedTokensUsed = self.lockedTokensUsed + amount

                    return <-lockedVault.withdraw(amount: amount)
                
                // If not all can be removed from locked, remove what can be, then remove the rest from unlocked
                } else {

                    // update locked tokens used record by adding the rest of the locked balance
                    self.lockedTokensUsed = self.lockedTokensUsed + lockedBalance

                    let numUnlockedTokensToUse = amount - lockedBalance

                    // Update the unlocked tokens used record by adding the amount requested
                    // minus whatever was used from the locked tokens
                    self.unlockedTokensUsed = self.unlockedTokensUsed + numUnlockedTokensToUse

                    let tokens <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())

                    // Get the actual tokens from each vault
                    let lockedPortion <- lockedVault.withdraw(amount: lockedBalance)
                    let unlockedPortion <- unlockedVault.withdraw(amount: numUnlockedTokensToUse)

                    // Deposit them into the same vault
                    tokens.deposit(from: <-lockedPortion)
                    tokens.deposit(from: <-unlockedPortion)

                    return <-tokens
                }
            } else {
                // Since there is no locked account, all tokens have to come from the normal unlocked balance

                assert(
                    amount <= unlockedBalance,
                    message: "FlowStakingCollection.StakingCollection.getTokens: Cannot get tokens to stake! "
                            .concat("The amount of FLOW requested to use, ")
                            .concat(amount.toString()).concat(", is more than the amount of FLOW, ")
                            .concat((unlockedBalance).toString())
                            .concat(", in the owner's account.")
                )

                self.unlockedTokensUsed = self.unlockedTokensUsed + amount

                return <-unlockedVault.withdraw(amount: amount)
            }
        }

        /// Deposits tokens back to a vault after being withdrawn from a Stake or Delegation.
        /// Deposits to unlocked tokens first, if possible, followed by locked tokens
        access(self) fun depositTokens(from: @{FungibleToken.Vault}) {
            pre {
                // This error should never be triggered in production becasue the tokens used fields
                // should be properly managed by all the other functions
                from.balance <= self.unlockedTokensUsed + self.lockedTokensUsed:
                    "FlowStakingCollection.StakingCollection.depositTokens: "
                    .concat(" Cannot return more FLOW to the account than is already in use for staking.")
            }

            let unlockedVault = self.unlockedVault.borrow()!

            /// If there is a locked account, get the locked vault holder for depositing
            if self.lockedVault != nil {
  
                if (from.balance <= self.unlockedTokensUsed) {
                    self.unlockedTokensUsed = self.unlockedTokensUsed - from.balance

                    unlockedVault.deposit(from: <-from)
                } else {
                    // Return unlocked tokens first
                    unlockedVault.deposit(from: <-from.withdraw(amount: self.unlockedTokensUsed))
                    self.unlockedTokensUsed = 0.0

                    self.lockedTokensUsed = self.lockedTokensUsed - from.balance
                    // followed by returning the difference as locked tokens
                    self.lockedVault!.borrow()!.deposit(from: <-from)
                }
            } else {
                self.unlockedTokensUsed = self.unlockedTokensUsed - from.balance
                
                // If there is no locked account, get the users vault capability and deposit tokens to it.
                unlockedVault.deposit(from: <-from)
            }
        }

        /// Returns true if a Stake or Delegation record exists in the StakingCollection for a given nodeID and optional delegatorID, otherwise false.
        access(all) view fun doesStakeExist(nodeID: String, delegatorID: UInt32?): Bool {
            var tokenHolderNodeID: String? = nil
            var tokenHolderDelegatorNodeID: String? = nil
            var tokenHolderDelegatorID: UInt32?  = nil

            // If there is a locked account, get the staking info from that account
            if self.tokenHolder != nil {
                if let _tokenHolder = self.tokenHolder!.borrow() {
                    tokenHolderNodeID = _tokenHolder.getNodeID()
                    tokenHolderDelegatorNodeID = _tokenHolder.getDelegatorNodeID()
                    tokenHolderDelegatorID = _tokenHolder.getDelegatorID()
                }
            }

            // If the request is for a delegator, check all possible delegators for possible matches
            if let delegatorID = delegatorID {
                if (tokenHolderDelegatorNodeID != nil
                    && tokenHolderDelegatorID != nil
                    && tokenHolderDelegatorNodeID! == nodeID
                    && tokenHolderDelegatorID! == delegatorID)
                {
                    return true
                }

                // Look for a delegator with the specified node ID and delegator ID
                return self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) != nil 
            } else {
                if (tokenHolderNodeID != nil && tokenHolderNodeID! == nodeID) {
                    return true
                }

                return self.borrowNode(nodeID) != nil
            }
        }

        /// Function to add an existing NodeStaker object
        access(all) fun addNodeObject(_ node: @FlowIDTableStaking.NodeStaker, machineAccountInfo: MachineAccountInfo?) {
            let id = node.id
            let stakingInfo = FlowIDTableStaking.NodeInfo(nodeID: id)
            let totalStaked = stakingInfo.totalTokensInRecord() - stakingInfo.tokensRewarded
            self.unlockedTokensUsed = self.unlockedTokensUsed + totalStaked

            emit NodeAddedToStakingCollection(
                nodeID: stakingInfo.id,
                role: stakingInfo.role,
                amountCommitted: stakingInfo.totalCommittedWithoutDelegators(),
                address: self.owner?.address
            )

            self.nodeStakers[id] <-! node
            // Set the machine account for the existing node
            // can be the same as the old account if needed
            self.machineAccounts[id] = machineAccountInfo
        }

        /// Function to add an existing NodeDelegator object
        access(all) fun addDelegatorObject(_ delegator: @FlowIDTableStaking.NodeDelegator) {
            let stakingInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegator.nodeID, delegatorID: delegator.id)
            let totalStaked = stakingInfo.totalTokensInRecord() - stakingInfo.tokensRewarded
            self.unlockedTokensUsed = self.unlockedTokensUsed + totalStaked
            emit DelegatorAddedToStakingCollection(
                nodeID: stakingInfo.nodeID,
                delegatorID: stakingInfo.id,
                amountCommitted: stakingInfo.tokensStaked + stakingInfo.tokensCommitted - stakingInfo.tokensRequestedToUnstake,
                address: self.owner?.address
            )
            self.nodeDelegators[delegator.nodeID] <-! delegator
        }

        /// Function to remove an existing NodeStaker object.
        /// If the user has used any locked tokens, removing NodeStaker objects is not allowed.
        /// We do not clear the machine account field for this node here
        /// because the operator may want to keep it the same
        access(CollectionOwner) fun removeNode(nodeID: String): @FlowIDTableStaking.NodeStaker? {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "removeNode", nodeID: nodeID, delegatorID: nil)
                self.lockedTokensUsed == UFix64(0.0):
                    "FlowStakingCollection.StakingCollection.removeNode: Cannot remove a node from the collection "
                    .concat("because the collection still manages ").concat(self.lockedTokensUsed.toString())
                    .concat(" locked tokens. This is to prevent locked tokens ")
                    .concat("from being unlocked and withdrawn before their allotted unlocking time.")
            }
            
            if self.nodeStakers[nodeID] != nil {
                let stakingInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
                let totalStaked = stakingInfo.totalTokensInRecord() - stakingInfo.tokensRewarded

                // Since the NodeStaker object is being removed, the total number of unlocked tokens staked to it is deducted from the counter.
                self.unlockedTokensUsed = self.unlockedTokensUsed - totalStaked

                // Removes the NodeStaker object from the Staking Collections internal nodeStakers map.
                let nodeStaker <- self.nodeStakers[nodeID] <- nil

                // Clear the machine account info from the record
                self.machineAccounts[nodeID] = nil

                emit NodeRemovedFromStakingCollection(nodeID: nodeID, role: stakingInfo.role, address: self.owner?.address)
                
                return <- nodeStaker
            } else {
                // The function does not allow for removing a NodeStaker stored in the locked account, if one exists.
                panic("Cannot remove node stored in locked account.")
            }
        }

        /// Function to remove an existing NodeDelegator object.
        /// If the user has used any locked tokens, removing NodeDelegator objects is not allowed.
        access(CollectionOwner) fun removeDelegator(nodeID: String, delegatorID: UInt32): @FlowIDTableStaking.NodeDelegator? {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "removeDelegator", nodeID: nodeID, delegatorID: delegatorID)
                self.lockedTokensUsed == UFix64(0.0):
                    "FlowStakingCollection.StakingCollection.removeDelegator: Cannot remove a delegator from the collection "
                    .concat("because the collection still manages ").concat(self.lockedTokensUsed.toString())
                    .concat(" locked tokens. This is to prevent locked tokens ")
                    .concat("from being unlocked and withdrawn before their allotted unlocking time.")
            }
            
            if self.nodeDelegators[nodeID] != nil {
                let delegatorRef = (&self.nodeDelegators[nodeID] as &FlowIDTableStaking.NodeDelegator?)!
                if delegatorRef.id == delegatorID { 
                    let stakingInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
                    let totalStaked = stakingInfo.totalTokensInRecord() - stakingInfo.tokensRewarded

                    // Since the NodeDelegator object is being removed, the total number of unlocked tokens delegated to it is deducted from the counter.
                    self.unlockedTokensUsed = self.unlockedTokensUsed - totalStaked

                    // Removes the NodeDelegator object from the Staking Collections internal nodeDelegators map.
                    let nodeDelegator <- self.nodeDelegators[nodeID] <- nil

                    emit DelegatorRemovedFromStakingCollection(
                        nodeID: nodeID,
                        delegatorID: delegatorID,
                        address: self.owner?.address
                    )

                    return <- nodeDelegator
                } else { 
                    panic("FlowStakingCollection.StakingCollection.removeDelegator: "
                            .concat("Expected delegatorID ").concat(delegatorID.toString())
                            .concat(" does not correspond to the Staking Collection's delegator ID ")
                            .concat(delegatorRef.id.toString()))
                }
            } else {
                // The function does not allow for removing a NodeDelegator stored in the locked account, if one exists.
                panic("FlowStakingCollection.StakingCollection.removeDelegator: "
                    .concat("Cannot remove a delegator with ID ").concat(delegatorID.toString())
                    .concat(" because it is stored in the locked account."))
            }
        }

        /// Operations to register new staking objects

        /// Function to register a new Staking Record to the Staking Collection
        access(CollectionOwner) fun registerNode(
            id: String,
            role: UInt8,
            networkingAddress: String,
            networkingKey: String,
            stakingKey: String,
            amount: UFix64,
            payer: auth(BorrowValue) &Account
        ): auth(Storage, Capabilities, Contracts, Keys, Inbox) &Account? {

            let tokens <- self.getTokens(amount: amount)

            let nodeStaker <- FlowIDTableStaking.addNodeRecord(
                id: id,
                role: role,
                networkingAddress: networkingAddress,
                networkingKey: networkingKey,
                stakingKey: stakingKey,
                tokensCommitted: <-tokens
            )

            emit NodeAddedToStakingCollection(
                nodeID: nodeStaker.id,
                role: role,
                amountCommitted: amount,
                address: self.owner?.address
            )

            self.nodeStakers[id] <-! nodeStaker

            let nodeReference = self.borrowNode(id)
                ?? panic("FlowStakingCollection.StakingCollection.registerNode: "
                        .concat("Could not borrow a reference to the newly created node with ID ")
                        .concat(id).concat("."))

            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeReference.id)

            // Register the machine account for the node
            // creates an auth account object and returns it to the caller
            if nodeInfo.role == FlowEpoch.NodeRole.Collector.rawValue || nodeInfo.role == FlowEpoch.NodeRole.Consensus.rawValue {
                return self.registerMachineAccount(nodeReference: nodeReference, payer: payer)
            } else {
                return nil
            }
        }

        /// Registers the secondary machine account for a node
        /// to store their epoch-related objects
        /// Only returns an AuthAccount object if the node is collector or consensus, otherwise returns nil
        /// The caller's qc or dkg object is stored in the new account
        /// but it is the caller's responsibility to add public keys to it
        access(self) fun registerMachineAccount(
            nodeReference: &FlowIDTableStaking.NodeStaker,
            payer: auth(BorrowValue) &Account
        ): auth(Storage, Capabilities, Contracts, Keys, Inbox) &Account? {

            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeReference.id)

            // Create the new account
            let machineAcct = Account(payer: payer)

            // Get the vault capability and create the machineAccountInfo struct
            let machineAccountVaultProvider = machineAcct.capabilities.storage
                .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)!

            let machineAccountInfo = MachineAccountInfo(
                nodeID: nodeInfo.id,
                role: nodeInfo.role,
                machineAccountVaultProvider: machineAccountVaultProvider
            )
            
            // If they are a collector node, create a QC Voter object and store it in the account
            if nodeInfo.role == FlowEpoch.NodeRole.Collector.rawValue {

                // Get the voter object and store it
                let qcVoter <- FlowEpoch.getClusterQCVoter(nodeStaker: nodeReference)
                machineAcct.storage.save(<-qcVoter, to: FlowClusterQC.VoterStoragePath)

                // set this node's machine account
                self.machineAccounts[nodeInfo.id] = machineAccountInfo

                emit MachineAccountCreated(
                    nodeID: nodeInfo.id,
                    role: FlowEpoch.NodeRole.Collector.rawValue,
                    address: machineAccountVaultProvider.borrow()!.owner!.address
                )

                return machineAcct

            // If they are a consensus node, create a DKG Participant object and store it in the account
            } else if nodeInfo.role == FlowEpoch.NodeRole.Consensus.rawValue {

                // get the participant object and store it
                let dkgParticipant <- FlowEpoch.getDKGParticipant(nodeStaker: nodeReference)
                machineAcct.storage.save(<-dkgParticipant, to: FlowDKG.ParticipantStoragePath)

                // set this node's machine account
                self.machineAccounts[nodeInfo.id] = machineAccountInfo

                emit MachineAccountCreated(
                    nodeID: nodeInfo.id,
                    role: FlowEpoch.NodeRole.Consensus.rawValue,
                    address: machineAccountVaultProvider.borrow()!.owner!.address
                )

                return machineAcct
            }

            return nil
        }

        /// Allows the owner to set the machine account for one of their nodes
        /// This is used if the owner decides to transfer the machine account resource to another account
        /// without also transferring the old machine account record,
        /// or if they decide they want to use a different machine account for one of their nodes
        /// If they want to use a different machine account, it is their responsibility to
        /// transfer the qc or dkg object to the new account
        access(all) fun addMachineAccountRecord(
            nodeID: String,
            machineAccount: auth(BorrowValue, StorageCapabilities) &Account
        ) {

            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "addMachineAccountRecord", nodeID: nodeID, delegatorID: nil)
            }

            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)

            // Make sure that the QC or DKG object in the machine account is correct for this node ID

            if nodeInfo.role == FlowEpoch.NodeRole.Collector.rawValue {
                let qcVoterRef = machineAccount.storage.borrow<&FlowClusterQC.Voter>(from: FlowClusterQC.VoterStoragePath)
                    ?? panic("FlowStakingCollection.StakingCollection.addMachineAccountRecord: "
                            .concat("Could not access a QC Voter object from the provided machine account with address ").concat(machineAccount.address.toString()))

                assert(
                    nodeID == qcVoterRef.nodeID,
                    message: "FlowStakingCollection.StakingCollection.addMachineAccountRecord: "
                            .concat("The QC Voter Object in the machine account with node ID ").concat(qcVoterRef.nodeID)
                            .concat(" does not match the Staking Collection's specified node ID ").concat(nodeID)
                )
            } else if nodeInfo.role == FlowEpoch.NodeRole.Consensus.rawValue {
                let dkgParticipantRef = machineAccount.storage.borrow<&FlowDKG.Participant>(from: FlowDKG.ParticipantStoragePath)
                    ?? panic("FlowStakingCollection.StakingCollection.addMachineAccountRecord: "
                            .concat("Could not access a DKG Participant object from the provided machine account with address ").concat(machineAccount.address.toString()))

                assert(
                    nodeID == dkgParticipantRef.nodeID,
                    message: "FlowStakingCollection.StakingCollection.addMachineAccountRecord: "
                            .concat("The DKG Participant Object in the machine account with node ID ").concat(dkgParticipantRef.nodeID)
                            .concat(" does not match the Staking Collection's specified node ID ").concat(nodeID)
                )
            }

            // Make sure that the vault capability is created
            let machineAccountVaultProvider = machineAccount.capabilities.storage
                .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)!

            // Create the new Machine account info object and store it
            let machineAccountInfo = MachineAccountInfo(
                nodeID: nodeID,
                role: nodeInfo.role,
                machineAccountVaultProvider: machineAccountVaultProvider
            )

            self.machineAccounts[nodeID] = machineAccountInfo
        }

        /// If a user has created a node before epochs were enabled, they'll need to use this function
        /// to create their machine account with their node 
        access(CollectionOwner) fun createMachineAccountForExistingNode(nodeID: String, payer: auth(BorrowValue) &Account): auth(Storage, Capabilities, Contracts, Keys, Inbox) &Account? {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "createMachineAccountForExistingNode", nodeID: nodeID, delegatorID: nil)
            }

            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)

            if let nodeReference = self.borrowNode(nodeID) {
                return self.registerMachineAccount(nodeReference: nodeReference, payer: payer)
            } else {
                if let tokenHolderObj = self.tokenHolder {

                    // borrow the main token manager object from the locked account 
                    // to get access to the locked vault capability
                    let lockedTokenManager = tokenHolderObj.borrow()!.borrowTokenManager()
                
                    let lockedNodeReference = lockedTokenManager.borrowNode()
                        ?? panic("FlowStakingCollection.StakingCollection.createMachineAccountForExistingNode: "
                                .concat("Could not borrow a node reference from the locked account."))

                    return self.registerMachineAccount(nodeReference: lockedNodeReference, payer: payer)
                }
            }

            return nil
        }

        /// Allows the owner to withdraw any available FLOW from their machine account
        access(CollectionOwner) fun withdrawFromMachineAccount(nodeID: String, amount: UFix64) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "withdrawFromMachineAccount", nodeID: nodeID, delegatorID: nil)
            }
            if let machineAccountInfo = self.machineAccounts[nodeID] {
                let vaultRef = machineAccountInfo.machineAccountVaultProvider.borrow()
                    ?? panic("FlowStakingCollection.StakingCollection.withdrawFromMachineAccount: "
                            .concat("Could not borrow reference to machine account vault."))

                let tokens <- vaultRef.withdraw(amount: amount)

                let unlockedVault = self.unlockedVault.borrow()!
                unlockedVault.deposit(from: <-tokens)

            } else {
                panic("FlowStakingCollection.StakingCollection.withdrawFromMachineAccount: "
                    .concat("Could not find a machine account for the specified node ID ")
                    .concat(nodeID).concat("."))
            }
        }

        /// Function to register a new Delegator Record to the Staking Collection
        access(CollectionOwner) fun registerDelegator(nodeID: String, amount: UFix64) {
            let delegatorIDs = self.getDelegatorIDs()
            for idInfo in delegatorIDs {
                if idInfo.delegatorNodeID == nodeID { 
                    panic("FlowStakingCollection.StakingCollection.registerDelegator: "
                        .concat("Cannot register a delegator for node ").concat(nodeID)
                        .concat(" because that node is already being delegated to from this Staking Collection."))
                }
            }
            
            let tokens <- self.getTokens(amount: amount)

            let nodeDelegator <- FlowIDTableStaking.registerNewDelegator(nodeID: nodeID, tokensCommitted: <-tokens)

            emit DelegatorAddedToStakingCollection(
                nodeID: nodeDelegator.nodeID,
                delegatorID: nodeDelegator.id,
                amountCommitted: amount,
                address: self.owner?.address
            )

            self.nodeDelegators[nodeDelegator.nodeID] <-! nodeDelegator
        }

        /// Borrows a reference to a node in the collection
        access(self) view fun borrowNode(_ nodeID: String): auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker? {
            if self.nodeStakers[nodeID] != nil {
                return &self.nodeStakers[nodeID] as auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker?
            } else {
                return nil
            }
        }

        /// Borrows a reference to a delegator in the collection
        access(self) view fun borrowDelegator(nodeID: String, delegatorID: UInt32): auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator? {
            if self.nodeDelegators[nodeID] != nil {
                let delegatorRef = (&self.nodeDelegators[nodeID] as auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator?)!
                if delegatorRef.id == delegatorID { return delegatorRef } else { return nil }
            } else {
                return nil
            }
        }

        // Staking Operations

        // The owner calls the same function whether or not they are staking for a node or delegating.
        // If they are staking for a node, they provide their node ID and `nil` as the delegator ID
        // If they are staking for a delegator, they provide the node ID for the node they are delegating to
        // and their delegator ID to specify that it is for their delegator object

        /// Updates the stored networking address for the specified node
        access(CollectionOwner) fun updateNetworkingAddress(nodeID: String, newAddress: String) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "updateNetworkingAddress", nodeID: nodeID, delegatorID: nil)
            }

            // If the node is stored in the collection, borrow it 
            if let node = self.borrowNode(nodeID) {
                node.updateNetworkingAddress(newAddress)
            } else {
                // Use the node stored in the locked account
                let node = self.tokenHolder!.borrow()!.borrowStaker()
                node.updateNetworkingAddress(newAddress)
            }
        }

        /// Function to stake new tokens for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun stakeNewTokens(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID): 
                    self.getStakerDoesntExistInCollectionError(funcName: "stakeNewTokens", nodeID: nodeID, delegatorID: delegatorID)
            }

            // If staking as a delegator, use the delegate functionality
            if let delegatorID = delegatorID {       
                // If the delegator is stored in the collection, borrow it         
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    delegator.delegateNewTokens(from: <- self.getTokens(amount: amount))
                } else {
                    let tokenHolder = self.tokenHolder!.borrow()!

                    // Get any needed unlocked tokens, and deposit them to the locked vault.
                    let lockedBalance = self.lockedVault!.borrow()!.balance - FlowStorageFees.minimumStorageReservation
                    if (amount > lockedBalance) {
                        let numUnlockedTokensToUse = amount - lockedBalance
                        tokenHolder.deposit(from: <- self.unlockedVault.borrow()!.withdraw(amount: numUnlockedTokensToUse))
                    }   

                    // Use the delegator stored in the locked account
                    let delegator = tokenHolder.borrowDelegator()
                    delegator.delegateNewTokens(amount: amount)
                }

            // If the node is stored in the collection, borrow it 
            } else if let node = self.borrowNode(nodeID) {
                node.stakeNewTokens(<-self.getTokens(amount: amount))
            } else {
                // Get any needed unlocked tokens, and deposit them to the locked vault.
                let lockedBalance = self.lockedVault!.borrow()!.balance - FlowStorageFees.minimumStorageReservation
                if (amount > lockedBalance) {
                    let numUnlockedTokensToUse = amount - lockedBalance
                    self.tokenHolder!.borrow()!.deposit(from: <- self.unlockedVault.borrow()!.withdraw(amount: numUnlockedTokensToUse))
                } 

                // Use the staker stored in the locked account
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.stakeNewTokens(amount: amount)
            }
        }

        /// Function to stake unstaked tokens for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun stakeUnstakedTokens(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "stakeUnstakedTokens", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    delegator.delegateUnstakedTokens(amount: amount)

                } else {
                    let delegator = self.tokenHolder!.borrow()!.borrowDelegator()
                    delegator.delegateUnstakedTokens(amount: amount)
                }
            } else if let node = self.borrowNode(nodeID) {
                node.stakeUnstakedTokens(amount: amount)
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.stakeUnstakedTokens(amount: amount)
            }
        }

        /// Function to stake rewarded tokens for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun stakeRewardedTokens(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "stakeRewardedTokens", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    // We add the amount to the unlocked tokens used because rewards are newly minted tokens
                    // and aren't immediately reflected in the tokens used fields
                    self.unlockedTokensUsed = self.unlockedTokensUsed + amount
                    delegator.delegateRewardedTokens(amount: amount)
                } else {
                    // Staking tokens in the locked account staking objects are not reflected in the tokens used fields,
                    // so they are not updated here
                    let delegator = self.tokenHolder!.borrow()!.borrowDelegator()
                    delegator.delegateRewardedTokens(amount: amount)
                }
            } else if let node = self.borrowNode(nodeID) {
                self.unlockedTokensUsed = self.unlockedTokensUsed + amount
                node.stakeRewardedTokens(amount: amount)
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.stakeRewardedTokens(amount: amount)
            }
        }

        /// Function to request tokens to be unstaked for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun requestUnstaking(nodeID: String, delegatorID: UInt32?, amount: UFix64) { 
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "requestUnstaking", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    delegator.requestUnstaking(amount: amount)

                } else {
                    let delegator = self.tokenHolder!.borrow()!.borrowDelegator()
                    delegator.requestUnstaking(amount: amount)
                }
            } else if let node = self.borrowNode(nodeID) {
                node.requestUnstaking(amount: amount)
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.requestUnstaking(amount: amount)
            }
        }

        /// Function to unstake all tokens for an existing node staking record in the StakingCollection
        /// Only available for node operators
        access(CollectionOwner) fun unstakeAll(nodeID: String) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: nil):
                    self.getStakerDoesntExistInCollectionError(funcName: "unstakeAll", nodeID: nodeID, delegatorID: nil)
            }
    
            if let node = self.borrowNode(nodeID) {
                node.unstakeAll()
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.unstakeAll()
            }
        }

        /// Function to withdraw unstaked tokens for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun withdrawUnstakedTokens(nodeID: String, delegatorID: UInt32?, amount: UFix64) { 
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "withdrawUnstakedTokens", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    let tokens <- delegator.withdrawUnstakedTokens(amount: amount)
                    self.depositTokens(from: <-tokens)
                } else {
                    let delegator = self.tokenHolder!.borrow()!.borrowDelegator()
                    delegator.withdrawUnstakedTokens(amount: amount)
                }
            } else if let node = self.borrowNode(nodeID) {
                let tokens <- node.withdrawUnstakedTokens(amount: amount)
                self.depositTokens(from: <-tokens)
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                staker.withdrawUnstakedTokens(amount: amount)
            }
        }

        /// Function to withdraw rewarded tokens for an existing Stake or Delegation record in the StakingCollection
        access(CollectionOwner) fun withdrawRewardedTokens(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "withdrawRewardedTokens", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    // We update the unlocked tokens used field before withdrawing because 
                    // rewards are newly minted and not immediately reflected in the tokens used fields
                    self.unlockedTokensUsed = self.unlockedTokensUsed + amount

                    let tokens <- delegator.withdrawRewardedTokens(amount: amount)

                    self.depositTokens(from: <-tokens)
                } else {
                    let delegator = self.tokenHolder!.borrow()!.borrowDelegator()
                    
                    delegator.withdrawRewardedTokens(amount: amount)

                    // move the unlocked rewards from the locked account to the unlocked account
                    let unlockedRewards <- self.tokenHolder!.borrow()!.withdraw(amount: amount)
                    self.unlockedVault.borrow()!.deposit(from: <-unlockedRewards)
                }
            } else if let node = self.borrowNode(nodeID) {
                self.unlockedTokensUsed = self.unlockedTokensUsed + amount

                let tokens <- node.withdrawRewardedTokens(amount: amount)

                self.depositTokens(from: <-tokens)
            } else {
                let staker = self.tokenHolder!.borrow()!.borrowStaker()
                
                staker.withdrawRewardedTokens(amount: amount)

                // move the unlocked rewards from the locked account to the unlocked account
                let unlockedRewards <- self.tokenHolder!.borrow()!.withdraw(amount: amount)
                self.unlockedVault.borrow()!.deposit(from: <-unlockedRewards)
            }
        }

        // Closers

        /// Closes an existing stake or delegation, moving all withdrawable tokens back to the users account and removing the stake
        /// or delegator object from the StakingCollection.
        access(CollectionOwner) fun closeStake(nodeID: String, delegatorID: UInt32?) {
            pre {
                self.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID):
                    self.getStakerDoesntExistInCollectionError(funcName: "closeStake", nodeID: nodeID, delegatorID: delegatorID)
            }

            if let delegatorID = delegatorID {
                let delegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)

                assert(
                    delegatorInfo.tokensStaked + delegatorInfo.tokensCommitted + delegatorInfo.tokensUnstaking == 0.0,
                    message: "FlowStakingCollection.StakingCollection.closeStake: "
                            .concat("Cannot close a delegation until all tokens have been withdrawn, or moved to a withdrawable state.")
                )

                if delegatorInfo.tokensUnstaked > 0.0 {
                    self.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: delegatorInfo.tokensUnstaked)
                }

                if delegatorInfo.tokensRewarded > 0.0 {
                    self.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: delegatorInfo.tokensRewarded)
                }

                if let delegator = self.borrowDelegator(nodeID: nodeID, delegatorID: delegatorID) {
                    let delegator <- self.nodeDelegators[nodeID] <- nil
                    destroy delegator
                } else if let tokenHolderCapability = self.tokenHolder {
                    let tokenManager = tokenHolderCapability.borrow()!.borrowTokenManager()
                    let delegator <- tokenManager.removeDelegator()
                    destroy delegator
                } else {
                    panic("FlowStakingCollection.StakingCollection.closeStake: Token Holder capability needed and not found.")
                }

                emit DelegatorRemovedFromStakingCollection(nodeID: nodeID, delegatorID: delegatorID, address: self.owner?.address)

            } else {
                let stakeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)

                /// Set the machine account for this node to `nil` because it no longer exists
                if let machineAccountInfo = self.machineAccounts[nodeID] {
                    let vaultRef = machineAccountInfo.machineAccountVaultProvider.borrow()
                        ?? panic("FlowStakingCollection.StakingCollection.closeStake: Could not borrow vault ref from machine account.")

                    let unlockedVault = self.unlockedVault!.borrow()!
                    var availableBalance: UFix64 = 0.0
                    if FlowStorageFees.storageMegaBytesPerReservedFLOW != (0.0) {
                        availableBalance = FlowStorageFees.defaultTokenAvailableBalance(machineAccountInfo.machineAccountVaultProvider.borrow()!.owner!.address)
                    } else {
                        availableBalance = vaultRef.balance
                    }
                    unlockedVault.deposit(from: <-vaultRef.withdraw(amount: availableBalance))

                    self.machineAccounts[nodeID] = nil
                }

                assert(
                    stakeInfo.tokensStaked + stakeInfo.tokensCommitted + stakeInfo.tokensUnstaking == 0.0,
                    message: "FlowStakingCollection.StakingCollection.closeStake: Cannot close a stake until all tokens have been withdrawn, or moved to a withdrawable state."
                )

                if stakeInfo.tokensUnstaked > 0.0 {
                    self.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: stakeInfo.tokensUnstaked)
                }

                if stakeInfo.tokensRewarded > 0.0 {
                    self.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: stakeInfo.tokensRewarded)
                }

                if let node = self.borrowNode(nodeID) {
                    let staker <- self.nodeStakers[nodeID] <- nil
                    destroy staker
                } else if let tokenHolderCapability = self.tokenHolder {
                    let tokenManager = tokenHolderCapability.borrow()!.borrowTokenManager()
                    let staker <- tokenManager.removeNode()
                    destroy staker
                } else {
                    panic("FlowStakingCollection.StakingCollection.closeStake: Token Holder capability needed and not found.")
                }

                emit NodeRemovedFromStakingCollection(nodeID: nodeID, role: stakeInfo.role, address: self.owner?.address)
            }
        }

        /// Getters

        /// Function to get all node ids for all Staking records in the StakingCollection
        access(all) fun getNodeIDs(): [String] {
            let nodeIDs: [String] = self.nodeStakers.keys

            if let tokenHolderCapability = self.tokenHolder {
                let _tokenHolder = tokenHolderCapability.borrow()!

                let tokenHolderNodeID = _tokenHolder.getNodeID()
                if let _tokenHolderNodeID = tokenHolderNodeID {
                    nodeIDs.append(_tokenHolderNodeID)
                }
            }

            return nodeIDs
        }

        /// Function to get all delegator ids for all Delegation records in the StakingCollection
        access(all) fun getDelegatorIDs(): [DelegatorIDs] {
            let nodeIDs: [String] = self.nodeDelegators.keys
            let delegatorIDs: [DelegatorIDs] = []

            for nodeID in nodeIDs {
                let delID = self.nodeDelegators[nodeID]?.id

                delegatorIDs.append(DelegatorIDs(nodeID: nodeID, delegatorID: delID!))
            }

            if let tokenHolderCapability = self.tokenHolder {
                let _tokenHolder = tokenHolderCapability.borrow()!

                let tokenHolderDelegatorNodeID = _tokenHolder.getDelegatorNodeID()
                let tokenHolderDelegatorID = _tokenHolder.getDelegatorID()

                if let _tokenHolderDelegatorNodeID = tokenHolderDelegatorNodeID {
                    if let _tokenHolderDelegatorID = tokenHolderDelegatorID {
                        delegatorIDs.append(DelegatorIDs(nodeID: _tokenHolderDelegatorNodeID, delegatorID: _tokenHolderDelegatorID))
                    }
                }
            }

            return delegatorIDs
        }

        /// Function to get all Node Info records for all Staking records in the StakingCollection
        access(all) fun getAllNodeInfo(): [FlowIDTableStaking.NodeInfo] {
            let nodeInfo: [FlowIDTableStaking.NodeInfo] = []

            let nodeIDs: [String] = self.nodeStakers.keys
            for nodeID in nodeIDs {
                nodeInfo.append(FlowIDTableStaking.NodeInfo(nodeID: nodeID))
            }

            if let tokenHolderCapability = self.tokenHolder {
                let _tokenHolder = tokenHolderCapability.borrow()!

                let tokenHolderNodeID = _tokenHolder.getNodeID()
                if let _tokenHolderNodeID = tokenHolderNodeID {
                    nodeInfo.append(FlowIDTableStaking.NodeInfo(nodeID: _tokenHolderNodeID))
                }
            }

            return nodeInfo
        }

        /// Function to get all Delegator Info records for all Delegation records in the StakingCollection
        access(all) fun getAllDelegatorInfo(): [FlowIDTableStaking.DelegatorInfo] {
            let delegatorInfo: [FlowIDTableStaking.DelegatorInfo] = []

            let nodeIDs: [String] = self.nodeDelegators.keys

            for nodeID in nodeIDs {

                let delegatorID = self.nodeDelegators[nodeID]?.id

                let info = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID!)

                delegatorInfo.append(info)
            }

            if let tokenHolderCapability = self.tokenHolder {
                let _tokenHolder = tokenHolderCapability.borrow()!

                let tokenHolderDelegatorNodeID = _tokenHolder.getDelegatorNodeID()
                let tokenHolderDelegatorID = _tokenHolder.getDelegatorID()

                if let _tokenHolderDelegatorNodeID = tokenHolderDelegatorNodeID {
                    if let _tokenHolderDelegatorID = tokenHolderDelegatorID {
                        let info = FlowIDTableStaking.DelegatorInfo(nodeID: _tokenHolderDelegatorNodeID, delegatorID: _tokenHolderDelegatorID)

                        delegatorInfo.append(info)
                    }
                }
            }

            return delegatorInfo
        }

        /// Gets a users list of machine account information
        access(all) fun getMachineAccounts(): {String: MachineAccountInfo} {
            return self.machineAccounts
        }

    } 

    // Getter functions for accounts StakingCollection information

    /// Function to get see if a node or delegator exists in an accounts staking collection
    access(all) view fun doesStakeExist(address: Address, nodeID: String, delegatorID: UInt32?): Bool {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.doesStakeExist(nodeID: nodeID, delegatorID: delegatorID)
    }

    /// Function to get the unlocked tokens used amount for an account
    access(all) view fun getUnlockedTokensUsed(address: Address): UFix64 {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.unlockedTokensUsed
    }

    /// Function to get the locked tokens used amount for an account
    access(all) view fun getLockedTokensUsed(address: Address): UFix64 {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.lockedTokensUsed
    }

    /// Function to get all node ids for all Staking records in a users StakingCollection, if one exists.
    access(all) fun getNodeIDs(address: Address): [String] {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.getNodeIDs()
    }

    /// Function to get all delegator ids for all Delegation records in a users StakingCollection, if one exists.
    access(all) fun getDelegatorIDs(address: Address): [DelegatorIDs] {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.getDelegatorIDs()
    }

    /// Function to get all Node Info records for all Staking records in a users StakingCollection, if one exists.
    access(all) fun getAllNodeInfo(address: Address): [FlowIDTableStaking.NodeInfo] {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.getAllNodeInfo()
    }

    /// Function to get all Delegator Info records for all Delegation records in a users StakingCollection, if one exists.
    access(all) fun getAllDelegatorInfo(address: Address): [FlowIDTableStaking.DelegatorInfo] {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.getAllDelegatorInfo()
    }

    /// Global function to get all the machine account info for all the nodes managed by an address' staking collection
    access(all) fun getMachineAccounts(address: Address): {String: MachineAccountInfo} {
        let account = getAccount(address)

        let stakingCollectionRef = account.capabilities.borrow<&StakingCollection>(self.StakingCollectionPublicPath)
            ?? panic(self.getCollectionMissingError(address))

        return stakingCollectionRef.getMachineAccounts()
    }

    /// Determines if an account is set up with a Staking Collection
    access(all) view fun doesAccountHaveStakingCollection(address: Address): Bool {
        let account = getAccount(address)
        return account.capabilities
            .get<&StakingCollection>(self.StakingCollectionPublicPath)
            .check()
    }

    /// Gets a standard error message for when a signer does not store a staking collection
    ///
    /// @param account: The account address if talking about an account that is not the signer.
    ///                 If referring to the signer, leave this argument as `nil`.
    ///
    /// @return String: The full error message
    access(all) view fun getCollectionMissingError(_ account: Address?): String {
        if let address = account {
            return "The account ".concat(address.toString())
                .concat(" does not store a Staking Collection object at the path ")
                .concat(FlowStakingCollection.StakingCollectionStoragePath.toString())
                .concat(". They must initialize their account with this object first!")
        } else {
            return "The signer does not store a Staking Collection object at the path "
                .concat(FlowStakingCollection.StakingCollectionStoragePath.toString())
                .concat(". The signer must initialize their account with this object first!")
        }
    }

    /// Creates a brand new empty staking collection resource and returns it to the caller
    access(all) fun createStakingCollection(
        unlockedVault: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,
        tokenHolder: Capability<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>?
    ): @StakingCollection {
        return <- create StakingCollection(unlockedVault: unlockedVault, tokenHolder: tokenHolder)
    }

    init() {
        self.StakingCollectionStoragePath = /storage/stakingCollection
        self.StakingCollectionPrivatePath = /private/stakingCollection
        self.StakingCollectionPublicPath = /public/stakingCollection
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/get_locked_account_address.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): Address {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getLockedAccountAddress()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/reset_epoch.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"

// The resetEpoch transaction ends the current epoch in the FlowEpoch smart contract
// and begins a new epoch with the given configuration. The new epoch always has
// the counter currentEpochCounter+1. The transaction sender must provide the 
// currentEpochCounter (before the reset takes place) as a safety mechanism.
//
// During network sporks, the bootstrapped protocol state is in a new Epoch (currentEpochCounter+1),
// and resetEpoch is used to change the epoch counter in the FlowEpoch smart contract
// from currentEpochCounter to (currentEpochCounter + 1), so that it's consistent with 
// the bootstrapped protocol state.
// This transaction should only be used with the output of the bootstrap utility:
//   util epoch reset-tx-args

transaction(currentEpochCounter: UInt64,
            randomSource: String,
            startView: UInt64,
            stakingEndView: UInt64,
            endView: UInt64) {

    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow heartbeat from storage path")

        epochAdmin.resetEpoch(currentEpochCounter: currentEpochCounter,
                            randomSource: randomSource,
                             startView: startView,
                             stakingEndView: stakingEndView,
                             endView: endView,
                             collectorClusters: [],
                             clusterQCs: [],
                             dkgPubKeys: [])
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/request_unstaking.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {
    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy

    prepare(account: auth(BorrowValue) &Account) {
        let holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")
        
        self.nodeDelegatorProxy = holderRef.borrowDelegator()
    }

    execute {
        self.nodeDelegatorProxy.requestUnstaking(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/update_networking_address.cdc

```
import "FlowIDTableStaking"

transaction(newAddress: String) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.stakerRef.updateNetworkingAddress(newAddress)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_execution_memory_weights.cdc

```
// This transactions sets new execution memory weights.
transaction(newWeights: {UInt64: UInt64}) {
    prepare(signer: auth(Storage) &Account) {
        signer.storage.load<{UInt64: UInt64}>(from: /storage/executionMemoryWeights)
        signer.storage.save(newWeights, to: /storage/executionMemoryWeights)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_delegators_below_min.cdc

```
import "FlowIDTableStaking"

// This script finds all of a node's delegators who are staked above zero
// but below the minimum of 50 FLOW and returns information about them

access(all) struct DelegatorBelowMinInfo {

    access(all) var totalStaked: UFix64
    access(all) var totalBelowMinimumStaked: UFix64

    access(all) var numDelegators: Int
    access(all) var numDelegatorsBelowMin: Int

    access(all) var delegatorInfoBelowMin: [FlowIDTableStaking.DelegatorInfo]

    init(numDelegators: Int) {
        self.totalStaked = 0.0
        self.totalBelowMinimumStaked = 0.0
        self.numDelegators = numDelegators
        self.numDelegatorsBelowMin = 0
        self.delegatorInfoBelowMin = []
    }

    access(all) fun addTotalStaked(_ stake: UFix64) {
        self.totalStaked = self.totalStaked + stake
    }

    access(all) fun addBelowMinStaked(_ stake: UFix64) {
        self.totalBelowMinimumStaked = self.totalBelowMinimumStaked + stake
    }

    access(all) fun addDelegatorBelowMin() {
        self.numDelegatorsBelowMin = self.numDelegatorsBelowMin + 1
    }

    access(all) fun addDelegatorInfo(_ info: FlowIDTableStaking.DelegatorInfo) {
        self.delegatorInfoBelowMin.append(info)
    }
}

access(all) fun main(nodeID: String): DelegatorBelowMinInfo {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)

    let delegators = nodeInfo.delegators

    let belowMinimum = DelegatorBelowMinInfo(numDelegators: delegators.length)

    for delegatorID in delegators {
        let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)

        belowMinimum.addTotalStaked(delInfo.tokensStaked)

        if delInfo.tokensStaked < 50.0 && delInfo.tokensStaked > 0.0 {
            belowMinimum.addDelegatorInfo(delInfo)
            belowMinimum.addDelegatorBelowMin()
            belowMinimum.addBelowMinStaked(delInfo.tokensStaked)
        }
    }

    return belowMinimum
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/withdraw_rewarded_tokens_locked.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.withdrawRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/accounts/add_key.cdc

```
import Crypto

transaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64) {

	prepare(signer: auth(AddKey) &Account) {
		pre {
			signatureAlgorithm == 1 || signatureAlgorithm == 2:
                "Cannot add Key: Must provide a signature algorithm raw value that corresponds to "
                .concat("one of the available signature algorithms for Flow keys.")
                .concat("You provided ").concat(signatureAlgorithm.toString())
                .concat(" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).")
			hashAlgorithm == 1 || hashAlgorithm == 3:
                "Cannot add Key: Must provide a hash algorithm raw value that corresponds to "
                .concat("one of of the available hash algorithms for Flow keys.")
                .concat("You provided ").concat(hashAlgorithm.toString())
                .concat(" but the options are either 1 (SHA2_256) or 3 (SHA3_256).")
			weight <= 1000.0:
                "Cannot add Key: The key weight must be between 0 and 1000."
                .concat(" You provided ").concat(weight.toString()).concat(" which is invalid.")
		}
		
		let publicKey = PublicKey(
			publicKey: key.decodeHex(),
			signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!
		)

		signer.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: weight)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_staked_tokens.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensStaked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/register_delegator.cdc

```
import "FlowToken"
import "LockedTokens"
import "FlowIDTableStaking"
import "FungibleToken"

transaction(id: String, amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")

        self.vaultRef = account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow flow token vault reference")
    }

    execute {
        let lockedBalance = self.holderRef.getLockedAccountBalance()

        if amount <= lockedBalance {

            self.holderRef.createNodeDelegator(nodeID: id)

            let stakerProxy = self.holderRef.borrowDelegator()

            stakerProxy.delegateNewTokens(amount: amount - FlowIDTableStaking.getDelegatorMinimumStakeRequirement())

        } else if ((amount - lockedBalance) <= self.vaultRef.balance) {

            self.holderRef.deposit(from: <-self.vaultRef.withdraw(amount: amount - lockedBalance))

            self.holderRef.createNodeDelegator(nodeID: id)

            let stakerProxy = self.holderRef.borrowDelegator()

            stakerProxy.delegateNewTokens(amount: amount - FlowIDTableStaking.getDelegatorMinimumStakeRequirement())

        } else {
            panic("Not enough tokens to stake!")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/withdraw_rewards.cdc

```
import "StakingProxy"

transaction(nodeID: String, amount: UFix64) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.withdrawRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/change_version_freeze_period.cdc

```
import "NodeVersionBeacon"

/// Transaction that allows NodeVersionAdmin to change
/// the defined versionUpdateBuffer

transaction(newFreezePeriod: UInt64) {

  let NodeVersionBeaconAdminRef: &NodeVersionBeacon.Admin

  prepare(acct: auth(BorrowValue) &Account) {
    // Borrow a reference to the NodeVersionAdmin implementing resource
    self.NodeVersionBeaconAdminRef = acct.storage.borrow<&NodeVersionBeacon.Admin>
      (from: NodeVersionBeacon.AdminStoragePath)
      ?? panic("Couldn't borrow NodeVersionBeacon.Admin Resource")
  }

  execute {
    self.NodeVersionBeaconAdminRef.setVersionBoundaryFreezePeriod(newFreezePeriod: newFreezePeriod)
  }

  post{
    NodeVersionBeacon.getVersionBoundaryFreezePeriod() == newFreezePeriod : "Freeze period was not updated"
  }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/unlock_tokens.cdc

```
import "LockedTokens"

transaction(targetAccount: Address, delta: UFix64) {

    prepare(admin: auth(BorrowValue) &Account) {

        let adminRef = admin.storage.borrow<&LockedTokens.TokenAdminCollection>(from: LockedTokens.LockedTokenAdminCollectionStoragePath)
            ?? panic("Could not borrow a reference to the admin collection")

        let tokenManagerRef = adminRef.getAccount(address: targetAccount)!.borrow()
            ?? panic("Could not borrow a reference to the user's token manager")

        tokenManagerRef.increaseUnlockLimit(delta: delta)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/get_node_id.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): String {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getNodeID()!
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/create_voter.cdc

```
import "FlowClusterQC"

// Test Transaction for a node to request a QC Voter Object from the contract
// Will be updated to use the epoch contract when that is completed
// The voter object only needs to be created once and is valid for every future epoch
// where the node is a valid staked node

// Parameters:
// 
// adminAddress: the address of the QC admin to request the Voter from
// nodeID: the id of the node that the account is operating
// stakingKey: The staking key for the collector node

transaction(adminAddress: Address, nodeID: String, stakingKey: String) {

    prepare(signer: auth(SaveValue) &Account) {

        // Get the admin reference from the admin account
        let admin = getAccount(adminAddress)
        let adminRef = admin.capabilities.borrow<&FlowClusterQC.Admin>(/public/voterCreator)
            ?? panic("Could not borrow a reference to the admin")

        // Create a voter object and save it to storage
        let voter <- adminRef.createVoter(nodeID: nodeID, stakingKey: stakingKey)

        signer.storage.save(<-voter, to: FlowClusterQC.VoterStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/lib/go/test/static/recover_new_epoch_unchecked.cdc

```
import FlowIDTableStaking from "FlowIDTableStaking"
import FlowEpoch from "FlowEpoch"
import FlowClusterQC from "FlowClusterQC"

// This transaction invokes recoverNewEpoch without the safety checks that exist in the
// production version of the transaction. Used for testing only.
transaction(recoveryEpochCounter: UInt64,
            startView: UInt64,
            stakingEndView: UInt64,
            endView: UInt64,
            targetDuration: UInt64,
            targetEndTime: UInt64,
            clusterAssignments: [[String]],
            clusterQCVoteData: [FlowClusterQC.ClusterQCVoteData],
            dkgPubKeys: [String],
            dkgGroupKey: String,
            dkgIdMapping: {String: Int},
            nodeIDs: [String],
            unsafeAllowOverwrite: Bool) {

    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow epoch admin from storage path")

        epochAdmin.recoverNewEpoch(
                recoveryEpochCounter: recoveryEpochCounter,
                startView: startView,
                stakingEndView: stakingEndView,
                endView: endView,
                targetDuration: targetDuration,
                targetEndTime: targetEndTime,
                clusterAssignments: clusterAssignments,
                clusterQCVoteData: clusterQCVoteData,
                dkgPubKeys: dkgPubKeys,
                dkgGroupKey: dkgGroupKey,
                dkgIdMapping: dkgIdMapping,
                nodeIDs: nodeIDs
            )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_next_version_boundary.cdc

```
import "NodeVersionBeacon"

/// Retrieves the next version boundary or nil
/// if there is no upcoming version boundary defined
access(all) fun main(): NodeVersionBeacon.VersionBoundary? {
    return NodeVersionBeacon.getNextVersionBoundary()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/setup_node_account.cdc

```
import "StakingProxy"

transaction() {

    prepare(nodeOperator: auth(SaveValue, Capabilities) &Account) {
        let proxyHolder <- StakingProxy.createProxyHolder()

        nodeOperator.storage.save(<-proxyHolder, to: StakingProxy.NodeOperatorCapabilityStoragePath)

        let nodeOperatorCap = nodeOperator.capabilities.storage.issue<&StakingProxy.NodeStakerProxyHolder>(
            StakingProxy.NodeOperatorCapabilityStoragePath
        )

        nodeOperator.capabilities.publish(
            nodeOperatorCap,
            at: StakingProxy.NodeOperatorCapabilityPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/start_staking.cdc

```
import "FlowIDTableStaking"

// This transaction pays rewards to all the staked nodes

transaction {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.startStakingAuction()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_remove_delegator.cdc

```
import "FlowIDTableStaking"
import "LockedTokens"

transaction {

    prepare(signer: auth(BorrowValue) &Account) {

        let managerRef = signer.storage.borrow<auth(LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(from: LockedTokens.LockedTokenManagerStoragePath)
            ?? panic("Could not borrow a reference to the locked token manager")

        let delegator <- managerRef.removeDelegator()!

        destroy delegator

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/end_epoch.cdc

```
import "FlowIDTableStaking"

// This transaction effectively ends the epoch and starts a new one.
//
// It combines the end_staking and move_tokens transactions
// which ends the staking auction, which refunds nodes with insufficient stake
// and moves tokens between buckets

transaction(ids: {String: Bool}) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setApprovedList(ids)
        
        self.adminRef.endStakingAuction()

        self.adminRef.moveTokens(newEpochCounter: 2)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_locked_tokens_used.cdc

```
import "FlowStakingCollection"

/// Tells how many locked tokens the account is using
/// For there staking collection nodes and delegators

access(all) fun main(account: Address): UFix64 {
    return FlowStakingCollection.getLockedTokensUsed(address: account)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_current_node_version_as_string.cdc

```
import "NodeVersionBeacon"

/// Gets the current version defined in the versionTable
/// as a String.
access(all) fun main(): String {
    let boundary = NodeVersionBeacon.getCurrentVersionBoundary()
    return boundary.version.toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_execution_memory_limit.cdc

```
import "FlowServiceAccount"

access(all) fun main(): UInt64 {
    return FlowServiceAccount.getExecutionMemoryLimit()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/stake_rewarded_tokens.cdc

```
import "LockedTokens"
import "StakingProxy"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.stakeRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/transfer_admin.cdc

```
import "FlowIDTableStaking"

transaction {
  prepare(owner: auth(Capabilities) &Account, receiver: auth(Storage) &Account) {

    // Get a staking admin capability
    let flowStakingAdmin = owner.capabilities.storage.issue<&FlowIDTableStaking.Admin>(FlowIDTableStaking.StakingAdminStoragePath)

    let capability <- receiver.storage.load<@FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)

    log(capability.getType())

    destroy capability

    // Save the capability to the receiver's account storage
    receiver.storage.save(flowStakingAdmin, to: FlowIDTableStaking.StakingAdminStoragePath)
  }
}
 

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_counter.cdc

```
import "FlowEpoch"

access(all) fun main(): UInt64 {
    return FlowEpoch.currentEpochCounter
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_voter_is_registered.cdc

```
import "FlowClusterQC"

// Returns a boolean indicating if a node is registered for voting

access(all) fun main(nodeID: String): Bool {

    return FlowClusterQC.voterIsRegistered(nodeID)

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_approved_nodes.cdc

```
import "FlowIDTableStaking"

// This transaction sets the list of approved nodes in the ID table

transaction(ids: {String: Bool}) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setApprovedList(ids)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/withdraw_unstaked_tokens.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.withdrawUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/calculate_rewards.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"

transaction() {
    prepare(signer: auth(BorrowValue) &Account) {
        let heartbeat = signer.storage.borrow<&FlowEpoch.Heartbeat>(from: FlowEpoch.heartbeatStoragePath)
            ?? panic("Could not borrow heartbeat from storage path")

        heartbeat.calculateAndSetRewards()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/custody_create_shared_accounts.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

/// Transaction that a custody provider would sign
/// to create a shared account and an unlocked
/// account for a user

transaction(
    partialAdminPublicKey: Crypto.KeyListEntry, // Weight: 100
    partialUserPublicKey: Crypto.KeyListEntry, // Weight: 900
    fullUserPublicKey: Crypto.KeyListEntry, // Weight: 1000
) {

    prepare(custodyProvider: auth(BorrowValue) &Account) {

        let sharedAccount = Account(payer: custodyProvider)
        let userAccount = Account(payer: custodyProvider)

        sharedAccount.keys.add(publicKey: partialAdminPublicKey.publicKey, hashAlgorithm: partialAdminPublicKey.hashAlgorithm, weight: partialAdminPublicKey.weight)
        sharedAccount.keys.add(publicKey: partialUserPublicKey.publicKey, hashAlgorithm: partialUserPublicKey.hashAlgorithm, weight: partialUserPublicKey.weight)

        userAccount.keys.add(publicKey: fullUserPublicKey.publicKey, hashAlgorithm: fullUserPublicKey.hashAlgorithm, weight: fullUserPublicKey.weight)

        let vaultCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)

        let lockedTokenManager <- LockedTokens.createLockedTokenManager(vault: vaultCapability)

        sharedAccount.storage.save(<-lockedTokenManager, to: LockedTokens.LockedTokenManagerStoragePath)

        let tokenManagerCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let tokenHolder <- LockedTokens.createTokenHolder(
            lockedAddress: sharedAccount.address,
            tokenManager: tokenManagerCapability
        )

        userAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let tokenHolderCap = userAccount.capabilities.storage.issue<&LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        userAccount.capabilities.publish(tokenHolderCap, at: LockedTokens.LockedAccountInfoPublicPath)

        let tokenAdminCapability = sharedAccount.capabilities.storage
            .issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath
            )

        let lockedAccountCreator = custodyProvider.storage
            .borrow<auth(LockedTokens.AccountCreator) &LockedTokens.LockedAccountCreator>(from: LockedTokens.LockedAccountCreatorStoragePath)
            ?? panic("Could not borrow account creator reference")

        lockedAccountCreator.addAccount(
            sharedAccountAddress: sharedAccount.address,
            unlockedAccountAddress: userAccount.address,
            tokenAdmin: tokenAdminCapability
        )

        // Override the default FlowToken receiver.
        sharedAccount.capabilities.unpublish(/public/flowTokenReceiver)

        // create new receiver that marks received tokens as unlocked.
        let lockedTokensManagerCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(LockedTokens.LockedTokenManagerStoragePath)
        sharedAccount.capabilities.publish(
            lockedTokensManagerCap,
            at: /public/flowTokenReceiver
        )

        // put normal receiver in a separate unique path.
        let tokenReceiverCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(/storage/flowTokenVault)
        sharedAccount.capabilities.publish(
            tokenReceiverCap,
            at: /public/lockedFlowTokenReceiver
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_epoch_views.cdc

```
import "FlowEpoch"

transaction(newAuctionViews: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateEpochViews(newAuctionViews)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_info.cdc

```
import "FlowIDTableStaking"

// This script returns all the info associated with a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): FlowIDTableStaking.DelegatorInfo {
    return FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_node_weight.cdc

```
import "FlowClusterQC"

access(all) fun main(clusterIndex: UInt16, nodeID: String): UInt64 {

    let clusters = FlowClusterQC.getClusters()

    if clusters[clusterIndex].nodeWeights[nodeID] != nil {
        return clusters[clusterIndex].nodeWeights[nodeID]!
    } else {
        return 0 as UInt64
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/README.md

# Flow Core Smart Contracts

These are the smart contracts that define the core functionality of the Flow protocol.

The version of the contracts in the `master` branch is the
Cadence 1.0 version of the contracts and is not the same
as the ones that are currently deployed to testnet and mainnet.
See the `cadence-0.42` branch for the currently deployed versions.

# What is Flow?

Flow is a new blockchain for open worlds. Read more about it [here](https://www.onflow.org/).

# What is Cadence?

Cadence is a new Resource-oriented programming language
for developing smart contracts for the Flow Blockchain.
Read more about it [here](https://www.docs.onflow.org)

We recommend that anyone who is reading this should have already
completed the [Cadence Tutorials](https://docs.onflow.org/docs/getting-started-1)
so they can build a basic understanding of the programming language.

## FlowToken

`contracts/FlowToken.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0x0ae53cb6e3f42a79` |
| Testnet  | `0x7e60df042a9c0868` |
| Mainnet  | `0x1654653399040a61` |

This is the contract that defines the network token for Flow.
This token is used for account creation fees, transaction fees, staking, and more. It is
implemented as a regular smart contract so that it can be easily used
just like any other token in the network. See the [flow fungible token repository](https://github.com/onflow/flow-ft)
for more information.

You can find transactions for using the Flow Token in the `transactions/flowToken` directory.

## Flow Transaction Fee Contract

`contracts/FlowFees.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xe5a8b7f23e8b548f` |
| Testnet  | `0x912d5440f7e3769e` |
| Mainnet  | `0xf919ee77447b7497` |

This contract defines fees that are spent for executing transactions and creating accounts.

## Storage Fee Contract

`contracts/FlowStorageFees.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x8c5303eaa26202d6` |
| Mainnet  | `0xe467b9dd11fa00df` |

This contract defines fees that are spent to pay for the storage that an account uses.
There is a minimum balance that an account needs to maintain in its main `FlowToken` Vault
in order to pay for the storage it uses.
You can see [more docs about storage capacity and fees here.](https://docs.onflow.org/concepts/storage/#overview)

## Service Account Contract

`contracts/FlowServiceAccount.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x8c5303eaa26202d6` |
| Mainnet  | `0xe467b9dd11fa00df` |

This contract manages account creation and flow token initialization. It enforces temporary
requirements for which accounts are allowed to create other accounts, and provides common
functionality for flow tokens.

You can find transactions for interacting with the service account contract in the `transactions/FlowServiceAccount` directory.

## Random Beacon History Contract

`contracts/RandomBeaconHistory.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x8c5303eaa26202d6` |
| Mainnet  | `0xe467b9dd11fa00df` |

This contract stores the history of random sources generated by
the Flow network. The defined Heartbeat resource is
updated by the Flow Service Account at the end of every block
with that block's source of randomness.

You can find transactions for interacting with the random beacon
 history contract in the `transactions/randomBeaconHistory` directory.

## Node Version Beacon Contract

`contracts/NodeVersionBeacon.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x8c5303eaa26202d6` |
| Mainnet  | `0xe467b9dd11fa00df` |

The `NodeVersionBeacon` contract holds the past
and future protocol versions that should be used
to execute/handle blocks at a given block height.

You can find transactions for interacting with the node version beacon
history contract in the `transactions/nodeVersionBeacon` directory.

## Flow Epochs, Identity Table, and Staking Contracts

`contracts/FlowIDTableStaking.cdc`
`contracts/epochs/FlowEpoch.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x9eca2b38b18b5dfe` |
| Mainnet  | `0x8624b52f9ddcd04a` |

These contract manages the list of identities that correspond to node operators in the Flow network
as well as the process for adding and removing nodes from the network via Epochs.
Each node identity stakes tokens with these contracts, and also gets paid rewards with their contracts.
This contract also manages the logic for users to delegate their tokens to a node operator
and receive their own rewards. You can see an explanation of this process in the staking section
of the [Flow Docs website](https://docs.onflow.org/token/staking/).

You can find all the transactions for interacting with the IDTableStaking contract with unlocked FLOW
in the `transactions/idTableStaking` directory, though it is recommended to use the staking collection
transactions instead. These are described in the "Flow Staking Collection" section below.

You can also find transactions and scripts for interacting
with all the epoch smart contracts in the following directories:
`transactions/epoch/`
`transactions/dkg/`
`transactions/quorumCertificate/`

You can also find scripts for querying info about staking and stakers in the `transactions/idTableStaking/scripts/` directory.
These scripts are documented in the [staking scripts section of the docs](https://docs.onflow.org/staking/scripts/)

## Flow Locked Tokens contract

`contracts/LockedTokens.cdc`

| Network  | Contract Address     |
| ---------| -------------------- |
| Emulator | `0xf8d6e0586b0a20c7` |
| Testnet  | `0x95e019a17d0e23d7` |
| Mainnet  | `0x8d0e87b65159ae63` |

This contract manages the two year lockup of Flow tokens that backers purchased in the initial
token sale in October of 2020. See more documentation about `LockedTokens` [here.](https://docs.onflow.org/flow-token/locked-account-setup/)

## Flow Staking Collection Contract

`contracts/FlowStakingCollection.cdc`

The `StakingCollection` contract has the same import addresses
as the `LockedTokens` contract on all the networks.

A Staking Collection is a resource that allows its owner to manage multiple staking
objects in a single account via a single storage path, and perform staking and delegation actions using both locked and unlocked Flow.

Before the staking collection, accounts could use the instructions in [the unlocked staking guide](https://docs.onflow.org/staking/unlocked-staking-guide/)
to stake with tokens. This was a bit restrictive, because that guide (and the corresponding transactions) only supports one node and one delegator object
per account. If a user wanted to have more than one per account, they would either have to use custom transactions with custom storage paths for each object,
or they would have had to use multiple accounts, which comes with many hassles of its own.

The same applies to the [locked tokens staking guide](https://docs.onflow.org/staking/locked-staking-guide/).
We only built in support for one node and one delegator per account.

The staking collection is a solution to both of these deficiencies. When an account is set up to use a staking collection,
the staking collection recognizes the existing locked account capabilities (if they exist) and unlocked account staking objects,
and incorporates their functionality so any user can stake for a node or delegator through a single common interface, regardless of
if they have a brand new account, or have been staking through the locked account or unlocked account before.

### Is the staking collection mandatory

Flow Port uses staking collection transaction by default other services are encouraged
to use it instead of any of the other account staking setups.
If you provide a staking service for [Ledger](https://www.ledger.com/) or [Blocto](https://blocto.io/download) users, you will need to upgrade
to this if you want to give your users access to the entire functionality of their account
if they are also using Flow Port. If their entire interaction with staking is through Flow Port,
then all the changes are handled for them and there is nothing for you to worry about.

### Staking Collection Technical features

* The staking collection contract stores [a dictionary of staking objects](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStakingCollection.cdc#L68) from the staking contract that are used to manage the stakers tokens. Since they are dictionaries, there can be as many node or delegator objects per account as the user wants.
* The resource only has one set of staking methods, which route the call to the correct staking object based on the arguments that the caller specifies. (nodeID, delegatorID)
* The contract also stores an [optional capability to the locked token vault](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStakingCollection.cdc#L63) and [locked tokens `TokenHolder` resource](https://github.com/onflow/flow-core-contracts/blob/master/ontracts/FlowStakingCollection.cdc#L73). This is only used if the user already has a locked account. The staking collection does not change the locked account setup at all, it only has access to it and to the locked vault.
* The collection makes the staking objects and vault capability fields private, because since it has access to the locked tokens, it needs to mediate access to the staking objects so users cannot withdraw tokens that are still locked from the sale. The resource has fields `unlockedTokensUsed` and `lockedTokensUsed`, to keep track of how many locked and unlocked tokens are being used for staking in order to allow the user to withdraw the correct amount when they choose to.
* The staking collection contract is a brand new contract that will be deployed to the same account as the existing locked tokens contract. A few of the fields on the `LockedTokens` contract have been updated to have `access(account)` visibility instead of `access(self)` because the staking collection contract needs to be able to access to them in order to work properly.
* We also included a public interface and getters in the contract so you can easily query it with an address to get node or delegator information from a collection.

Looking for feedback on design decisions, implementation details, any events that would be useful to include in the contract, and whatever you feel is important!

We intend for this to be the method that all Flow Port users (ledger, blocto, etc) use for the forseeable future. When we enable it in Flow Port, we will ask every user to run a transaction to set up their account to use the staking collection from then on.

## Linear Code Address Generator

`contracts/LinearCodeAddressGenerator.cdc`

The linear code address generator contract allows translating an address index to an address,
and and address back to an address index.
It implements the same address generation logic as used on all Flow networks.

# Testing

To run the tests in the repo, use `make test`.

These tests need to utilize the transaction templates that are contained in `transactions/`.

# Audit

Flow Core Contracts were audited by Quantstamp in July 2021: [final report](https://certificate.quantstamp.com/full/epoch-functionality-contracts.pdf).

# Getting Transaction Templates

If you need to use the contracts and transaction templates we have provided in an app, you don't necessarily
need to copy and paste them into your code. We plan on providing packages for different
languages to import in order to use the transactions instead of copying and pasting.

We currently include the `lib/go/templates` package for getting templates in the Go programming language.
To use this package, run `go get github.com/onflow/flow-core-contracts/lib/go/templates@{latest version}`
in your Go project direcory. To use it in your Go code, you can simply call one of the many
template getters in one of the `*_templates.go` files.

### Packages in other languages

We would like to add new packages for other popular languages to get transaction templates.
If you would like to contribute to add one of these new packages, please reach out
to the team and we would be happy to help!

## License

The works in these folders are under the [Unlicense](https://github.com/onflow/flow-core-contracts/blob/master/LICENSE):

- [src/contracts](https://github.com/onflow/flow-core-contracts/tree/master/contracts)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster_weight.cdc

```
import "FlowClusterQC"

access(all) fun main(clusterIndex: UInt16): UInt64 {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].totalWeight

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/deposit_fees.cdc

```
import "FungibleToken"
import "FlowToken"
import "FlowFees"

// Deposit tokens to the FlowFees Vault
// only for testing

transaction(amount: UFix64) {

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
			?? panic("Could not borrow reference to the owner's Vault!")

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {
        // Deposit the withdrawn tokens in the FlowFees vault
        FlowFees.deposit(from: <-self.sentVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_node_has_submitted.cdc

```
import "FlowDKG"

access(all) fun main(nodeID: String): Bool {
    return FlowDKG.nodeHasSubmitted(nodeID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/send_empty_final_submission.cdc

```
import "FlowDKG"

// Used by DKG participants to submit their final submission for the current DKG instance.
// This transaction is used when the participant locally failed the DKG process, and are
// recording this by submitting an empty result. For non-empty submissions, use "send_final_submission".
transaction() {

    let dkgParticipant: &FlowDKG.Participant
    let submission: FlowDKG.ResultSubmission

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgParticipant = signer.storage.borrow<&FlowDKG.Participant>(from: FlowDKG.ParticipantStoragePath)
            ?? panic("Cannot borrow DKG Participant reference from path "
                    .concat(FlowDKG.ParticipantStoragePath.toString())
                    .concat(". The signer needs to ensure their account is initialized with the DKG Participant resource."))
        self.submission = FlowDKG.ResultSubmission(groupPubKey: nil, pubKeys: nil, idMapping: nil)
    }

    execute {
        self.dkgParticipant.sendFinalSubmission(self.submission)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/remove_approved_nodes.cdc

```
import "FlowIDTableStaking"

// This transaction removes node IDs from the list of approved nodes in
// the ID table. 
// If any of the IDs DO NOT exist already in the identity table, this
// transaction will revert (not idempotent)

transaction(ids: [String]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
	let nodeIDs = FlowIDTableStaking.getApprovedList()
        ?? panic("Could not read approve list from storage")

	// remove each node 
	for nodeIDToRemove in ids {
		nodeIDs[nodeIDToRemove] = nil
	}

	// set the approved list to the new allow-list
        self.adminRef.setApprovedList(nodeIDs)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_tx_fee_surge_factor.cdc

```
import "FlowFees"

// This transaction sets the FlowFees parameters
transaction(surgeFactor: UFix64) {
	let flowFeesAccountAdmin: &FlowFees.Administrator

	prepare(signer: auth(BorrowValue) &Account) {
		self.flowFeesAccountAdmin = signer.storage.borrow<&FlowFees.Administrator>(from: /storage/flowFeesAdmin)
			?? panic("Unable to borrow reference to administrator resource")
	}
	execute {
		self.flowFeesAccountAdmin.setFeeSurgeFactor(surgeFactor: surgeFactor)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/remove_account_creator.cdc

```
import "FlowServiceAccount"

// This transaction removes an account creator
transaction(accountCreator: Address) {

	let serviceAccountAdmin: &FlowServiceAccount.Administrator

	prepare(signer: auth(BorrowValue) &Account) {
		// Borrow reference to FlowServiceAccount Administrator resource.
		//
		self.serviceAccountAdmin = signer.storage.borrow<&FlowServiceAccount.Administrator>(from: /storage/flowServiceAdmin)
			?? panic("Unable to borrow reference to administrator resource")
	}
	execute {
		self.serviceAccountAdmin.removeAccountCreator(accountCreator)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_consensus_nodes.cdc

```
import "FlowDKG"

access(all) fun main(): [String] {
    return FlowDKG.getConsensusNodeIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_cut_percentage.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(): UFix64 {
    return FlowIDTableStaking.getRewardCutPercentage()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_committed.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of committed tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensCommitted
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_node_is_claimed.cdc

```
import "FlowDKG"

access(all) fun main(nodeID: String): Bool {
    if FlowDKG.participantIsClaimed(nodeID) != nil {
        return FlowDKG.participantIsClaimed(nodeID)!
    } else {
        return false
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_proposed_counter.cdc

```
import "FlowEpoch"

access(all) fun main(): UInt64 {
    return FlowEpoch.proposedEpochCounter()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/restake_all_stakers.cdc

```
import "FlowStakingCollection"
import "FlowIDTableStaking"

/// Commits rewarded tokens to stake for all nodes and delegators in a collection

transaction {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))
    }

    execute {
        let nodeIDs = self.stakingCollectionRef.getNodeIDs()

        for nodeID in nodeIDs {
            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
            self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: nil, amount: nodeInfo.tokensRewarded)
        }

        let delegators = self.stakingCollectionRef.getDelegatorIDs()

        for delegator in delegators {
            let delegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegator.delegatorNodeID, delegatorID: delegator.delegatorID)
            
            self.stakingCollectionRef.stakeRewardedTokens(nodeID: delegator.delegatorNodeID, delegatorID: delegator.delegatorID, amount: delegatorInfo.tokensRewarded)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/change_del_minimums.cdc

```
import "FlowIDTableStaking"

// This transaction changes the flow token reward cut that nodes take from delegators

transaction(newDelegatorMinimum: UFix64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setDelegatorMinimumStakeRequirement(newDelegatorMinimum)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_is_account_creation_restricted.cdc

```
import "FlowServiceAccount"

// This transaction changes `is account ceration restricted` value
transaction(restricted: Bool) {

	let serviceAccountAdmin: &FlowServiceAccount.Administrator

	prepare(signer: auth(BorrowValue) &Account) {
		// Borrow reference to FlowServiceAccount Administrator resource.
		//
		self.serviceAccountAdmin = signer.storage.borrow<&FlowServiceAccount.Administrator>(from: /storage/flowServiceAdmin)
			?? panic("Unable to borrow reference to administrator resource")
	}
	execute {
		self.serviceAccountAdmin.setIsAccountCreationRestricted(restricted)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/node/register_node.cdc

```
import Crypto
import "FlowIDTableStaking"
import "FlowToken"
import "FlowClusterQC"
import "FlowDKG"
import "FlowEpoch"
import "FungibleToken"

// This transaction creates a new node struct object
// Then, if the node is a collector node, creates a new account and adds a QC object to it
// If the node is a consensus node, it creates a new account and adds a DKG object to it

transaction(
    id: String,
    role: UInt8,
    networkingAddress: String,
    networkingKey: String,
    stakingKey: String,
    amount: UFix64,
    publicKeys: [Crypto.KeyListEntry]
) {

    let flowTokenRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(Storage, Capabilities, AddKey) &Account) {

        self.flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

        // Register Node
        if acct.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) == nil {

            let nodeStaker <- FlowIDTableStaking.addNodeRecord(
                id: id,
                role: role,
                networkingAddress: networkingAddress,
                networkingKey: networkingKey,
                stakingKey: stakingKey,
                tokensCommitted: <-self.flowTokenRef.withdraw(amount: amount)
            )

            acct.storage.save(<-nodeStaker, to: FlowIDTableStaking.NodeStakerStoragePath)

            let nodeStakerCap = acct.capabilities.storage.issue<&{FlowIDTableStaking.NodeStakerPublic}>(FlowIDTableStaking.NodeStakerStoragePath)
            acct.capabilities.publish(nodeStakerCap, at: FlowIDTableStaking.NodeStakerPublicPath)
        }

        let nodeRef = acct.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow node reference from storage path")

        let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeRef.id)

        // If the node is a collector or consensus node, create a secondary account for their specific objects
        if nodeInfo.role == 1 as UInt8 {

            let machineAcct = Account(payer: acct)
            for key in publicKeys {
                machineAcct.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
            }

            let qcVoter <- FlowEpoch.getClusterQCVoter(nodeStaker: nodeRef)
            machineAcct.storage.save(<-qcVoter, to: FlowClusterQC.VoterStoragePath)

        } else if nodeInfo.role == 2 as UInt8 {

            let machineAcct = Account(payer: acct)
            for key in publicKeys {
                machineAcct.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
            }

            let dkgParticipant <- FlowEpoch.getDKGParticipant(nodeStaker: nodeRef)
            machineAcct.storage.save(<-dkgParticipant, to: FlowDKG.ParticipantStoragePath)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/send_final_submission.cdc

```
import "FlowDKG"

// Used by DKG participants to submit their final submission for the current DKG instance.
// This transaction is used when the participant locally passed the DKG process.
// For empty submissions, use "send_empty_final_submission".
transaction(groupKey: String, pubKeys: [String], idMapping: {String: Int}) {

    let dkgParticipant: &FlowDKG.Participant
    let submission: FlowDKG.ResultSubmission

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgParticipant = signer.storage.borrow<&FlowDKG.Participant>(from: FlowDKG.ParticipantStoragePath)
            ?? panic("Cannot borrow DKG Participant reference from path "
                    .concat(FlowDKG.ParticipantStoragePath.toString())
                    .concat(". The signer needs to ensure their account is initialized with the DKG Participant resource."))
        self.submission = FlowDKG.ResultSubmission(groupPubKey: groupKey, pubKeys: pubKeys, idMapping: idMapping)
    }

    execute {
        self.dkgParticipant.sendFinalSubmission(self.submission)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/register_many_nodes.cdc

```
import "FlowIDTableStaking"
import "FlowToken"
import "FungibleToken"

transaction(
    ids: [String],
    roles: [UInt8],
    networkingAddresses: [String],
    networkingKeys: [String],
    stakingKeys: [String],
    amounts: [UFix64],
    paths: [StoragePath]
) {

    prepare(acct: auth(Storage) &Account) {

        var i = 0

        for path in paths {

            let flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
                ?? panic("Could not borrow reference to FLOW Vault")

            let tokensCommitted <- flowTokenRef.withdraw(amount: amounts[i])

            let nodeStaker <- FlowIDTableStaking.addNodeRecord(
                id: ids[i],
                role: roles[i],
                networkingAddress: networkingAddresses[i],
                networkingKey: networkingKeys[i],
                stakingKey: stakingKeys[i],
                tokensCommitted: <-tokensCommitted
            )

            // Store the node object
            acct.storage.save(<-nodeStaker, to: path)

            i = i + 1
        }
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_non_operational.cdc

```
import "FlowIDTableStaking"

// This script returns the list of non-operational nodes

access(all) fun main(): [String] {
    return FlowIDTableStaking.getNonOperationalNodesList().keys
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_account_creators.cdc

```
import "FlowServiceAccount"

access(all) fun main(): [Address] {
    return FlowServiceAccount.getAccountCreators()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_whiteboard_messages.cdc

```
import "FlowDKG"

access(all) fun main(): [FlowDKG.Message] {
    return FlowDKG.getWhiteBoardMessages() 
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/change_candidate_limits.cdc

```
import "FlowIDTableStaking"

/// This transaction changes the limit of new nodes that can be candidates
/// for the next epoch
transaction(role: UInt8, newCandidateNodeLimit: UInt64) {

    /// Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setCandidateNodeLimit(role: role, newLimit: newCandidateNodeLimit)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_config_metadata.cdc

```
import "FlowEpoch"

access(all) fun main(): FlowEpoch.Config {
    return FlowEpoch.getConfigMetadata()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_epoch_timing_config.cdc

```
import "FlowEpoch"

transaction(duration: UInt64, refCounter: UInt64, refTimestamp: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        let config = FlowEpoch.EpochTimingConfig(duration: duration, refCounter: refCounter, refTimestamp: refTimestamp)
        epochAdmin.updateEpochTimingConfig(config)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_dkg_canonical_final_submission.cdc

```
import "FlowDKG"

access(all) fun main(): FlowDKG.ResultSubmission? {
    return FlowDKG.dkgCompleted()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/get_locked_account_balance.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): UFix64 {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getLockedAccountBalance()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_stake_unstaked.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the Delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to delegator")

    }

    execute {

        self.delegatorRef.delegateUnstakedTokens(amount: amount)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/.github/ISSUE_TEMPLATE/feature-request.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/add_account_creator.cdc

```
import "FlowServiceAccount"

// This transaction adds a new account crerator
transaction(accountCreator: Address) {

	let serviceAccountAdmin: &FlowServiceAccount.Administrator

	prepare(signer: auth(BorrowValue) &Account) {
		// Borrow reference to FlowServiceAccount Administrator resource.
		//
		self.serviceAccountAdmin = signer.storage.borrow<&FlowServiceAccount.Administrator>(from: /storage/flowServiceAdmin)
			?? panic("Unable to borrow reference to administrator resource")
	}
	execute {
		self.serviceAccountAdmin.addAccountCreator(accountCreator)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/delegate_new_tokens.cdc

```
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")

        self.vaultRef = account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow flow token vault reference")
    }

    execute {
        let stakerProxy = self.holderRef.borrowDelegator()

        let lockedBalance = self.holderRef.getLockedAccountBalance()

        if amount <= lockedBalance {

            stakerProxy.delegateNewTokens(amount: amount)

        } else if ((amount - lockedBalance) <= self.vaultRef.balance) {

            self.holderRef.deposit(from: <-self.vaultRef.withdraw(amount: amount - lockedBalance))

            stakerProxy.delegateNewTokens(amount: amount)
        } else {
            panic("Not enough tokens to stake!")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/withdraw_reward_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"


transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    let flowTokenRef: &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")

        self.flowTokenRef = acct.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")
    }

    execute {
        self.flowTokenRef.deposit(from: <-self.stakerRef.withdrawRewardedTokens(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/create_new_tokenholder_acct.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"
import "FlowStakingCollection"

// This transaction allows the controller of the locked account
// to create a new LockedTokens.TokenHolder object and store it in a new account
// also adding a staking collection object to the new account

// Keep in mind that this does not invalidate the existing TokenHolder account
// To invalidate that account, you need to either delete the TokenHolder resource
// or revoke all keys from that account

transaction(publicKeys: [Crypto.KeyListEntry]) {
    prepare(signer: auth(BorrowValue, Storage, Capabilities) &Account) {

        // Create the new account and add public keys.
        let newAccount = Account(payer: signer)
        for key in publicKeys {
            newAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
        }

        // Get the TokenManager Capability from the locked account.
        let tokenManagerCapabilityController = signer.capabilities.storage.getControllers(forPath: LockedTokens.LockedTokenManagerStoragePath)[2]!
        let tokenManagerCapability = tokenManagerCapabilityController.capability as! Capability<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>

        // Use the manager capability to create a new TokenHolder.
        let tokenHolder <- LockedTokens.createTokenHolder(
            lockedAddress: signer.address,
            tokenManager: tokenManagerCapability
        )

        // Save the TokenHolder resource to the new account and create a public capability.
        newAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let tokenHolderCap = newAccount.capabilities.storage
            .issue<&LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        newAccount.capabilities.publish(
            tokenHolderCap,
            at: LockedTokens.LockedAccountInfoPublicPath
        )


        // Create capabilities for the token holder and unlocked vault.
        let lockedHolder = newAccount.capabilities.storage.issue<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)
        let flowToken = newAccount.capabilities.storage.issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)
        
        // Create a new Staking Collection and put it in storage.
        if lockedHolder.check() {
            newAccount.storage.save(
                <- FlowStakingCollection.createStakingCollection(
                    unlockedVault: flowToken,
                    tokenHolder: lockedHolder
                ),
                to: FlowStakingCollection.StakingCollectionStoragePath
            )
        } else {
            newAccount.storage.save(
                <- FlowStakingCollection.createStakingCollection(
                    unlockedVault: flowToken,
                    tokenHolder: nil
                ),
                to: FlowStakingCollection.StakingCollectionStoragePath
            )
        }

        // Publish a capability to the created staking collection.
        let stakingCollectionCap = newAccount.capabilities.storage.issue<&FlowStakingCollection.StakingCollection>(
            FlowStakingCollection.StakingCollectionStoragePath
        )

        newAccount.capabilities.publish(
            stakingCollectionCap,
            at: FlowStakingCollection.StakingCollectionPublicPath
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_weekly_payout.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(): UFix64 {
    return FlowIDTableStaking.getEpochTokenPayout()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_create_clusters.cdc

```
import "FlowEpoch"
import "FlowClusterQC"

access(all) fun main(array: [String]): [FlowClusterQC.Cluster] {
    return FlowEpoch.createCollectorClusters(nodeIDs: array)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/send_whiteboard_message.cdc

```
import "FlowDKG"

transaction(content: String) {

    let dkgParticipant: &FlowDKG.Participant

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgParticipant = signer.storage.borrow<&FlowDKG.Participant>(from: FlowDKG.ParticipantStoragePath)
            ?? panic("Cannot borrow dkg participant reference")
    }

    execute {
        self.dkgParticipant.postMessage(content)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/move_tokens.cdc

```
import "FlowIDTableStaking"

// This transaction moves tokens between buckets

transaction {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.moveTokens(newEpochCounter: 2)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/unstake_all.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction() {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.unstakeAll()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_dkg_completed.cdc

```
import "FlowDKG"

access(all) fun main(): Bool {
    return FlowDKG.dkgCompleted() != nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_execution_effort_weights.cdc

```
// This transactions sets new execution effort weights
// The maximum execution effort limit for transactions is always 99999.
// The weight names/ids can be seen here:
// 
// - [Cadence ComputationKind](https://github.com/onflow/cadence/blob/6075ef48c7c2a061d27e36b095ae7ec5e2045ca7/runtime/common/computationkind.go#L30)
// - [FVM ComputationKind](https://github.com/onflow/flow-go/blob/1df43de85c5b75618511a8fe99e9998ab2e4cd59/fvm/meter/meter.go#L9)
//
// - the internal precision of the execution effort meter is 2^16, which means 2^16 is equal to 1 out of the total 99999 execution effort available to a transaction.
//
// The default weights are:
//
// - ComputationKindLoop: 1
// - ComputationKindStatement: 1 
// - ComputationKindFunctionInvocation: 1
//
// or in parameter form:
//
// ```json
// [
//   {
//     "type": "Dictionary",
//     "value": [
//       {
//         "key": { "type": "UInt64", "value": "1001" },
//         "value": { "type": "UInt64", "value": "65536" }
//       },
//       {
//         "key": { "type": "UInt64", "value": "1002" },
//         "value": { "type": "UInt64", "value": "65536" }
//       },
//       {
//         "key": { "type": "UInt64", "value": "1003" },
//         "value": { "type": "UInt64", "value": "65536" }
//       }
//     ]
//   },
//   { "type": "Path", "value": { "domain": "storage", "identifier": "executionEffortWeights" } }
// ]
// ```
transaction(newWeights: {UInt64: UInt64}) {
    prepare(signer: auth(Storage) &Account) {
        signer.storage.load<{UInt64: UInt64}>(from: /storage/executionEffortWeights)
        signer.storage.save(newWeights, to: /storage/executionEffortWeights)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_committed_tokens.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensCommitted
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/scripts/get_storage_capacity.cdc

```
import "FlowStorageFees"

access(all) fun main(accountAddress: Address): UFix64 {
    return FlowStorageFees.calculateAccountCapacity(accountAddress)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/verify_payer_balance_for_tx_execution.cdc

```
import "FlowFees"

access(all) fun main(payerAcct: Address, inclusionEffort: UFix64, maxExecutionEffort: UFix64): FlowFees.VerifyPayerBalanceResult {
    let authAcct = getAuthAccount<auth(BorrowValue) &Account>(payerAcct)
    return FlowFees.verifyPayersBalanceForTransactionExecution(authAcct, inclusionEffort: inclusionEffort,
        maxExecutionEffort: maxExecutionEffort)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/admin/stop_voting.cdc

```
import "FlowClusterQC"

// Test transaction for the QC contract to stop the voting period

transaction {

    prepare(signer: auth(BorrowValue) &Account) {
        let adminRef = signer.storage.borrow<&FlowClusterQC.Admin>(from: FlowClusterQC.AdminStoragePath)
            ?? panic("Could not borrow reference to qc admin")

        adminRef.stopVoting()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/unstake_all.cdc

```
import "StakingProxy"

transaction(nodeID: String) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.unstakeAll()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_unlocked_tokens_used.cdc

```
import "FlowStakingCollection"

/// Tells how many unlocked tokens the account is using
/// For there staking collection nodes and delegators

access(all) fun main(account: Address): UFix64 {
    return FlowStakingCollection.getUnlockedTokensUsed(address: account)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster_vote_threshold.cdc

```
import "FlowClusterQC"

access(all) fun main(clusterIndex: UInt16): UInt64 {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].voteThreshold()

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_withdraw_reward_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"


transaction(amount: UFix64) {

    // Local variable for a reference to the delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    let flowTokenRef: &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to staking admin")

        self.flowTokenRef = acct.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

    }

    execute {

        self.flowTokenRef.deposit(from: <-self.delegatorRef.withdrawRewardedTokens(amount: amount))

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/withdraw_unstaked.cdc

```
import "StakingProxy"

transaction(nodeID: String, amount: UFix64) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.withdrawUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/pay_rewards.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"

/// Pays the rewards for the previous epoch
/// If the rewards have already been paid, the payment will not happen

transaction {
    prepare(signer: auth(BorrowValue) &Account) {
        let heartbeat = signer.storage.borrow<&FlowEpoch.Heartbeat>(from: FlowEpoch.heartbeatStoragePath)
            ?? panic("Could not borrow heartbeat from storage path")

        heartbeat.payRewardsForPreviousEpoch()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/custody_setup_account_creator.cdc

```
import "LockedTokens"

transaction {

    prepare(custodyProvider: auth(SaveValue, Capabilities) &Account) {

        let accountCreator <- LockedTokens.createLockedAccountCreator()

        custodyProvider.storage.save(
            <-accountCreator,
            to: LockedTokens.LockedAccountCreatorStoragePath
        )

        // create new receiver that marks received tokens as unlocked
        let lockedAccountCreatorCap = custodyProvider.capabilities.storage.issue<&LockedTokens.LockedAccountCreator>(
            LockedTokens.LockedAccountCreatorStoragePath
        )

        custodyProvider.capabilities.publish(
            lockedAccountCreatorCap,
            at: LockedTokens.LockedAccountCreatorPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_initial_weight.cdc

```
import "FlowIDTableStaking"

// This script returns the initial weight of a node

access(all) fun main(nodeID: String): UInt64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.initialWeight
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_machine_account_address.cdc

```
import "FlowStakingCollection"

/// Gets the machine account address for a specific node
/// in an account's staking collection

access(all) fun main(account: Address, nodeID: String): Address? {
    let machineAccounts = FlowStakingCollection.getMachineAccounts(address: account)

    if let accountInfo = machineAccounts[nodeID] {
        return accountInfo.getAddress()
    } else {
        return nil
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/accounts/create_new_account.cdc

```
import Crypto

transaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8) {
	prepare(signer: auth(BorrowValue, Storage) &Account) {
		pre {
			signatureAlgorithm == 1 || signatureAlgorithm == 2:
                "Cannot add Key: Must provide a signature algorithm raw value that corresponds to "
                .concat("one of the available signature algorithms for Flow keys.")
                .concat("You provided ").concat(signatureAlgorithm.toString())
                .concat(" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).")
			hashAlgorithm == 1 || hashAlgorithm == 3:
                "Cannot add Key: Must provide a hash algorithm raw value that corresponds to "
                .concat("one of of the available hash algorithms for Flow keys.")
                .concat("You provided ").concat(hashAlgorithm.toString())
                .concat(" but the options are either 1 (SHA2_256) or 3 (SHA3_256).")
		}

		let publicKey = PublicKey(
			publicKey: key.decodeHex(),
			signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!
		)

		let account = Account(payer: signer)

		account.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: 1000.0)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/setup_staking_collection.cdc

```
import "FungibleToken"
import "FlowToken"
import "FlowIDTableStaking"
import "LockedTokens"
import "FlowStakingCollection"

/// This transaction sets up an account to use a staking collection
/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,
/// or staking objects stored in the unlocked account

transaction {
    prepare(signer: auth(BorrowValue, Storage, Capabilities) &Account) {

        // If there isn't already a staking collection
        if signer.storage.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {

            // Create private capabilities for the token holder and unlocked vault
            let lockedHolder = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)!
            let flowToken = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)!

            // Create a new Staking Collection and put it in storage
            if lockedHolder.check() {
                signer.storage.save(
                    <- FlowStakingCollection.createStakingCollection(
                        unlockedVault: flowToken,
                        tokenHolder: lockedHolder
                    ),
                    to: FlowStakingCollection.StakingCollectionStoragePath
                )
            } else {
                signer.storage.save(
                    <- FlowStakingCollection.createStakingCollection(
                        unlockedVault: flowToken,
                        tokenHolder: nil
                    ),
                    to: FlowStakingCollection.StakingCollectionStoragePath
                )
            }

            // Publish a capability to the created staking collection.
            let stakingCollectionCap = signer.capabilities.storage.issue<&FlowStakingCollection.StakingCollection>(
                FlowStakingCollection.StakingCollectionStoragePath
            )

            signer.capabilities.publish(
                stakingCollectionCap,
                at: FlowStakingCollection.StakingCollectionPublicPath
            )
        }

        // borrow a reference to the staking collection
        let collectionRef = signer.storage.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow staking collection reference")

        // If there is a node staker object in the account, put it in the staking collection
        if signer.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {
            let node <- signer.storage.load<@FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)!
            collectionRef.addNodeObject(<-node, machineAccountInfo: nil)
        }

        // If there is a delegator object in the account, put it in the staking collection
        if signer.storage.borrow<&FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath) != nil {
            let delegator <- signer.storage.load<@FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)!
            collectionRef.addDelegatorObject(<-delegator)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/deploy_collection_contract.cdc

```
// Deploys a contract to an account
// Used to deploy the staking collection to the same account as the locked tokens contract

transaction(contractName: String, code: String) {
    
    prepare(admin: auth(AddContract) &Account) {
        admin.contracts.add(name: contractName, code: code.decodeHex())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_metadata.cdc

```
import "FlowEpoch"

access(all) fun main(epochCounter: UInt64): FlowEpoch.EpochMetadata {
    return FlowEpoch.getEpochMetadata(epochCounter)!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/get_multiple_unlock_limits.cdc

```
import "LockedTokens"

access(all) fun main(accounts: [Address]): [UFix64] {

    var limits: [UFix64] = []

    for account in accounts {
        let lockedAccountInfoRef = getAccount(account)
            .capabilities.borrow<&LockedTokens.TokenHolder>(
                LockedTokens.LockedAccountInfoPublicPath
            )
            ?? panic("Could not borrow a reference to public LockedAccountInfo")

        limits.append(lockedAccountInfoRef.getUnlockLimit())
    }

    return limits
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/get_staker_info.cdc

```
import "FlowIDTableStaking"
import "LockedTokens"

// Returns an array of NodeInfo objects that the account controls
// in its normal account and shared account

access(all) fun main(account: Address): [FlowIDTableStaking.NodeInfo] {

    let nodeInfoArray: [FlowIDTableStaking.NodeInfo] = []

    let pubAccount = getAccount(account)

    let optionalNodeStakerRef = pubAccount
        .capabilities.borrow<&{FlowIDTableStaking.NodeStakerPublic}>(
            FlowIDTableStaking.NodeStakerPublicPath
        )

    if let nodeStakerRef = optionalNodeStakerRef {
        let info = FlowIDTableStaking.NodeInfo(nodeID: nodeStakerRef.id)
        nodeInfoArray.append(info)
    }

    let optionalLockedAccountInfoRef = pubAccount
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )

    if let lockedAccountInfoRef = optionalLockedAccountInfoRef {
        if let nodeID = lockedAccountInfoRef.getNodeID() {
            let info = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
            nodeInfoArray.append(info)
        }
    }

    return nodeInfoArray
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/deploy_epoch.cdc

```
import "FlowClusterQC"

transaction(name: String, 
            code: [UInt8],
            currentEpochCounter: UInt64,
            numViewsInEpoch: UInt64,
            numViewsInStakingAuction: UInt64,
            numViewsInDKGPhase: UInt64,
            numCollectorClusters: UInt16,
            FLOWsupplyIncreasePercentage: UFix64,
            randomSource: String,
            collectorClusters: [FlowClusterQC.Cluster],
            clusterQCs: [FlowClusterQC.ClusterQC],
            dkgPubKeys: [String]) {

  prepare(signer: auth(AddContract) &Account) {

    signer.contracts.add(name: name, 
            code: code,
            currentEpochCounter: currentEpochCounter,
            numViewsInEpoch: numViewsInEpoch,
            numViewsInStakingAuction: numViewsInStakingAuction, 
            numViewsInDKGPhase: numViewsInDKGPhase, 
            numCollectorClusters: numCollectorClusters,
            FLOWsupplyIncreasePercentage: FLOWsupplyIncreasePercentage,
            randomSource: randomSource,
            collectorClusters: [] as [FlowClusterQC.Cluster],
            clusterQCs: [] as [FlowClusterQC.ClusterQC],
            dkgPubKeys: [] as [String])
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_total_staked.cdc

```
import "FlowIDTableStaking"

access(all) fun main(): UFix64 {
    let stakedTokens = FlowIDTableStaking.getTotalTokensStakedByNodeType()

    // calculate the total number of tokens staked
    var totalStaked: UFix64 = 0.0
    for nodeType in stakedTokens.keys {
        // Do not count access nodes
        if nodeType != UInt8(5) {
            totalStaked = totalStaked + stakedTokens[nodeType]!
        }
    }

    return totalStaked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_execution_effort_weights.cdc

```
import "FlowServiceAccount"

access(all) fun main(): {UInt64: UInt64} {
    return FlowServiceAccount.getExecutionEffortWeights()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_tx_fee_parameters.cdc

```
import "FlowFees"

// This transaction sets the FlowFees parameters
transaction(surgeFactor: UFix64, inclusionEffortCost: UFix64, executionEffortCost: UFix64) {
	let flowFeesAccountAdmin: &FlowFees.Administrator

	prepare(signer: auth(BorrowValue) &Account) {
		self.flowFeesAccountAdmin = signer.storage.borrow<&FlowFees.Administrator>(from: /storage/flowFeesAdmin)
			?? panic("Unable to borrow reference to administrator resource")
	}
	execute {
		self.flowFeesAccountAdmin.setFeeParameters(surgeFactor: surgeFactor, inclusionEffortCost: inclusionEffortCost, executionEffortCost: executionEffortCost)
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_dkg_phase_views.cdc

```
import "FlowEpoch"

transaction(newPhaseViews: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateDKGPhaseViews(newPhaseViews)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/contracts/testContracts/TestFlowIDTableStaking.cdc

```
/*

    TestFlowIDTableStaking

    This is a test contract to act as an API for
    testing the lockbox and staking proxy contracts.

 */

import "FungibleToken"
import "FlowToken"
// import Burner from "Burner"

access(all) contract FlowIDTableStaking {

    /*********** ID Table and Staking Composite Type Definitions *************/

    /// Contains information that is specific to a node in Flow
    /// only lives in this contract
    access(all) resource NodeRecord {

        /// The unique ID of the node
        /// Set when the node is created
        access(all) let id: String

        /// The type of node:
        /// 1 = collection
        /// 2 = consensus
        /// 3 = execution
        /// 4 = verification
        /// 5 = access
        access(all) var role: UInt8

        /// The address used for networking
        access(all) var networkingAddress: String

        /// the public key for networking
        access(all) var networkingKey: String

        /// the public key for staking
        access(all) var stakingKey: String

        init(
            id: String,
            role: UInt8,  /// role that the node will have for future epochs
            networkingAddress: String,
            networkingKey: String,
            stakingKey: String,
            tokensCommitted: @{FungibleToken.Vault}
        ) {

            self.id = id
            self.role = role
            self.networkingAddress = networkingAddress
            self.networkingKey = networkingKey
            self.stakingKey = stakingKey

            destroy tokensCommitted
        }
    }

        // Struct to create to get read-only info about a node
    access(all) struct NodeInfo {
        access(all) let id: String
        access(all) let role: UInt8
        access(all) let networkingAddress: String
        access(all) let networkingKey: String
        access(all) let stakingKey: String
        access(all) let tokensStaked: UFix64
        access(all) let totalTokensStaked: UFix64
        access(all) let tokensCommitted: UFix64
        access(all) let tokensUnstaking: UFix64
        access(all) let tokensUnstaked: UFix64
        access(all) let tokensRewarded: UFix64

        /// list of delegator IDs for this node operator
        access(all) let delegators: [UInt32]
        access(all) let delegatorIDCounter: UInt32
        access(all) let tokensRequestedToUnstake: UFix64
        access(all) let initialWeight: UInt64

        init(nodeID: String) {

            self.id = nodeID
            self.role = 2
            self.networkingAddress = "address"
            self.networkingKey = "key"
            self.stakingKey = "key"
            self.tokensStaked = 0.0
            self.totalTokensStaked = 0.0
            self.tokensCommitted = 0.0
            self.tokensUnstaking = 0.0
            self.tokensUnstaked = 0.0
            self.tokensRewarded = 0.0
            self.delegators = []
            self.delegatorIDCounter = 0
            self.tokensRequestedToUnstake = 0.0
            self.initialWeight = 0
        }
    }

    access(all) entitlement NodeOperator

    /// Resource that the node operator controls for staking
    access(all) resource NodeStaker {

        /// Unique ID for the node operator
        access(all) let id: String

        init(id: String) {
            self.id = id
        }

        access(NodeOperator) fun updateNetworkingAddress(_ newAddress: String) {
            
        }

        /// Add new tokens to the system to stake during the next epoch
        access(NodeOperator) fun stakeNewTokens(_ tokens: @{FungibleToken.Vault}) {

            destroy tokens
        }

        /// Stake tokens that are in the tokensUnstaked bucket
        /// but haven't been officially staked
        access(NodeOperator) fun stakeUnstakedTokens(amount: UFix64) {

        }

        /// Stake tokens that are in the tokensRewarded bucket
        /// but haven't been officially staked
        access(NodeOperator) fun stakeRewardedTokens(amount: UFix64) {

        }

        /// Request amount tokens to be removed from staking
        /// at the end of the next epoch
        access(NodeOperator) fun requestUnstaking(amount: UFix64) {

        }

        /// Requests to unstake all of the node operators staked and committed tokens,
        /// as well as all the staked and committed tokens of all of their delegators
        access(NodeOperator) fun unstakeAll() {

        }

        /// Withdraw tokens from the unstaked bucket
        access(NodeOperator) fun withdrawUnstakedTokens(amount: UFix64): @{FungibleToken.Vault} {
            let flowTokenMinter = FlowIDTableStaking.account.storage.borrow<&FlowToken.Minter>(from: /storage/flowTokenMinter)
                ?? panic("Could not borrow minter reference")

            return <- flowTokenMinter.mintTokens(amount: amount)

        }

        /// Withdraw tokens from the rewarded bucket
        access(NodeOperator) fun withdrawRewardedTokens(amount: UFix64): @{FungibleToken.Vault} {
            let flowTokenMinter = FlowIDTableStaking.account.storage.borrow<&FlowToken.Minter>(from: /storage/flowTokenMinter)
                ?? panic("Could not borrow minter reference")

            return <- flowTokenMinter.mintTokens(amount: amount)
        }

    }

    access(all) entitlement DelegatorOwner

    access(all) struct DelegatorInfo {

        access(all) let id: UInt32
        access(all) let nodeID: String
        access(all) let tokensCommitted: UFix64
        access(all) let tokensStaked: UFix64
        access(all) let tokensUnstaking: UFix64
        access(all) let tokensRewarded: UFix64
        access(all) let tokensUnstaked: UFix64
        access(all) let tokensRequestedToUnstake: UFix64

        init(nodeID: String, delegatorID: UInt32) {

            self.id = delegatorID
            self.nodeID = nodeID
            self.tokensCommitted = 0.0
            self.tokensStaked = 0.0
            self.tokensUnstaking = 0.0
            self.tokensUnstaked = 0.0
            self.tokensRewarded = 0.0
            self.tokensRequestedToUnstake = 0.0
        }

    }

    /// Resource object that the delegator stores in their account
    /// to perform staking actions
    access(all) resource NodeDelegator {

        /// Each delegator for a node operator has a unique ID
        access(all) let id: UInt32

        /// The ID of the node operator that this delegator delegates to
        access(all) let nodeID: String

        init(id: UInt32, nodeID: String) {
            self.id = id
            self.nodeID = nodeID
        }

        /// Delegate new tokens to the node operator
        access(DelegatorOwner) fun delegateNewTokens(from: @{FungibleToken.Vault}) {

            destroy from
        }

        /// Delegate tokens from the unstaked bucket to the node operator
        access(DelegatorOwner) fun delegateUnstakedTokens(amount: UFix64) {

        }

        /// Delegate tokens from the rewards bucket to the node operator
        access(DelegatorOwner) fun delegateRewardedTokens(amount: UFix64) {

        }

        /// Request to unstake delegated tokens during the next epoch
        access(DelegatorOwner) fun requestUnstaking(amount: UFix64) {

        }

        /// Withdraw tokens from the unstaked bucket
        access(DelegatorOwner) fun withdrawUnstakedTokens(amount: UFix64): @{FungibleToken.Vault} {
            let flowTokenMinter = FlowIDTableStaking.account.storage.borrow<&FlowToken.Minter>(from: /storage/flowTokenMinter)
                ?? panic("Could not borrow minter reference")

            return <- flowTokenMinter.mintTokens(amount: amount)
        }

        /// Withdraw tokens from the rewarded bucket
        access(DelegatorOwner) fun withdrawRewardedTokens(amount: UFix64): @{FungibleToken.Vault} {
            let flowTokenMinter = FlowIDTableStaking.account.storage.borrow<&FlowToken.Minter>(from: /storage/flowTokenMinter)
                ?? panic("Could not borrow minter reference")

            return <- flowTokenMinter.mintTokens(amount: amount)
        }
    }

    /// Any node can call this function to register a new Node
    /// It returns the resource for nodes that they can store in
    /// their account storage
    access(all) fun addNodeRecord(
        id: String,
        role: UInt8,
        networkingAddress: String,
        networkingKey: String,
        stakingKey: String,
        tokensCommitted: @{FungibleToken.Vault}
    ): @NodeStaker {
        destroy tokensCommitted

        // return a new NodeStaker object that the node operator stores in their account
        return <-create NodeStaker(id: id)

    }

    access(all) fun registerNewDelegator(nodeID: String, tokensCommitted: @{FungibleToken.Vault}): @NodeDelegator {

        destroy tokensCommitted

        return <-create NodeDelegator(id: 1, nodeID: nodeID)
    }

    /// Gets the minimum stake requirement for delegators
    access(all) fun getDelegatorMinimumStakeRequirement(): UFix64 {
        return self.account.storage.copy<UFix64>(from: /storage/delegatorStakingMinimum)
            ?? 0.0
    }

    init(_ epochTokenPayout: UFix64, _ rewardCut: UFix64, _ candidateLimits: {UInt8: UInt64}) {
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_machine_accounts.cdc

```
import "FlowStakingCollection"

/// Gets all the machine account addresses for nodes
/// in the account's staking collection

access(all) fun main(account: Address): {String: FlowStakingCollection.MachineAccountInfo} {
    return FlowStakingCollection.getMachineAccounts(address: account)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_create_shared_accounts.cdc

```
import Crypto
import "FlowToken"
import "FungibleToken"
import "LockedTokens"

/// Transaction that the main token admin would sign
/// to create a shared account and an unlocked
/// acount for a user

transaction(
    partialAdminPublicKey: Crypto.KeyListEntry, // Weight: 100
    partialUserPublicKey: Crypto.KeyListEntry, // Weight: 900
    fullUserPublicKey: Crypto.KeyListEntry, // Weight: 1000
)  {

    prepare(admin: auth(BorrowValue) &Account) {

        // Create the new accounts and add their keys
        let sharedAccount = Account(payer: admin)
        let userAccount = Account(payer: admin)

        sharedAccount.keys.add(publicKey: partialAdminPublicKey.publicKey, hashAlgorithm: partialAdminPublicKey.hashAlgorithm, weight: partialAdminPublicKey.weight)
        sharedAccount.keys.add(publicKey: partialUserPublicKey.publicKey, hashAlgorithm: partialUserPublicKey.hashAlgorithm, weight: partialUserPublicKey.weight)

        userAccount.keys.add(publicKey: fullUserPublicKey.publicKey, hashAlgorithm: fullUserPublicKey.hashAlgorithm, weight: fullUserPublicKey.weight)

        // Create a private link to the stored vault
        let vaultCapability = sharedAccount.capabilities.storage.issue
            <auth(FungibleToken.Withdraw) &FlowToken.Vault>
            (/storage/flowTokenVault)

        // create a locked token manager and stored it in the shared account
        let lockedTokenManager <- LockedTokens.createLockedTokenManager(vault: vaultCapability)
        sharedAccount.storage.save(<-lockedTokenManager, to: LockedTokens.LockedTokenManagerStoragePath)

        let tokenManagerCapability = sharedAccount
            .capabilities.storage.issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath)

        let tokenHolder <- LockedTokens.createTokenHolder(
            lockedAddress: sharedAccount.address,
            tokenManager: tokenManagerCapability
        )

        userAccount.storage.save(
            <-tokenHolder,
            to: LockedTokens.TokenHolderStoragePath
        )

        let infoCap = userAccount.capabilities.storage.issue<&LockedTokens.TokenHolder>(
            LockedTokens.TokenHolderStoragePath
        )
        userAccount.capabilities.publish(infoCap, at: LockedTokens.LockedAccountInfoPublicPath)

        let tokenAdminCollection = admin.storage
            .borrow<auth(LockedTokens.AccountCreator) &LockedTokens.TokenAdminCollection>(
                from: LockedTokens.LockedTokenAdminCollectionStoragePath
            )
            ?? panic("Could not borrow reference to admin collection")

        let tokenManagerUnlockCapability = sharedAccount
            .capabilities.storage.issue<auth(FungibleToken.Withdraw, LockedTokens.UnlockTokens) &LockedTokens.LockedTokenManager>(
                LockedTokens.LockedTokenManagerStoragePath)

        tokenAdminCollection.addAccount(
            sharedAccountAddress: sharedAccount.address,
            unlockedAccountAddress: userAccount.address,
            tokenAdmin: tokenManagerUnlockCapability
        )

        // Override the default FlowToken receiver
        sharedAccount.capabilities.unpublish(/public/flowTokenReceiver)

        // create new receiver that marks received tokens as unlocked
        let lockedTokensManagerCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(LockedTokens.LockedTokenManagerStoragePath)
        sharedAccount.capabilities.publish(
            lockedTokensManagerCap,
            at: /public/flowTokenReceiver
        )

        // put normal receiver in a separate unique path
        let tokenReceiverCap = sharedAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(/storage/flowTokenVault)
        sharedAccount.capabilities.publish(
            tokenReceiverCap,
            at: /public/lockedFlowTokenReceiver
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_unstaked_tokens.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of unstaked tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensUnstaked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_version_boundary_freeze_period.cdc

```
import "NodeVersionBeacon"

/// Returns the versionBoundaryFreezePeriod which defines the minimum number of blocks
/// that must pass between updating a version and its defined block height
/// boundary
access(all) fun main(): UInt64 {
    return NodeVersionBeacon.getVersionBoundaryFreezePeriod()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/change_payout.cdc

```
import "FlowIDTableStaking"

// This transaction changes the flow token weekly payout

transaction(newPayout: UFix64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setEpochTokenPayout(newPayout)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/add_node_info.cdc

```
import "StakingProxy"

transaction(id: String, role: UInt8, networkingAddress: String, networkingKey: String, stakingKey: String) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let nodeInfo = StakingProxy.NodeInfo(nodeID: id, role: role, networkingAddress: networkingAddress, networkingKey: networkingKey, stakingKey: stakingKey)

        proxyHolder.addNodeInfo(nodeInfo: nodeInfo)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_unstaking_tokens.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of unstaking tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.tokensUnstaking
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/get_delegator_info.cdc

```
import "FlowIDTableStaking"
import "LockedTokens"

// Returns an array of DelegatorInfo objects that the account controls
// in its normal account and shared account

access(all) fun main(account: Address): [FlowIDTableStaking.DelegatorInfo] {

    let delegatorInfoArray: [FlowIDTableStaking.DelegatorInfo] = []

    let pubAccount = getAccount(account)

    let optionalDelegatorRef = pubAccount
        .capabilities.borrow<&{FlowIDTableStaking.NodeDelegatorPublic}>(
            /public/flowStakingDelegator
        )

    if let delegatorRef = optionalDelegatorRef {
        let info = FlowIDTableStaking.DelegatorInfo(
            nodeID: delegatorRef.nodeID,
            delegatorID: delegatorRef.id
        )
        delegatorInfoArray.append(info)
    }

    let optionalLockedAccountInfoRef = pubAccount
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )

    if let lockedAccountInfoRef = optionalLockedAccountInfoRef {
        let nodeID = lockedAccountInfoRef.getDelegatorNodeID()
        let delegatorID = lockedAccountInfoRef.getDelegatorID()

        if nodeID != nil && delegatorID != nil {
            let info = FlowIDTableStaking.DelegatorInfo(
                nodeID: nodeID!,
                delegatorID: delegatorID!
            )
            delegatorInfoArray.append(info)
        }
    }

    return delegatorInfoArray
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/deploy_qc_dkg.cdc

```
// Deploys two contracts to an account in one transaction
 
transaction(qcName: String, qcCode: [UInt8], dkgName: String, dkgCode: [UInt8]) {

  prepare(signer: auth(AddContract) &Account) {

    signer.contracts.add(name: qcName, code: qcCode)

    signer.contracts.add(name: dkgName, code: dkgCode)
  }

}
 

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/remove_node_info.cdc

```
import "StakingProxy"

transaction(nodeID: String) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)

        proxyHolder.removeNodeInfo(nodeID: nodeID)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/register_many_delegators.cdc

```
import "FlowIDTableStaking"
import "FlowToken"

transaction(nodeIDs: [String], paths: [StoragePath]) {

    prepare(acct: auth(SaveValue) &Account) {

        var i = 0

        for path in paths {
            // Create a new delegator object for the node
            let newDelegator <- FlowIDTableStaking.registerNewDelegator(nodeID: nodeIDs[i], tokensCommitted: <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>()))

            // Store the delegator object
            acct.storage.save(<-newDelegator, to: path)

            i = i + 1
            if i == nodeIDs.length {
                i = 0
            }
        }
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_unstaking.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of unstaking tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensUnstaking
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_networking_addr.cdc

```
import "FlowIDTableStaking"

// This script returns the networking Address of a node

access(all) fun main(nodeID: String): String {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.networkingAddress
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/create_participant.cdc

```
import "FlowDKG"

// TODO: only used for testing

transaction(address: Address, nodeID: String) {

    prepare(signer: auth(SaveValue) &Account) {
        let admin = getAccount(address).capabilities.borrow<&FlowDKG.Admin>(/public/dkgAdmin)
             ?? panic("Could not borrow admin reference")

        let dkgParticipant <- admin.createParticipant(nodeID: nodeID)

        signer.storage.save(<-dkgParticipant, to: FlowDKG.ParticipantStoragePath)
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/unstake_all.cdc

```
import "FlowIDTableStaking"


transaction {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.stakerRef.unstakeAll()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/transfer_minter_deploy.cdc

```
import Crypto
import "FlowToken"

transaction(publicKeys: [Crypto.KeyListEntry], contractName: String, code: String, rewardAmount: UFix64, rewardCut: UFix64, candidateNodeLimits: [UInt64]) {

  prepare(signer: auth(AddKey, SaveValue, BorrowValue) &Account) {

    let acct = Account(payer: signer)
    
    for key in publicKeys {
        acct.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
    }

    /// Borrow a reference to the Flow Token Admin in the account storage
    let flowTokenAdmin = signer.storage.borrow<&FlowToken.Administrator>(from: /storage/flowTokenAdmin)
        ?? panic("Could not borrow a reference to the Flow Token Admin resource")

    /// Create a flowTokenMinterResource
    let flowTokenMinter <- flowTokenAdmin.createNewMinter(allowedAmount: 1000000000.0)

    acct.storage.save(<-flowTokenMinter, to: /storage/flowTokenMinter)

    assert(candidateNodeLimits.length == 5,
           message: "Candidate Node Limit list but have a length of 5")

    let candidateNodeLimitsDict: {UInt8: UInt64} = {}
    var role: UInt8 = 1

    for limit in candidateNodeLimits {
      candidateNodeLimitsDict[role] = limit
      role = role + 1
    }

    acct.contracts.add(name: contractName, code: code.utf8, rewardAmount, rewardCut, candidateNodeLimitsDict)
  }

}
 

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/add_approved_nodes.cdc

```
import "FlowIDTableStaking"

// This transaction adds node IDs to the list of approved nodes in
// the ID table. 
// If any of the provided nodes already exist in the ID table, this
// transaction will not revert (idempotent)

transaction(ids: [String]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
		let nodeIDs = FlowIDTableStaking.getApprovedList()
            ?? panic("Could not read approve list from storage")

		// add any new node ID which doesn't already exist
		for newNodeID in ids {
			nodeIDs[newNodeID] = true
		}

		// set the approved list to the union of existing and new node IDs
        self.adminRef.setApprovedList(nodeIDs)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/admin/start_voting.cdc

```
import "FlowClusterQC"

// Test transaction for the QC admin to start the QC voting period
// with a array of collector node clusters

// Arguments:
// 
// indices: An array of cluster indices
// clusterNodeIDs: Array of arrays of all the node IDs in each cluster
// nodeWeights: Array of arrays of node weights in each cluster

transaction(indices: [UInt16], clusterNodeIDs: [[String]], nodeWeights: [[UInt64]]) {

    prepare(signer: auth(BorrowValue) &Account) {

        // Borrow a reference to the QC admin object
        let adminRef = signer.storage.borrow<&FlowClusterQC.Admin>(from: FlowClusterQC.AdminStoragePath)
            ?? panic("Could not borrow reference to qc admin")

        let clusters: [FlowClusterQC.Cluster] = []
        
        // Iterate through each cluster and construct a Cluster object
        for index in indices {

            let nodeWeightsDictionary: {String: UInt64} = {}
            var i = 0

            // Set each node's id and weight
            // Calculate the total weight for each cluster
            for nodeID in clusterNodeIDs[index] {
                let nodes = nodeWeights[index]
                let nodeWeight = nodes[i]

                nodeWeightsDictionary[nodeID] = nodeWeight

                i = i + 1
            }

            clusters.append(FlowClusterQC.Cluster(index: index, nodeWeights: nodeWeightsDictionary))
        }

        // Start QC Voting with the supplied clusters
        adminRef.startVoting(clusters: clusters)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/withdraw_rewarded_tokens_locked.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {
    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy

    prepare(account: auth(BorrowValue) &Account) {
        let holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")
        
        self.nodeDelegatorProxy = holderRef.borrowDelegator()
    }

    execute {
        self.nodeDelegatorProxy.withdrawRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_approved_nodes.cdc

```
import "FlowIDTableStaking"

// This script returns the current approved list

access(all) fun main(): [String] {
    let approveList = FlowIDTableStaking.getApprovedList()
        ?? panic("Could not read approved list from storage")

    return approveList.keys
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/request_unstaking.cdc

```
import "LockedTokens"
import "StakingProxy"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.requestUnstaking(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster_complete.cdc

```
import "FlowClusterQC"

// Gets the status of a cluster's QC generation

access(all) fun main(clusterIndex: UInt16): Bool {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].isComplete() != nil

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/get_node_info.cdc

```
import "StakingProxy"

access(all) fun main(account: Address, nodeID: String): StakingProxy.NodeInfo {

    let proxyRef = getAccount(account)
        .capabilities.borrow<&StakingProxy.NodeStakerProxyHolder{StakingProxy.NodeStakerProxyHolderPublic}>(
            StakingProxy.NodeOperatorCapabilityPublicPath
        )
        ?? panic("Could not borrow public reference to staking proxy")

    return proxyRef.getNodeInfo(nodeID: nodeID)!
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_fees_balance.cdc

```
import "FlowFees"

access(all) fun main(): UFix64 {
    return FlowFees.getFeeBalance()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_staking_views.cdc

```
import "FlowEpoch"

transaction(newStakingViews: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateAuctionViews(newStakingViews)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/advance_view.cdc

```
import "FlowEpoch"

transaction(phase: String) {
    prepare(signer: auth(BorrowValue) &Account) {
        let heartbeat = signer.storage.borrow<&FlowEpoch.Heartbeat>(from: FlowEpoch.heartbeatStoragePath)
            ?? panic("Could not borrow heartbeat from storage path")

        if phase == "EPOCHSETUP" {
            heartbeat.endStakingAuction()
        } else if phase == "EPOCHCOMMIT" {
            heartbeat.startEpochCommit()
        } else if phase == "ENDEPOCH" {
            heartbeat.endEpoch()
        } else if phase == "BLOCK" {
            heartbeat.advanceBlock()
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/change_minimums.cdc

```
import "FlowIDTableStaking"

// This transaction changes the staking minumums for node operators

transaction(newMinimums: [UFix64]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        let minimums: {UInt8: UFix64} = {}
        var i: UInt8 = 1
        for min in newMinimums {
            minimums[i] = min
            i = i + UInt8(1)
        }

        self.adminRef.setMinimumStakeRequirements(minimums)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_bonus_tokens.cdc

```
import "FlowEpoch"

access(all) fun main(): UFix64 {
    return FlowEpoch.getBonusTokens()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/SECURITY.md

# Security Policy

Flow was built from the ground up with security in mind.
Our code, infrastructure, and development methodology helps us keep our users safe.

We really appreciate the community's help.
Responsible disclosure of vulnerabilities helps to maintain the security and privacy of everyone.

If you care about making a difference, please follow the guidelines below.

## Reporting a Vulnerability

Reports are welcome! Please definitely reach out to us if you have a security concern.

If you believe you may have found a security vulnerability in our project,
to be on the safe side, **do NOT open a public issue**.

We ask that all researchers adhere to these guidelines [here](https://flow.com/flow-responsible-disclosure)




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_node_ids.cdc

```
import "FlowStakingCollection"

/// Returns an array of all the node IDs stored in the staking collection

access(all) fun main(address: Address): [String] {
    return FlowStakingCollection.getNodeIDs(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/delegate_unstaked_tokens.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {
    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy

    prepare(account: auth(BorrowValue) &Account) {
        let holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")

        self.nodeDelegatorProxy = holderRef.borrowDelegator()
    }

    execute {
        self.nodeDelegatorProxy.delegateUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/lib/go/templates/README.md

# Core Contracts Transaction Templates

This module contains transaction and script templates for the Flow core contracts,
primarly templates for staking and delegating FLOW.

## Generated manifest files

The `manifest.mainnet.json` and `testnet.mainnet.json` files declare all transaction templates
in a portable format for mainnet and testnet respectively.

To update the manifest files:

- Add your desired templates to [cmd/manifest/manifest.go](./cmd/manifest/manifest.go).
- Run `make generate` in this directory.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/scripts/get_account_available_balance.cdc

```
import "FlowStorageFees"

access(all) fun main(accountAddress: Address): UFix64 {
    return FlowStorageFees.defaultTokenAvailableBalance(accountAddress)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_reward.cdc

```
import "FlowEpoch"

transaction(newRewardAPY: UFix64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        epochAdmin.updateFLOWSupplyIncreasePercentage(newRewardAPY)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/withdraw_unstaked_tokens.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {
    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy

    prepare(account: auth(BorrowValue) &Account) {
        let holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")
        
        self.nodeDelegatorProxy = holderRef.borrowDelegator()
    }

    execute {
        self.nodeDelegatorProxy.withdrawUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/stake_unstaked_tokens.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: /storage/flowStaker)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.stakerRef.stakeUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/register_multiple_delegators.cdc

```
import "FlowStakingCollection"

/// Registers multiple delegators in the staking collection resource
/// for the specified nodeIDs and amount of tokens to commit

transaction(ids: [String], amounts: [UFix64]) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))
    }

    execute {
        var i = 0
        for id in ids {
            self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amounts[i])    

            i = i + 1
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/recover_lease_tokens.cdc

```
import "FungibleToken"
import "FlowToken"
import "LockedTokens"

transaction(delegator: Bool, amount: UFix64, to: Address) {

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        // Get a reference to the signer's locked token manager
        let tokenManagerRef = signer.storage.borrow<auth(FungibleToken.Withdraw, LockedTokens.RecoverLease) &LockedTokens.LockedTokenManager>(from: LockedTokens.LockedTokenManagerStoragePath)
            ?? panic("The signer does not store a LockedTokenManager object at the path "
                    .concat(LockedTokens.LockedTokenManagerStoragePath.toString()))

        if !delegator {
            let nodeRef = tokenManagerRef.borrowNodeForLease()
                ?? panic("Could not borrow a reference to a node in the LockedTokenManager of the signer's account")

            // Withdraw enough tokens to pay for fees, assuming there are some rewards in the rewards bucket
            tokenManagerRef.deposit(from: <-nodeRef.withdrawRewardedTokens(amount: 0.0001)!)

            // Withdraw tokens from the signer's stored vault
            self.sentVault <- nodeRef.withdrawUnstakedTokens(amount: amount)!
        } else {
            let delegatorRef = tokenManagerRef.borrowDelegatorForLease()
                ?? panic("Could not borrow a reference to a delegator in the LockedTokenManager of the signer's account")

            // Withdraw enough tokens to pay for fees, assuming there are some rewards in the rewards bucket
            tokenManagerRef.deposit(from: <-delegatorRef.withdrawRewardedTokens(amount: 0.0001)!)

            // Withdraw tokens from the signer's stored vault
            self.sentVault <- delegatorRef.withdrawUnstakedTokens(amount: amount)!
        }
    }

    execute {

        // Get a reference to the recipient's Receiver
        let receiverRef =  getAccount(to)
            .capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            ?? panic("Could not borrow a Receiver reference to the FlowToken Vault in account "
                .concat(to.toString()).concat(" at path /public/flowTokenReceiver")
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FlowToken Vault set up properly at the specified path."))

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/randomBeaconHistory/scripts/get_latest_source_of_randomness.cdc

```
import "RandomBeaconHistory"

access(all) fun main(): RandomBeaconHistory.RandomSource {
    return RandomBeaconHistory.sourceOfRandomness(
        atBlockHeight: getCurrentBlock().height - 1
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/scripts/get_execution_memory_weights.cdc

```
import "FlowServiceAccount"

access(all) fun main(): {UInt64: UInt64} {
    return FlowServiceAccount.getExecutionMemoryWeights()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_unstaked.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of unlocked tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensUnstaked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_role_counts.cdc

```
import "FlowIDTableStaking"

// This script returns the slot limits for node roles

access(all) fun main(): {UInt8: UInt16} {
    return FlowIDTableStaking.getCurrentRoleNodeCounts()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/get_delegator_node_id.cdc

```
import "LockedTokens"

access(all) fun main(account: Address): String {

    let lockedAccountInfoRef = getAccount(account)
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )
        ?? panic("Could not borrow a reference to public LockedAccountInfo")

    return lockedAccountInfoRef.getDelegatorNodeID()!
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_node_has_voted.cdc

```
import "FlowClusterQC"

// Returns a boolean indicating if a node has submitted a vote for this epoch

access(all) fun main(nodeID: String): Bool {

    // If we are in the staking auction phase (voting not in progress), the votes
    // from last epoch are still stored and nodeHasVoted reports True. Since we
    // only want to know whether we have voted for the CURRENT epoch, omit this case.
    return FlowClusterQC.inProgress && FlowClusterQC.nodeHasVoted(nodeID)

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_qc_enabled.cdc

```
import "FlowClusterQC"

access(all) fun main(): Bool {

    return FlowClusterQC.inProgress

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/deposit_tokens.cdc

```
import "FungibleToken"
import "FlowToken"
import "LockedTokens"

transaction(amount: UFix64) {

    let holderRef: &LockedTokens.TokenHolder
    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        self.holderRef = acct.storage.borrow<&LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Cannot deposit tokens to a locked account! The signer of the transaction "
                    .concat("does not have an associated locked account, ")
                    .concat("so there is nowhere to deposit the tokens."))

        self.vaultRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("The signer does not store a FlowToken Vault object at the path "
                    .concat("/storage/flowTokenVault. ")
                    .concat("The signer must initialize their account with this vault first!"))
    }

    execute {
        self.holderRef.deposit(from: <-self.vaultRef.withdraw(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/admin/start_dkg.cdc

```
import "FlowDKG"

transaction(nodeIDs: [String]) {

    let dkgAdmin: &FlowDKG.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.dkgAdmin = signer.storage.borrow<&FlowDKG.Admin>(from: FlowDKG.AdminStoragePath)
            ?? panic("Could not borrow DKG Admin reference")
    }

    execute {
        self.dkgAdmin.startDKG(nodeIDs: nodeIDs)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/unlock_tokens_for_multiple_accounts.cdc

```
import "LockedTokens"

// This transaction uses the locked tokens admin
// to set the unlock limit for multiple accounts
// in a single transaction
// The account addresses used as keys
// should be the unlocked account addresses

transaction(unlockInfo: {Address: UFix64}) {

    prepare(admin: auth(Storage, Capabilities) &Account) {

        // Unlocked Account addresses that had some sort of error
        // are stored in this dictionary so they can be inspected later
        // If the transaction needs to run multiple times,
        // then the dictionary is not overwritten
        var badAccounts: {Address: UFix64} = admin.storage.load<{Address: UFix64}>(from: /storage/unlockingBadAccounts)
            ?? {} as {Address: UFix64}

        let adminRef = admin.storage.borrow<&LockedTokens.TokenAdminCollection>(from: LockedTokens.LockedTokenAdminCollectionStoragePath)
            ?? panic("Could not borrow a reference to the admin collection")

        for unlockedAddress in unlockInfo.keys {

            // All of the if lets are because we don't  want to
            // revert the entire transaction if it fails
            // to get the information for a single address
            if let lockedAccountInfoRef = getAccount(unlockedAddress)
                .capabilities.borrow<&LockedTokens.TokenHolder>(LockedTokens.LockedAccountInfoPublicPath) {

                let lockedAccountAddress = lockedAccountInfoRef.getLockedAccountAddress()

                if let lockedTokenAccountRecord = adminRef.getAccount(address: lockedAccountAddress) {
                    
                    if let tokenManagerRef = lockedTokenAccountRecord.borrow() {

                        // Get the unlock amount from the transaction argument dictionary
                        var unlockAmount = unlockInfo[unlockedAddress]!

                        // Increase the unlock limit by the amount
                        tokenManagerRef.increaseUnlockLimit(delta: unlockAmount)

                        // Continue to the next iteration of the loop
                        // because the account succeeded and does not need
                        // to be marked as bad
                        continue
                    }
                } 
            }

            // If the execution makes it here (does not reach the continue above)
            // it means something went wrong with the unlocking for the account
            // and it needs to be saved
            badAccounts[unlockedAddress] = unlockInfo[unlockedAddress]
        }

        admin.storage.save<{Address: UFix64}>(badAccounts, to: /storage/unlockingBadAccounts)

        let unlockingBadAccountCap = admin.capabilities.get<&{Address: UFix64}>(/public/unlockingBadAccounts)
        if !unlockingBadAccountCap.check() {
            let unlockingBadAccountCap = admin.capabilities.storage.issue<&{Address: UFix64}>(/storage/unlockingBadAccounts)
            admin.capabilities.unpublish(/public/unlockingBadAccounts)
            admin.capabilities.publish(unlockingBadAccountCap, at: /public/unlockingBadAccounts)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/set_bonus_tokens.cdc

```

/// Saves an amount to storage that represent the amount
/// of bonus tokens that have yet to be burned
/// This amount is subtracted from the total supply of FLOW
/// whenever a new total rewards amount is calculated every epoch
/// because they are not meant to be a part of the total supply
/// 
/// Eventually, all bonus tokens will be burned and the amount will be zero

transaction(bonusTokenAmount: UFix64) {
    prepare(signer: auth(Storage) &Account) {
        signer.storage.load<UFix64>(from: /storage/FlowBonusTokenAmount)
        signer.storage.save(bonusTokenAmount, to: /storage/FlowBonusTokenAmount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/update_epoch_config.cdc

```
import "FlowEpoch"

transaction(dkgPhaseLen: UInt64, stakingLen: UInt64, epochLen: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow admin from storage path")

        if !FlowEpoch.isValidPhaseConfiguration(stakingLen, dkgPhaseLen, epochLen) {
            panic("New Epoch Views must be greater than the sum of staking and DKG Phase views")
        }

        /// Due to the fact that epoch Views must be greater than the sum of staking and DKG Phase views
        /// we must update the epoch config in the correct order. This validation is done on each epoch config
        /// update. How the number of views in the epoch is being updated determines the order
        /// in which numViewsInEpoch, numViewsInStakingAuction, and numViewsInDKGPhase need to be updated such that the validation passes.
        /// - increasing numViewsInEpoch: update numViewsInEpoch before numViewsInStakingAuction, and numViewsInDKGPhase
        /// - decreasing numViewsInEpoch: update numViewsInStakingAuction and  numViewsInDKGPhase before numViewsInStakingAuction
        /// NOTE: We assume here that the DKG phase length is much smaller than the staking length for all potential configurations.
        if epochLen > FlowEpoch.getConfigMetadata().numViewsInEpoch  {
            epochAdmin.updateEpochViews(epochLen)
            epochAdmin.updateAuctionViews(stakingLen)
            epochAdmin.updateDKGPhaseViews(dkgPhaseLen)
        } else {
            epochAdmin.updateAuctionViews(stakingLen)
            epochAdmin.updateDKGPhaseViews(dkgPhaseLen)
            epochAdmin.updateEpochViews(epochLen)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_claimed.cdc

```
import "FlowIDTableStaking"

// This transaction pays rewards to all the staked nodes

transaction {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setClaimed()
        self.adminRef.startStakingAuction()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_randomize.cdc

```
import "FlowEpoch"

access(all) fun main(array: [String]): [String] {
    return FlowEpoch.randomize(array)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/transfer_delegator.cdc

```
import "FlowStakingCollection"

// Transfers a NodeDelegator object from an authorizers account
// and adds the NodeDelegator to another accounts Staking Collection
// identified by the to Address.

transaction(nodeID: String, delegatorID: UInt32, to: Address) {
    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection
    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.
        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {
            panic(FlowStakingCollection.getCollectionMissingError(to))
        }

        // Get a reference to the authorizers StakingCollection
        self.fromStakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))

        // Get the PublicAccount of the account to transfer the NodeDelegator to. 
        let toAccount = getAccount(to)

        // Borrow a capability to the public methods available on the receivers StakingCollection.
        self.toStakingCollectionCap = toAccount.capabilities
            .borrow<&FlowStakingCollection.StakingCollection>(FlowStakingCollection.StakingCollectionPublicPath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(to))
    }

    execute {
        // Remove the NodeDelegator from the authorizers StakingCollection.
        let nodeDelegator <- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)

        // Deposit the NodeDelegator to the receivers StakingCollection.
        self.toStakingCollectionCap.addDelegatorObject(<- nodeDelegator!)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/generate_quorum_certificate.cdc

```
import "FlowClusterQC"

// Gets the status of a cluster's QC generation

access(all) fun main(clusterIndex: UInt16): FlowClusterQC.ClusterQC {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].generateQuorumCertificate()
        ?? panic("Could not generate quorum certificate")

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/scripts/get_version_boundaries.cdc

```
import "NodeVersionBeacon"

/// Returns the versionBoundaries page for the given page and perPage.
access(all) fun main(page: Int, perPage: Int): NodeVersionBeacon.VersionBoundaryPage {
    return NodeVersionBeacon.getVersionBoundariesPage(page: page, perPage: perPage)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/check_main_registration.cdc

```
import "FungibleToken"
import "FlowToken"

import "LockedTokens"

transaction(mainAccount: Address) {

    prepare(signer: auth(BorrowValue) &Account) {

        let adminRef = signer.storage.borrow<&LockedTokens.TokenAdminCollection>(from: LockedTokens.LockedTokenAdminCollectionStoragePath)
            ?? panic("Could not borrow a reference to the locked token admin collection")

        let lockedAccountInfoRef = getAccount(mainAccount)
            .capabilities.borrow<&LockedTokens.TokenHolder>(LockedTokens.LockedAccountInfoPublicPath)
            ?? panic("Could not borrow a reference to public LockedAccountInfo")

        let lockedAccount = lockedAccountInfoRef.getLockedAccountAddress()

        assert(
            adminRef.getAccount(address: lockedAccount) != nil,
            message: "The specified account is not a locked account! Cannot send locked tokens"
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/register_node.cdc

```
import "FlowIDTableStaking"
import "FlowToken"
import "FungibleToken"

// This transaction creates a new node struct object
// and updates the proposed Identity Table

transaction(
    id: String,
    role: UInt8,
    networkingAddress: String,
    networkingKey: String,
    stakingKey: String,
    amount: UFix64
) {

    let flowTokenRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(Storage, Capabilities) &Account) {

        self.flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

        let nodeStaker <- FlowIDTableStaking.addNodeRecord(
            id: id,
            role: role,
            networkingAddress: networkingAddress,
            networkingKey: networkingKey,
            stakingKey: stakingKey,
            tokensCommitted: <-self.flowTokenRef.withdraw(amount: amount)
        )

        if acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) == nil {

            acct.storage.save(<-nodeStaker, to: FlowIDTableStaking.NodeStakerStoragePath)

            let nodeStakerCap = acct.capabilities.storage.issue<&{FlowIDTableStaking.NodeStakerPublic}>(
                FlowIDTableStaking.NodeStakerStoragePath
            )

            acct.capabilities.publish(
                nodeStakerCap,
                at: FlowIDTableStaking.NodeStakerPublicPath
            )
        } else {
            destroy nodeStaker
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/node/register_qc_voter.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"
import "FlowClusterQC"

transaction() {

    prepare(signer: auth(Storage) &Account) {

        let nodeRef = signer.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow node reference from storage path")

        let qcVoter <- FlowEpoch.getClusterQCVoter(nodeStaker: nodeRef)

        signer.storage.save(<-qcVoter, to: FlowClusterQC.VoterStoragePath)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_node_weight.cdc

```
import "FlowIDTableStaking"

// This transaction sets the initialWeight of an existing node
transaction(id: String, weight: UInt64) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setNodeWeight(nodeID: id, weight: weight)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_does_stake_exist.cdc

```
import "FlowStakingCollection"
import "FlowIDTableStaking"

/// Tells if the specified node or delegator exists in the staking collection 
/// for the specified address

access(all) fun main(address: Address, nodeID: String, delegatorID: UInt32?): Bool {
    return FlowStakingCollection.doesStakeExist(address: address, nodeID: nodeID, delegatorID: delegatorID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_delegator_ids.cdc

```
import "FlowStakingCollection"

/// Returns an array of all the delegator IDs stored in the staking collection

access(all) fun main(address: Address): [FlowStakingCollection.DelegatorIDs] {
    return FlowStakingCollection.getDelegatorIDs(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/stake_rewarded_tokens.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.stakerRef.stakeRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/withdraw_rewarded_tokens.cdc

```
import "LockedTokens"
import "FlowToken"
import "FungibleToken"

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder
    let vaultRef: &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")

        self.vaultRef = account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FlowToken value")
    }

    execute {
        let stakerProxy = self.holderRef.borrowStaker()

        stakerProxy.withdrawRewardedTokens(amount: amount)
        self.vaultRef.deposit(from: <-self.holderRef.withdraw(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/submit_vote.cdc

```
import "FlowClusterQC"

// A node voter uses this transaction to submit a QC vote
//
// Parameters:
// 
// voteSignature: The signed message using the node's staking key
// voteMessage: The hex-encoded string of the raw message

transaction(voteSignature: String, voteMessage: String) {

    prepare(signer: auth(BorrowValue) &Account) {
        let voterRef = signer.storage.borrow<&FlowClusterQC.Voter>(from: FlowClusterQC.VoterStoragePath)
            ?? panic("Could not borrow reference to qc voter")

        voterRef.vote(voteSignature: voteSignature, voteMessage: voteMessage)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster_votes.cdc

```
import "FlowClusterQC"

// Returns an array of Votes for the specified cluster

access(all) fun main(clusterIndex: UInt16): [FlowClusterQC.Vote] {

    let clusters = FlowClusterQC.getClusters()

    return clusters[clusterIndex].votes

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/stake_unstaked_tokens.cdc

```
import "StakingProxy"

transaction(nodeID: String, amount: UFix64) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.stakeUnstakedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/register_node.cdc

```
import "LockedTokens"
import "StakingProxy"

transaction(address: Address, id: String, amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations) &LockedTokens.TokenHolder

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow reference to TokenHolder")
    }

    execute {
        let nodeOperatorRef = getAccount(address).capabilities
            .borrow<&StakingProxy.NodeStakerProxyHolder>(
                StakingProxy.NodeOperatorCapabilityPublicPath
            )
            ?? panic("Could not borrow node operator public capability")

        let nodeInfo = nodeOperatorRef.getNodeInfo(nodeID: id)
            ?? panic("Couldn't get info for nodeID=".concat(id))

        self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)

        let nodeStakerProxy = self.holderRef.borrowStaker()

        nodeOperatorRef.addStakingProxy(nodeID: nodeInfo.id, proxy: nodeStakerProxy)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_target_end_time_for_epoch.cdc

```
import "FlowEpoch"

access(all) fun main(targetEpoch: UInt64): UInt64 {
    pre {
        targetEpoch >= FlowEpoch.currentEpochCounter
    }
    let config = FlowEpoch.getEpochTimingConfig()
    return config.getTargetEndTimeForEpoch(targetEpoch)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_dkg_enabled.cdc

```
import "FlowDKG"

access(all) fun main(): Bool {
    return FlowDKG.dkgEnabled
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/.github/ISSUE_TEMPLATE/bug-report.md

---
name: Reporting a Problem/Bug
about: Reporting a Problem/Bug
title: ''
labels: bug, Feedback
assignees: ''

---

### Problem

<what is the problem you've encountered?> 

### Steps to Reproduce 

<share any logs/screenshots or steps to replicate>

### Acceptance Criteria

<if any>
  
### Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_request.cdc

```
import "FlowIDTableStaking"

// This script returns the requested unstaking balance of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensRequestedToUnstake
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/register_multiple_nodes.cdc

```
import Crypto
import "FlowStakingCollection"

/// Registers multiple nodes in the staking collection resource
/// for the specified node information

transaction(ids: [String],
            roles: [UInt8],
            networkingAddresses: [String],
            networkingKeys: [String],
            stakingKeys: [String],
            amounts: [UFix64],
            publicKeys: [[Crypto.KeyListEntry]?]) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))

        var i = 0

        for id in ids {
            if let machineAccount = self.stakingCollectionRef.registerNode(
                id: id,
                role: roles[i],
                networkingAddress: networkingAddresses[i],
                networkingKey: networkingKeys[i],
                stakingKey: stakingKeys[i],
                amount: amounts[i],
                payer: account) 
            {
                if publicKeys[i] == nil || publicKeys[i]!.length == 0 {
                    panic("Cannot provide zero keys for the machine account")
                }
                for key in publicKeys[i]! {
                    machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
                }
            }
            i = i + 1
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/storageFees/admin/set_parameters.cdc

```
import "FlowStorageFees"

// This transaction changes the flow storage fees parameters
transaction(storageBytesPerReservedFLOW: UFix64?, minimumStorageReservation: UFix64?) {
    
    let adminRef: &FlowStorageFees.Administrator

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowStorageFees.Administrator>(from: /storage/storageFeesAdmin)
            ?? panic("Could not borrow reference to storage fees admin")
    }

    execute {
        if storageBytesPerReservedFLOW != nil {
            self.adminRef.setStorageMegaBytesPerReservedFLOW(storageBytesPerReservedFLOW!)
        }
        if minimumStorageReservation != nil {
            self.adminRef.setMinimumStorageReservation(minimumStorageReservation!)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_voting_completed.cdc

```
import "FlowClusterQC"

// Returns a boolean indicating if a node has submitted a vote for this epoch

access(all) fun main(): Bool {

    return FlowClusterQC.votingCompleted()

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/set_version_boundary.cdc

```
import "NodeVersionBeacon"

/// Transaction that allows NodeVersionAdmin to add a new version to the
/// version table defining a version boundary at the targetBlockHeight

transaction(
  newMajor: UInt8,
  newMinor: UInt8,
  newPatch: UInt8,
  newPreRelease: String,
  blockHeight: UInt64
) {

  let NodeVersionBeaconAdminRef: &NodeVersionBeacon.Admin
  let newVersionBoundary: NodeVersionBeacon.VersionBoundary

  prepare(acct: auth(BorrowValue) &Account) {
    // Create the new version from the passed parameters
    let newVersion = NodeVersionBeacon.Semver(
      major: newMajor, minor: newMinor, patch: newPatch, preRelease: newPreRelease
    )

    self.newVersionBoundary = NodeVersionBeacon.VersionBoundary(blockHeight: blockHeight, version: newVersion)

    // Borrow a reference to the NodeVersionAdmin resource
    self.NodeVersionBeaconAdminRef = acct.storage.borrow<&NodeVersionBeacon.Admin>
      (from: NodeVersionBeacon.AdminStoragePath)
      ?? panic("Couldn't borrow NodeVersionBeacon.Admin Resource")
  }

  execute {
    // Add the new version to the version table
    self.NodeVersionBeaconAdminRef.setVersionBoundary(versionBoundary: self.newVersionBoundary)
  }

  post {
    NodeVersionBeacon.getVersionBoundary(effectiveAtBlockHeight: blockHeight).version
        .strictEqualTo(self.newVersionBoundary.version) : "New version was not added to the versionTable"
  }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/stake_new_tokens.cdc

```
import "StakingProxy"

transaction(nodeID: String, amount: UFix64) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.stakeNewTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/end_staking.cdc

```
import "FlowIDTableStaking"

// This transaction ends the staking auction, which refunds nodes 
// with insufficient stake

transaction(ids: {String: Bool}) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {

        self.adminRef.setApprovedList(ids)

        self.adminRef.endStakingAuction()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_moves_pending.cdc

```
import "FlowIDTableStaking"

// This script returns the current moves pending list

access(all) fun main(): {String: {UInt32: Bool}} {
    return FlowIDTableStaking.getMovesPendingList()!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/does_account_have_staking_collection.cdc

```
import "FlowStakingCollection"

/// Determines if an account is set up with a Staking Collection

access(all) fun main(address: Address): Bool {
    return FlowStakingCollection.doesAccountHaveStakingCollection(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_candidate_limits.cdc

```
import "FlowIDTableStaking"

// This script returns the limits for candidate nodes for each role
access(all) fun main(): {UInt8: UInt64} {
    return FlowIDTableStaking.getCandidateNodeLimits()
        ?? panic("Could not load candidate limits")
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingProxy/request_unstaking.cdc

```
import "StakingProxy"

transaction(nodeID: String, amount: UFix64) {

    prepare(account: auth(BorrowValue) &Account) {
        let proxyHolder = account.storage.borrow<&StakingProxy.NodeStakerProxyHolder>(from: StakingProxy.NodeOperatorCapabilityStoragePath)
            ?? panic("Could not borrow reference to staking proxy holder")

        let stakingProxy = proxyHolder.borrowStakingProxy(nodeID: nodeID)!

        stakingProxy.requestUnstaking(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_del_stake_requirements.cdc

```
import "FlowIDTableStaking"

// This script returns the minimum stake requirement for delegators

access(all) fun main(): UFix64 {
    return FlowIDTableStaking.getDelegatorMinimumStakeRequirement()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_latest_whiteboard_messages.cdc

```
import "FlowDKG"

access(all) fun main(fromIndex: Int): [FlowDKG.Message] {
    let messages = FlowDKG.getWhiteBoardMessages()
    var latestMessages: [FlowDKG.Message] = []
    var i = fromIndex
    while i < messages.length {
        latestMessages.append(messages[i])
        i = i + 1
    }
    return latestMessages
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_info_from_address.cdc

```
import "FlowIDTableStaking"

// This script gets all the info about a node and returns it

access(all) fun main(address: Address): FlowIDTableStaking.NodeInfo {

    let nodeStaker = getAccount(address)
        .capabilities.borrow<&{FlowIDTableStaking.NodeStakerPublic}>(FlowIDTableStaking.NodeStakerPublicPath)
        ?? panic("Could not borrow reference to node staker object")

    return FlowIDTableStaking.NodeInfo(nodeID: nodeStaker.id)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/delegator/delegate_rewarded_tokens.cdc

```
import "LockedTokens"
import "FungibleToken"

transaction(amount: UFix64) {
    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy

    prepare(account: auth(BorrowValue) &Account) {
        let holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("TokenHolder is not saved at specified path")
        
        self.nodeDelegatorProxy = holderRef.borrowDelegator()
    }

    execute {
        self.nodeDelegatorProxy.delegateRewardedTokens(amount: amount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/user/get_total_balance.cdc

```
import "FungibleToken"
import "FlowToken"
import "FlowIDTableStaking"
import "LockedTokens"

// This script gets the TOTAL number of FLOW an account owns, across unlocked, locked, and staking.

// Adds up these numbers:

// tokens in normal account
// tokens in normal account staking
// tokens in normal account delegating
// tokens in shared account
// tokens in shared account staking
// tokens in shared account delegating


access(all) fun main(address: Address): UFix64 {

    var sum = 0.0

    let account = getAccount(address)

    if let vaultRef = account.capabilities.borrow<&FlowToken.Vault>(/public/flowTokenBalance) {
        sum = sum + vaultRef.balance
    }

    // Get token balance from the unlocked account's node staking pools
    let optionalNodeStakerRef = account
        .capabilities.borrow<&{FlowIDTableStaking.NodeStakerPublic}>(
            FlowIDTableStaking.NodeStakerPublicPath
        )

    if let nodeStakerRef = optionalNodeStakerRef {
        let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeStakerRef.id)
        sum = sum + nodeInfo.totalTokensInRecord()
    }

    // Get token balance from the unlocked account's delegator staking pools
    let optionalDelegatorRef = account
        .capabilities.borrow<&{FlowIDTableStaking.NodeDelegatorPublic}>(
            /public/flowStakingDelegator
        )

    if let delegatorRef = optionalDelegatorRef {
        let delegatorInfo = FlowIDTableStaking.DelegatorInfo(
            nodeID: delegatorRef.nodeID,
            delegatorID: delegatorRef.id
        )
        sum = sum + delegatorInfo.totalTokensInRecord()
 
    }

    // Get the locked account public capability
    let optionalLockedAccountInfoRef = account
        .capabilities.borrow<&LockedTokens.TokenHolder>(
            LockedTokens.LockedAccountInfoPublicPath
        )

    if let lockedAccountInfoRef = optionalLockedAccountInfoRef {
        // Add the locked account balance
        sum = sum + lockedAccountInfoRef.getLockedAccountBalance()

        // Add the balance of all the node staking pools from the locked account
        if let nodeID = lockedAccountInfoRef.getNodeID() {
            let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
            sum = sum + nodeInfo.totalTokensInRecord()
        }

        // Add the balance of all the delegator staking pools from the locked account
        if let delegatorID = lockedAccountInfoRef.getDelegatorID() {
            if let nodeID = lockedAccountInfoRef.getDelegatorNodeID() {
                let delegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
                sum = sum + delegatorInfo.totalTokensInRecord()
            }
        }
    }

    return sum
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/admin/recover_epoch.cdc

```
import "FlowEpoch"
import "FlowIDTableStaking"
import "FlowClusterQC"

// The recoverEpoch transaction creates and starts a new epoch in the FlowEpoch smart contract
// which will cause the network exit Epoch Fallback Mode [EFM]. The RecoverEpoch service event
// will be processed by the consensus committee, which will add it to the Protocol State.
//
// This transaction should only be used with the output of the bootstrap utility:
//   util epoch efm-recover-tx-args
//
// NOTE: setting unsafeAllowOverwrite to true will allow the FlowEpoch contract to overwrite the current 
// epoch with the new configuration, if the recoveryEpochCounter matches (otherwise will panic).
// This function exists to recover from potential race conditions that caused a prior recoverCurrentEpoch transaction to fail;
// this allows operators to retry the recovery procedure, overwriting the prior failed attempt.
transaction(recoveryEpochCounter: UInt64,
            startView: UInt64,
            stakingEndView: UInt64,
            endView: UInt64,
            targetDuration: UInt64,
            targetEndTime: UInt64,
            clusterAssignments: [[String]],
            clusterQCVoteData: [FlowClusterQC.ClusterQCVoteData],
            dkgPubKeys: [String],
            dkgGroupKey: String,
            dkgIdMapping: {String: Int},
            nodeIDs: [String],
            unsafeAllowOverwrite: Bool) {

    prepare(signer: auth(BorrowValue) &Account) {
        let epochAdmin = signer.storage.borrow<&FlowEpoch.Admin>(from: FlowEpoch.adminStoragePath)
            ?? panic("Could not borrow epoch admin from ".concat(FlowEpoch.adminStoragePath.toString()))

        let proposedEpochCounter = FlowEpoch.proposedEpochCounter()
        if recoveryEpochCounter == proposedEpochCounter {
            // Typical path: RecoveryEpoch uses proposed epoch counter (+1 from current)
            epochAdmin.recoverNewEpoch(
                recoveryEpochCounter: recoveryEpochCounter,
                startView: startView,
                stakingEndView: stakingEndView,
                endView: endView,
                targetDuration: targetDuration,
                targetEndTime: targetEndTime,
                clusterAssignments: clusterAssignments,
                clusterQCVoteData: clusterQCVoteData,
                dkgPubKeys: dkgPubKeys,
                dkgGroupKey: dkgGroupKey,
                dkgIdMapping: dkgIdMapping,
                nodeIDs: nodeIDs
            )
        } else {
            // Atypical path: RecoveryEpoch is overwriting existing epoch. 
            // CAUTION: This causes data loss by replacing the existing current epoch metadata with the inputs to this function.
            // This function exists to recover from potential race conditions that caused a prior recoverCurrentEpoch transaction to fail;
            // this allows operators to retry the recovery procedure, overwriting the prior failed attempt.
            if !unsafeAllowOverwrite {
                panic("Cannot overwrite existing epoch without unsafeAllowOverwrite set to true")
            }
            epochAdmin.recoverCurrentEpoch(
                recoveryEpochCounter: recoveryEpochCounter,
                startView: startView,
                stakingEndView: stakingEndView,
                endView: endView,
                targetDuration: targetDuration,
                targetEndTime: targetEndTime,
                clusterAssignments: clusterAssignments,
                clusterQCVoteData: clusterQCVoteData,
                dkgPubKeys: dkgPubKeys,
                dkgGroupKey: dkgGroupKey,
                dkgIdMapping: dkgIdMapping,
                nodeIDs: nodeIDs
            )
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/staker/register_node.cdc

```
import "FlowToken"
import "FungibleToken"
import "LockedTokens"
import "StakingProxy"

transaction(id: String, role: UInt8, networkingAddress: String, networkingKey: String, stakingKey: String, amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder

    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(account: auth(BorrowValue) &Account) {
        self.holderRef = account.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("Could not borrow ref to TokenHolder")

        self.vaultRef = account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow flow token vault reference")
    }

    execute {
        let nodeInfo = StakingProxy.NodeInfo(
          nodeID: id,
          role: role,
          networkingAddress: networkingAddress,
          networkingKey: networkingKey,
          stakingKey: stakingKey
        )

        let lockedBalance = self.holderRef.getLockedAccountBalance()

        if amount <= lockedBalance {

            self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)

        } else if ((amount - lockedBalance) <= self.vaultRef.balance) {

            self.holderRef.deposit(from: <-self.vaultRef.withdraw(amount: amount - lockedBalance))

            self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)

        } else {
            panic("Not enough tokens to stake!")
        }
        
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/accounts/revoke_key.cdc

```
transaction(keyIndex: Int) {
	prepare(signer: auth(RevokeKey) &Account) {
		if let key = signer.keys.get(keyIndex: keyIndex) {
			signer.keys.revoke(keyIndex: keyIndex)
		} else {
            panic("Cannot revoke key: No key with the index "
                  .concat(keyIndex.toString())
                  .concat(" exists on the authorizer's account."))
		}
	}
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_total_commitment_without_delegators.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.totalCommittedWithoutDelegators()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/upgrade_staking.cdc

```

transaction(code: [UInt8]) {

    prepare(acct: auth(UpdateContract) &Account) {
        acct.contracts.update(name: "FlowIDTableStaking", code: code)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/node/withdraw_unstaked_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"


transaction(amount: UFix64) {

    // Local variable for a reference to the node object
    let stakerRef: auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker

    let flowTokenRef: &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the node object
        self.stakerRef = acct.storage.borrow<auth(FlowIDTableStaking.NodeOperator) &FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)
            ?? panic("Could not borrow reference to staking admin")

        self.flowTokenRef = acct.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")
    }

    execute {
        self.flowTokenRef.deposit(from: <-self.stakerRef.withdrawUnstakedTokens(amount: amount))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_stake_new_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"
import "FungibleToken"


transaction(amount: UFix64) {

    // Local variable for a reference to the delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    let flowTokenRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to delegator")

        self.flowTokenRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

    }

    execute {

        self.delegatorRef.delegateNewTokens(from: <-self.flowTokenRef.withdraw(amount: amount))

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_stake_rewarded.cdc

```
import "FlowIDTableStaking"


transaction(amount: UFix64) {

    // Local variable for a reference to the Delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to delegator")

    }

    execute {

        self.delegatorRef.delegateRewardedTokens(amount: amount)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/del_withdraw_unstaked_tokens.cdc

```
import "FlowIDTableStaking"
import "FlowToken"


transaction(amount: UFix64) {

    // Local variable for a reference to the delegator object
    let delegatorRef: auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator

    let flowTokenRef: &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the delegator object
        self.delegatorRef = acct.storage.borrow<auth(FlowIDTableStaking.DelegatorOwner) &FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)
            ?? panic("Could not borrow reference to staking admin")

        self.flowTokenRef = acct.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to FLOW Vault")

    }

    execute {

        self.flowTokenRef.deposit(from: <-self.delegatorRef.withdrawUnstakedTokens(amount: amount))

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_rewarded.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of rewarded tokens of a delegator

access(all) fun main(nodeID: String, delegatorID: UInt32): UFix64 {
    let delInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
    return delInfo.tokensRewarded
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/randomBeaconHistory/transactions/set_backfiller_max_entries.cdc

```
import "RandomBeaconHistory"

transaction(maxEntries: UInt64) {
    prepare(acct: auth(BorrowValue) &Account) {
        let backfiller = acct.storage.borrow<&RandomBeaconHistory.Backfiller>(
            from: /storage/randomBeaconHistoryBackfiller
        ) ?? panic("Could not borrow backfiller resource")
    
        backfiller.setMaxEntriesPerCall(max: maxEntries) 
    } 
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/upgrade_set_claimed.cdc

```
import "FlowIDTableStaking"

// This transaction pays rewards to all the staked nodes

transaction(code: [UInt8]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(UpdateContract, BorrowValue) &Account) {

        acct.contracts.update(name: "FlowIDTableStaking", code: code)

        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        self.adminRef.setClaimed()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/randomBeaconHistory/scripts/get_source_of_randomness.cdc

```
import "RandomBeaconHistory"

/// Retrieves the source of randomness for the requested block height from the RandomBeaconHistory contract.
///
access(all) fun main(atBlockHeight: UInt64): RandomBeaconHistory.RandomSource {
    return RandomBeaconHistory.sourceOfRandomness(atBlockHeight: atBlockHeight)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_type_ratio.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(role: UInt8): UFix64 {
    let ratios = FlowIDTableStaking.getRewardRatios()

    return ratios[role]!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/admin/publish_voter.cdc

```
import "FlowClusterQC"

// Test transaction for the QC admin to publish a reference
// that allows accounts to register for QC voting

transaction {

    prepare(signer: auth(Capabilities) &Account) {
        let adminCap = signer.capabilities.storage.issue<&FlowClusterQC.Admin>(FlowClusterQC.AdminStoragePath)
        signer.capabilities.publish(adminCap, at: /public/voterCreator)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_total_staked_by_type.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(role: UInt8): UFix64 {
    let staked = FlowIDTableStaking.getTotalTokensStakedByNodeType()

    return staked[role]!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_final_submissions.cdc

```
import "FlowDKG"

access(all) fun main(): [FlowDKG.ResultSubmission] {
    return FlowDKG.getFinalSubmissions()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/admin/set_slot_limits.cdc

```
import "FlowIDTableStaking"

/// This transaction sets the slot limits for each node type 

/// slotLimits is a UInt16 array that contains the limit for
/// each node type in order from 0-4. It is used to populate
/// a dictionary that has keys shifted +1 so that they align
/// with the enumerated node types from 1-5

/// There is another mechanism which allows for a specified
/// number of slots for each node role per epoch.
/// If that mechanism has a value set for a node role, it will override
/// whatever has been set with this transaction.

transaction(slotLimits: [UInt16]) {

    // Local variable for a reference to the ID Table Admin object
    let adminRef: &FlowIDTableStaking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin object
        self.adminRef = acct.storage.borrow<&FlowIDTableStaking.Admin>(from: FlowIDTableStaking.StakingAdminStoragePath)
            ?? panic("Could not borrow reference to staking admin")
    }

    execute {
        // panic if we do not specify exactly one slot limit per node role
        if slotLimits.length != 5 {
            panic("transaction argument must specify one slot limit per node role")
        }

        var slotLimitDictionary: {UInt8: UInt16} = {}
        var dictionaryKey: UInt8 = 1

        for slotLimit in slotLimits {
            slotLimitDictionary.insert(key: dictionaryKey, slotLimit)
            dictionaryKey = dictionaryKey + 1
        }

        self.adminRef.setSlotLimits(slotLimits: slotLimitDictionary)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/.github/ISSUE_TEMPLATE/pull_request_template.md

Closes: #???

## Description

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review.
-->

______

For contributor use:

- [ ] Targeted PR against `master` branch
- [ ] Linked to Github issue with discussion and accepted design OR link to spec that describes this work.
- [ ] Code follows the [standards mentioned here](https://github.com/onflow/flow-core-contracts/blob/master/CONTRIBUTING.md#styleguides).
- [ ] Updated relevant documentation 
- [ ] Re-reviewed `Files changed` in the Github PR explorer




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/FlowServiceAccount/set_execution_memory_limit.cdc

```
// This transactions sets a new execution memory limit.
transaction(newLimit: UInt64) {
    prepare(signer: auth(Storage) &Account) {
        signer.storage.load<UInt64>(from: /storage/executionMemoryLimit)
        signer.storage.save(newLimit, to: /storage/executionMemoryLimit)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_total_commitment.cdc

```
import "FlowIDTableStaking"

// This script returns the balance of staked tokens of a node

access(all) fun main(nodeID: String): UFix64 {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID)
    return nodeInfo.totalCommittedWithDelegators()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/tokenForwarder/change_recipient.cdc

```
/**

This transaction changes the recipient for a token forwarder recource
to a different account

*/

import "FungibleToken"
import "ExampleToken"
import "TokenForwarding"

transaction(newRecipient: Address) {

    prepare(signer: auth(BorrowValue) &Account) {

        // Get the receiver capability for the account being forwarded to
        let recipient = getAccount(newRecipient).capabilities.get<&{FungibleToken.Receiver}>(ExampleToken.ReceiverPublicPath)

        // Get a reference to the signer's forwarder
        let forwarderRef = signer.storage.borrow<auth(TokenForwarding.Owner) &TokenForwarding.Forwarder>(from: /storage/exampleTokenForwarder)
			?? panic("Could not borrow reference to the owner's forwarder!")

        forwarderRef.changeRecipient(recipient)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/CODE_OF_CONDUCT.md

# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at os@dapperlabs.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_supported_vault_types.cdc

```
import "FungibleToken"

/// This scripts returns the supported FungibleToken's type by the provided `target` address.
/// `target` address should hold the capability which conforms with FungibleToken.Receiver restricted type
/// while it doesn't matter whether capability refers to fungible token or a custom receiver like 
/// `FungibleTokenSwitchboard` or `TokenReceiver`. However `targetPath` tells where the capability stores
access(all) fun main(target: Address, targetPath: PublicPath): {Type: Bool} {

    // Access the capability for the provided target address
    let capabilityRef = getAccount(target).capabilities.borrow<&{FungibleToken.Receiver}>(targetPath)
        ?? panic("Unable to borrow capability with restricted sub type {FungibleToken.Receiver} from path".concat(targetPath.toString()))
    // Return the supported vault types.
    return capabilityRef.getSupportedVaultTypes()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/transfer_tokens.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to send tokens to another account
/// through a switchboard, as long as they have set up their switchboard and have add the proper capability to it
///
/// The address of the receiver account, the amount to transfer and the PublicPath for the generic FT receiver will be
/// the parameters
///
transaction(to: Address, amount: UFix64, receiverPath: PublicPath) {

    // The signer's vault to withdraw from
    let sourceVault: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction"))

        // Get a reference to the signer's stored vault
        self.sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: vaultData.storagePath)
			?? panic("The signer does not store a ExampleToken Vault object at the path "
                .concat(vaultData.storagePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(receiverPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(to.toString()).concat(" at path ").concat(receiverPath.toString())
                .concat(". Make sure you are querying an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sourceVault.withdraw(amount: amount))

    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/setup_account.cdc

```
import "FungibleTokenSwitchboard"
import "FungibleToken"

// This transaction is a template for a transaction that could be used by 
// anyone to to add a Switchboard resource to their account so that they can
// receive multiple fungible tokens using a single {FungibleToken.Receiver}
transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {

        // Check if the account already has a Switchboard resource, return early if so
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>(from: FungibleTokenSwitchboard.StoragePath) != nil {
            return
        }
            
        // Create a new Switchboard resource and put it into storage
        signer.storage.save(
            <- FungibleTokenSwitchboard.createSwitchboard(),
            to: FungibleTokenSwitchboard.StoragePath
        )

        // Clear existing Capabilities at canonical paths
        signer.capabilities.unpublish(FungibleTokenSwitchboard.ReceiverPublicPath)
        signer.capabilities.unpublish(FungibleTokenSwitchboard.PublicPath)

        // Create a public capability to the Switchboard exposing the deposit
        // function through the {FungibleToken.Receiver} interface
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)
        
        // Create a public capability to the Switchboard exposing both the
        // {FungibleTokenSwitchboard.SwitchboardPublic} and the 
        // {FungibleToken.Receiver} interfaces
        let switchboardPublicCap = signer.capabilities.storage.issue<&{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(switchboardPublicCap, at: FungibleTokenSwitchboard.PublicPath)

    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/utility/Burner.cdc

```
/// Burner is a contract that can facilitate the destruction of any resource on flow.
///
/// Contributors
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Bastian Müller - https://twitter.com/turbolent
access(all) contract Burner {
    /// When Crescendo (Cadence 1.0) is released, custom destructors will be removed from cadece.
    /// Burnable is an interface meant to replace this lost feature, allowing anyone to add a callback
    /// method to ensure they do not destroy something which is not meant to be,
    /// or to add logic based on destruction such as tracking the supply of a FT Collection
    ///
    /// NOTE: The only way to see benefit from this interface
    /// is to always use the burn method in this contract. Anyone who owns a resource can always elect **not**
    /// to destroy a resource this way
    access(all) resource interface Burnable {
        access(contract) fun burnCallback()
    }

    /// burn is a global method which will destroy any resource it is given.
    /// If the provided resource implements the Burnable interface,
    /// it will call the burnCallback method and then destroy afterwards.
    access(all) fun burn(_ toBurn: @AnyResource?) {
        if toBurn == nil {
            destroy toBurn
            return
        }
        let r <- toBurn!

        if let s <- r as? @{Burnable} {
            s.burnCallback()
            destroy s
        } else if let arr <- r as? @[AnyResource] {
            while arr.length > 0 {
                let item <- arr.removeFirst()
                self.burn(<-item)
            }
            destroy arr
        } else if let dict <- r as? @{HashableStruct: AnyResource} {
            let keys = dict.keys
            while keys.length > 0 {
                let item <- dict.remove(key: keys.removeFirst())!
                self.burn(<-item)
            }
            destroy dict
        } else {
            destroy r
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/generic_transfer_with_address.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"

#interaction (
  version: "1.0.0",
	title: "Generic FT Transfer with Contract Address and Name",
	description: "Transfer any Fungible Token by providing the contract address and name",
	language: "en-US",
)

/// Can pass in any contract address and name to transfer a token from that contract
/// This lets you choose the token you want to send
///
/// Any contract can be chosen here, so wallets should check argument values
/// to make sure the intended token contract name and address is passed in
/// Contracts that are used must implement the FTVaultData Metadata View
///
/// Note: This transaction only will work for Fungible Tokens that
///       have their token's resource name set as "Vault".
///       Tokens with other names will need to use a different transaction
///       that additionally specifies the identifier
///
/// @param amount: The amount of tokens to transfer
/// @param to: The address to transfer the tokens to
/// @param contractAddress: The address of the contract that defines the tokens being transferred
/// @param contractName: The name of the contract that defines the tokens being transferred. Ex: "FlowToken"
///
transaction(amount: UFix64, to: Address, contractAddress: Address, contractName: String) {

    // The Vault resource that holds the tokens that are being transferred
    let tempVault: @{FungibleToken.Vault}

    // FTVaultData struct to get paths from
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    prepare(signer: auth(BorrowValue) &Account) {

        // Borrow a reference to the vault stored on the passed account at the passed publicPath
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{FungibleToken}>(name: contractName)
                ?? panic("Could not borrow FungibleToken reference to the contract. Make sure the provided contract name ("
                          .concat(contractName).concat(") and address (").concat(contractAddress.toString()).concat(") are correct!"))

        // Use that reference to retrieve the FTView 
        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ".concat(contractName)
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: self.vaultData.storagePath)
			?? panic("The signer does not store a FungibleToken.Provider object at the path "
                .concat(self.vaultData.storagePath.toString()).concat("For the ").concat(contractName)
                .concat(" contract at address ").concat(contractAddress.toString())
                .concat(". The signer must initialize their account with this object first!"))

        self.tempVault <- vaultRef.withdraw(amount: amount)

        // Get the string representation of the address without the 0x
        var addressString = contractAddress.toString()
        if addressString.length == 18 {
            addressString = addressString.slice(from: 2, upTo: 18)
        }
        let typeString: String = "A.".concat(addressString).concat(".").concat(contractName).concat(".Vault")
        let type = CompositeType(typeString)
        assert(
            type != nil,
            message: "Could not create a type out of the contract name and address!"
        )

        assert(
            self.tempVault.getType() == type!,
            message: "The Vault that was withdrawn to transfer is not the type that was requested!"
        )
    }

    execute {
        let recipient = getAccount(to)
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(to.toString()).concat(" at path ").concat(self.vaultData.receiverPath.toString())
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))

        // Transfer tokens from the signer's stored vault to the receiver capability
        receiverRef.deposit(from: <-self.tempVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/transactions/burn_array.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "Burner"

/// This transaction is for testing burning an array of Vaults
///
transaction(amountPerIndex: UFix64, numIndicies: Int) {

    /// Vault resource that holds the tokens that are being burned
    let burnVaults: @[ExampleToken.Vault]

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")

        // Withdraw tokens from the signer's vault in storage
        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(
                from: vaultData.storagePath
            ) ?? panic("Could not borrow a reference to the signer's ExampleToken vault")
        
        self.burnVaults <- []
        var i = 0
        while i < numIndicies {
            let vault <- sourceVault.withdraw(amount: amountPerIndex) as! @ExampleToken.Vault
            self.burnVaults.append(<-vault)
            i = i + 1
        }
    }

    execute {

        Burner.burn(<-self.burnVaults)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/safe_generic_transfer.cdc

```
import "FungibleToken"

/// Can pass in any storage path and receiver path instead of just the default.
/// This lets you choose the token you want to send as well the capability you want to send it to.
///
/// Any token path can be passed as an argument here, so wallets should
/// should check argument values to make sure the intended token path is passed in
///
transaction(amount: UFix64, to: Address, senderPath: StoragePath, receiverPath: PublicPath) {

    // The Vault resource that holds the tokens that are being transferred
    let tempVault: @FungibleToken.Vault

    // Borrowed teference receive tokens if receiving account doesn't support the sending token
    let senderReceiverRef: &{Token.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: senderPath)
            ?? panic("The signer does not store a FungibleToken.Provider object at the path "
                    .concat(senderPath.toString())
                    .concat(". The signer must initialize their account with this object first!"))
        
        self.senderReceiverRef = signer.storage.borrow<&{FungibleToken.Receiver}>(from: senderPath)
			?? panic("Could not borrow {FungibleToken.Receiver} reference to the signer's Vault!")

        self.tempVault <- vaultRef.withdraw(amount: amount)
    }

    execute {
        let receiverRef = getAccount(to).capabilities.borrow<&{FungibleToken.Receiver}>(receiverPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(to.toString()).concat(" at path ").concat(receiverPath.toString())
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))

        let supportedVaultTypes = receiverRef.getSupportedVaultTypes()
        // Only transfer tokens when the receiver is willing to receive the targeted FT.
        if supportedVaultTypes.containsKey(self.tempVault.getType()) {
            // Transfer tokens from the signer's stored vault to the receiver capability
            receiverRef.deposit(from: <-self.tempVault)
        } else {
            self.senderReceiverRef.deposit(from: <-self.tempVault)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/.github/ISSUE_TEMPLATE/bug-report.md

---
name: Reporting a Problem/Bug
about: Reporting a Problem/Bug
title: ''
labels: bug, Feedback
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Problem

<what is the problem you've encountered?> 

### Steps to Reproduce 

<share any logs/screenshots or steps to replicate>

### Acceptance Criteria

<if any>
  
### Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/safe_transfer_tokens.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to send tokens to another account
/// through a switchboard using the deposit method but before depositing we will explicitly check whether receiving
/// capability is borrowable or not and if yes then it will deposit the vault to the receiver capability.
///
transaction(to: Address, amount: UFix64) {

    // The reference to the vault from the payer's account
    let vaultRef: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction"))

        // Get a reference to the signer's stored vault
        self.vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: vaultData.storagePath)
			?? panic("The signer does not store a ExampleToken Vault object at the path "
                .concat(vaultData.storagePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        let sentVault <- self.vaultRef.withdraw(amount: amount)

        // Get a reference to the recipient's SwitchboardPublic
        let switchboardRef = recipient.capabilities.borrow<&{FungibleTokenSwitchboard.SwitchboardPublic}>(
                FungibleTokenSwitchboard.PublicPath)
			?? panic("The signer does not store a FungibleToken Switchboard capability at the path "
                .concat(FungibleTokenSwitchboard.PublicPath.toString())
                .concat(". The signer must initialize their account with this object first!"))  

        // Validate the receiving capability by using safeBorrowByType
        if let receivingRef = switchboardRef.safeBorrowByType(type: Type<@ExampleToken.Vault>()) {
            switchboardRef.deposit(from: <-sentVault)
        } else {
            // Return funds to signer's account if receiver is not configured to receive the funds
            self.vaultRef.deposit(from: <-sentVault)
        }
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/private_receiver_forwarder_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "ExampleToken"

/* Test Setup */

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let senderStoragePath = /storage/Sender
access(all) let privateReceiverStoragePath = /storage/PrivateReceiver
access(all) let privateReceiverPublicPath = /public/PrivateReceiver

access(all) fun setup() {

    // helper nft contract so we can actually talk to nfts with tests
    // deploy("ViewResolver", "../contracts/utility/ViewResolver.cdc")
    deploy("Burner", "../contracts/utility/Burner.cdc")
    deploy("FungibleToken", "../contracts/FungibleToken.cdc")
    // deploy("NonFungibleToken", "../contracts/utility/NonFungibleToken.cdc")
    // deploy("MetadataViews", "../contracts/utility/MetadataViews.cdc")
    deploy("FungibleTokenMetadataViews", "../contracts/FungibleTokenMetadataViews.cdc")
    deploy("ExampleToken", "../contracts/ExampleToken.cdc")
    deployWithArgs(
        "PrivateReceiverForwarder",
        "../contracts/utility/PrivateReceiverForwarder.cdc",
        args: [
            senderStoragePath,
            privateReceiverStoragePath,
            privateReceiverPublicPath
        ]
    )
}

/* Test Cases */

access(all) fun testSetupForwader() {
    let alice = Test.createAccount()
    let txResult = executeTransaction(
        "../transactions/privateForwarder/setup_and_create_forwarder.cdc",
        [],
        alice
    )
    Test.expect(txResult, Test.beSucceeded())
}

access(all) fun testTransferPrivateTokens() {
    let senderBalanceBefore = getExampleTokenBalance(admin)
    assert(senderBalanceBefore == 1000.0, message: "ExampleToken balance should be 1000.0")

    let recipient = Test.createAccount()
    let recipientAmount = 300.0

    let pair = {recipient.address: recipientAmount}

    txExecutor("../transactions/privateForwarder/setup_and_create_forwarder.cdc", [recipient], [], nil, nil)
    
    txExecutor("../transactions/privateForwarder/transfer_private_many_accounts.cdc", [admin], [pair], nil, nil)

    let recipientBalance = getExampleTokenBalance(recipient)
    Test.assertEqual(recipientAmount, recipientBalance)

    let senderBalanceAfter = getExampleTokenBalance(admin)
    Test.assertEqual(senderBalanceBefore - recipientAmount, senderBalanceAfter)
}


/* Transaction Helpers */

access(all) fun setupExampleToken(_ acct: Test.TestAccount) {
    txExecutor("setup_account.cdc", [acct], [], nil, nil)
}

access(all) fun mintExampleToken(_ acct: Test.TestAccount, recipient: Address, amount: UFix64) {
    txExecutor("mint_tokens.cdc", [acct], [recipient, amount], nil, nil)
}

access(all) fun setupTokenForwarder(_ acct: Test.TestAccount) {
    txExecutor("../transactions/privateForwarder/setup_and_create_forwarder.cdc", [acct], [], nil, nil)
}

/* Script Helpers */

access(all) fun getExampleTokenBalance(_ acct: Test.TestAccount): UFix64 {
    let balance: UFix64? = (scriptExecutor("get_balance.cdc", [acct.address])! as! UFix64)
    return balance!
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/switchboard_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "FungibleTokenMetadataViews"
import "ExampleToken"
import "FungibleTokenSwitchboard"
import "FungibleToken"

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let recipient = Test.createAccount()

access(all)
fun setup() {
    // deploy("ViewResolver", "../contracts/utility/ViewResolver.cdc")
    deploy("Burner", "../contracts/utility/Burner.cdc")
    deploy("FungibleToken", "../contracts/FungibleToken.cdc")
    // deploy("NonFungibleToken", "../contracts/utility/NonFungibleToken.cdc")
    // deploy("MetadataViews", "../contracts/utility/MetadataViews.cdc")
    deploy("FungibleTokenMetadataViews", "../contracts/FungibleTokenMetadataViews.cdc")
    deploy("ExampleToken", "../contracts/ExampleToken.cdc")
    deploy("FungibleTokenSwitchboard", "../contracts/FungibleTokenSwitchboard.cdc")
    deploy("TokenForwarding", "../contracts/utility/TokenForwarding.cdc")
}

access(all)
fun testSetupSwitchboard() {
    var txResult = executeTransaction(
        "../transactions/setup_account.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/switchboard/setup_account.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the newly-setup switchboard cannot accept any types
    var scriptResult = executeScript(
        "../transactions/scripts/get_supported_vault_types.cdc",
        [recipient.address, /public/GenericFTReceiver]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    var supportedTypes = scriptResult.returnValue! as! {Type: Bool}
    Test.expect(supportedTypes, Test.beEmpty())

    txResult = executeTransaction(
        "../transactions/switchboard/add_vault_capability.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the switchboard can now accept one vault type
    scriptResult = executeScript(
        "../transactions/scripts/get_supported_vault_types.cdc",
        [recipient.address, /public/GenericFTReceiver]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    supportedTypes = scriptResult.returnValue! as! {Type: Bool}
    let expectedTypes = {Type<@ExampleToken.Vault>(): true}
    Test.assertEqual(expectedTypes, supportedTypes)

    // Test that the switchboard capability is correct
    scriptResult = executeScript(
        "../transactions/switchboard/scripts/get_vault_types_and_address.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    var typeAddresses = scriptResult.returnValue! as! {Type: Address}
    let expectedAddresses = {Type<@ExampleToken.Vault>(): recipient.address}
    Test.assertEqual(expectedAddresses, typeAddresses)
}

access(all)
fun testUseSwitchboard() {
    var txResult = executeTransaction(
        "../transactions/switchboard/safe_transfer_tokens.cdc",
        [recipient.address, 10.0],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/switchboard/transfer_tokens.cdc",
        [recipient.address, 10.0, /public/fungibleTokenSwitchboardPublic],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the switchboard account has a balance of 20.0
    let scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(20.0, balance)
}

access(all)
fun testRemoveVaultTypeFromSwitchboard() {
    var txResult = executeTransaction(
        "../transactions/switchboard/remove_vault_capability.cdc",
        [/public/exampleTokenReceiver],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/switchboard/transfer_tokens.cdc",
        [recipient.address, 10.0, /public/fungibleTokenSwitchboardPublic],
        admin
    )
    Test.expect(txResult, Test.beFailed())

    // Test that the switchboard can now accept zero vault types
    let scriptResult = executeScript(
        "../transactions/scripts/get_supported_vault_types.cdc",
        [recipient.address, /public/GenericFTReceiver]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let supportedTypes = scriptResult.returnValue! as! {Type: Bool}
    Test.expect(supportedTypes, Test.beEmpty())
}

access(all)
fun testUseSwitchboardWithForwarder() {
    var txResult = executeTransaction(
        "../transactions/tokenForwarder/create_forwarder.cdc",
        [admin.address],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/tokenForwarder/change_recipient.cdc",
        [admin.address],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Fail with invalid capability
    txResult = executeTransaction(
        "../transactions/switchboard/add_vault_wrapper_capability.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/switchboard/batch_add_vault_wrapper_capabilities.cdc",
        [recipient.address],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/switchboard/batch_add_vault_capabilities.cdc",
        [recipient.address],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the switchboard can now accept one vault types
    var scriptResult = executeScript(
        "../transactions/scripts/get_supported_vault_types.cdc",
        [recipient.address, /public/GenericFTReceiver]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let supportedTypes = scriptResult.returnValue! as! {Type: Bool}
    let expectedTypes = {Type<@ExampleToken.Vault>(): true}
    Test.assertEqual(expectedTypes, supportedTypes)

    txResult = executeTransaction(
        "../transactions/switchboard/transfer_tokens.cdc",
        [recipient.address, 10.0, /public/fungibleTokenSwitchboardPublic],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the switchboard account has a balance of 20.0
    scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(20.0, balance)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/setup_account_from_vault_reference.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "ViewResolver"

/// This transaction is what an account would run
/// to set itself up to manage fungible tokens. This function
/// uses views to know where to set up the vault
/// in storage and to create the empty vault.

transaction(address: Address, publicPath: PublicPath) {

    prepare(signer: auth(SaveValue, Capabilities) &Account) {
        // Borrow a reference to the vault stored on the passed account at the passed publicPath
        let resolverRef = getAccount(address)
            .capabilities.borrow<&{ViewResolver.Resolver}>(publicPath)
            ?? panic("Could not borrow a reference to the ViewResolver in account "
                .concat(address.toString()).concat(" at path ").concat(publicPath.toString())
                .concat(". Make sure you are querying an address that has a Vault set up properly."))

        // Use that reference to retrieve the FTView 
        let ftView = FungibleTokenMetadataViews.getFTView(viewResolver: resolverRef)

        // Get the FTVaultData view from from the FTView
        let ftVaultData = ftView.ftVaultData ?? panic ("The stored vault didn't implement the vault data view")

        // Create a new empty vault using the createEmptyVault function inside the FTVaultData
        let emptyVault <-ftVaultData.createEmptyVault()

        // Save it to the account
        signer.storage.save(<-emptyVault, to: ftVaultData.storagePath)
        
        // Create a public capability for the vault which includes the .Resolver interface
        let vaultCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(ftVaultData.storagePath)
        signer.capabilities.publish(vaultCap, at: ftVaultData.metadataPath)

        // Create a public capability for the vault exposing the receiver interface
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(ftVaultData.storagePath)
        signer.capabilities.publish(receiverCap, at: ftVaultData.receiverPath)

    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_supply.cdc

```
// This script reads the total supply field
// of the ExampleToken smart contract

import "ExampleToken"

access(all) fun main(): UFix64 {
    return ExampleToken.totalSupply
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/README.md

# Fungible Token Standard

This is a description of the Flow standard for fungible token contracts. 
It is meant to contain the minimum requirements to implement a safe, secure, easy to understand,
and easy to use fungible token contract.
It also includes an example implementation to show how a 
concrete smart contract would actually implement the interface.

The version of the contracts in the `master` branch is the
Cadence 1.0 version of the contracts and is not the same
as the ones that are currently deployed to testnet and mainnet.
See the `cadence-0.42` branch for the currently deployed versions.

## What is Flow?

Flow is a new blockchain for open worlds. Read more about it [here](https://www.flow.com/).

## What is Cadence?

Cadence is a new Resource-oriented programming language 
for developing smart contracts for the Flow Blockchain.
Read more about it [here](https://developers.flow.com/) and see its implementation [here](https://github.com/onflow/cadence)

We recommend that anyone who is reading this should have already
completed the [Cadence Tutorials](https://cadence-lang.org/docs/tutorial/first-steps) 
so they can build a basic understanding of the programming language.

Resource-oriented programming, and by extension Cadence, 
is the perfect programming environment for currencies, because users are able
to store their tokens directly in their accounts and transact
peer-to-peer. Please see the [blog post about resources](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e)
to understand why they are perfect for digital assets.

## Import Addresses

The `FungibleToken`, `FungibleTokenMetadataViews`, and `FungibleTokenSwitchboard` contracts are already deployed
on various networks. You can import them in your contracts from these addresses.
There is no need to deploy them yourself.

| Network           | Contract Address     |
| ----------------- | -------------------- |
| Emulator          | `0xee82856bf20e2aa6` |
| Testnet           | `0x9a0766d93b6608b7` |
| Sandboxnet        | `0xe20612a0776ca4bf` |
| Mainnet           | `0xf233dcee88fe0abe` |

The `Burner` contract is also deployed to these addresses, but should only be used in Cadence 1.0 `FungibleToken` implementations of the standard.

## Basics of the Standard:

The code for the standard is in [`contracts/FungibleToken.cdc`](contracts/FungibleToken.cdc). An example implementation of the standard that simulates what a simple token would be like is in [`contracts/ExampleToken.cdc`](contracts/FungibleToken.cdc). 

The exact smart contract that is used for the official Flow Network Token (`FlowToken`) is in [the `flow-core-contracts` repository](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowToken.cdc).

Example transactions that users could use to interact with fungible tokens are located in the `transactions/` directory. These templates are mostly generic and can be used with any fungible token implementation by providing the correct addresses, names, and values.

The standard consists of a contract interface called `FungibleToken` that defines important
functionality for token implementations. Contracts are expected to define a resource
that implement the `FungibleToken.Vault` resource interface.
A `Vault` represents the tokens that an account owns. Each account that owns tokens
will have a `Vault` stored in its account storage. 
Users call functions on each other's `Vault`s to send and receive tokens.  

The standard uses unsigned 64-bit fixed point numbers `UFix64` as the type to represent token balance information. This type has 8 decimal places and cannot represent negative numbers.

## Core Features (All contained in the main FungibleToken interface)

### `Balance` Interface

Specifies that the implementing type must have a `UFix64` `balance` field.
  - `access(all) var balance: UFix64`

### `Provider` Interface
Defines a [`withdraw ` function](contracts/FungibleToken.cdc#L95) for withdrawing a specific amount of tokens as *amount*.
  - `access(all) fun withdraw(amount: UFix64): @{FungibleToken.Vault}`
      - Conditions
          - the returned Vault's balance must equal the amount withdrawn
          - The amount withdrawn must be less than or equal to the balance
          - The resulting balance must equal the initial balance - amount
  - Users can give other accounts a persistent Capability
  or ephemeral reference to their `Vault` cast as a `Provider`
  to allow them to withdraw and send tokens for them. 
  A contract can define any custom logic to govern the amount of tokens
  that can be withdrawn at a time with a `Provider`. 
  This can mimic the `approve`, `transferFrom` functionality of ERC20.
- [`FungibleToken.Withdrawn` event](contracts/FungibleToken.cdc#L50)
    - Event that is emitted automatically to indicate how much was withdrawn
    and from what account the `Vault` is stored in.
      If the `Vault` is not in account storage when the event is emitted,
      `from` will be `nil`.
    - Contracts do not have to emit their own events,
    the standard events will automatically be emitted from the interface contract with values identifying the relevant `Vault`.

Defines [an `isAvailableToWithdraw()` function](contracts/FungibleToken.cdc#L95)
to ask a `Provider` if the specified number of tokens can be withdrawn from the implementing type.

### `Receiver` Interface
Defines functionality to depositing fungible tokens into a resource object.
- [`deposit()` function](contracts/FungibleToken.cdc#L119):
  - `access(all) fun deposit(from: @{FungibleToken.Vault})`
  - Conditions
      - `from` balance must be non-zero
      - The resulting balance must be equal to the initial balance + the balance of `from`
  - It is important that if you are making your own implementation of the fungible token interface that
  you cast the input to `deposit` as the type of your token.
  `let vault <- from as! @ExampleToken.Vault`
  The interface specifies the argument as `@{FungibleToken.Vault}`, any resource that satisfies this can be sent to the deposit function. The interface checks that the concrete types match, but you'll still need to cast the `Vault` before incrementing the receiving `Vault`'s balance.
- deposit event
    - [`FungibleToken.Deposited` event](contracts/FungibleToken.cdc#L53) from the standard
    that indicates how much was deposited and to what account the `Vault` is stored in.
      - If the `Vault` is not in account storage when the event is emitted,
        `to` will be `nil`.
      - This event is emitted from the interface contract automatically on any deposit,
        so projects do not need to define and emit their own events.

Defines Functionality for Getting Supported Vault Types
- Some resource types can accept multiple different vault types in their deposit functions,
  so the `getSupportedVaultTypes()` and `isSupportedVaultType()` functions allow callers
  to query a resource that implements `Receiver` to see if the `Receiver` accepts
  their desired `Vault` type in its deposit function.

Users could create custom `Receiver`s to trigger special code when transfers to them happen,
like forwarding the tokens to another account, splitting them up, and much more.

### `Vault` Interface
[Interface](contracts/FungibleToken.cdc#L134) that inherits from `Provider`, `Receiver`, `Balance`, `ViewResolver.Resolver`,
and `Burner.Burnable` and provides additional pre and post conditions.

The `ViewResolver.Resolver` interface defines functionality for retrieving metadata
about a particular resource object. [Fungible Token metadata](README.md#ft-metadata) is described below.

See the comments in [the `Burner` contract](contracts/Burner.cdc) for context about it.
Basically, it defines functionality for tokens to have custom logic when those tokens
are destroyed.

### Creating an empty Vault resource
Defines functionality in the contract to create a new empty vault of
of the contract's defined type.
- `access(all) fun createEmptyVault(vaultType: Type): @{FungibleToken.Vault}`
- Defined in the contract 
- To create an empty `Vault`, the caller calls the function and provides the Vault Type
  that they want. They get a vault back and can store it in their storage.
- Conditions:
    - the balance of the returned Vault must be 0


## Comparison to Similar Standards in Ethereum

This spec covers much of the same ground that a spec like ERC-20 covers, but without most of the downsides.  

- Tokens cannot be sent to accounts or contracts that don't have owners or don't understand how to use them, because an account has to have a `Vault` in its storage to receive tokens.  No `safetransfer` is needed.
- If the recipient is a contract that has a stored `Vault`, the tokens can just be deposited to that Vault without having to do a clunky `approve`, `transferFrom`
- Events are defined in the contract for withdrawing and depositing, so a recipient will always be notified that someone has sent them tokens with the deposit event.
- The `approve`, `transferFrom` pattern is not included, so double spends are not permitted
- Transfers can trigger actions because users can define custom `Receivers` to execute certain code when a token is sent.
- Cadence integer types protect against overflow and underflow, so a `SafeMath`-equivalent library is not needed.

## FT Metadata

FT Metadata is represented in a flexible and modular way using both
the [standard proposed in FLIP-0636](https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md)
and the [standard proposed in FLIP-1087](https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md).

[A guide for NFT metadata](https://developers.flow.com/build/advanced-concepts/metadata-views)
is provided on the docs site. Many of the concepts described there also apply
to fungible tokens, so it is useful to read for any Cadence developer.

When writing an FT contract interface, your contract will implement
the `FungibleToken` contract interface which already inherits
from [the `ViewResolver` contract interface](https://github.com/onflow/flow-nft/blob/master/contracts/ViewResolver.cdc),
so you will be required to implement the metadata functions.
Additionally, your `Vault` will also implement the `ViewResolver.Resolver` by default,
which allows your `Vault` resource to implement one or more metadata types called views.

Views do not specify or require how to store your metadata, they only specify
the format to query and return them, so projects can still be flexible with how they store their data.

### Fungible token Metadata Views

The [FungibleTokenMetadataViews contract](contracts/FungibleTokenMetadataViews.cdc) defines four new views that can used to communicate any fungible token information:

1. `FTView`: A view that wraps the two other views that actually contain the data.
2. `FTDisplay`: The view that contains all the information that will be needed
by other dApps to display the fungible token: name, symbol, description, external URL, logos and links to social media.
3. `FTVaultData`: The view that can be used by other dApps to interact programmatically
with the fungible token, providing the information about the public and storage paths
used by default by the token, the public linked types for exposing capabilities
and the function for creating new empty vaults.
You can use this view to [setup an account using the vault stored in other account without the need of importing the actual token contract.](transactions/setup_account_from_vault_reference.cdc)
4. `TotalSupply`: Specifies the total supply of the given token.

### How to implement metadata

The [Example Token contract](contracts/ExampleToken.cdc) shows how to implement metadata views for fungible tokens.

### How to read metadata

In this repository you can find examples on how to read metadata, accessing the `ExampleToken` display (name, symbol, logos, etc.) and its vault data (paths, linked types and the method to create a new vault).

Latter using that reference you can call methods defined in the [Fungible Token Metadata Views contract](contracts/FungibleTokenMetadataViews.cdc) that will return you the structure containing the desired information:



## Bonus Features

The following features could each be defined as a separate standard. It would be good to make standards for these, but not necessary to include in the main standard interface and are not currently defined in this example.

- Scoped Provider 
This refers to restricting a `Provider` capability to only be able to withdraw a specific amount of tokens from someone else's `Vault`
This is currently being worked on.

- Pausing Token transfers (maybe a way to prevent the contract from being imported)
- Cloning the token to create a new token with the same distribution
- Restricted ownership (For accredited investors and such)
- allowlisting
- denylisting

# How to use the Fungible Token contract

To use the Flow Token contract as is, you need to follow these steps:

1. If you are using any network or the playground, there is no need to deploy
the `FungibleToken` definition to accounts yourself.
It is a pre-deployed interface in the emulator, testnet, mainnet,
and playground and you can import definition from those accounts:
    - `0xee82856bf20e2aa6` on emulator
    - `0x9a0766d93b6608b7` on testnet/crescendo
    - `0xf233dcee88fe0abe` on mainnet
2. Deploy the `ExampleToken` definition, making sure to import the `FungibleToken` interface.
3. You can use the `get_balance.cdc` or `get_supply.cdc` scripts to read the 
   balance of a user's `Vault` or the total supply of all tokens, respectively.
4. Use the `setup_account.cdc` on any account to set up the account to be able to
   use `ExampleToken`.
5. Use the `transfer_tokens.cdc` transaction file to send tokens from one user with
   a `Vault` in their account storage to another user with a `Vault` in their account storage.
6. Use the `mint_tokens.cdc` transaction with the admin account to mint new tokens.
7. Use the `burn_tokens.cdc` transaction with the admin account to burn tokens.
8. Use the `create_minter.cdc` transaction to create a new MintandBurn resource
   and store it in a new Admin's account.

# Fungible Token Switchboard

`FungibleTokenSwitchboard.cdc`, allows users to receive payments in different fungible tokens using a single `&{FungibleToken.Receiver}` placed in a standard receiver path `/public/GenericFTReceiver`.

 ## How to use it

 Users willing to use the Fungible Token Switchboard will need to setup their accounts by creating a new `FungibleTokenSwitchboard.Switchboard` resource and saving it to their accounts at the `FungibleTokenSwitchboard.StoragePath` path.
 
 This can be accomplished by executing the transaction found in this repository `transactions/switchboard/setup_account.cdc`.
 This transaction will create and save a Switchboard resource to the signer's account,
 and it also will create the needed public capabilities to access it.
 After setting up their switchboard, in order to make it support receiving a certain token,
 users will need to add the desired token's receiver capability to their switchboard resource.
 
 ## Adding a new vault to the switchboard
 When a user wants to receive a new fungible token through their switchboard,
 they will need to add a new public capability linked to said FT
 to their switchboard resource. This can be accomplished in two different ways:
 
 1. Adding a single capability using `addNewVault(capability: Capability<&{FungibleToken.Receiver}>)`
    * Before calling this method on a transaction you should first retrieve the capability to the token's vault you are
    willing to add to the switchboard, as is done in the template transaction [`transactions/switchboard/add_vault_capability.cdc`](./transactions/switchboard/add_vault_capability.cdc).

    This function will panic if is not possible to `.borrow()` a reference
    to a `&{FungibleToken.Receiver}` from the passed capability.

 2. Adding one or more capabilities using the paths where they are stored using `addNewVaultsByPath(paths: [PublicPath], address: Address)`. This is shown in
    the [`batch_add_vault_wrapper_capabilities.cdc` transaction](./transactions/switchboard/batch_add_vault_wrapper_capabilities.cdc)
    * When using this method, an array of `PublicPath` objects should be passed along with the `Address` of the account from where the vaults' capabilities should be retrieved.

    This function won't panic, instead it will just not add to the `@Switchboard`
    any capability which can not be retrieved from any of the provided `PublicPath`s.
    It will also ignore any type of `&{FungibleToken.Receiver}` that is already present on the `@Switchboard`

  3. Adding a capability to a receiver specifying which type of token will be deposited there 
  using `addNewVaultWrapper(capability: Capability<&{FungibleToken.Receiver}>, type: Type)`. 
  This method can be used to link a token forwarder or any other wrapper to the switchboard. 
  Once the `Forwarder` has been properly created containing the capability to an actual `@FungibleToken.Vault`,
  this method can be used to link the `@Forwarder` to the switchboard to deposit the specified type of Fungible Token.
  In [the template transaction  `switchboard/add_vault_wrapper_capability.cdc`](./transactions/switchboard/add_vault_wrapper_capability.cdc),
  we assume that the signer has a forwarder containing a capability to an `@ExampleToken.Vault` resource:

 ## Removing a vault from the switchboard
 If a user no longer wants to be able to receive deposits from a certain FT,
 or if they want to update the provided capability for one of them,
 they will need to remove the vault from the switchboard.
 This can be accomplished by using `removeVault(capability: Capability<&{FungibleToken.Receiver}>)`. 
This can be observed in [the template transaction `transactions/switchboard/remove_vault_capability.cdc`](./transactions/switchboard/remove_vault_capability.cdc):

 This function will panic if is not possible to `.borrow()` a reference to a `&{FungibleToken.Receiver}` from the passed capability.

 ## Transferring tokens through the switchboard
 The Fungible Token Switchboard provides two different ways of depositing tokens to it,
 using the `deposit(from: @{FungibleToken.Vault})` method enforced by
 the `{FungibleToken.Receiver}` or using the `safeDeposit(from: @FungibleToken.Vault): @FungibleToken`:

 1. Using the first method will be just the same as depositing to `&{FungibleToken.Receiver}`.
 The path for the Switchboard receiver is defined in `FungibleTokenSwitchboard.ReceiverPublicPath`,
 the generic receiver path `/public/GenericFTReceiver` that can also be obtained from the NFT MetadataViews contract.
 An example of how to do this can be found in the transaction template on this repo [`transactions/switchboard/transfer_tokens.cdc`](./transactions/switchboard/transfer_tokens.cdc).

 2. The `safeDeposit(from: @FungibleToken.Vault): @FungibleToken` works in a similar way,
 with the difference that it will not panic if the desired FT Vault
 can not be obtained from the Switchboard. The method will return the passed vault,
 empty if the funds were deposited successfully or still containing the funds
 if the transfer of the funds was not possible. Keep in mind that 
 when using this method on a transaction you will always have to deal
 with the returned resource. An example of this can be found on [`transactions/switchboard/safe_transfer_tokens.cdc`](./transactions/switchboard/safe_transfer_tokens.cdc):

# Running Automated Tests

There are two sets of tests in the repo, Cadence tests and Go tests.
The Cadence tests are much more straightforward and are all written in Cadence,
so we recommend following those.

## Cadence Testing Framework

The Cadence tests are located in the `tests/` repository. They are written in Cadence
and can be run directly from the command line using the Flow CLI.
Make sure you are using [the latest Cadence 1.0 CLI verion](https://forum.flow.com/t/update-on-cadence-1-0/5197/10).
```
flow test --cover --covercode="contracts" tests/*.cdc
```

## Go tests

You can find automated tests in the `lib/go/test/token_test.go` file.
It uses the transaction templates that are contained in the
`lib/go/templates/transaction_templates.go` file. You can run them by navigating
to the `lib/go/test/` directory and running `go test -v`.
If you make changes to the contracts or transactions in between running tests,
you will need to run `make generate` from the `lib/go/` directory
to generate the assets used in the tests.

## License 

The works in these folders are under the [Unlicense](https://github.com/onflow/flow-ft/blob/master/LICENSE):

- [/contracts](https://github.com/onflow/flow-ft/blob/master/contracts/)







---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/transactions/burn_dict.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "Burner"

/// This transaction is for testing burning a dictionary of Vaults
///
transaction(amountPerIndex: UFix64, numIndicies: Int) {

    /// Vault resource that holds the tokens that are being burned
    let burnVaults: @{Int: ExampleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")

        // Withdraw tokens from the signer's vault in storage
        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(
                from: vaultData.storagePath
            ) ?? panic("Could not borrow a reference to the signer's ExampleToken vault")
        
        self.burnVaults <- {}
        var i = 0
        while i < numIndicies {
            let vault <- sourceVault.withdraw(amount: amountPerIndex) as! @ExampleToken.Vault
            self.burnVaults[i] <-! vault
            i = i + 1
        }
    }

    execute {

        Burner.burn(<-self.burnVaults)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/batch_add_vault_capabilities.cdc

```
import "FungibleTokenSwitchboard"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to add several new fungible token
/// vaults, belonging to a certain `Address` to their switchboard resource.
///
transaction (address: Address) {

    let exampleTokenVaultPath: PublicPath
    let vaultPaths: [PublicPath]
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Get the example token vault path from the contract
        self.exampleTokenVaultPath = vaultData.receiverPath
      
        // And store it in the array of public paths that will be passed to the
        // switchboard method
        self.vaultPaths = []
        self.vaultPaths.append(self.exampleTokenVaultPath)
      
        // Get a reference to the signers switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>(
            from: FungibleTokenSwitchboard.StoragePath)
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))
    
    }

    execute {

        // Add the capability to the switchboard using addNewVault method
        self.switchboardRef.addNewVaultsByPath(paths: self.vaultPaths, address: address)

    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/example_token_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "FungibleTokenMetadataViews"
import "ExampleToken"
import "FungibleToken"

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let service = Test.getAccount(0x0000000000000001)
access(all) let recipient = Test.createAccount()

access(all)
fun setup() {
    deploy("Burner", "../contracts/utility/Burner.cdc")
    deploy("FungibleToken", "../contracts/FungibleToken.cdc")
    deploy("FungibleTokenMetadataViews", "../contracts/FungibleTokenMetadataViews.cdc")
    deploy("ExampleToken", "../contracts/ExampleToken.cdc")
    deploy("MaliciousToken", "../contracts/test/MaliciousToken.cdc")
}

access(all)
fun testGetTotalSupply() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_supply.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let totalSupply = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1000.0, totalSupply)
}

access(all)
fun testGetAdminBalance() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [admin.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1000.0, balance)
}

access(all)
fun testSetupAccount() {
    let txResult = executeTransaction(
        "../transactions/setup_account.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the newly-setup account has a balance of 0.0
    let scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(0.0, balance)
}

access(all)
fun testMintTokens() {
    let txResult = executeTransaction(
        "../transactions/mint_tokens.cdc",
        [recipient.address, 250.0],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    // Test that the proper events were emitted
    var typ = Type<ExampleToken.TokensMinted>()
    var events = Test.eventsOfType(typ)
    Test.assertEqual(2, events.length)

    let tokensMintedEvent = events[1] as! ExampleToken.TokensMinted
    Test.assertEqual(250.0, tokensMintedEvent.amount)

    typ = Type<FungibleToken.Deposited>()
    events = Test.eventsOfType(typ)

    let tokensDepositedEvent = events[events.length - 1] as! FungibleToken.Deposited
    Test.assertEqual(250.0, tokensDepositedEvent.amount)
    Test.assertEqual(recipient.address, tokensDepositedEvent.to!)
    Test.assertEqual("A.0000000000000007.ExampleToken.Vault", tokensDepositedEvent.type)
    Test.assertEqual(250.0, tokensDepositedEvent.balanceAfter!)

    // Test that the totalSupply increased by the amount of minted tokens
    let scriptResult = executeScript(
        "../transactions/scripts/get_supply.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let totalSupply = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1250.0, totalSupply)
}

access(all)
fun testTransferTokens() {
    let txResult = executeTransaction(
        "../transactions/transfer_tokens.cdc",
        [50.0, admin.address],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    var typ = Type<FungibleToken.Deposited>()
    Test.assertEqual(2, Test.eventsOfType(typ).length)

    typ = Type<FungibleToken.Withdrawn>()
    let events = Test.eventsOfType(typ)
    Test.assertEqual(1, events.length)

    let tokensWithdrawnEvent = events[0] as! FungibleToken.Withdrawn
    Test.assertEqual("A.0000000000000007.ExampleToken.Vault", tokensWithdrawnEvent.type)
    Test.assertEqual(50.0, tokensWithdrawnEvent.amount)
    Test.assertEqual(recipient.address, tokensWithdrawnEvent.from!)
    Test.assertEqual(200.0, tokensWithdrawnEvent.balanceAfter!)

    var scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    var balance = scriptResult.returnValue! as! UFix64
    // 250.0 tokens were previously minted to the recipient
    Test.assertEqual(200.0, balance)

    scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [admin.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    // The admin had initially 1000.0 tokens (initial supply)
    balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1050.0, balance)
}

access(all)
fun testTransferTokenAmountGreaterThanBalance() {
    let txResult = executeTransaction(
        "../transactions/transfer_tokens.cdc",
        [1550.0, admin.address],
        recipient
    )
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "FungibleToken.Vault.withdraw: Cannot withdraw tokens! The amount requested to be withdrawn (1550.00000000) is greater than the balance of the Vault (200.00000000)."
    )
}

access(all)
fun testBurnTokens() {
    var txResult = executeTransaction(
        "../transactions/burn_tokens.cdc",
        [50.0],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    let type = Type<FungibleToken.Burned>()
    let events = Test.eventsOfType(type)
    Test.assertEqual(1, events.length)

    let tokensBurnedEvent = events[0] as! FungibleToken.Burned
    Test.assertEqual(50.0, tokensBurnedEvent.amount)
    Test.assertEqual("A.0000000000000007.ExampleToken.Vault", tokensBurnedEvent.type)

    var scriptResult = executeScript(
        "../transactions/scripts/get_balance.cdc",
        [admin.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    // The admin should now have the initial supply of 1000.0 tokens
    var balance = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1000.0, balance)

    txResult = executeTransaction(
        "transactions/burn_array.cdc",
        [10.0, 5],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    scriptResult = executeScript(
        "../transactions/scripts/get_supply.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    var totalSupply = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1150.0, totalSupply)

        txResult = executeTransaction(
        "transactions/burn_dict.cdc",
        [10.0, 5],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    scriptResult = executeScript(
        "../transactions/scripts/get_supply.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    totalSupply = scriptResult.returnValue! as! UFix64
    Test.assertEqual(1100.0, totalSupply)

    txResult = executeTransaction(
        "transactions/burn_optional.cdc",
        [],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    scriptResult = executeScript(
        "../transactions/scripts/get_supply.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    totalSupply = scriptResult.returnValue! as! UFix64
    Test.assertEqual(200.0, totalSupply)
}

access(all)
fun testVaultTypes() {
    let scriptResult = executeScript(
        "../transactions/metadata/scripts/get_views.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let supportedViews = scriptResult.returnValue! as! [Type]
    let expectedViews = [
        Type<FungibleTokenMetadataViews.FTView>(),
        Type<FungibleTokenMetadataViews.FTDisplay>(),
        Type<FungibleTokenMetadataViews.FTVaultData>(),
        Type<FungibleTokenMetadataViews.TotalSupply>()
    ]
    Test.assertEqual(expectedViews, supportedViews)
}

access(all)
fun testGetVaultDisplay() {
    let scriptResult = executeScript(
        "scripts/get_vault_display.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let ftDisplay = scriptResult.returnValue! as! FungibleTokenMetadataViews.FTDisplay
    Test.assertEqual("Example Fungible Token", ftDisplay.name)
    Test.assertEqual("EFT", ftDisplay.symbol)
    Test.assertEqual(
        "This fungible token is used as an example to help you develop your next FT #onFlow.",
        ftDisplay.description
    )
    Test.assertEqual(
        "https://example-ft.onflow.org",
        ftDisplay.externalURL!.url
    )
    Test.assertEqual(
        "https://twitter.com/flow_blockchain",
        ftDisplay.socials["twitter"]!.url
    )
    Test.assertEqual(
        "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg",
        ftDisplay.logos.items[0].file.uri()
    )
}

access(all)
fun testGetVaultData() {
    let scriptResult = executeScript(
        "scripts/get_vault_data.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testGetTokenMetadata() {
    let scriptResult = executeScript(
        "scripts/get_token_metadata.cdc",
        [recipient.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testGetUnsupportedViewType() {
    let scriptResult = executeScript(
        "scripts/get_unsupported_view.cdc",
        [recipient.address, Type<String>()]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let view = scriptResult.returnValue
    Test.expect(view, Test.beNil())
}


access(all) fun testTransferTokenFromMaliciousContract() {

    var txResult = executeTransaction(
        "../transactions/generic_transfer_with_address.cdc",
        [0.1, admin.address, admin.address, "MaliciousToken"],
        recipient
    )
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "The Vault that was withdrawn to transfer is not the type that was requested!"
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/scripts/get_vault_supply_view.cdc

```
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "FungibleToken"
import "ViewResolver"

/// Gets the total supply of the vault's token directly from the vault

access(all) fun main(address: Address): UFix64 {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the ExampleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(vaultData.metadataPath.toString())
                .concat(". Make sure you are querying an address that has an ExampleToken Vault set up properly."))

    let ftSupply = vaultRef.resolveView(Type<FungibleTokenMetadataViews.TotalSupply>())!

    let supplyView = ftSupply as! FungibleTokenMetadataViews.TotalSupply

    return supplyView.supply
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/changesets/changesets/blob/main/docs/common-questions.md

# Common Questions

A quick list of common questions you might want answered to understand what changesets is doing, without going into minutiae or workflow.

## Changesets are automatically generated

Changesets are generated by the `yarn changeset` or `npx @changesets/cli` command. As long as you are following a changeset release flow, you shouldn't have any problems.

## Each changeset is its own file

We use random human readable names by default for these files to avoid collisions when generating them, but there's no harm that will come from renaming them.

## Changesets are automatically removed

When `changeset version` or equivalent command is run, all the changeset files are removed. This is so we only ever use a changeset once. This makes the `.changeset` folder a very bad place to store any other information.

## Changesets are markdown files with YAML front matter

The two parts of the file are for different purposes. You should feel free to edit both parts as much as you want.

- The markdown text is a summary of the changes that will be prepended to your changelog when you next run your version command.
- The YAML front matter describes what should be versioned by the version command

## I want to edit the summary or package bump types - is it safe to do that?

Editing the summary or package bump types is completely safe. You can even write changesets without the command if you want.

## Can I manually delete changesets?

You can, but you should be aware this will remove the intent to release communicated by the changeset, and should be done with caution.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/setup_account_from_address.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"

#interaction (
  version: "1.0.0",
	title: "Generic FT Transfer with Contract Address and Name",
	description: "Transfer any Fungible Token by providing the contract address and name",
	language: "en-US",
)

/// This transaction is what an account would run
/// to set itself up to manage fungible tokens. This function
/// uses views to know where to set up the vault
/// in storage and to create the empty vault.
///
/// @param contractAddress: The address of the contract
///        that defines the tokens to initialize
/// @param contractName: The name of the contract
///        that defines the tokens to initialize. Ex: "FlowToken"

transaction(contractAddress: Address, contractName: String) {

    prepare(signer: auth(SaveValue, Capabilities) &Account) {
        // Borrow a reference to the vault stored on the passed account at the passed publicPath
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{FungibleToken}>(name: contractName)
                ?? panic("Could not borrow FungibleToken reference to the contract. Make sure the provided contract name ("
                          .concat(contractName).concat(") and address (").concat(contractAddress.toString()).concat(") are correct!"))

        // Use that reference to retrieve the FTView 
        let ftVaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ".concat(contractName)
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Create a new empty vault using the createEmptyVault function inside the FTVaultData
        let emptyVault <-ftVaultData.createEmptyVault()

        // Save it to the account
        signer.storage.save(<-emptyVault, to: ftVaultData.storagePath)
        
        // Create a public capability for the vault which includes the .Resolver interface
        let vaultCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(ftVaultData.storagePath)
        signer.capabilities.publish(vaultCap, at: ftVaultData.metadataPath)

        // Create a public capability for the vault exposing the receiver interface
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(ftVaultData.storagePath)
        signer.capabilities.publish(receiverCap, at: ftVaultData.receiverPath)

    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/scripts/example_token_vault_display_strict_equal.cdc

```
import "FungibleTokenMetadataViews"
import "MetadataViews"
import "ViewResolver"
import "ExampleToken"

/// Test helper script to validate ExampleToken serves FTDisplay as expected
///
access(all) fun main(address: Address): Bool {
    let account = getAccount(address)

    let expected = FungibleTokenMetadataViews.FTDisplay(
            name: "Example Fungible Token",
            symbol: "EFT",
            description: "This fungible token is used as an example to help you develop your next FT #onFlow.",
            externalURL: MetadataViews.ExternalURL("https://example-ft.onflow.org"),
            logos: MetadataViews.Medias([
                MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )]
            ),
            socials: {
                "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
            }
        )

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get vault data view for the contract")

    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the vault resolver")

    let actual = FungibleTokenMetadataViews.getFTDisplay(vaultRef)
        ?? panic("Token does not implement FTDisplay view")

    assert(actual.logos.items.length == expected.logos.items.length, message: "Medias length mismatch")

    let expectedLogoMedia = expected.logos.items[0]
    let actualLogoMedia = actual.logos.items[0]
    return expected.name == actual.name && expected.symbol == actual.symbol &&
        expected.description == actual.description && expected.externalURL.url == actual.externalURL.url && 
        expectedLogoMedia.file.uri() == actualLogoMedia.file.uri() && expectedLogoMedia.mediaType == actualLogoMedia.mediaType
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/batch_add_vault_wrapper_capabilities.cdc

```
import "FungibleTokenSwitchboard"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to add several capabilities that point
/// to fungible token vaults of a different `Type` and belong to a certain `Address`, to their switchboard resource.
///
transaction (address: Address) {

    let vaultPaths: [PublicPath]
    let vaultTypes: [Type]
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Store the Example Token receiver's public path in the array of public 
        // paths that will be passed to the switchboard method
        self.vaultPaths = []
        self.vaultPaths.append(vaultData.receiverPath)

        // Store the Example Token's type in the array of types that will be passed 
        // to the switchboard method
        self.vaultTypes = []
        self.vaultTypes.append(Type<@ExampleToken.Vault>())
      
        // Get a reference to the signers switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>(
                from: FungibleTokenSwitchboard.StoragePath)
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))
    
    }

    execute {

        // Add the capability(ies) to the switchboard using addNewVaultWrappersByPath
        self.switchboardRef.addNewVaultWrappersByPath(
            paths: self.vaultPaths, 
            types: self.vaultTypes,
            address: address
        )

    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/CONTRIBUTING.md

# Contributing to the Fungible Token Standard

The following is a set of guidelines for contributing to the Flow fungible token standard. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request.

#### Table Of Contents

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Pull Requests](#pull-requests)

[Styleguides](#styleguides)

- [Git Commit Messages](#git-commit-messages)

[Additional Notes](#additional-notes)


## How Can I Contribute?

You are free to contribute however you want! You can submit a bug report in an issue, suggest an enhancment, or even just make a PR for us to review. We just ask that you are clear in your communication and documentation of all your work so we can understand how you are trying to help.

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported. If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible. When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include screenshots and animated GIFs** which show you following the described steps and clearly demonstrate the problem. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

- **What's the name and version of the OS you're using**?
- **What's the name and version of the flow-cli that you are using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**. Include copy/pasteable snippets which you use in those examples, as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Include screenshots and animated GIFs**. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.
- **Explain why this enhancement would be useful** to be included in the standard.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

Before contributing, make sure to examine the project to get familiar with the patterns and style already being used.

### Git Commit Messages

- Use the present tense ("Add feature" not "Added feature")
- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
- Limit the first line to 72 characters or less
- Reference issues and pull requests liberally after the first line


### Additional Notes

Thank you for your interest in contributing to the Flow Token Standards!




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/setup_royalty_account_by_paths.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "FlowToken"
import "FiatToken"


/// This transaction is a template for a transaction that could be used by 
/// anyone fully setup an account for receiving both Flow and USDC tokens at the same
/// public path (for instance the royalties /public/GenericFTReceiver path)
/// Using the addNewVaultWrappersByPath switchboard method allows anyone to use
/// capability wrappers such as TokenForwarders instead of the actual token vault.

transaction (address: Address) {

    let vaultPaths: [PublicPath]
    let vaultTypes: [Type]    
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) Account) {

        // Prepare the paths and types arrays with the Flow and USDC tokens data
        self.vaultPaths = []
        self.vaultPaths.append(/public/flowTokenReceiver)
        self.vaultPaths.append(FiatToken.VaultReceiverPubPath)
        self.vaultTypes = []
        self.vaultTypes.append(Type<@FlowToken.Vault>())
        self.vaultTypes.append(Type<@FiatToken.Vault>())

        // Check if the account already has a USDC Vault
        if signer.storage.borrow<&FiatToken.Vault>(from: FiatToken.VaultStoragePath) == nil {
            // If not, create a new USDC Vault resource and put it into storage
            signer.storage.save(<-FiatToken.createEmptyVault(vaultType: Type<@FiatToken.Vault>()), 
                                                      to: FiatToken.VaultStoragePath)
        }

        // Check if the receiver capability is linked on the USDC receiver path
        if !signer.capabilities.get<&{FungibleToken.Receiver}>
                                           (FiatToken.VaultReceiverPubPath)!.check() {
            // if it's not, create a public capability to the USDC vault
            let tokenCap = signer.capabilities.storage.issue<&FiatToken.Vault>(FiatToken.VaultStoragePath)
            signer.capabilities.publish(tokenCap, at: FiatToken.VaultReceiverPubPath)
            let receiverCap = signer.capabilities.storage.issue<&FiatToken.Vault>(FiatToken.VaultStoragePath)
            signer.capabilities.publish(receiverCap, at: FiatToken.VaultBalancePubPath)
        }
        self.fiatTokenVaultCapability = signer.capabilities.get<&{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)

        // Check if the account already has a Switchboard resource
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>
                                (from: FungibleTokenSwitchboard.StoragePath) == nil {
            // If not, create a new Switchboard resource and put it into storage
            signer.storage.save(<- FungibleTokenSwitchboard.createSwitchboard(), 
                                            to: FungibleTokenSwitchboard.StoragePath)
        }
        // Check if the receiver capability is linked on the receiver path
        if !signer.capabilities.get
                      <&FungibleTokenSwitchboard.Switchboard>
                              (FungibleTokenSwitchboard.ReceiverPublicPath)!.check() {
            // if it's not, create a public capability to the Switchboard 
            let receiverCap = signer.capabilities.storage.issue<&FungibleTokenSwitchboard.Switchboard>(FungibleTokenSwitchboard.StoragePath)
            signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)
        }
        // Check if the SwitchboardPublic and ft receiver capabilities are linked on
        // the switchboard public path
        if !signer.capabilities.get<
        &FungibleTokenSwitchboard.Switchboard
                                       >(FungibleTokenSwitchboard.ReceiverPublicPath)!
                                                                           .check() {
            // if it's not, create a public capability to the Switchboard
            let switchboardReceiverCap = signer.capabilities.storage.issue<
            &FungibleTokenSwitchboard.Switchboard
                                               >(FungibleTokenSwitchboard.StoragePath)
            signer.capabilities.publish(switchboardReceiverCap, at: FungibleTokenSwitchboard.PublicPath)
        }
        // Get a reference to the switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>
                                         (from: FungibleTokenSwitchboard.StoragePath) 
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))
    }

    execute {

      // Add the capabilities to the switchboard using addNewVaultWrappersByPath
      self.switchboardRef.addNewVaultWrappersByPath(paths: self.vaultPaths, 
                                            types: self.vaultTypes, address: address)

    }

}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/generic_transfer_with_paths.cdc

```
import "FungibleToken"

#interaction (
  version: "1.0.0",
	title: "Generic FT Transfer with Paths",
	description: "Transfer any Fungible Token by providing the paths for the source Vault and destination Vault",
	language: "en-US",
)

/// Can pass in any storage path and receiver path identifier instead of just the default.
/// This lets you choose the token you want to send as well the capability you want to send it to.
///
/// Any token path can be passed as an argument here, so wallets should
/// should check argument values to make sure the intended token path is passed in
///
/// @param amount: The amount of tokens to transfer
/// @param to: The address to transfer the tokens to
/// @param senderPathIdentifier: The string identifier of the storage path
///        where the tokens should be withdrawn from
/// @param receiverPathIdentifier: The string identifier of the public path
///        where the tokens should be deposited to
///
transaction(amount: UFix64, to: Address, senderPathIdentifier: String, receiverPathIdentifier: String) {

    // The Vault resource that holds the tokens that are being transferred
    let tempVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        let storagePath = StoragePath(identifier: senderPathIdentifier)
            ?? panic("Could not construct a storage path from the provided path identifier string.")

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: storagePath)
			?? panic("The signer does not store a FungibleToken.Provider object at the path "
                .concat(storagePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

        self.tempVault <- vaultRef.withdraw(amount: amount)

        assert(
            self.tempVault.balance == amount,
            message: "Error: The Vault to transfer does not have the balance that was requested!"
        )
    }

    execute {
        let publicPath = PublicPath(identifier: receiverPathIdentifier)
            ?? panic("Could not construct a public path from the provided path identifier string")

        let recipient = getAccount(to)
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(publicPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(to.toString()).concat(" at path ").concat(publicPath.toString())
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))

        // Transfer tokens from the signer's stored vault to the receiver capability
        receiverRef.deposit(from: <-self.tempVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/scripts/get_vault_display.cdc

```
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "FungibleToken"
import "ViewResolver"

access(all) fun main(address: Address): FungibleTokenMetadataViews.FTDisplay {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the ExampleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(vaultData.metadataPath.toString())
                .concat(". Make sure you are querying an address that has an ExampleToken Vault set up properly."))

    let ftDisplay = FungibleTokenMetadataViews.getFTDisplay(vaultRef)
        ?? panic("Token does not implement FTDisplay view")

    return ftDisplay
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/scripts/get_vault_display.cdc

```
// This script checks the FTDisplay view from ExampleToken
// is the expected one. This is merely used in testing.

import "ExampleToken"
import "FungibleTokenMetadataViews"
import "MetadataViews"
import "ViewResolver"

access(all) fun main(address: Address): FungibleTokenMetadataViews.FTDisplay {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get vault data view for the contract")
    
    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow Balance reference to the Vault")

    let ftDisplay = FungibleTokenMetadataViews.getFTDisplay(vaultRef)
        ?? panic("Token does not implement FTDisplay view")

    return ftDisplay
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/.github/ISSUE_TEMPLATE.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature, SC-Eng
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/scripts/get_views.cdc

```
// This script checks the supported views from ExampleToken
// are the expected ones. This is merely used in testing.

import "MetadataViews"
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "FungibleToken"

access(all) fun main(address: Address): [Type] {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))
    
    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the ExampleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(vaultData.metadataPath.toString())
                .concat(". Make sure you are querying an address that has an ExampleToken Vault set up properly."))

    return vaultRef.getViews()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/scripts/get_vault_data.cdc

```
// This script checks the FTVaultData view from ExampleToken
// is the expected one. This is merely used in testing.

import "ExampleToken"
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "MetadataViews"

access(all) fun main(address: Address): Bool {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get vault data view for the contract")

    // FungibleTokenMetadataViews.FTVaultData cannot be returned as
    // a script result, because of the createEmptyVault() function.
    // So we perform the assertions here.
    assert(Type<&ExampleToken.Vault>() == vaultData.receiverLinkedType)
    assert(Type<&ExampleToken.Vault>() == vaultData.metadataLinkedType)
    let vault <- vaultData.createEmptyVault()
    let vaultIsEmpty = vault.balance == 0.0
    assert(vaultIsEmpty)

    destroy vault

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/test/MaliciousToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"
import "ExampleToken"

/// This is a contract that returns metadata for a different token
/// type to try to get a user who is transferring tokens
/// via the generic transactions to transfer the wrong tokens

access(all) contract MaliciousToken: FungibleToken {

    /// The event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64, type: String)

    /// Total supply of MaliciousTokens in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath
    access(all) let AdminStoragePath: StoragePath

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/exampleTokenVault,
                    receiverPath: /public/exampleTokenReceiver,
                    metadataPath: /public/exampleTokenVault,
                    receiverLinkedType: Type<&ExampleToken.Vault>(),
                    metadataLinkedType: Type<&ExampleToken.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-MaliciousToken.createEmptyVault(vaultType: Type<@MaliciousToken.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: MaliciousToken.totalSupply
                )
        }
        return nil
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                MaliciousToken.totalSupply = MaliciousToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        /// In fungible tokens, there are no specific views for specific vaults,
        /// So we can route calls to view functions to the contract views functions
        access(all) view fun getViews(): [Type] {
            return MaliciousToken.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return MaliciousToken.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @MaliciousToken.Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @MaliciousToken.Vault
            self.balance = self.balance + vault.balance
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @MaliciousToken.Vault {
            return <-create Vault(balance: 0.0)
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    access(all) resource Minter {
        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        access(all) fun mintTokens(amount: UFix64): @MaliciousToken.Vault {
            MaliciousToken.totalSupply = MaliciousToken.totalSupply + amount
            let vault <-create Vault(balance: amount)
            emit TokensMinted(amount: amount, type: vault.getType().identifier)
            return <-vault
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @MaliciousToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 1000.0

        self.VaultStoragePath = /storage/maliciousTokenVault
        self.VaultPublicPath = /public/maliciousTokenVault
        self.ReceiverPublicPath = /public/maliciousTokenReceiver
        self.AdminStoragePath = /storage/maliciousTokenAdmin 

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)
        emit TokensMinted(amount: vault.balance, type: vault.getType().identifier)

        // Create a public capability to the stored Vault that exposes
        // the `deposit` method and getAcceptedTypes method through the `Receiver` interface
        // and the `balance` method through the `Balance` interface
        //
        let maliciousTokenCap = self.account.capabilities.storage.issue<&MaliciousToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(maliciousTokenCap, at: self.VaultPublicPath)
        let receiverCap = self.account.capabilities.storage.issue<&MaliciousToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(receiverCap, at: self.ReceiverPublicPath)

        self.account.storage.save(<-vault, to: /storage/maliciousTokenVault)

        let admin <- create Minter()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/SECURITY.md


# Responsible Disclosure Policy

Flow was built from the ground up with security in mind. Our code, infrastructure, and development methodology helps us keep our users safe.

We really appreciate the community's help. Responsible disclosure of vulnerabilities helps to maintain the security and privacy of everyone.

If you care about making a difference, please follow the guidelines below.

# **Guidelines For Responsible Disclosure**

We ask that all researchers adhere to these guidelines [here](https://docs.onflow.org/bounties/responsible-disclosure/)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance.cdc

```
// This script reads the balance field
// of an account's ExampleToken Balance

import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

access(all) fun main(address: Address): UFix64 {
    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

    return getAccount(address).capabilities.borrow<&{FungibleToken.Balance}>(
            vaultData.metadataPath
        )?.balance
        ?? panic("Could not borrow a balance reference to the FungibleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(vaultData.metadataPath.toString())
                .concat(". Make sure you are querying an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/privateForwarder/create_account_private_forwarder.cdc

```
import "FungibleToken"
import "ExampleToken"
import "PrivateReceiverForwarder"
import "FungibleTokenMetadataViews"

/// This transaction is used to create a user's Flow account with a private forwarder

transaction {

    /// New Account that will hold the forwarder
    let newAccount: auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account

    prepare(signer: auth(BorrowValue) &Account) {
        self.newAccount = Account(payer: signer)
    }

    execute {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Save a regular vault to the new account
        self.newAccount.storage.save(<-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>()), to: vaultData.storagePath)

        // Issue a Receiver Capability targetting the ExampleToken Vault
        let receiverCapability = self.newAccount.capabilities.storage.issue<&{FungibleToken.Receiver}>(
            vaultData.storagePath
        )

        // Use the private receiver to create a private forwarder
        let forwarder <- PrivateReceiverForwarder.createNewForwarder(recipient: receiverCapability)

        // Save the private forwarder to account storage
        self.newAccount.storage.save(<-forwarder, to: PrivateReceiverForwarder.PrivateReceiverStoragePath)

        // Issue a Capability to the Forwarder resource
        let forwarderCap = self.newAccount.capabilities.storage.issue<&PrivateReceiverForwarder.Forwarder>(
                PrivateReceiverForwarder.PrivateReceiverStoragePath
            )
        // Publish the Capability to the Forwarder resource
        self.newAccount.capabilities.publish(
            forwarderCap,
            at: PrivateReceiverForwarder.PrivateReceiverPublicPath
        )

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

access(all) contract FlowToken: FungibleToken {

    // Total supply of Flow tokens in existence
    access(all) var totalSupply: UFix64

    // Event that is emitted when tokens are withdrawn from a Vault
    access(all) event TokensWithdrawn(amount: UFix64, from: Address?)

    // Event that is emitted when tokens are deposited to a Vault
    access(all) event TokensDeposited(amount: UFix64, to: Address?)

    // Event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64)

    // Event that is emitted when a new minter resource is created
    access(all) event MinterCreated(allowedAmount: UFix64)

    // Event that is emitted when a new burner resource is created
    access(all) event BurnerCreated()

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    access(all) resource Vault: FungibleToken.Vault {

        // holds the balance of a users tokens
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                FlowToken.totalSupply = FlowToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return {self.getType(): true}
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            if (type == self.getType()) { return true } else { return false }
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault} {
            self.balance = self.balance - amount

            // If the owner is the staking account, do not emit the contract defined events
            // this is to help with the performance of the epoch transition operations
            // Either way, event listeners should be paying attention to the 
            // FungibleToken.Withdrawn events anyway because those contain
            // much more comprehensive metadata
            // Additionally, these events will eventually be removed from this contract completely
            // in favor of the FungibleToken events
            if let address = self.owner?.address {
                if address != 0xf8d6e0586b0a20c7 &&
                   address != 0xf4527793ee68aede &&
                   address != 0x9eca2b38b18b5dfe &&
                   address != 0x8624b52f9ddcd04a 
                {
                    emit TokensWithdrawn(amount: amount, from: address)
                }
            } else {
                emit TokensWithdrawn(amount: amount, from: nil)
            }
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @FlowToken.Vault
            self.balance = self.balance + vault.balance

            // If the owner is the staking account, do not emit the contract defined events
            // this is to help with the performance of the epoch transition operations
            // Either way, event listeners should be paying attention to the 
            // FungibleToken.Deposited events anyway because those contain
            // much more comprehensive metadata
            // Additionally, these events will eventually be removed from this contract completely
            // in favor of the FungibleToken events
            if let address = self.owner?.address {
                if address != 0xf8d6e0586b0a20c7 &&
                   address != 0xf4527793ee68aede &&
                   address != 0x9eca2b38b18b5dfe &&
                   address != 0x8624b52f9ddcd04a 
                {
                    emit TokensDeposited(amount: vault.balance, to: address)
                }
            } else {
                emit TokensDeposited(amount: vault.balance, to: nil)
            }
            vault.balance = 0.0
            destroy vault
        }

        /// Get all the Metadata Views implemented by FlowToken
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        access(all) view fun getViews(): [Type]{
            return FlowToken.getContractViews(resourceType: nil)
        }

        /// Get a Metadata View from FlowToken
        ///
        /// @param view: The Type of the desired view.
        /// @return A structure representing the requested view.
        ///
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return FlowToken.resolveContractView(resourceType: nil, viewType: view)
        }

        access(all) fun createEmptyVault(): @{FungibleToken.Vault} {
            return <-create Vault(balance: 0.0)
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    access(all) fun createEmptyVault(vaultType: Type): @FlowToken.Vault {
        return <-create Vault(balance: 0.0)
    }

    /// Gets a list of the metadata views that this contract supports
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [Type<FungibleTokenMetadataViews.FTView>(),
                Type<FungibleTokenMetadataViews.FTDisplay>(),
                Type<FungibleTokenMetadataViews.FTVaultData>(),
                Type<FungibleTokenMetadataViews.TotalSupply>()]
    }

    /// Get a Metadata View from FlowToken
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: FlowToken.getLogoURI()
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "FLOW Network Token",
                    symbol: "FLOW",
                    description: "FLOW is the native token for the Flow blockchain. It is required for securing the network, transaction fees, storage fees, staking, FLIP voting and may be used by applications built on the Flow Blockchain",
                    externalURL: MetadataViews.ExternalURL("https://flow.com"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                let vaultRef = FlowToken.account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
			        ?? panic("Could not borrow reference to the contract's Vault!")
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/flowTokenVault,
                    receiverPath: /public/flowTokenReceiver,
                    metadataPath: /public/flowTokenBalance,
                    receiverLinkedType: Type<&{FungibleToken.Receiver, FungibleToken.Vault}>(),
                    metadataLinkedType: Type<&{FungibleToken.Balance, FungibleToken.Vault}>(),
                    createEmptyVaultFunction: (fun (): @{FungibleToken.Vault} {
                        return <-vaultRef.createEmptyVault()
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(totalSupply: FlowToken.totalSupply)
        }
        return nil
    }

    access(all) resource Administrator {
        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        access(all) fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    access(all) resource Minter {

        // the amount of tokens that the minter is allowed to mint
        access(all) var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        access(all) fun mintTokens(amount: UFix64): @FlowToken.Vault {
            pre {
                amount > UFix64(0): "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            FlowToken.totalSupply = FlowToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    /// Gets the Flow Logo XML URI from storage
    access(all) view fun getLogoURI(): String {
        return FlowToken.account.storage.copy<String>(from: /storage/flowTokenLogoURI) ?? ""
    }

    init() {
        self.totalSupply = 0.0

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)

        self.account.storage.save(<-vault, to: /storage/flowTokenVault)

        // Create a public capability to the stored Vault that only exposes
        // the `deposit` method through the `Receiver` interface
        //
        let receiverCapability = self.account.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)
        self.account.capabilities.publish(receiverCapability, at: /public/flowTokenReceiver)

        // Create a public capability to the stored Vault that only exposes
        // the `balance` field through the `Balance` interface
        //
        let balanceCapability = self.account.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)
        self.account.capabilities.publish(balanceCapability, at: /public/flowTokenBalance)

        let admin <- create Administrator()
        self.account.storage.save(<-admin, to: /storage/flowTokenAdmin)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc

```
/**

# The Flow Fungible Token standard

## `FungibleToken` contract

If a users wants to deploy a new token contract, their contract
needs to implement the FungibleToken interface and their tokens
need to implement the interfaces defined in this contract.

/// Contributors (please add to this list if you contribute!):
/// - Joshua Hannan - https://github.com/joshuahannan
/// - Bastian Müller - https://twitter.com/turbolent
/// - Dete Shirley - https://twitter.com/dete73
/// - Bjarte Karlsen - https://twitter.com/0xBjartek
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Jonny - https://github.com/dryruner
///
/// Repo reference: https://github.com/onflow/flow-ft

## `Vault` resource interface

Each fungible token resource type needs to implement the `Vault` resource interface.

## `Provider`, `Receiver`, and `Balance` resource interfaces

These interfaces declare pre-conditions and post-conditions that restrict
the execution of the functions in the Vault.

It gives users the ability to make custom resources that implement
these interfaces to do various things with the tokens.
For example, a faucet can be implemented by conforming
to the Provider interface.

*/

import "ViewResolver"
import "Burner"

/// FungibleToken
///
/// Fungible Token implementations should implement the fungible token
/// interface.
access(all) contract interface FungibleToken: ViewResolver {

    // An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// The event that is emitted when tokens are withdrawn
    /// from any Vault that implements the `Vault` interface
    access(all) event Withdrawn(type: String,
                                amount: UFix64,
                                from: Address?,
                                fromUUID: UInt64,
                                withdrawnUUID: UInt64,
                                balanceAfter: UFix64)

    /// The event that is emitted when tokens are deposited to
    /// any Vault that implements the `Vault` interface
    access(all) event Deposited(type: String,
                                amount: UFix64,
                                to: Address?,
                                toUUID: UInt64,
                                depositedUUID: UInt64,
                                balanceAfter: UFix64)

    /// Event that is emitted when the global `Burner.burn()` method
    /// is called with a non-zero balance
    access(all) event Burned(type: String, amount: UFix64, fromUUID: UInt64)

    /// Balance
    ///
    /// The interface that provides a standard field
    /// for representing balance
    ///
    access(all) resource interface Balance {
        access(all) var balance: UFix64
    }

    /// Provider
    ///
    /// The interface that enforces the requirements for withdrawing
    /// tokens from the implementing type.
    ///
    /// It does not enforce requirements on `balance` here,
    /// because it leaves open the possibility of creating custom providers
    /// that do not necessarily need their own balance.
    ///
    access(all) resource interface Provider {

        /// Function to ask a provider if a specific amount of tokens
        /// is available to be withdrawn
        /// This could be useful to avoid panicing when calling withdraw
        /// when the balance is unknown
        /// Additionally, if the provider is pulling from multiple vaults
        /// it only needs to check some of the vaults until the desired amount
        /// is reached, potentially helping with performance.
        ///
        /// @param amount the amount of tokens requested to potentially withdraw
        /// @return Bool Whether or not this amount is available to withdraw
        /// 
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool

        /// withdraw subtracts tokens from the implementing resource
        /// and returns a Vault with the removed tokens.
        ///
        /// The function's access level is `access(Withdraw)`
        /// So in order to access it, one would either need the object itself
        /// or an entitled reference with `Withdraw`.
        ///
        /// @param amount the amount of tokens to withdraw from the resource
        /// @return The Vault with the withdrawn tokens
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    "FungibleToken.Provider.withdraw: Cannot withdraw tokens!"
                    .concat("The balance of the withdrawn tokens (").concat(result.balance.toString())
                    .concat(") is not equal to the amount requested to be withdrawn (")
                    .concat(amount.toString()).concat(")")
            }
        }
    }

    /// Receiver
    ///
    /// The interface that enforces the requirements for depositing
    /// tokens into the implementing type.
    ///
    /// We do not include a condition that checks the balance because
    /// we want to give users the ability to make custom receivers that
    /// can do custom things with the tokens, like split them up and
    /// send them to different places.
    ///
    access(all) resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        /// @param from the Vault that contains the tokens to deposit
        ///
        access(all) fun deposit(from: @{Vault})

        /// getSupportedVaultTypes returns a dictionary of Vault types
        /// and whether the type is currently supported by this Receiver
        ///
        /// @return {Type: Bool} A dictionary that indicates the supported types
        ///                      If a type is not supported, it should be `nil`, not false
        ///
        access(all) view fun getSupportedVaultTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the Receiver
        /// A vault that can accept any type should just return true by default
        ///
        /// @param type The type to query about
        /// @return Bool Whether or not the vault type is supported
        ///
        access(all) view fun isSupportedVaultType(type: Type): Bool
    }

    /// Vault
    /// Conforms to all other interfaces so that implementations
    /// only have to conform to `Vault`
    ///
    access(all) resource interface Vault: Receiver, Provider, Balance, ViewResolver.Resolver, Burner.Burnable {

        /// Field that tracks the balance of a vault
        access(all) var balance: UFix64

        /// Called when a fungible token is burned via the `Burner.burn()` method
        /// Implementations can do any bookkeeping or emit any events
        /// that should be emitted when a vault is destroyed.
        /// Many implementations will want to update the token's total supply
        /// to reflect that the tokens have been burned and removed from the supply.
        /// Implementations also need to set the balance to zero before the end of the function
        /// This is to prevent vault owners from spamming fake Burned events.
        access(contract) fun burnCallback() {
            pre {
                emit Burned(type: self.getType().identifier, amount: self.balance, fromUUID: self.uuid)
            }
            post {
                self.balance == 0.0:
                    "FungibleToken.Vault.burnCallback: Cannot burn this Vault with Burner.burn(). "
                    .concat("The balance must be set to zero during the burnCallback method so that it cannot be spammed.")
            }
            self.balance = 0.0
        }

        /// getSupportedVaultTypes
        /// The default implementation is included here because vaults are expected
        /// to only accepted their own type, so they have no need to provide an implementation
        /// for this function
        ///
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            // Below check is implemented to make sure that run-time type would
            // only get returned when the parent resource conforms with `FungibleToken.Vault`. 
            if self.getType().isSubtype(of: Type<@{FungibleToken.Vault}>()) {
                return {self.getType(): true}
            } else {
                // Return an empty dictionary as the default value for resource who don't
                // implement `FungibleToken.Vault`, such as `FungibleTokenSwitchboard`, `TokenForwarder` etc.
                return {}
            }
        }

        /// Checks if the given type is supported by this Vault
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// withdraw subtracts `amount` from the Vault's balance
        /// and returns a new Vault with the subtracted balance
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            pre {
                self.balance >= amount:
                    "FungibleToken.Vault.withdraw: Cannot withdraw tokens! "
                    .concat("The amount requested to be withdrawn (").concat(amount.toString())
                    .concat(") is greater than the balance of the Vault (")
                    .concat(self.balance.toString()).concat(").")
            }
            post {
                result.getType() == self.getType(): 
                    "FungibleToken.Vault.withdraw: Cannot withdraw tokens! "
                    .concat("The withdraw method tried to return an incompatible Vault type <")
                    .concat(result.getType().identifier).concat(">. ")
                    .concat("It must return a Vault with the same type as self <")
                    .concat(self.getType().identifier).concat(">.")

                // use the special function `before` to get the value of the `balance` field
                // at the beginning of the function execution
                //
                self.balance == before(self.balance) - amount:
                    "FungibleToken.Vault.withdraw: Cannot withdraw tokens! " 
                    .concat("The sender's balance after the withdrawal (")
                    .concat(self.balance.toString())
                    .concat(") must be the difference of the previous balance (").concat(before(self.balance.toString()))
                    .concat(") and the amount withdrawn (").concat(amount.toString()).concat(")")

                emit Withdrawn(
                        type: result.getType().identifier,
                        amount: amount,
                        from: self.owner?.address,
                        fromUUID: self.uuid,
                        withdrawnUUID: result.uuid,
                        balanceAfter: self.balance
                )
            }
        }

        /// deposit takes a Vault and adds its balance to the balance of this Vault
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            // Assert that the concrete type of the deposited vault is the same
            // as the vault that is accepting the deposit
            pre {
                from.isInstance(self.getType()): 
                    "FungibleToken.Vault.deposit: Cannot deposit tokens! "
                    .concat("The type of the deposited tokens <")
                    .concat(from.getType().identifier)
                    .concat("> has to be the same type as the Vault being deposited into <")
                    .concat(self.getType().identifier)
                    .concat(">. Check that you are withdrawing and depositing to the correct paths in the sender and receiver accounts ")
                    .concat("and that those paths hold the same Vault types.")
            }
            post {
                emit Deposited(
                        type: before(from.getType().identifier),
                        amount: before(from.balance),
                        to: self.owner?.address,
                        toUUID: self.uuid,
                        depositedUUID: before(from.uuid),
                        balanceAfter: self.balance
                )
                self.balance == before(self.balance) + before(from.balance):
                    "FungibleToken.Vault.deposit: Cannot deposit tokens! " 
                    .concat("The receiver's balance after the deposit (")
                    .concat(self.balance.toString())
                    .concat(") must be the sum of the previous balance (").concat(before(self.balance.toString()))
                    .concat(") and the amount deposited (").concat(before(from.balance).toString()).concat(")")
            }
        }

        /// createEmptyVault allows any user to create a new Vault that has a zero balance
        ///
        /// @return A Vault of the same type that has a balance of zero
        access(all) fun createEmptyVault(): @{Vault} {
            post {
                result.balance == 0.0:
                    "FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! "
                    .concat("The newly created Vault must have zero balance but it has a balance of ")
                    .concat(result.balance.toString())

                result.getType() == self.getType():
                    "FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! "
                    .concat("The type of the new Vault <")
                    .concat(result.getType().identifier)
                    .concat("> has to be the same type as the Vault that created it <")
                    .concat(self.getType().identifier)
                    .concat(">.")
            }
        }
    }

    /// createEmptyVault allows any user to create a new Vault that has a zero balance
    ///
    /// @return A Vault of the requested type that has a balance of zero
    access(all) fun createEmptyVault(vaultType: Type): @{FungibleToken.Vault} {
        post {
            result.balance == 0.0:
                "FungibleToken.createEmptyVault: Empty Vault creation failed! "
                .concat("The newly created Vault must have zero balance but it has a balance of (")
                .concat(result.balance.toString()).concat(")")

            result.getType() == vaultType:
                "FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! "
                .concat("The type of the new Vault <")
                .concat(result.getType().identifier)
                .concat("> has to be the same as the type that was requested <")
                .concat(vaultType.identifier)
                .concat(">.")
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/privateForwarder/deploy_forwarder_contract.cdc

```
/// Deploys the TokenForwarding contract with the specified init parameters

transaction(contractName: String,
            code: [UInt8],
            senderStoragePath: StoragePath,
            storagePath: StoragePath,
            publicPath: PublicPath) {

  prepare(signer: auth(AddContract) &Account) {

    signer.contracts.add(name: contractName, code: code, senderStoragePath, storagePath, publicPath)

  }
}
 

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/.changeset/README.md

# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/remove_vault_capability.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "ExampleToken"

/// This transaction is a template for a transaction that could be used by anyone to remove fungible token vault
/// capability from their switchboard resource
///
transaction(path: PublicPath) {

    let exampleTokenVaultCapabilty: Capability<&{FungibleToken.Receiver}>
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue) &Account) {

        // Get the capability from the signer's account
        self.exampleTokenVaultCapabilty = signer.capabilities.get<&{FungibleToken.Receiver}>(path)

        // Get a reference to the signers switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>(
                from: FungibleTokenSwitchboard.StoragePath)
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

    }

    execute {

      // Remove the capability from the switchboard using the .removeVault() method
      self.switchboardRef.removeVault(capability: self.exampleTokenVaultCapabilty)

    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md

---
status: implemented
flip: 636
authors: Bjarte Karslen (bjartek@find.xyz), Deniz Mert Edincik (Deniz@edincik.com), Brian Dilley (briandilley@briandilley.com)
sponsor: Peter Siemens (peter@dapperlabs.com)
updated: 2021-12-06
---

# FLIP 636: Non-Fungible Token Metadata

## Objective

This proposal will make it possible to create generic solutions that will interoperate
through views and not hard-coded NFT types. Want to create a marketplace? If you know
how to display a certain Type that defines a sellable Item, you can do so. And it will
work for any contract and any resource, not just a single one.

## Motivation

Currently there is no standard for defining NFT/resource metadata. At best, most implementations
employ a simple `{String: AnyStruct}` dictionary. Due to the various methods that NFT
authors use, it’s hard / impossible to create applications that use NFTs whether it be
for something as simple as viewing them or as complex as integrating them into a game
or application.

If you want to create an Auction contract on Flow today, you have to hardcode all the NFTs
you want to support. This will often lead to duplicated contracts and code and just lots
of things to maintain. This standard will enable you to create a single Auction contract
and define the Type of views you need to expose in your NFT in order to support the contract.
So it will enable a design-by-contract pattern where the creator of a contract can define
the views it requires and a NFT can tell what views they export.

All NFTs and contracts using NFTs on Flow are affected by this problem. This is most
visible in the number of contracts that Viv3 needs in order to support all their different
sellable items. With all the oncoming marketplaces/auction houses and things like that
coming to Flow, a good standard for NFTs will help everybody.

## User Benefit

We feel that a standard that authors can implement that enables easy consumption of metadata
will lead to more applications that integrate NFTs. This will make NFTs intrinsically more
useful and valuable to the end users holding the NFTs.

A user will be much more likely to transfer their NFT to other marketplaces and sell their NFT
in different ways with this solution. Without it, all marketplaces need to hardcode support
for all NFTs directly.

It will also open up the possibility to standardize on some shared structs like Royalty
and SaleItem/Auction.

Indirectly, users will benefit from the fact that Flow developers can put their development cycles to better use than integrating each new NFT contract to their platform.

## Design Proposal

The core of this proposal is to add the following interface and have the NFT resource implement it
```
pub resource interface ViewResolver {
  pub fun getViews() : [Type]
  pub fun resolveView(_ view:Type): AnyStruct?
}
```

We will also add default implementations for these methods so that no compatibility will be broken
for existing NFT solutions. The new NFT resource could look something like this:
```
pub resource NFT: INFT, ViewResolver {
    pub let id: UInt64
    pub fun getViews(): [Type] {
       return []
    }
    pub fun resolveView(_ view: Type): AnyStruct? {
        return nil
    }
}
```

We propose that all metadata be expressed in Cadence types. The `pub fun getViews(): [Type]`
method allows for discovery of the various types of metadata supported by the NFT by returning a `Type`
for each supported type of metadata. An instance of any supported type could then be retrieved by
calling the `pub fun resolveView(_ view: Type): AnyStruct?` method passing the desired type in as
an argument.

This proposal by no means precludes the use of member variable on the NFT resource itself. In fact,
ideally, all immutable data for an NFT is stored as immutable members of the NFT resource, and views
are resolved and created by accessing those immutable members.

### Supporting other resources besides NFTs

In order to support any other resource and resource collections, like marketplaces and fungible tokens, the following new interface is proposed:
```
pub resource interface ViewResolverCollection {
    pub fun borrowViewResolver(id: UInt64): &{ViewResolver}
    pub fun getIDs(): [UInt64]
}
```

This will allow any collection to be exposed as view resolvable.

For single resources that are stored as is like a fungible token or a profile contract you can just implement the `ViewResolver` interface directly.

### Basic Views

The most basic example is having `String` be a view. Think of this as `toString()` in Java or a `Stringer` implementation in Go. It is a way to view your NFT as a string.

The bigger brother of `String` would be `Display`. Here is how you could display an NFT in a wallet, marketplace or other user-facing application:
```
pub struct Display{
    pub let name: String
    pub let thumbnail: String
    pub let description: String

    // This is a field describing the source of this NFT. This could be Versus, Evolution, Chainmonsters, etc.
    pub let source: String

    init(name:String, thumbnail: String, description: String, source:String) {
        self.source=source
        self.name=name
        self.thumbnail=thumbnail
        self.description=description
    }
}
```

The data above is taken from what the [Blocto wallet](https://blocto.portto.io/) uses to display an NFT in their application.
 - Would it be wise to add some sort of link here to be able to know how to navigate to the source page for this resource?

### Other examples

For example, an NFT artwork implementation may want to allow for image data to be retrieved
as an `IPFSImage` struct:
```
struct IPFSImage {
    let url: String
    let ipfsHash: String
    let width: UInt32
    let height: UInt32
    let contentType: String
}
```

It could then be retrieved from the NFT using the following:
```
import ArtNFT from 0x01010101

let artwork = nft.resolveView(Type<ArtNFT.IPFSImage>()) as? ArtNFT.IPFSImage
```

Another suggestion for media from FIND is:
```
pub struct Media {
    pub let data: String
    pub let contentType: String
    pub let protocol: String

    init(data:String, contentType: String, protocol: String) {
        self.data=data
        self.protocol=protocol
        self.contentType=contentType
    }
}
```
Examples here are:

An image on IPFS:
data: QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4
contentType: image/jpeg
protocol: ipfs

An HTTP image:
data: https://test.find.xyz/find.png
contentType: image/jpeg
protocol: http

An on-chain image:
data: data:image/png;base64,SOMEPNGDATAURI/wD/
contentType: image/jpeg
protocol: data

The problem here is that the on-chain image can be quite large and you might not want to resolve those every time you fetch the media view. So what if we made a method on the struct that allowed you to retrieve the data/content instead?


The same NFT author may also want to expose other metadata about the artwork:
```
struct Artwork {
    let name: String
    let dateCreated: UInt64
    let medium: String
    let artistName: String
}

// ...

let artwork = nft.resolveView(Type<ArtNFT.Artwork>()) as? ArtNFT.Artwork
```

If an art piece had more than one image then they could be retrieved using an array type as such:
```
import ArtNFT from 0x01010101

// ...

let images = nft.resolveView(Type<[ArtNFT.IPFSImage]>()) as? [ArtNFT.IPFSImage]
```

Or if a more structured approach is desired the NFT author may want to create a composite struct:
```
struct ArtworkDetail {
    let artwork: Artwork
    let primaryImage: IPFSImage
    let secondaryImage: IPFSImage
}
```

Because this proposal relies on the Cadence type system, adding new view types for exposing various
types of metadata is trivial and very robust. A few examples that one might use as a view type are:

```
// an image
pub struct IPFSImage {
    pub let url: String
    pub let ipfsHash: String
    pub let width: UInt32
    pub let height: UInt32
    pub let contentType: String
}

// a video
pub struct IPFSVideo {
    pub let url: String
    pub let ipfsHash: String
    pub let width: UInt32
    pub let height: UInt32
    pub let codec: String
    pub let container: String
    pub let contentType: String
}

// a file stored on the blockchain
pub struct Mime {
    pub let type: String
    pub let bytes: [UInt8]
}

// a location on the planet
pub struct GeoPoint {
    pub let lat: UFix64
    pub let lng: UFix64
    pub let projection: String
}

// a file hosted by a web server with a hash for verifying its contents
pub struct URLWithHash {
    pub let url: String
    pub let hash: String?
    pub let hashAlgo: String?
}
```

## Drawbacks

This standard does not include any required ways to store the metadata, and therefore some of the metadata
could be dynamic, depending on how the NFTs are authored. This is a double edged sword; it allows for greater
flexibility, but also means that some of the metadata returned by an NFT’s view may not be immutable. This,
however, may be desirable. For instance, a game may allow an NFT to be used as a character in the game and
expose a view that exposes a member containing the character's health.

## Alternatives Considered

A number of alternatives were discussed [here](https://github.com/onflow/flow-nft/issues/9).

## Performance Implications

Due to the potentially dynamic nature of this proposal, the methods that return metadata views can be implemented
in any way that the NFT author sees fit which could lead to some non-performant implementations.

## Dependencies

This proposal builds on the existing NFT interface defined [here](https://github.com/onflow/flow-nft).

## Engineering Impact

Adhering to this standard will require contract authors to implement a few new methods as part of their NFT.
They will also likely need to import standard types into their contracts.

There may also need to be a committee, process, and code repository put in place for managing the standard metadata
types.

## Best Practices

NFT authors should do their best to implement as many views from the standard metadata set as appropriate for
their application.

NFT authors should document the views they support and contract creators should document the views they require.
It could be worth exploring a design-by-contract paradigm to formalize this in a forthcoming FLIP.

## Tutorials and Examples

The following examples show the flexibility of this proposal with varying implementations.

### Example 1

The Find project is going to be using metadata as lookup and index points. The project is available here:
https://github.com/findonflow/find

### Example 2

This example shows how you might implement this specification with the ability to add new view types to your NFT
contract after it has already been published through the use of a `ViewResolver` pattern.
[Gist available here](https://gist.github.com/briandilley/962e94682b7945d882fcd99702011ea4),
[Playground available here](https://play.onflow.org/a71203b9-a03a-47f9-ab70-7285fcf4c56a?type=account&id=0)

## Compatibility

Provided support for default methods on interfaces is added to Cadence, there are no backwards compatibility issues.
Short of that, NFT authors will need to add implementations for the new methods added to their contracts.

## User Impact

This feature can be rolled out with no fear of changes to the user. However documentation should be provided on how
they can change their contracts and add views.

## Related Issues

Defining how metadata stored is out of the scope of this proposal.

## Prior Art

None

## Questions and Discussion Topics

What post/pre conditions would be needed in the NFT methods (if any)?
Are the arguments strong enough?
Are more examples needed here or are the arguments strong enough?





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/scripts/get_vault_data.cdc

```
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "FungibleToken"
import "ViewResolver"

access(all) fun main(address: Address): FungibleTokenMetadataViews.FTVaultData {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

    return vaultData
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/transfer_many_accounts.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// Transfers tokens to a list of addresses specified in the `addressAmountMap` parameter

transaction(addressAmountMap: {Address: UFix64}) {

    /// FTVaultData metadata view for the token being used
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    /// The Vault resource that holds the tokens that are being transferred
    let vaultRef: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {
        self.vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Get a reference to the signer's stored vault
        self.vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: self.vaultData.storagePath)
            ?? panic("The signer does not store an ExampleToken.Vault object at the path "
                    .concat(self.vaultData.storagePath.toString())
                    .concat(". The signer must initialize their account with this vault first!"))
    }

    execute {

        for address in addressAmountMap.keys {

            // Withdraw tokens from the signer's stored vault
            let sentVault <- self.vaultRef.withdraw(amount: addressAmountMap[address]!)

            // Get the recipient's public account object
            let recipient = getAccount(address)

            // Get a reference to the recipient's Receiver
            let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)
                ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                    .concat(address.toString()).concat(" at path ").concat(self.vaultData.receiverPath.toString())
                    .concat(". Make sure you are sending to an address that has ")
                    .concat("a FungibleToken Vault set up properly at the specified path."))

            // Deposit the withdrawn tokens in the recipient's receiver
            receiverRef.deposit(from: <-sentVault)

        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/scripts/get_unsupported_view.cdc

```
// This script checks the resolveView from ExampleToken
// returns nil for unsupported view. This is merely used
// in testing.

import "ExampleToken"
import "MetadataViews"
import "FungibleToken"
import "FungibleTokenMetadataViews"

access(all) fun main(address: Address, type: Type): AnyStruct? {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get the vault data view for ExampleToken")
    
    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow Balance reference to the Vault")

    return vaultRef.resolveView(type)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/test_helpers.cdc

```
// Helper functions. All of the following were taken from
// - deploy
// - scriptExecutor
// - txExecutor
// - getErrorMessagePointer

import Test

access(all) fun deploy(_ contractName: String, _ path: String) {
    let err = Test.deployContract(
        name: contractName,
        path: path,
        arguments: [],
    )

    Test.expect(err, Test.beNil())
}

access(all) fun deployWithArgs(_ contractName: String, _ path: String, args: [AnyStruct]) {
    let err = Test.deployContract(
        name: contractName,
        path: path,
        arguments: args,
    )

    Test.expect(err, Test.beNil())
}

access(all) fun scriptExecutor(_ scriptName: String, _ arguments: [AnyStruct]): AnyStruct? {
    let scriptCode = loadCode(scriptName, "transactions/scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    if let failureError = scriptResult.error {
        panic(
            "Failed to execute the script because -:  ".concat(failureError.message)
        )
    }

    return scriptResult.returnValue
}

access(all) fun expectScriptFailure(_ scriptName: String, _ arguments: [AnyStruct]): String {
    let scriptCode = loadCode(scriptName, "transactions/scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    assert(scriptResult.error != nil, message: "script error was expected but there is no error message")
    return scriptResult.error!.message
}

access(all) fun txExecutor(_ txName: String, _ signers: [Test.TestAccount], _ arguments: [AnyStruct], _ expectedError: String?, _ expectedErrorType: ErrorType?): Bool {
    let txCode = loadCode(txName, "transactions")

    let authorizers: [Address] = []
    for signer in signers {
        authorizers.append(signer.address)
    }

    let tx = Test.Transaction(
        code: txCode,
        authorizers: authorizers,
        signers: signers,
        arguments: arguments,
    )

    let txResult = Test.executeTransaction(tx)
    if let err = txResult.error {
        if let expectedErrorMessage = expectedError {
            let ptr = getErrorMessagePointer(errorType: expectedErrorType!)
            let errMessage = err.message
            let hasEmittedCorrectMessage = contains(errMessage, expectedErrorMessage)
            let failureMessage = "Expecting - "
                .concat(expectedErrorMessage)
                .concat("\n")
                .concat("But received - ")
                .concat(err.message)
            assert(hasEmittedCorrectMessage, message: failureMessage)
            return true
        }
        panic(err.message)
    } else {
        if let expectedErrorMessage = expectedError {
            panic("Expecting error - ".concat(expectedErrorMessage).concat(". While no error triggered"))
        }
    }

    return txResult.status == Test.ResultStatus.succeeded
}

access(all) fun loadCode(_ fileName: String, _ baseDirectory: String): String {
    return Test.readFile("../".concat(baseDirectory).concat("/").concat(fileName))
}

access(all) enum ErrorType: UInt8 {
    access(all) case TX_PANIC
    access(all) case TX_ASSERT
    access(all) case TX_PRE
}

access(all) fun getErrorMessagePointer(errorType: ErrorType): Int {
    switch errorType {
        case ErrorType.TX_PANIC: return 159
        case ErrorType.TX_ASSERT: return 170
        case ErrorType.TX_PRE: return 174
        default: panic("Invalid error type")
    }
}

access(all) fun buildTypeIdentifier(_ acct: Test.TestAccount, _ contractName: String, _ suffix: String): String {
    let addrString = acct.address.toString()
    return "A.".concat(addrString.slice(from: 2, upTo: addrString.length)).concat(".").concat(contractName).concat(".").concat(suffix)
}

// Copied functions from flow-utils so we can assert on error conditions
// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/StringUtils.cdc
access(all) fun contains(_ s: String, _ substr: String): Bool {
    if let index = index(s, substr, 0) {
        return true
    }
    return false
}

// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/StringUtils.cdc
access(all) fun index(_ s: String, _ substr: String, _ startIndex: Int): Int? {
    for i in range(startIndex, s.length - substr.length + 1) {
        if s[i] == substr[0] && s.slice(from: i, upTo: i + substr.length) == substr {
            return i
        }
    }
    return nil
}

// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/ArrayUtils.cdc
access(all) fun rangeFunc(_ start: Int, _ end: Int, _ f: (fun (Int): Void)) {
    var current = start
    while current < end {
        f(current)
        current = current + 1
    }
}

access(all) fun range(_ start: Int, _ end: Int): [Int] {
    let res: [Int] = []
    rangeFunc(start, end, fun (i: Int) {
        res.append(i)
    })
    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md

---
status: Implemented
flip: 1087
authors: Álvaro Lillo Igualada (alvaro.lillo@dapperlabs.com)
sponsor: Josh Hannan (joshua.hannan@dapperlabs.com)
updated: 2022-08-16
---

# FLIP 1087: Fungible Tokens Metadata

## Objective

The goal of this proposal is to allow Fungible Tokens (FT) to provide metadata, in a similar fashion as the [NFT Metadata Standard, FLIP 636](https://github.com/onflow/flow/blob/master/flips/20210916-nft-metadata.md). This will allow better interoperability between fungible tokens and external applications.

## Motivation

As the Flow ecosystem continues to grow, the need of assuring contract and external apps interoperability increases. The development of the NFT Metadata standard showed how important it is for NFTs on Flow to be able to communicate their features to other dapps, and the advantages of doing so in a standardized way.

## User Benefit

The creation of a Metadata standard for fungible tokens will bring two major user benefits: discoverability and interoperability. It will make it easier for any FT to be presented in any app that displays fungible tokens, and will also allow those FTs to communicate how they can be used programmatically.

## Design Proposal

The core of this proposal is to add the following interface and have any `FungibleToken.Vault` implement it. This is the same interface that can be found in the NFT metadata contract.

```cadence
    /// Provides access to a set of metadata views. A struct or
    /// resource (e.g. a Vault) can implement this interface to provide access to
    /// the views that it supports.
    ///
    pub resource interface Resolver {
        pub fun getViews(): [Type]
        pub fun resolveView(_ view: Type): AnyStruct?
    }
```

Also, based on the experience gained from the NFT metadata standard, implementations are required to provide an  `FTView` view, which provides a full picture of the FT. It wraps the `FTDisplay` and `FTVaultData` views.

```cadence
    /// FTView wraps FTDisplay and FTVaultData, and is used
    /// to give a complete picture of a FT. Most FTs should implement this
    /// view.
    ///
    pub struct FTView {
        pub let ftDisplay: FTDisplay?
        pub let vaultData: FTVaultData?
        init(
            ftDisplay: FTDisplay?,
            vaultData: FTVaultData?
        ) {
            self.ftDisplay = ftDisplay
            self.vaultData = vaultData
        }
    }
```

The `FTView` contains two sub-views:
- `FTDisplay`, which provides the "human readable" information about the fungible token; and
- `FTVaultData`, which provides the data needed to interact with the fungible token (paths, types linked to those paths, similar to `NFTCollectionData`)

```cadence
    /// View to expose the information needed to showcase this FT.
    /// This can be used by applications to give an overview and
    /// graphics of the FT.
    ///
    pub struct FTDisplay {
        /// Name that should be used when displaying this FT.
        pub let name: String

        /// Description that should be used to give an overview of this FT.
        pub let description: String?

        /// A small logo that represents the FT.
        ///
        /// This field should be a web-friendly file (i.e JPEG, PNG)
        /// that can be displayed in lists, link previews, etc.
        pub let logo: AnyStruct{File}?

        /// External link to a URL to view more information about this token.
        pub let externalURL: ExternalURL?

        /// Social links to reach this token's social homepages.
        /// Possible keys may be "instagram", "twitter", "discord", etc.
        pub let socials: {String: ExternalURL}?

        init(
            name: String,
            description: String?,
            logo: AnyStruct{File}?,
            externalURL: ExternalURL?,
            socials: {String: ExternalURL}?
        ) {
            self.name = name
            self.description = description
            self.logo = logo
            self.externalURL = externalURL
            self.socials = socials
        }
    }
```

```cadence
    /// View to expose the information needed store and interact with a FT vault.
    /// This can be used by applications to setup a FT vault with proper
    /// storage and public capabilities.
    ///
    pub struct FTVaultData {
        /// Path in storage where this FT vault is recommended to be stored.
        pub let storagePath: StoragePath

        /// Public path which must be linked to expose public capabilities of
        /// this FT, including standard FT interfaces and metadataviews
        /// interfaces
        pub let publicPath: PublicPath

        /// Private path which should be linked to expose the provider
        /// capability to withdraw funds from the vault
        pub let providerPath: PrivatePath

        /// Type that should be linked at the aforementioned public path. This
        /// is normally a restricted type with many interfaces. Notably the
        /// `FT.Balance`, `FT.Receiver`, and `FungibleMetadataViews.Resolver`
        /// interfaces are required.
        pub let publicLinkedType: Type

        /// Type that should be linked at the aforementioned private path. This
        /// is normally a restricted type with at a minimum the `FT.Provider`
        /// interface
        pub let providerLinkedType: Type

        /// Function that allows creation of an empty FT vault that is intended
        /// to store the funds.
        pub let createEmptyVault: ((): @FungibleToken.Vault)

        init(
            storagePath: StoragePath,
            publicPath: PublicPath,
            providerPath: PrivatePath,
            publicCollection: Type,
            publicLinkedType: Type,
            providerLinkedType: Type,
            createEmptyVaultFunction: ((): @FungibleToken.Vault)
        ) {
            pre {
                publicLinkedType.isSubtype(of: Type<&{FungibleToken.Receiver, FungibleToken.Balance, Resolver}>()): "Public type must include FungibleToken.Receiver, FungibleToken.Balance and FungibleMetadataViews.Resolver interfaces."
                providerLinkedType.isSubtype(of: Type<&{FungibleToken.Provider, Resolver}>()): "Provider type must include NonFungibleToken.Provider and FungibleMetadataViews.Resolver interface."
            }
            self.storagePath = storagePath
            self.publicPath = publicPath
            self.providerPath = providerPath
            self.publicLinkedType = publicLinkedType
            self.providerLinkedType = providerLinkedType
            self.createEmptyVault = createEmptyVaultFunction
        }
    }
```

In order to be able to use the `FTDisplay` we will need to use or import (depending on if this ends up being part of the original `MetadataViews.cdc` contract or having its own contract) the following views: `ExternalURL`, `File`, `HTTPFile`, `IPFSFile`, `Media` and `Medias`.

### Alternatives Considered

Since the `MetadataViews` contract has been a successful solution for increasing NFT interoperability, no alternatives have been considered.

### Performance Implications

Due to the potentially dynamic nature of this proposal, the methods that return metadata views can be implemented in any way that the author sees fit which could lead to some non-performant implementations.

### Dependencies

This proposal builds on the [existing FT interface](https://github.com/onflow/flow-ft).

### Engineering Impact

Adhering to this standard will require contract authors to implement a few new methods as part of their FT. They will also likely need to import standard types into their contracts.

There may also need to be a committee, process, and code repository put in place for managing the standard metadata types.

### Best Practices

Fungible Token issuers should implement the `FTView` to achieve the as much ecosystem compatibility as possible.

### Tutorials and Examples

Guidelines on how to implement the new views will be added to the `ExampleToken.cdc` contract, and their used will be documented on the `flow-ft` repo docs.

### Compatibility

Fungible Token contract owners will need to update them to add implementations for the new methods.

### User Impact

This feature can be rolled out with no fear of changes to the user. However documentation should be provided on how they can change their contracts and add views.

## Prior Art

The existing [NFT Metadata views standard](https://github.com/onflow/flow/blob/master/flips/20210916-nft-metadata.md) has been used as the main inspiration for this proposal.

## Questions and Discussion Topics

We should agree on which views, new ones and existing ones, should be needed to implement by any `Fungible Token` adopting the standard.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/setup_royalty_account.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "FlowToken"
import "FiatToken"


/// This transaction is a template for a transaction that could be used by 
/// anyone fully setup an account for receiving both Flow and USDC tokens at the same
/// public path (for instance the royalties /public/GenericFTReceiver path)
/// Using the addNewVaultWrappersByPath switchboard method allows anyone to use
/// capability wrappers such as TokenForwarders instead of the actual token vault.
transaction () {

    let flowTokenVaultCapability: Capability<&{FungibleToken.Receiver}>
    let fiatTokenVaultCapability: Capability<&{FungibleToken.Receiver}>   
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) Account) {

        self.flowTokenVaultCapability = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            ?? panic("The signer does not store a FlowToken Vault capability at the path "
                .concat("/public/flowTokenReceiver. The signer must initialize their account with this object first!"))

        // Check if the account already has a USDC Vault
        if signer.storage.borrow<&FiatToken.Vault>(from: FiatToken.VaultStoragePath) == nil {
            // If not, create a new USDC Vault resource and put it into storage
            signer.storage.save(<-FiatToken.createEmptyVault(vaultType: Type<@FiatToken.Vault>()), 
                                                      to: FiatToken.VaultStoragePath)
        }
        // Check if the receiver capability is linked on the USDC receiver path
        if !signer.capabilities.get<&{FungibleToken.Receiver}>
                                           (FiatToken.VaultReceiverPubPath)!.check() {
            // if it's not, create a public capability to the USDC vault
            let tokenCap = signer.capabilities.storage.issue<&FiatToken.Vault>(FiatToken.VaultStoragePath)
            signer.capabilities.publish(tokenCap, at: FiatToken.VaultReceiverPubPath)
            let receiverCap = signer.capabilities.storage.issue<&FiatToken.Vault>(FiatToken.VaultStoragePath)
            signer.capabilities.publish(receiverCap, at: FiatToken.VaultBalancePubPath)
        }
        self.fiatTokenVaultCapability = signer.capabilities.get<&{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)
        
        // Check if the account already has a Switchboard resource
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>
                                (from: FungibleTokenSwitchboard.StoragePath) == nil {
            // If not, create a new Switchboard resource and put it into storage
            signer.storage.save(<- FungibleTokenSwitchboard.createSwitchboard(), 
                                            to: FungibleTokenSwitchboard.StoragePath)
        }
        // Check if the receiver capability is linked on the receiver path
        if !signer.capabilities.get
                      <&FungibleTokenSwitchboard.Switchboard>
                              (FungibleTokenSwitchboard.ReceiverPublicPath)!.check() {
            // if it's not, create a public capability to the Switchboard 
            let receiverCap = signer.capabilities.storage.issue<&FungibleTokenSwitchboard.Switchboard>(FungibleTokenSwitchboard.StoragePath)
            signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)
        }
        // Check if the SwitchboardPublic and ft receiver capabilities are linked on
        // the switchboard public path
        if !signer.capabilities.get<
        &FungibleTokenSwitchboard.Switchboard
                                       >(FungibleTokenSwitchboard.ReceiverPublicPath)!
                                                                           .check() {
            // if it's not, create a public capability to the Switchboard
            let switchboardReceiverCap = signer.capabilities.storage.issue<
            &FungibleTokenSwitchboard.Switchboard
                                               >(FungibleTokenSwitchboard.StoragePath)
            signer.capabilities.publish(switchboardReceiverCap, at: FungibleTokenSwitchboard.PublicPath)
        }
        // Get a reference to the switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>
                                         (from: FungibleTokenSwitchboard.StoragePath) 
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

    }

    execute {
        // Add the capability to the switchboard using addNewVault method
        self.switchboardRef.addNewVault(capability: self.flowTokenVaultCapability)
        self.switchboardRef.addNewVault(capability: self.fiatTokenVaultCapability)
    }

}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/privateForwarder/transfer_private_many_accounts.cdc

```
import "FungibleToken"
import "ExampleToken"
import "PrivateReceiverForwarder"
import "FungibleTokenMetadataViews"

/// This transaction transfers to many addresses through their private receivers

transaction(addressAmountMap: {Address: UFix64}) {

    // The Vault resource that holds the tokens that are being transferred
    let vaultRef: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    let privateForwardingSender: &PrivateReceiverForwarder.Sender

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Get a reference to the signer's stored vault
        self.vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: vaultData.storagePath)
            ?? panic("The signer does not store an ExampleToken.Vault object at the path "
                    .concat(vaultData.storagePath.toString())
                    .concat(". The signer must initialize their account with this vault first!"))

        self.privateForwardingSender = signer.storage.borrow<&PrivateReceiverForwarder.Sender>(from: PrivateReceiverForwarder.SenderStoragePath)
			?? panic("Could not borrow reference to the owner's Vault!")

    }

    execute {

        for address in addressAmountMap.keys {

            self.privateForwardingSender.sendPrivateTokens(address, tokens: <-self.vaultRef.withdraw(amount: addressAmountMap[address]!))

        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/privateForwarder/create_private_forwarder.cdc

```
import "FungibleToken"
import "ExampleToken"
import "PrivateReceiverForwarder"
import "FungibleTokenMetadataViews"

// This transaction creates a new private receiver in an account that 
// doesn't already have a private receiver or a public token receiver
// but does already have a Vault

transaction {

    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Issue a Receiver Capability targetting the ExampleToken Vault
        let receiverCapability = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
            vaultData.storagePath
        )
        // Create the Forwarder resource
        let forwarder <- PrivateReceiverForwarder.createNewForwarder(recipient: receiverCapability)
        // Save the Forwarder resource to storage
        signer.storage.save(<-forwarder, to: PrivateReceiverForwarder.PrivateReceiverStoragePath)
        // Issue a Capability to the Forwarder resource
        let forwarderCap = signer.capabilities.storage.issue<&PrivateReceiverForwarder.Forwarder>(
                PrivateReceiverForwarder.PrivateReceiverStoragePath
            )
        // Publish the Capability to the Forwarder resource
        signer.capabilities.publish(
            forwarderCap,
            at: PrivateReceiverForwarder.PrivateReceiverPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/.github/ISSUE_TEMPLATE/feature-request.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc

```
import "FungibleToken"

/// The contract that allows an account to receive payments in multiple fungible
/// tokens using a single `{FungibleToken.Receiver}` capability.
/// This capability should ideally be stored at the 
/// `FungibleTokenSwitchboard.ReceiverPublicPath = /public/GenericFTReceiver`
/// but it can be stored anywhere.
/// 
access(all) contract FungibleTokenSwitchboard {
  
    // Storage and Public Paths
    access(all) let StoragePath: StoragePath
    access(all) let PublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath

    access(all) entitlement Owner

    /// The event that is emitted when a new vault capability is added to a
    /// switchboard resource.
    /// 
    access(all) event VaultCapabilityAdded(type: Type, switchboardOwner: Address?, 
                                    capabilityOwner: Address?)

    /// The event that is emitted when a vault capability is removed from a 
    /// switchboard resource.
    /// 
    access(all) event VaultCapabilityRemoved(type: Type,  switchboardOwner: Address?, 
                                        capabilityOwner: Address?)

    /// The event that is emitted when a deposit can not be completed.
    /// 
    access(all) event NotCompletedDeposit(type: Type, amount: UFix64, 
                                    switchboardOwner: Address?)

    /// The interface that enforces the method to allow anyone to check on the
    /// available capabilities of a switchboard resource and also exposes the 
    /// deposit methods to deposit funds on it.
    /// 
    access(all) resource interface SwitchboardPublic {
        access(all) view fun getVaultTypesWithAddress(): {Type: Address}
        access(all) view fun getSupportedVaultTypes(): {Type: Bool}
        access(all) view fun isSupportedVaultType(type: Type): Bool
        access(all) fun deposit(from: @{FungibleToken.Vault})
        access(all) fun safeDeposit(from: @{FungibleToken.Vault}): @{FungibleToken.Vault}?
        access(all) view fun safeBorrowByType(type: Type): &{FungibleToken.Receiver}?
    }

    /// The resource that stores the multiple fungible token receiver 
    /// capabilities, allowing the owner to add and remove them and anyone to 
    /// deposit any fungible token among the available types.
    /// 
    access(all) resource Switchboard: FungibleToken.Receiver, SwitchboardPublic {
       
        /// Dictionary holding the fungible token receiver capabilities, 
        /// indexed by the fungible token vault type.
        /// 
        access(contract) var receiverCapabilities: {Type: Capability<&{FungibleToken.Receiver}>}

        /// Adds a new fungible token receiver capability to the switchboard 
        /// resource.
        /// 
        /// @param capability: The capability to expose a certain fungible
        /// token vault deposit function through `{FungibleToken.Receiver}` that
        /// will be added to the switchboard.
        /// 
        access(Owner) fun addNewVault(capability: Capability<&{FungibleToken.Receiver}>) {
            // Borrow a reference to the vault pointed to by the capability we 
            // want to store inside the switchboard
            let vaultRef = capability.borrow() 
                ?? panic("FungibleTokenSwitchboard.Switchboard.addNewVault: Cannot borrow reference to vault from capability! "
                          .concat("Make sure that the capability path points to a Vault that has been properly initialized. "))

            // Check if there is a previous capability for this token
            if (self.receiverCapabilities[vaultRef.getType()] == nil) {
                // use the vault reference type as key for storing the 
                // capability and then
                self.receiverCapabilities[vaultRef.getType()] = capability
                // emit the event that indicates that a new capability has been 
                // added
                emit VaultCapabilityAdded(type: vaultRef.getType(),
                                               switchboardOwner: self.owner?.address, 
                                                 capabilityOwner: capability.address)
            } else {
                // If there was already a capability for that token, panic
                panic("FungibleTokenSwitchboard.Switchboard.addNewVault: Cannot add new Vault capability! "
                    .concat("There is already a vault in the Switchboard for this type <")
                    .concat(vaultRef.getType().identifier).concat(">."))
            }
        }

        /// Adds a number of new fungible token receiver capabilities by using
        /// the paths where they are stored.
        ///                    
        /// @param paths: The paths where the public capabilities are stored.
        /// @param address: The address of the owner of the capabilities.
        /// 
        access(Owner) fun addNewVaultsByPath(paths: [PublicPath], address: Address) {
            // Get the account where the public capabilities are stored
            let owner = getAccount(address)
            // For each path, get the saved capability and store it 
            // into the switchboard's receiver capabilities dictionary
            for path in paths {
                let capability = owner.capabilities.get<&{FungibleToken.Receiver}>(path)
                // Borrow a reference to the vault pointed to by the capability
                // we want to store inside the switchboard
                // If the vault was borrowed successfully...
                if let vaultRef = capability.borrow() {
                    // ...and if there is no previous capability added for that token
                    if (self.receiverCapabilities[vaultRef!.getType()] == nil) {
                        // Use the vault reference type as key for storing the
                        // capability
                        self.receiverCapabilities[vaultRef!.getType()] = capability
                        // and emit the event that indicates that a new
                        // capability has been added
                        emit VaultCapabilityAdded(type: vaultRef.getType(),
                            switchboardOwner: self.owner?.address,
                            capabilityOwner: address,
                        )
                    }
                }
            }
        }

        /// Adds a new fungible token receiver capability to the switchboard 
        /// resource specifying which `Type` of `@{FungibleToken.Vault}` can be 
        /// deposited to it. Use it to include in your switchboard "wrapper"
        /// receivers such as a `@TokenForwarding.Forwarder`. It can also be
        /// used to overwrite the type attached to a certain capability without 
        /// having to remove that capability first.
        ///
        /// @param capability: The capability to expose a certain fungible
        /// token vault deposit function through `{FungibleToken.Receiver}` that
        /// will be added to the switchboard.
        ///
        /// @param type: The type of fungible token that can be deposited to that
        /// capability, rather than the `Type` from the reference borrowed from
        /// said capability
        /// 
        access(Owner) fun addNewVaultWrapper(capability: Capability<&{FungibleToken.Receiver}>, 
                                                                        type: Type) {
            // Check if the capability is working
            assert (
                capability.check(),
                message:
                    "FungibleTokenSwitchboard.Switchboard.addNewVaultWrapper: Cannot borrow reference to a vault from the provided capability! "
                    .concat("Make sure that the capability path points to a Vault that has been properly initialized.")
            )
            // Use the type parameter as key for the capability
            self.receiverCapabilities[type] = capability
            // emit the event that indicates that a new capability has been 
            // added
            emit VaultCapabilityAdded(
                type: type,
                switchboardOwner: self.owner?.address,
                capabilityOwner: capability.address,
            )
        }

        /// Adds zero or more new fungible token receiver capabilities to the  
        /// switchboard resource specifying which `Type`s of `@{FungibleToken.Vault}`s  
        /// can be deposited to it. Use it to include in your switchboard "wrapper"
        /// receivers such as a `@TokenForwarding.Forwarder`. It can also be
        /// used to overwrite the types attached to certain capabilities without 
        /// having to remove those capabilities first.
        ///                    
        /// @param paths: The paths where the public capabilities are stored.
        /// @param types: The types of the fungible token to be deposited on each path.
        /// @param address: The address of the owner of the capabilities.
        /// 
        access(Owner) fun addNewVaultWrappersByPath(paths: [PublicPath], types: [Type], 
                                                                  address: Address) {
            // Get the account where the public capabilities are stored
            let owner = getAccount(address)
            // For each path, get the saved capability and store it 
            // into the switchboard's receiver capabilities dictionary
            for i, path in paths {
                let capability = owner.capabilities.get<&{FungibleToken.Receiver}>(path)
                // Borrow a reference to the vault pointed to by the capability
                // we want to store inside the switchboard
                // If the vault was borrowed successfully...
                if let vaultRef = capability.borrow() {
                    // Use the vault reference type as key for storing the capability
                    self.receiverCapabilities[types[i]] = capability
                    // and emit the event that indicates that a new capability has been added
                    emit VaultCapabilityAdded(
                        type: types[i],
                        switchboardOwner: self.owner?.address,
                        capabilityOwner: address,
                    )
                }
            }
        }

        /// Removes a fungible token receiver capability from the switchboard
        /// resource.
        /// 
        /// @param capability: The capability to a fungible token vault to be
        /// removed from the switchboard.
        /// 
        access(Owner) fun removeVault(capability: Capability<&{FungibleToken.Receiver}>) {
            // Borrow a reference to the vault pointed to by the capability we 
            // want to remove from the switchboard
            let vaultRef = capability.borrow()
                ?? panic ("FungibleTokenSwitchboard.Switchboard.addNewVaultWrapper: Cannot borrow reference to a vault from the provided capability! "
                          .concat("Make sure that the capability path points to a Vault that has been properly initialized."))

            // Use the vault reference to find the capability to remove
            self.receiverCapabilities.remove(key: vaultRef.getType())
            // Emit the event that indicates that a new capability has been 
            // removed
            emit VaultCapabilityRemoved(
                type: vaultRef.getType(),
                switchboardOwner: self.owner?.address,
                capabilityOwner: capability.address,
            )
        }
        
        /// Takes a fungible token vault and routes it to the proper fungible 
        /// token receiver capability for depositing it.
        /// 
        /// @param from: The deposited fungible token vault resource.
        /// 
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            // Get the capability from the ones stored at the switchboard
            let depositedVaultCapability = self.receiverCapabilities[from.getType()]
                ?? panic ("FungibleTokenSwitchboard.Switchboard.deposit: Cannot deposit Vault! "
                          .concat("The deposited vault of type <").concat(from.getType().identifier)
                          .concat("> is not available on this Fungible Token switchboard. ")
                          .concat("The recipient needs to initialize their account and switchboard to hold and receive the deposited vault type."))

            // Borrow the reference to the desired vault
            let vaultRef = depositedVaultCapability.borrow()
                ?? panic ("FungibleTokenSwitchboard.Switchboard.deposit: Cannot borrow reference to a vault "
                          .concat("from the type of the deposited Vault <").concat(from.getType().identifier)
                          .concat(">. Make sure that the capability path points to a Vault that has been properly initialized."))

            vaultRef.deposit(from: <-from)
        }

        /// Takes a fungible token vault and tries to route it to the proper
        /// fungible token receiver capability for depositing the funds, 
        /// avoiding panicking if the vault is not available.
        ///             
        /// @param vaultType: The type of the ft vault that wants to be 
        /// deposited.
        /// 
        /// @return The deposited fungible token vault resource, without the
        /// funds if the deposit was successful, or still containing the funds
        /// if the reference to the needed vault was not found.
        /// 
        access(all) fun safeDeposit(from: @{FungibleToken.Vault}): @{FungibleToken.Vault}? {
            // Try to get the proper vault capability from the switchboard
            // If the desired vault is present on the switchboard...
            if let depositedVaultCapability = self.receiverCapabilities[from.getType()] {
                // We try to borrow a reference to the vault from the capability
                // If we can borrow a reference to the vault...
                if let vaultRef = depositedVaultCapability.borrow() {
                    // We deposit the funds on said vault
                    vaultRef.deposit(from: <-from.withdraw(amount: from.balance))
                }
            }
            // if deposit failed for some reason
            if from.balance > 0.0 {
                emit NotCompletedDeposit(
                    type: from.getType(),
                    amount: from.balance,
                    switchboardOwner: self.owner?.address,
                )
                return <-from
            }
            destroy from 
            return nil
        }

        /// Checks that the capability tied to a type is valid
        ///
        /// @param vaultType: The type of the ft vault whose capability needs to be checked
        ///
        /// @return a boolean marking the capability for a type as valid or not
        access(all) view fun checkReceiverByType(type: Type): Bool {
            if self.receiverCapabilities[type] == nil {
                return false
            }

            return self.receiverCapabilities[type]!.check()
        }

        /// Gets the receiver assigned to a provided vault type.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid 
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @param vaultType: The type of the ft vault whose capability needs to be checked
        ///
        /// @return an optional receiver capability for consumers of the switchboard to check/validate on their own
        access(all) view fun safeBorrowByType(type: Type): &{FungibleToken.Receiver}? {
            if !self.checkReceiverByType(type: type) {
                return nil
            }

            return self.receiverCapabilities[type]!.borrow()
        }

        /// A getter function to know which tokens a certain switchboard 
        /// resource is prepared to receive along with the address where
        /// those tokens will be deposited.
        ///
        /// @return A dictionary mapping the `{FungibleToken.Receiver}` 
        /// type to the receiver owner's address 
        ///
        access(all) view fun getVaultTypesWithAddress(): {Type: Address} {
            let effectiveTypesWithAddress: {Type: Address} = {}
            // Check if each capability is live
            for vaultType in self.receiverCapabilities.keys {
                if self.receiverCapabilities[vaultType]!.check() {
                    // and attach it to the owner's address
                    effectiveTypesWithAddress[vaultType] = self.receiverCapabilities[vaultType]!.address
                }
            }
            return effectiveTypesWithAddress
        }

        /// A getter function that returns the token types supported by this resource,
        /// which can be deposited using the 'deposit' function.
        ///
        /// @return Dictionary of FT types that can be deposited.
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} { 
            let supportedVaults: {Type: Bool} = {}
            for receiverType in self.receiverCapabilities.keys {
                if self.receiverCapabilities[receiverType]!.check() {
                    if receiverType.isSubtype(of: Type<@{FungibleToken.Vault}>()) {
                        supportedVaults[receiverType] = true
                    }
                    if receiverType.isSubtype(of: Type<@{FungibleToken.Receiver}>()) {
                        let receiverRef = self.receiverCapabilities[receiverType]!.borrow()!
                        let subReceiverSupportedTypes = receiverRef.getSupportedVaultTypes()
                        for subReceiverType in subReceiverSupportedTypes.keys {                          
                            if subReceiverType.isSubtype(of: Type<@{FungibleToken.Vault}>()) {
                                supportedVaults[subReceiverType] = true
                            }
                        }
                    }
                }
            }
            return supportedVaults
        }

        /// Returns whether or not the given type is accepted by the Receiver
        /// A vault that can accept any type should just return true by default
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            let supportedVaults = self.getSupportedVaultTypes()
            if let supported = supportedVaults[type] {
                return supported
            } else { return false }
        }

        init() {
            // Initialize the capabilities dictionary
            self.receiverCapabilities = {}
        }

    }

    /// Function that allows to create a new blank switchboard. A user must call
    /// this function and store the returned resource in their storage.
    ///
    access(all) fun createSwitchboard(): @Switchboard {
        return <-create Switchboard()
    }

    init() {
        self.StoragePath = /storage/fungibleTokenSwitchboard
        self.PublicPath = /public/fungibleTokenSwitchboardPublic
        self.ReceiverPublicPath = /public/GenericFTReceiver
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/mint_tokens.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is what the minter Account uses to mint new tokens
/// They provide the recipient address and amount to mint, and the tokens
/// are transferred to the address after minting

transaction(recipient: Address, amount: UFix64) {

    /// Reference to the Example Token Minter Resource object
    let tokenMinter: &ExampleToken.Minter

    /// Reference to the Fungible Token Receiver of the recipient
    let tokenReceiver: &{FungibleToken.Receiver}

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    prepare(signer: auth(BorrowValue) &Account) {
        self.supplyBefore = ExampleToken.totalSupply

        // Borrow a reference to the admin object
        self.tokenMinter = signer.storage.borrow<&ExampleToken.Minter>(from: ExampleToken.AdminStoragePath)
            ?? panic("Cannot mint: Signer does not store the ExampleToken Minter in their account!")

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))
    
        self.tokenReceiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(recipient.toString()).concat(" at path ").concat(vaultData.receiverPath.toString())
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))
    }

    execute {

        // Create mint tokens
        let mintedVault <- self.tokenMinter.mintTokens(amount: amount)

        // Deposit them to the receiever
        self.tokenReceiver.deposit(from: <-mintedVault)
    }

    post {
        ExampleToken.totalSupply == self.supplyBefore + amount: "The total supply must be increased by the amount"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenMetadataViews.cdc

```
import "FungibleToken"
import "MetadataViews"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-1087.
/// 
/// Ref: https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md
/// 
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata.
///
access(all) contract FungibleTokenMetadataViews {

    /// FTView wraps FTDisplay and FTVaultData, and is used to give a complete 
    /// picture of a Fungible Token. Most Fungible Token contracts should 
    /// implement this view.
    ///
    access(all) struct FTView {
        access(all) let ftDisplay: FTDisplay?     
        access(all) let ftVaultData: FTVaultData?
        view init(
            ftDisplay: FTDisplay?,
            ftVaultData: FTVaultData?
        ) {
            self.ftDisplay = ftDisplay
            self.ftVaultData = ftVaultData
        }
    }

    /// Helper to get a FT view.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A FTView struct
    ///
    access(all) fun getFTView(viewResolver: &{ViewResolver.Resolver}): FTView {
        let maybeFTView = viewResolver.resolveView(Type<FTView>())
        if let ftView = maybeFTView {
            return ftView as! FTView
        }
        return FTView(
            ftDisplay: self.getFTDisplay(viewResolver),
            ftVaultData: self.getFTVaultData(viewResolver)
        )
    }

    /// View to expose the information needed to showcase this FT. 
    /// This can be used by applications to give an overview and 
    /// graphics of the FT.
    ///
    access(all) struct FTDisplay {
        /// The display name for this token.
        ///
        /// Example: "Flow"
        ///
        access(all) let name: String

        /// The abbreviated symbol for this token.
        ///
        /// Example: "FLOW"
        access(all) let symbol: String

        /// A description the provides an overview of this token.
        ///
        /// Example: "The FLOW token is the native currency of the Flow network."
        access(all) let description: String

        /// External link to a URL to view more information about the fungible token.
        access(all) let externalURL: MetadataViews.ExternalURL

        /// One or more versions of the fungible token logo.
        access(all) let logos: MetadataViews.Medias

        /// Social links to reach the fungible token's social homepages.
        /// Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            symbol: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            logos: MetadataViews.Medias,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.symbol = symbol
            self.description = description
            self.externalURL = externalURL
            self.logos = logos
            self.socials = socials
        }
    }

    /// Helper to get FTDisplay in a way that will return a typed optional.
    /// 
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional FTDisplay struct
    ///
    access(all) fun getFTDisplay(_ viewResolver: &{ViewResolver.Resolver}): FTDisplay? {
        if let maybeDisplayView = viewResolver.resolveView(Type<FTDisplay>()) {
            if let displayView = maybeDisplayView as? FTDisplay {
                return displayView
            }
        }
        return nil
    }

    /// View to expose the information needed store and interact with a FT vault.
    /// This can be used by applications to setup a FT vault with proper 
    /// storage and public capabilities.
    ///
    access(all) struct FTVaultData {
        /// Path in storage where this FT vault is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose the public receiver capability.
        access(all) let receiverPath: PublicPath

        /// Public path which must be linked to expose the balance and resolver public capabilities.
        access(all) let metadataPath: PublicPath

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring 
        /// the `FungibleToken.Receiver` interface.
        access(all) let receiverLinkedType: Type

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring 
        /// the `ViewResolver.Resolver` interfaces.
        access(all) let metadataLinkedType: Type

        /// Function that allows creation of an empty FT vault that is intended
        /// to store the funds.
        access(all) let createEmptyVault: fun(): @{FungibleToken.Vault}

        view init(
            storagePath: StoragePath,
            receiverPath: PublicPath,
            metadataPath: PublicPath,
            receiverLinkedType: Type,
            metadataLinkedType: Type,
            createEmptyVaultFunction: fun(): @{FungibleToken.Vault}
        ) {
            pre {
                receiverLinkedType.isSubtype(of: Type<&{FungibleToken.Receiver}>()):
                    "Receiver public type <".concat(receiverLinkedType.identifier)
                    .concat("> must be a subtype of <").concat(Type<&{FungibleToken.Receiver}>().identifier)
                    .concat(">.")
                metadataLinkedType.isSubtype(of: Type<&{FungibleToken.Vault}>()):
                    "Metadata linked type <".concat(metadataLinkedType.identifier)
                    .concat("> must be a subtype of <").concat(Type<&{FungibleToken.Vault}>().identifier)
                    .concat(">.")
            }
            self.storagePath = storagePath
            self.receiverPath = receiverPath
            self.metadataPath = metadataPath
            self.receiverLinkedType = receiverLinkedType
            self.metadataLinkedType = metadataLinkedType
            self.createEmptyVault = createEmptyVaultFunction
        }
    }

    /// Helper to get FTVaultData in a way that will return a typed Optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional FTVaultData struct
    ///
    access(all) fun getFTVaultData(_ viewResolver: &{ViewResolver.Resolver}): FTVaultData? {
        if let view = viewResolver.resolveView(Type<FTVaultData>()) {
            if let v = view as? FTVaultData {
                return v
            }
        }
        return nil
    }

    /// View to expose the total supply of the Vault's token
    access(all) struct TotalSupply {
        access(all) let supply: UFix64

        view init(totalSupply: UFix64) {
            self.supply = totalSupply
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/metadata/scripts/get_token_metadata.cdc

```
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "FungibleToken"
import "ViewResolver"

access(all) fun main(address: Address): FungibleTokenMetadataViews.FTView {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not resolve FTVaultData view. The ExampleToken"
            .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))


    let vaultRef = account.capabilities.borrow<&ExampleToken.Vault>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the ExampleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(vaultData.metadataPath.toString())
                .concat(". Make sure you are querying an address that has an ExampleToken Vault set up properly."))

    let ftView = FungibleTokenMetadataViews.getFTView(viewResolver: vaultRef)

    return ftView
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/scripts/get_token_metadata.cdc

```
// This script checks the FTView view from ExampleToken
// is the expected one. This is merely used in testing.

import "ExampleToken"
import "FungibleTokenMetadataViews"
import "MetadataViews"
import "ViewResolver"

access(all) fun main(address: Address): Bool {
    let account = getAccount(address)

    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get the vault data view for ExampleToken")

    let vaultRef = account.capabilities.borrow<&{ViewResolver.Resolver}>(vaultData.metadataPath)
        ?? panic("Could not borrow a reference to the vault resolver")

    let ftView = FungibleTokenMetadataViews.getFTView(viewResolver: vaultRef)

    // FungibleTokenMetadataViews.FTVaultData cannot be returned as
    // a script result, because of the createEmptyVault() function.
    // So we perform the assertions here.
    return ftView.ftDisplay != nil && ftView.ftVaultData != nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/privateForwarder/setup_and_create_forwarder.cdc

```

import "FungibleToken"
import "ExampleToken"
import "PrivateReceiverForwarder"
import "FungibleTokenMetadataViews"

/// This transaction adds a Vault, a private receiver forwarder
/// a balance capability, and a public capability for the receiver

transaction {

    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        if signer.capabilities.get<&PrivateReceiverForwarder.Forwarder>(PrivateReceiverForwarder.PrivateReceiverPublicPath).check() {
            // private forwarder was already set up
            return
        }

        if signer.storage.check<&ExampleToken.Vault>(from: vaultData.storagePath) == false {
            // Create a new ExampleToken Vault and put it in storage
            signer.storage.save(
                <-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>()),
                to: vaultData.storagePath
            )
        }

        // Create a public Vault Capability if needed
        if signer.capabilities.borrow<&{FungibleToken.Vault}>(vaultData.metadataPath) == nil {
            let vaultCap = signer.capabilities.storage.issue<&{FungibleToken.Balance, FungibleToken.Vault}>(
                    vaultData.storagePath
                )
            signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)
        }

        // Issue a Receiver Capability targetting the ExampleToken Vault
        let receiverCapability = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                vaultData.storagePath
            )

        let forwarder <- PrivateReceiverForwarder.createNewForwarder(recipient: receiverCapability)

        signer.storage.save(<-forwarder, to: PrivateReceiverForwarder.PrivateReceiverStoragePath)

        // Issue a Capability to the Forwarder resource
        let forwarderCap = signer.capabilities.storage.issue<&PrivateReceiverForwarder.Forwarder>(
                PrivateReceiverForwarder.PrivateReceiverStoragePath
            )
        // Publish the Capability to the Forwarder resource
        signer.capabilities.publish(
            forwarderCap,
            at: PrivateReceiverForwarder.PrivateReceiverPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/transactions/burn_optional.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "Burner"

/// This transaction is a template for a transaction that could be used by an account
/// to load a vault from storage and burn the whole vault
///
/// It is meant for testing purposes to burn an optional vault with the burner contract
///
transaction {

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    /// Vault resource that holds the tokens that are being burned
    let burnVault: @AnyResource

    prepare(signer: auth(Storage) &Account) {

        self.supplyBefore = ExampleToken.totalSupply

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")

        // Withdraw tokens from the signer's vault in storage
        self.burnVault <- signer.storage.load<@AnyResource>(
                from: vaultData.storagePath
        )
    }

    execute {

        Burner.burn(<-self.burnVault)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/add_vault_wrapper_capability.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to add a new vault wrapper capability
/// to their switchboard resource
/// They would just need to change the contract name they are importing from
/// to the token contract that they want to support with their switchboard
///
transaction {

    let tokenReceiverCapability: Capability<&{FungibleToken.Receiver}>
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction"))

        // Get the token forwarder capability from the signer's account
        self.tokenReceiverCapability = signer.capabilities.get<&{FungibleToken.Receiver}>(
            vaultData.receiverPath)

        // Check if the receiver capability exists
        assert(
            self.tokenReceiverCapability.check(),
            message: "The signer does not store a ExampleToken Vault capability at the path "
                .concat(vaultData.receiverPath.toString())
                .concat(". The signer must initialize their account with this object first!")
        )

        // Get a reference to the signers switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>(
                from: FungibleTokenSwitchboard.StoragePath)
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

    }

    execute {

        // Add the capability to the switchboard using addNewVault method
        self.switchboardRef.addNewVaultWrapper(
            capability: self.tokenReceiverCapability,
            type: Type<@ExampleToken.Vault>()
        )

    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/utility/TokenForwarding.cdc

```
/**

# Fungible Token Forwarding Contract

This contract shows how an account could set up a custom FungibleToken Receiver
to allow them to forward tokens to a different account whenever they receive tokens.

They can publish this Forwarder resource as a Receiver capability just like a Vault,
and the sender doesn't even need to know it is different.

When an account wants to create a Forwarder, they call the createNewForwarder
function and provide it with the Receiver reference that they want to forward
their tokens to.

*/

import "FungibleToken"

access(all) contract TokenForwarding {

    access(all) entitlement Owner

    // Event that is emitted when tokens are deposited to the target receiver
    access(all) event ForwardedDeposit(amount: UFix64, depositedUUID: UInt64, from: Address?, to: Address?, toUUID: UInt64, depositedType: String)

    // Event that is emitted when the recipient of a forwarder has changed
    access(all) event ForwarderRecipientUpdated(owner: Address?, oldRecipient: Address?, newRecipient: Address?, newReceiverType: String, newReceiverUUID: UInt64)

    access(all) resource interface ForwarderPublic {

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        access(all) fun check(): Bool

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid 
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        access(all) fun safeBorrow(): &{FungibleToken.Receiver}?
    }

    access(all) resource Forwarder: FungibleToken.Receiver, ForwarderPublic {

        // This is where the deposited tokens will be sent.
        // The type indicates that it is a reference to a receiver
        //
        access(self) var recipient: Capability

        // deposit
        //
        // Function that takes a Vault object as an argument and forwards
        // it to the recipient's Vault using the stored reference
        //
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let receiverRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!

            let balance = from.balance

            let uuid = from.uuid

            emit ForwardedDeposit(amount: balance, depositedUUID: uuid, from: self.owner?.address, to: receiverRef.owner?.address, toUUID: receiverRef.uuid, depositedType: from.getType().identifier)

            receiverRef.deposit(from: <-from)
        }

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        access(all) fun check(): Bool {
            return self.recipient.check<&{FungibleToken.Receiver}>()
        }

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid 
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        access(all) fun safeBorrow(): &{FungibleToken.Receiver}? {
            return self.recipient.borrow<&{FungibleToken.Receiver}>()
        }

        // changeRecipient changes the recipient of the forwarder to the provided recipient
        //
        access(Owner) fun changeRecipient(_ newRecipient: Capability) {
            pre {
                newRecipient.borrow<&{FungibleToken.Receiver}>() != nil:
                    "TokenForwarding.Forwarder.changeRecipient: Could not borrow a Receiver reference from the new Capability. "
                    .concat("This is likely because the recipient account ")
                    .concat(newRecipient.address.toString())
                    .concat(" has not set up the FungibleToken Vault or public capability correctly. ")
                    .concat("Verify that the address is correct and the account has the correct Vault and capability.")
            }
            let newRef = newRecipient.borrow<&{FungibleToken.Receiver}>()!
            let oldRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!
            emit ForwarderRecipientUpdated(owner: self.owner?.address, oldRecipient: oldRef.owner?.address, newRecipient: newRef.owner?.address, newReceiverType: newRef.getType().identifier, newReceiverUUID: newRef.uuid)
            self.recipient = newRecipient
        }

        /// A getter function that returns the token types supported by this resource,
        /// which can be deposited using the 'deposit' function.
        ///
        /// @return Array of FT types that can be deposited.
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            if !self.recipient.check<&{FungibleToken.Receiver}>() {
                return {}
            }
            let vaultRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!
            let supportedVaults: {Type: Bool} = {}
            supportedVaults[vaultRef.getType()] = true
            return supportedVaults
        }

        /// Returns whether or not the given type is accepted by the Receiver
        /// A vault that can accept any type should just return true by default
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            let supportedVaults = self.getSupportedVaultTypes()
            if let supported = supportedVaults[type] {
                return supported
            } else { return false }
        }

        init(recipient: Capability) {
            pre {
                recipient.borrow<&{FungibleToken.Receiver}>() != nil:
                    "TokenForwarding.Forwarder.changeRecipient: Could not borrow a Receiver reference from the Capability. "
                    .concat("This is likely because the recipient account ")
                    .concat(recipient.address.toString())
                    .concat(" has not set up the FungibleToken Vault or public capability correctly. ")
                    .concat("Verify that the address is correct and the account has the correct Vault and capability. ")
            }
            self.recipient = recipient
        }
    }

    // createNewForwarder creates a new Forwarder reference with the provided recipient
    //
    access(all) fun createNewForwarder(recipient: Capability): @Forwarder {
        return <-create Forwarder(recipient: recipient)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/utility/PrivateReceiverForwarder.cdc

```
/*

# Fungible Token Private Receiver Contract

This contract implements a special resource and receiver interface 
whose deposit function is only callable by an admin through a public capability.

*/

import "FungibleToken"

access(all) contract PrivateReceiverForwarder {

    // Event that is emitted when tokens are deposited to the target receiver
    access(all) event PrivateDeposit(amount: UFix64, depositedUUID: UInt64, from: Address?, to: Address?, toUUID: UInt64)

    access(all) let SenderStoragePath: StoragePath

    access(all) let PrivateReceiverStoragePath: StoragePath
    access(all) let PrivateReceiverPublicPath: PublicPath

    access(all) resource Forwarder {

        // This is where the deposited tokens will be sent.
        // The type indicates that it is a reference to a receiver
        //
        access(self) var recipient: Capability<&{FungibleToken.Receiver}>

        // deposit
        //
        // Function that takes a Vault object as an argument and forwards
        // it to the recipient's Vault using the stored reference
        //
        access(contract) fun deposit(from: @{FungibleToken.Vault}) {
            let receiverRef = self.recipient.borrow()!

            let balance = from.balance

            let uuid = from.uuid

            receiverRef.deposit(from: <-from)

            emit PrivateDeposit(amount: balance, depositedUUID: uuid, from: self.owner?.address, to: receiverRef.owner?.address, toUUID: receiverRef.uuid)
        }

        init(recipient: Capability<&{FungibleToken.Receiver}>) {
            pre {
                recipient.borrow() != nil: 
                    "PrivateReceiverForwarder.Forwarder.init: Could not borrow a Receiver reference from the recipient Capability. "
                    .concat("The recipient needs to have the correct Fungible Token Vault initialized in their account with a public Receiver Capability.")
            }
            self.recipient = recipient
        }
    }

    // createNewForwarder creates a new Forwarder reference with the provided recipient
    //
    access(all) fun createNewForwarder(recipient: Capability<&{FungibleToken.Receiver}>): @Forwarder {
        return <-create Forwarder(recipient: recipient)
    }


    access(all) resource Sender {
        access(all) fun sendPrivateTokens(_ address: Address, tokens: @{FungibleToken.Vault}) {

            let account = getAccount(address)

            let privateReceiver = account.capabilities.borrow<&PrivateReceiverForwarder.Forwarder>(
                    PrivateReceiverForwarder.PrivateReceiverPublicPath
                ) ?? panic("PrivateReceiverForwarder.Sender.sendPrivateTokens: Could not borrow a reference to the private forwarder in the account "
                            .concat(address.toString())
                            .concat(". Make sure this account has a Forwarder initialized in its storage with a public capability at ")
                            .concat(PrivateReceiverForwarder.PrivateReceiverPublicPath.toString()))

            privateReceiver.deposit(from: <-tokens)
            
        }
    }

    init(senderPath: StoragePath, storagePath: StoragePath, publicPath: PublicPath) {

        self.SenderStoragePath = senderPath

        self.PrivateReceiverStoragePath = storagePath
        self.PrivateReceiverPublicPath = publicPath

        self.account.storage.save(<-create Sender(), to: self.SenderStoragePath)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/ViewResolver.cdc

```
// Taken from the NFT Metadata standard, this contract exposes an interface to let 
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
access(all) contract interface ViewResolver {

    /// Function that returns all the Metadata Views implemented by the resolving contract.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there is an optional parameter to specify which resource type the caller
    /// is requesting views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type]

    /// Function that resolves a metadata view for this token.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there there is an optional parameter for specify which resource type the caller
    /// is looking for views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct?

    /// Provides access to a set of metadata views. A struct or 
    /// resource (e.g. an NFT) can implement this interface to provide access to 
    /// the views that it supports.
    ///
    access(all) resource interface Resolver {

        /// Same as getViews above, but on a specific NFT instead of a contract
        access(all) view fun getViews(): [Type]

        /// Same as resolveView above, but on a specific NFT instead of a contract
        access(all) fun resolveView(_ view: Type): AnyStruct?
    }

    /// A group of view resolvers indexed by ID.
    ///
    access(all) resource interface ResolverCollection {
        access(all) view fun borrowViewResolver(id: UInt64): &{Resolver}? {
            return nil
        }

        access(all) view fun getIDs(): [UInt64] {
            return []
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/tests/metadata_views_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "ViewResolver"
import "FungibleTokenMetadataViews"
import "ExampleToken"
import "FungibleToken"

access(all) let admin = Test.getAccount(0x0000000000000007)

/* Test Setup */

access(all) fun setup() {
    deploy("Burner", "../contracts/utility/Burner.cdc")
    deploy("FungibleToken", "../contracts/FungibleToken.cdc")
    deploy("FungibleTokenMetadataViews", "../contracts/FungibleTokenMetadataViews.cdc")
    deploy("ExampleToken", "../contracts/ExampleToken.cdc")
}

/* Test Cases */

access(all) fun testSetupAccountUsingFTView() {
    let alice = Test.createAccount()
    let bob = Test.createAccount()

    setupExampleToken(alice)
    let aliceBalance = getExampleTokenBalance(alice)
    txExecutor("metadata/setup_account_from_vault_reference.cdc", [bob], [alice.address, /public/exampleTokenVault], nil, nil)
    let bobBalance = getExampleTokenBalance(bob)

    Test.assertEqual(0.0, aliceBalance)
    Test.assertEqual(0.0, bobBalance)
}

access(all) fun testSetupAccountUsingContractAddressAndName() {
    let bob = Test.createAccount()

    txExecutor("metadata/setup_account_from_address.cdc", [bob], [admin.address, "ExampleToken"], nil, nil)
    let bobBalance = getExampleTokenBalance(bob)

    Test.assertEqual(0.0, bobBalance)
}

access(all) fun testRetrieveVaultDisplayInfo() {
    let alice = Test.createAccount()

    setupExampleToken(alice)
    let scriptResult = executeScript(
        "scripts/example_token_vault_display_strict_equal.cdc",
        [alice.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}


/* Transaction Helpers */

access(all) fun setupExampleToken(_ acct: Test.TestAccount) {
    txExecutor("setup_account.cdc", [acct], [], nil, nil)
}

/* Script Helpers */

access(all) fun getExampleTokenBalance(_ acct: Test.TestAccount): UFix64 {
    let balance: UFix64? = (scriptExecutor("get_balance.cdc", [acct.address])! as! UFix64)
    return balance!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/setup_account.cdc

```
// This transaction is a template for a transaction to allow
// anyone to add a Vault resource to their account so that
// they can use the exampleToken

import "FungibleToken"
import "ExampleToken"
import "ViewResolver"
import "FungibleTokenMetadataViews"

transaction () {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Return early if the account already stores a ExampleToken Vault
        if signer.storage.borrow<&ExampleToken.Vault>(from: vaultData.storagePath) != nil {
            return
        }

        let vault <- ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())

        // Create a new ExampleToken Vault and put it in storage
        signer.storage.save(<-vault, to: vaultData.storagePath)

        // Create a public capability to the Vault that exposes the Vault interfaces
        let vaultCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)

        // Create a public Capability to the Vault's Receiver functionality
        let receiverCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/scripts/get_vault_types_and_address.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"

/// This script reads the stored vault capabilities from a switchboard on the passed account
///
access(all) fun main(account: Address): {Type: Address} {

    // Get a reference to the switchboard conforming to SwitchboardPublic
    let switchboardRef = getAccount(account).capabilities.borrow<&{FungibleTokenSwitchboard.SwitchboardPublic}>(
            FungibleTokenSwitchboard.PublicPath)
        ?? panic("The signer does not store a FungibleToken Switchboard capability at the path "
            .concat(FungibleTokenSwitchboard.PublicPath.toString())
            .concat(". The signer must initialize their account with this object first!"))

    // Return the result of `getVaultTypesWithAddress()`
    return switchboardRef.getVaultTypesWithAddress()

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/switchboard/add_vault_capability.cdc

```
import "FungibleToken"
import "FungibleTokenSwitchboard"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is a template for a transaction that could be used by anyone to add a new fungible token vault
/// capability to their switchboard resource
///
transaction {

    let exampleTokenVaultCapability: Capability<&{FungibleToken.Receiver}>
    let switchboardRef:  auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        /* ExampleToken Vault configuration */
        //
        // Configure an ExampleToken Vault if needed
        if signer.storage.borrow<&ExampleToken.Vault>(from: vaultData.storagePath) == nil {
            // Create a new ExampleToken Vault and save it in storage
            signer.storage.save(<-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>()), to: vaultData.storagePath)
            // Clear existing Capabilities at canonical paths
            signer.capabilities.unpublish(vaultData.metadataPath)
            signer.capabilities.unpublish(vaultData.receiverPath)
            // Issue Vault & Receiver Capabilities
            let vaultCap = signer.capabilities.storage.issue<&{FungibleToken.Balance, FungibleToken.Vault}>(vaultData.storagePath)
            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(vaultData.storagePath)
            // Publish Capabilities
            signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)
            signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
        }
        
        // Get the example token vault capability from the signer's account
        self.exampleTokenVaultCapability = signer.capabilities.get<&{FungibleToken.Receiver}>(
                vaultData.receiverPath)
        
        // Check if the receiver capability exists
        assert(
            self.exampleTokenVaultCapability.check(), 
            message: "The signer does not store a ExampleToken Vault capability at the path "
                .concat(vaultData.receiverPath.toString())
                .concat(". The signer must initialize their account with this object first!")
        )
        
        /* Switchboard setup */
        //
        // Configure .Switchboard if needed
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>(from: FungibleTokenSwitchboard.StoragePath) == nil {
            // Create a new Switchboard and save it in storage
            signer.storage.save(<-FungibleTokenSwitchboard.createSwitchboard(), to: FungibleTokenSwitchboard.StoragePath)
            // Clear existing Capabilities at canonical paths
            signer.capabilities.unpublish(FungibleTokenSwitchboard.ReceiverPublicPath)
            signer.capabilities.unpublish(FungibleTokenSwitchboard.PublicPath)
            // Issue Receiver & Switchboard Capabilities
            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                    FungibleTokenSwitchboard.StoragePath
                )
            let switchboardPublicCap = signer.capabilities.storage.issue<&{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}>(
                    FungibleTokenSwitchboard.StoragePath
                )
            // Publish Capabilities
            signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)
            signer.capabilities.publish(switchboardPublicCap, at: FungibleTokenSwitchboard.PublicPath)
        }
        // Get a reference to the signers switchboard
        self.switchboardRef = signer.storage.borrow<auth(FungibleTokenSwitchboard.Owner) &FungibleTokenSwitchboard.Switchboard>(
                from: FungibleTokenSwitchboard.StoragePath)
			?? panic("The signer does not store a FungibleToken Switchboard object at the path "
                .concat(FungibleTokenSwitchboard.StoragePath.toString())
                .concat(". The signer must initialize their account with this object first!"))
    
    }

    execute {

        // Add the capability to the switchboard using addNewVault method
        self.switchboardRef.addNewVault(capability: self.exampleTokenVaultCapability)
    
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/tokenForwarder/create_forwarder.cdc

```
/**

This transaction is a template for a transaction that could be used
to set up an account to forward deposited tokens to another receiver.

If anyone sends tokens to a user's Forwarder Receiver,
the Receiver will just forward those tokens to the Vault that has been
set as the recipient and emit an event that indicates
which user forwarded the tokens.

This way, if an off-chain service wants to monitor who is forwarding
tokens to it, it can watch events to see where the tokens came from.

Steps to set up accounts with token forwarder:

1. The Fungible Token contract interface should already be deployed somewhere
2. The applicable token contract should be deployed.
3. The recipient account should have a Vault for this token created
    and stored in its storage with a published Receiver
4. Deploy the `TokenForwarding.cdc` contract to a different account
5. For a new Account: Create the account normally,
    then run the `create_forwarder.cdc` transaction,
    getting the Receiver from the account that is the recipient.
*/

import "FungibleToken"
import "ExampleToken"
import "TokenForwarding"
import "FungibleTokenMetadataViews"

transaction(receiver: Address) {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction"))

        // Get the receiver capability for the account being forwarded to
        let recipient = getAccount(receiver).capabilities.get<&{FungibleToken.Receiver}>(vaultData.receiverPath)

        // Create the forwarder and save it to the account that is doing the forwarding
        let vault <- TokenForwarding.createNewForwarder(recipient: recipient)
        signer.storage.save(<-vault, to: /storage/exampleTokenForwarder)

        // Unlink the existing capability
        signer.capabilities.unpublish(vaultData.receiverPath)

        // Link the new forwarding receiver capability
        let tokenReceiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                /storage/exampleTokenForwarder
            )
        signer.capabilities.publish(tokenReceiverCap, at: vaultData.receiverPath)

        // Link the new ForwarderPublic capability
        let tokenForwarderCap = signer.capabilities.storage.issue<&{TokenForwarding.ForwarderPublic}>(
                /storage/exampleTokenForwarder
            )
        signer.capabilities.publish(tokenForwarderCap, at: /public/exampleTokenForwarder)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/transfer_tokens.cdc

```
// This transaction is a template for a transaction that
// could be used by anyone to send tokens to another account
// that has been set up to receive tokens.
//
// The withdraw amount and the account from getAccount
// would be the parameters to the transaction

import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

transaction(amount: UFix64, to: Address) {

    /// FTVaultData metadata view for the token being used
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        self.vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction."))

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: self.vaultData.storagePath)
            ?? panic("The signer does not store an ExampleToken.Vault object at the path "
                    .concat(self.vaultData.storagePath.toString())
                    .concat(". The signer must initialize their account with this vault first!"))

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)
            ?? panic("Could not borrow a Receiver reference to the FungibleToken Vault in account "
                .concat(to.toString()).concat(" at path ").concat(self.vaultData.receiverPath.toString())
                .concat(". Make sure you are sending to an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance_generic.cdc

```
/// This script reads the balance of a vault at whatever path
/// is passed in as an argument

import "FungibleToken"

access(all) fun main(address: Address, path: PublicPath): UFix64 {
    return getAccount(address).capabilities.borrow<&{FungibleToken.Balance}>(
            path
        )?.balance
        ?? panic("Could not borrow a balance reference to the FungibleToken Vault in account "
                .concat(address.toString()).concat(" at path ").concat(path.toString())
                .concat(". Make sure you are querying an address that has ")
                .concat("a FungibleToken Vault set up properly at the specified path."))
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/burn_tokens.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"
import "Burner"

/// This transaction is a template for a transaction that could be used by the admin account to burn tokens from their
/// stored Vault
///
/// The burning amount would be a parameter to the transaction
///
transaction(amount: UFix64) {

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    /// Vault resource that holds the tokens that are being burned
    let burnVault: @ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {

        self.supplyBefore = ExampleToken.totalSupply

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view. The ExampleToken"
                .concat(" contract needs to implement the FTVaultData Metadata view in order to execute this transaction"))

        // Withdraw tokens from the signer's vault in storage
        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(
                from: vaultData.storagePath)
			?? panic("The signer does not store a ExampleToken Vault object at the path "
                .concat(vaultData.storagePath.toString())
                .concat(". The signer must initialize their account with this object first!"))

        self.burnVault <- sourceVault.withdraw(amount: amount) as! @ExampleToken.Vault
    }

    execute {

        Burner.burn(<-self.burnVault)

    }

    post {
        ExampleToken.totalSupply == (self.supplyBefore - amount):
            "Before: ".concat(self.supplyBefore.toString())
            .concat(" | After: ".concat(ExampleToken.totalSupply.toString()))
            .concat(" | Expected: ".concat((self.supplyBefore - amount).toString()))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/transactions/tokenForwarder/scripts/is_recipient_valid.cdc

```
import "TokenForwarding"

access(all) fun main(addr: Address, tokenForwardingPath: PublicPath): Bool {
    let forwarderRef = getAccount(addr)
                       .capabilities.borrow<&{TokenForwarding.ForwarderPublic}>(tokenForwardingPath)

    return forwarderRef.check()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/.github/PULL_REQUEST_TEMPLATE.md

Closes: #???

## Description

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review.
-->

______

For contributor use:

- [ ] Targeted PR against `master` branch
- [ ] Linked to Github issue with discussion and accepted design OR link to spec that describes this work.
- [ ] Code follows the [standards mentioned here](https://github.com/onflow/flow-ft/blob/master/CONTRIBUTING.md#styleguides).
- [ ] Updated relevant documentation 
- [ ] Re-reviewed `Files changed` in the Github PR explorer




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-ft/blob/master/contracts/ExampleToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

access(all) contract ExampleToken: FungibleToken {

    /// The event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64, type: String)

    /// Total supply of ExampleTokens in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath
    access(all) let AdminStoragePath: StoragePath

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Example Fungible Token",
                    symbol: "EFT",
                    description: "This fungible token is used as an example to help you develop your next FT #onFlow.",
                    externalURL: MetadataViews.ExternalURL("https://example-ft.onflow.org"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: self.VaultStoragePath,
                    receiverPath: self.ReceiverPublicPath,
                    metadataPath: self.VaultPublicPath,
                    receiverLinkedType: Type<&ExampleToken.Vault>(),
                    metadataLinkedType: Type<&ExampleToken.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: ExampleToken.totalSupply
                )
        }
        return nil
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                ExampleToken.totalSupply = ExampleToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        /// In fungible tokens, there are no specific views for specific vaults,
        /// So we can route calls to view functions to the contract views functions
        access(all) view fun getViews(): [Type] {
            return ExampleToken.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return ExampleToken.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @ExampleToken.Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @ExampleToken.Vault
            self.balance = self.balance + vault.balance
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @ExampleToken.Vault {
            return <-create Vault(balance: 0.0)
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    access(all) resource Minter {
        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        access(all) fun mintTokens(amount: UFix64): @ExampleToken.Vault {
            ExampleToken.totalSupply = ExampleToken.totalSupply + amount
            let vault <-create Vault(balance: amount)
            emit TokensMinted(amount: amount, type: vault.getType().identifier)
            return <-vault
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @ExampleToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 1000.0

        self.VaultStoragePath = /storage/exampleTokenVault
        self.VaultPublicPath = /public/exampleTokenVault
        self.ReceiverPublicPath = /public/exampleTokenReceiver
        self.AdminStoragePath = /storage/exampleTokenAdmin 

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)
        emit TokensMinted(amount: vault.balance, type: vault.getType().identifier)

        // Create a public capability to the stored Vault that exposes
        // the `deposit` method and getAcceptedTypes method through the `Receiver` interface
        // and the `balance` method through the `Balance` interface
        //
        let exampleTokenCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(exampleTokenCap, at: self.VaultPublicPath)
        let receiverCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(receiverCap, at: self.ReceiverPublicPath)

        self.account.storage.save(<-vault, to: /storage/exampleTokenVault)

        let admin <- create Minter()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/nft-forwarding/transfer_nft_to_receiver.cdc

```
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

/// This transaction is for transferring an NFT from one account to the recipient's Receiver
///
transaction(
    contractAddress: Address,
    contractName: String,
    recipient: Address,
    withdrawID: UInt64
) {

    // reference to the withdrawer's collection
    let withdrawRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}
    // reference of the Receiver to deposit the NFT to
    let depositRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        // get the collection data from the NFT contract
        let nftContract = getAccount(contractAddress).contracts.borrow<&{ViewResolver}>(name: contractName)
            ?? panic("Could not borrow ViewResolver reference to the contract. Make sure the provided contract name "
                      .concat(contractName).concat(" and address ").concat(contractAddress.toString()).concat(" are correct!"))
            
        let collectionData = nftContract.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))

        // borrow a reference to the signer's NFT collection
        self.withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("The signer does not store a "
                        .concat(contractName)
                        .concat(".Collection object at the path ")
                        .concat(collectionData.storagePath.toString())
                        .concat("The signer must initialize their account with this collection first!"))

        // borrow a public reference to the recipient's Receiver
        self.depositRef = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(
                collectionData.publicPath
            ) ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                        .concat(collectionData.publicPath.toString())
                        .concat(" that is capable of receiving a ")
                        .concat(contractName)
                        .concat(" NFT.")
                        .concat("The recipient must initialize their account with this collection and receiver first!"))
    }

    execute {

        // withdraw the NFT from the owner's collection
        let nft <- self.withdrawRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient
        self.depositRef.deposit(token: <-nft)
    }

    post {
        !self.withdrawRef.getIDs().contains(withdrawID): "Original owner should not have the NFT anymore"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/test/MaliciousNFT.cdc

```
/*
*
*  This is an example implementation of a Flow Non-Fungible Token
*  using the V2 standard.
*  It is not part of the official standard but it assumed to be
*  similar to how many NFTs would implement the core functionality.
*
*  This contract does not implement any sophisticated classification
*  system for its NFTs. It defines a simple NFT with minimal metadata.
*
*/

import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "ExampleNFT"

access(all) contract MaliciousNFT: NonFungibleToken {

    /// Standard Paths
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath

    /// Path where the minter should be stored
    /// The standard paths for the collection are stored in the collection resource type
    access(all) let MinterStoragePath: StoragePath

    /// We choose the name NFT here, but this type can have any name now
    /// because the interface does not require it to have a specific name any more
    access(all) resource NFT: NonFungibleToken.NFT {

        access(all) let id: UInt64

        /// From the Display metadata view
        access(all) let name: String
        access(all) let description: String
        access(all) let thumbnail: String

        /// For the Royalties metadata view
        access(self) let royalties: [MetadataViews.Royalty]

        /// Generic dictionary of traits the NFT has
        access(self) let metadata: {String: AnyStruct}

        init(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
        ) {
            self.id = self.uuid
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.royalties = royalties
            self.metadata = metadata
        }

        /// createEmptyCollection creates an empty Collection
        /// and returns it to the caller so that they can own NFTs
        /// @{NonFungibleToken.Collection}
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-MaliciousNFT.createEmptyCollection(nftType: Type<@MaliciousNFT.NFT>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Example NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://example-nft.onflow.org/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return MaliciousNFT.resolveContractView(resourceType: Type<@MaliciousNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return MaliciousNFT.resolveContractView(resourceType: Type<@MaliciousNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    // foo is a trait with its own rarity
                    let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
                    let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
                    traitsView.addTrait(fooTrait)

                    return traitsView
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Implementing this view gives the project control over how the bridged NFT is represented as an
                    // ERC721 when bridged to EVM on Flow via the public infrastructure bridge.

                    // Get the contract-level name and symbol values
                    let contractLevel = MaliciousNFT.resolveContractView(
                            resourceType: nil,
                            viewType: Type<MetadataViews.EVMBridgedMetadata>()
                        ) as! MetadataViews.EVMBridgedMetadata?
                        ?? panic("Could not resolve contract-level EVMBridgedMetadata")
                    // Compose the token-level URI based on a base URI and the token ID, pointing to a JSON file. This
                    // would be a file you've uploaded and are hosting somewhere - in this case HTTP, but this could be
                    // IPFS, S3, a data URL containing the JSON directly, etc.
                    let baseURI = "https://example-nft.onflow.org/token-metadata/"
                    let uriValue = self.id.toString().concat(".json")

                    return MetadataViews.EVMBridgedMetadata(
                        name: contractLevel.name,
                        symbol: contractLevel.symbol,
                        uri: MetadataViews.URI(
                            baseURI: baseURI, // defining baseURI results in a concatenation of baseURI and value
                            value: self.id.toString().concat(".json")
                        )
                    )

            }
            return nil
        }
    }

    // Deprecated: Only here for backward compatibility.
    access(all) resource interface MaliciousNFTCollectionPublic {}

    access(all) resource Collection: NonFungibleToken.Collection, MaliciousNFTCollectionPublic {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an `UInt64` ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init () {
            self.ownedNFTs <- {}
        }

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@MaliciousNFT.NFT>()] = true
            return supportedTypes
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            return type == Type<@MaliciousNFT.NFT>()
        }

        /// withdraw removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("MaliciousNFT.Collection.withdraw: Could not withdraw an NFT with the ID="
                        .concat(withdrawID.toString())
                        .concat(". Check the submitted ID to make sure it is one that this collection owns"))

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @MaliciousNFT.NFT
            let id = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken

            // This code is for testing purposes only
            // Do not add to your contract unless you have a specific
            // reason to want to emit the NFTUpdated event somewhere
            // in your contract
            let authTokenRef = (&self.ownedNFTs[id] as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT}?)!
            //authTokenRef.updateTransferDate(date: getCurrentBlock().timestamp)
            MaliciousNFT.emitNFTUpdated(authTokenRef)
        }

        /// getIDs returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return (&self.ownedNFTs[id] as &{NonFungibleToken.NFT}?)
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-MaliciousNFT.createEmptyCollection(nftType: Type<@MaliciousNFT.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: /storage/exampleNFTCollection,
                    publicPath: /public/exampleNFTCollection,
                    publicCollection: Type<&ExampleNFT.Collection>(),
                    publicLinkedType: Type<&ExampleNFT.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-MaliciousNFT.createEmptyCollection(nftType: Type<@MaliciousNFT.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://example-nft.onflow.org"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                // Implementing this view gives the project control over how the bridged NFT is represented as an ERC721
                // when bridged to EVM on Flow via the public infrastructure bridge.

                // Compose the contract-level URI. In this case, the contract metadata is located on some HTTP host,
                // but it could be IPFS, S3, a data URL containing the JSON directly, etc.
                return MetadataViews.EVMBridgedMetadata(
                    name: "MaliciousNFT",
                    symbol: "XMPL",
                    uri: MetadataViews.URI(
                        baseURI: nil, // setting baseURI as nil sets the given value as the uri field value
                        value: "https://example-nft.onflow.org/contract-metadata.json"
                    )
                )
        }
        return nil
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    access(all) resource NFTMinter {

        /// mintNFT mints a new NFT with a new ID
        /// and returns it to the calling context
        access(all) fun mintNFT(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty]
        ): @MaliciousNFT.NFT {

            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp

            // this piece of metadata will be used to show embedding rarity into a trait
            metadata["foo"] = "bar"

            // create a new NFT
            var newNFT <- create NFT(
                name: name,
                description: description,
                thumbnail: thumbnail,
                royalties: royalties,
                metadata: metadata,
            )

            return <-newNFT
        }
    }

    init() {

        // Set the named paths
        self.CollectionStoragePath = /storage/maliciousNFTCollection
        self.CollectionPublicPath = /public/maliciousNFTCollection
        self.MinterStoragePath = /storage/maliciousNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.storage.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        let collectionCap = self.account.capabilities.storage.issue<&MaliciousNFT.Collection>(self.CollectionStoragePath)
        self.account.capabilities.publish(collectionCap, at: self.CollectionPublicPath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.storage.save(<-minter, to: self.MinterStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/unlink_collection.cdc

```
/// This transaction unlinks signer's public Capability at canonical public path

import "MetadataViews"
import "ExampleNFT"

transaction {
    prepare(signer: auth(UnpublishCapabilty) &Account) {
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")
        signer.capabilities.unpublish(ExampleNFT.CollectionPublicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/nft-forwarding/change_forwarder_recipient.cdc

```
import "NonFungibleToken"
import "NFTForwarding"

/// This transaction updates the NFTForwarder recipient to the one given at the specified PublicPath
///
transaction(newRecipientAddress: Address, collectionPublicPath: PublicPath) {

    // reference to the NFTFowarder Resource
    let forwarderRef: auth(NFTForwarding.Mutable) &NFTForwarding.NFTForwarder
    // Collection we will designate as forwarding recipient
    let newRecipientCollection: Capability<&{NonFungibleToken.Collection}>

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow reference to NFTForwarder resource
        self.forwarderRef = signer.storage.borrow<auth(NFTForwarding.Mutable) &NFTForwarding.NFTForwarder>(
                from: NFTForwarding.StoragePath
            ) ?? panic("Could not borrow reference to NFTForwarder in the signer's account at path ".concat(NFTForwarding.StoragePath.toString()))

        // get Collection Capability from the recipientAddress account
        self.newRecipientCollection = getAccount(newRecipientAddress).capabilities.get<&{NonFungibleToken.Collection}>(
                collectionPublicPath
            )

    }

    execute {
        // set new recipient
        self.forwarderRef.changeRecipient(self.newRecipientCollection)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/test_helpers.cdc

```

import Test

access(all) fun deploy(_ contractName: String, _ path: String) {
    let err = Test.deployContract(
        name: contractName,
        path: path,
        arguments: [],
    )

    Test.expect(err, Test.beNil())
}

access(all) fun deployWithArgs(_ contractName: String, _ path: String, args: [AnyStruct]) {
    let err = Test.deployContract(
        name: contractName,
        path: path,
        arguments: args,
    )

    Test.expect(err, Test.beNil())
}

access(all) fun scriptExecutor(_ scriptName: String, _ arguments: [AnyStruct]): AnyStruct? {
    let scriptCode = loadCode(scriptName, "transactions/scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    if let failureError = scriptResult.error {
        panic(
            "Failed to execute the script because -:  ".concat(failureError.message)
        )
    }

    return scriptResult.returnValue
}

access(all) fun expectScriptFailure(_ scriptName: String, _ arguments: [AnyStruct]): String {
    let scriptCode = loadCode(scriptName, "transactions/scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    assert(scriptResult.error != nil, message: "script error was expected but there is no error message")
    return scriptResult.error!.message
}

access(all) fun txExecutor(_ txName: String, _ signers: [Test.TestAccount], _ arguments: [AnyStruct], _ expectedError: String?, _ expectedErrorType: ErrorType?): Bool {
    let txCode = loadCode(txName, "transactions")

    let authorizers: [Address] = []
    for signer in signers {
        authorizers.append(signer.address)
    }

    let tx = Test.Transaction(
        code: txCode,
        authorizers: authorizers,
        signers: signers,
        arguments: arguments,
    )

    let txResult = Test.executeTransaction(tx)
    if let err = txResult.error {
        if let expectedErrorMessage = expectedError {
            let ptr = getErrorMessagePointer(errorType: expectedErrorType!)
            let errMessage = err.message
            let hasEmittedCorrectMessage = contains(errMessage, expectedErrorMessage)
            let failureMessage = "Expecting - "
                .concat(expectedErrorMessage)
                .concat("\n")
                .concat("But received - ")
                .concat(err.message)
            assert(hasEmittedCorrectMessage, message: failureMessage)
            return true
        }
        panic(err.message)
    } else {
        if let expectedErrorMessage = expectedError {
            panic("Expecting error - ".concat(expectedErrorMessage).concat(". While no error triggered"))
        }
    }

    return txResult.status == Test.ResultStatus.succeeded
}

access(all) fun loadCode(_ fileName: String, _ baseDirectory: String): String {
    return Test.readFile("../".concat(baseDirectory).concat("/").concat(fileName))
}

access(all) enum ErrorType: UInt8 {
    access(all) case TX_PANIC
    access(all) case TX_ASSERT
    access(all) case TX_PRE
}

access(all) fun getErrorMessagePointer(errorType: ErrorType): Int {
    switch errorType {
        case ErrorType.TX_PANIC: return 159
        case ErrorType.TX_ASSERT: return 170
        case ErrorType.TX_PRE: return 174
        default: panic("Invalid error type")
    }
}

access(all) fun buildTypeIdentifier(_ acct: Test.TestAccount, _ contractName: String, _ suffix: String): String {
    let addrString = acct.address.toString()
    return "A.".concat(addrString.slice(from: 2, upTo: addrString.length)).concat(".").concat(contractName).concat(".").concat(suffix)
}

// Copied functions from flow-utils so we can assert on error conditions
// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/StringUtils.cdc
access(all) fun contains(_ s: String, _ substr: String): Bool {
    if let index = index(s, substr, 0) {
        return true
    }
    return false
}

// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/StringUtils.cdc
access(all) fun index(_ s: String, _ substr: String, _ startIndex: Int): Int? {
    for i in range(startIndex, s.length - substr.length + 1) {
        if s[i] == substr[0] && s.slice(from: i, upTo: i + substr.length) == substr {
            return i
        }
    }
    return nil
}

// https://github.com/green-goo-dao/flow-utils/blob/main/cadence/contracts/ArrayUtils.cdc
access(all) fun rangeFunc(_ start: Int, _ end: Int, _ f: (fun (Int): Void)) {
    var current = start
    while current < end {
        f(current)
        current = current + 1
    }
}

access(all) fun range(_ start: Int, _ end: Int): [Int] {
    let res: [Int] = []
    rangeFunc(start, end, fun (i: Int) {
        res.append(i)
    })
    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/test/ExampleNFT_preCrossVMPointer.cdc

```
/*
*
*  This is an example implementation of a Flow Non-Fungible Token
*  using the V2 standard.
*  It is not part of the official standard but it assumed to be
*  similar to how many NFTs would implement the core functionality.
*
*  This contract does not implement any sophisticated classification
*  system for its NFTs. It defines a simple NFT with minimal metadata.
*
*/

import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

access(all) contract ExampleNFT: NonFungibleToken {

    /// Standard Paths
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath

    /// Path where the minter should be stored
    /// The standard paths for the collection are stored in the collection resource type
    access(all) let MinterStoragePath: StoragePath

    /// We choose the name NFT here, but this type can have any name now
    /// because the interface does not require it to have a specific name any more
    access(all) resource NFT: NonFungibleToken.NFT {

        access(all) let id: UInt64

        /// From the Display metadata view
        access(all) let name: String
        access(all) let description: String
        access(all) let thumbnail: String

        /// For the Royalties metadata view
        access(self) let royalties: [MetadataViews.Royalty]

        /// Generic dictionary of traits the NFT has
        access(self) let metadata: {String: AnyStruct}

        init(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
        ) {
            self.id = self.uuid
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.royalties = royalties
            self.metadata = metadata
        }

        /// createEmptyCollection creates an empty Collection
        /// and returns it to the caller so that they can own NFTs
        /// @{NonFungibleToken.Collection}
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Example NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://example-nft.onflow.org/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    // foo is a trait with its own rarity
                    let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
                    let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
                    traitsView.addTrait(fooTrait)

                    return traitsView
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Implementing this view gives the project control over how the bridged NFT is represented as an
                    // ERC721 when bridged to EVM on Flow via the public infrastructure bridge.

                    // Get the contract-level name and symbol values
                    let contractLevel = ExampleNFT.resolveContractView(
                            resourceType: nil,
                            viewType: Type<MetadataViews.EVMBridgedMetadata>()
                        ) as! MetadataViews.EVMBridgedMetadata?

                    if let contractMetadata = contractLevel {
                        // Compose the token-level URI based on a base URI and the token ID, pointing to a JSON file. This
                        // would be a file you've uploaded and are hosting somewhere - in this case HTTP, but this could be
                        // IPFS, S3, a data URL containing the JSON directly, etc.
                        let baseURI = "https://example-nft.onflow.org/token-metadata/"
                        let uriValue = self.id.toString().concat(".json")

                        return MetadataViews.EVMBridgedMetadata(
                            name: contractMetadata.name,
                            symbol: contractMetadata.symbol,
                            uri: MetadataViews.URI(
                                baseURI: baseURI, // defining baseURI results in a concatenation of baseURI and value
                                value: self.id.toString().concat(".json")
                            )
                        )
                    } else {
                        return nil
                    }
            }
            return nil
        }
    }

    // Deprecated: Only here for backward compatibility.
    access(all) resource interface ExampleNFTCollectionPublic {}

    access(all) resource Collection: NonFungibleToken.Collection, ExampleNFTCollectionPublic {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an `UInt64` ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init () {
            self.ownedNFTs <- {}
        }

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@ExampleNFT.NFT>()] = true
            return supportedTypes
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            return type == Type<@ExampleNFT.NFT>()
        }

        /// withdraw removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("ExampleNFT.Collection.withdraw: Could not withdraw an NFT with ID "
                        .concat(withdrawID.toString())
                        .concat(". Check the submitted ID to make sure it is one that this collection owns."))

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @ExampleNFT.NFT
            let id = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken

            // This code is for testing purposes only
            // Do not add to your contract unless you have a specific
            // reason to want to emit the NFTUpdated event somewhere
            // in your contract
            let authTokenRef = (&self.ownedNFTs[id] as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT}?)!
            //authTokenRef.updateTransferDate(date: getCurrentBlock().timestamp)
            ExampleNFT.emitNFTUpdated(authTokenRef)
        }

        /// getIDs returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: self.CollectionStoragePath,
                    publicPath: self.CollectionPublicPath,
                    publicCollection: Type<&ExampleNFT.Collection>(),
                    publicLinkedType: Type<&ExampleNFT.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://example-nft.onflow.org"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                // Implementing this view gives the project control over how the bridged NFT is represented as an ERC721
                // when bridged to EVM on Flow via the public infrastructure bridge.

                // Compose the contract-level URI. In this case, the contract metadata is located on some HTTP host,
                // but it could be IPFS, S3, a data URL containing the JSON directly, etc.
                return MetadataViews.EVMBridgedMetadata(
                    name: "ExampleNFT",
                    symbol: "XMPL",
                    uri: MetadataViews.URI(
                        baseURI: nil, // setting baseURI as nil sets the given value as the uri field value
                        value: "https://example-nft.onflow.org/contract-metadata.json"
                    )
                )
        }
        return nil
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    access(all) resource NFTMinter {

        /// mintNFT mints a new NFT with a new ID
        /// and returns it to the calling context
        access(all) fun mintNFT(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty]
        ): @ExampleNFT.NFT {

            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp

            // this piece of metadata will be used to show embedding rarity into a trait
            metadata["foo"] = "bar"

            // create a new NFT
            var newNFT <- create NFT(
                name: name,
                description: description,
                thumbnail: thumbnail,
                royalties: royalties,
                metadata: metadata,
            )

            return <-newNFT
        }
    }

    init() {

        // Set the named paths
        self.CollectionStoragePath = /storage/exampleNFTCollection
        self.CollectionPublicPath = /public/exampleNFTCollection
        self.MinterStoragePath = /storage/exampleNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.storage.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        let collectionCap = self.account.capabilities.storage.issue<&ExampleNFT.Collection>(self.CollectionStoragePath)
        self.account.capabilities.publish(collectionCap, at: self.CollectionPublicPath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.storage.save(<-minter, to: self.MinterStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_collection_length_from_storage.cdc

```
import NonFungibleToken from "NonFungibleToken"
import MetadataViews from "MetadataViews"
import ExampleNFT from "ExampleNFT"

access(all) fun main(address: Address): Int {
    let account = getAuthAccount<auth(BorrowValue) &Account>(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collectionRef = account.storage.borrow<&{NonFungibleToken.Collection}>(
            from: collectionData.storagePath
            ) ?? panic("The account ".concat(address.toString())
                        .concat(" does not store an ExampleNFT.Collection object at the path ")
                        .concat(collectionData.storagePath.toString())
                        .concat(". The account must initialize their account with this collection first!"))

    return collectionRef.getLength()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/nft-forwarding/create_forwarder.cdc

```
import "NonFungibleToken"
import "MetadataViews"
import "NFTForwarding"

/// This transaction is what an account would run to set itself up to forward NFTs to a designated recipient's 
/// NFT.Collection assuming the recipient is configured for the given NFT Collection
///
transaction(recipientAddress: Address, collectionPublicPath: PublicPath) {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        
        // get Collection Capability from the recipientAddress account
        let recipientCollectionCap = getAccount(recipientAddress).capabilities.get<&{NonFungibleToken.Collection}>(
            collectionPublicPath
        )

        if !recipientCollectionCap.check() {
            panic("The recipient with address ".concat(recipientAddress.toString())
            .concat(" has not configured their account with an NFT Collection at the given public path ")
            .concat(collectionPublicPath.toString()).concat("."))
        }

        // create a new NFTForwarder resource & save in storage, forwarding to the recipient's Collection
        let forwarder <- NFTForwarding.createNewNFTForwarder(recipient: recipientCollectionCap)
        signer.storage.save(<-forwarder, to: NFTForwarding.StoragePath)

        // unpublish existing Collection capabilities from PublicPath
        signer.capabilities.unpublish(collectionPublicPath)

        // create & publish a capability for the forwarder where the collection would normally be
        let forwarderReceiverCap = signer.capabilities.storage.issue<&{NonFungibleToken.Receiver}>(NFTForwarding.StoragePath)
        signer.capabilities.publish(forwarderReceiverCap, at: collectionPublicPath)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/CODE_OF_CONDUCT.md

# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at os@dapperlabs.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_cross_vm_nft_view.cdc

```
import "ExampleNFT"
import "MetadataViews"
import "CrossVMMetadataViews"
import "ViewResolver"
import "EVM"

access(all) struct NFTView {
    access(all) let id: UInt64
    access(all) let name: String
    access(all) let symbol: String
    access(all) let nftType: Type
    access(all) let cadenceContractAddress: Address
    access(all) let nativeVM: CrossVMMetadataViews.VM
    access(all) let evmMetadata: String

    init(
        id: UInt64,
        name: String,
        symbol: String,
        nftType: Type,
        cadenceContractAddress: Address,
        nativeVM: CrossVMMetadataViews.VM,
        evmMetadata: String
    ) {
        self.id = id
        self.name = name
        self.symbol = symbol
        self.nftType = nftType
        self.cadenceContractAddress = cadenceContractAddress
        self.nativeVM = nativeVM
        self.evmMetadata = evmMetadata
    }
}

access(all) fun main(address: Address, id: UInt64): NFTView {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collection = account.capabilities.borrow<&ExampleNFT.Collection>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    let viewResolver = collection.borrowViewResolver(id: id) 
        ?? panic("Could not borrow resolver with given id ".concat(id.toString()))

    let evmBridgedMetadata = MetadataViews.getEVMBridgedMetadata(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMBridgedMetadata view"))
    let evmPointer = CrossVMMetadataViews.getEVMPointer(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMPointer view"))
    let evmBytesMetadata = CrossVMMetadataViews.getEVMBytesMetadata(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMBytesMetadata view"))

    let decodedBytesMetadata = EVM.decodeABI(types: [Type<String>()], data: evmBytesMetadata.bytes.value)
    let bytesMetadataAsString = decodedBytesMetadata[0] as! String


    return NFTView(
        id: id,
        name: evmBridgedMetadata.name,
        symbol: evmBridgedMetadata.symbol,
        nftType: evmPointer.cadenceType,
        cadenceContractAddress: evmPointer.cadenceContractAddress,
        nativeVM: evmPointer.nativeVM,
        evmMetadata: bytesMetadataAsString
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/nft_forwarding_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "ViewResolver"
import "NonFungibleToken"

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let forwarder = Test.createAccount()
access(all) let recipient = Test.createAccount()

access(all) let collectionStoragePath = /storage/exampleNFTCollection
access(all) let collectionPublicPath = /public/exampleNFTCollection

access(all) fun setup() {

    deploy("ViewResolver", "../contracts/ViewResolver.cdc")
    deploy("NonFungibleToken", "../contracts/NonFungibleToken.cdc")
    deploy("MetadataViews", "../contracts/MetadataViews.cdc")
    deploy("CrossVMMetadataViews", "../contracts/CrossVMMetadataViews.cdc")
    deploy("ExampleNFT", "../contracts/ExampleNFT.cdc")
    deploy("NFTForwarding", "../contracts/utility/NFTForwarding.cdc")
    
}

access(all) fun testCreateForwarderFails() {

    let expectedErrorMessage = "The recipient with address 0x000000000000001b has not configured their account with an NFT Collection at the given public path /public/exampleNFTCollection."
    let expectedErrorType = ErrorType.TX_PANIC
    
    // Setup Collection in forwarder
    let forwarderCollectionSetupSuccess: Bool = txExecutor("setup_account.cdc", [forwarder], [], nil, nil)
    Test.assertEqual(true, forwarderCollectionSetupSuccess)

    // Create forwarder in forwarding account should **fail** since recipient doesn't have Collection configured
    txExecutor(
        "nft-forwarding/create_forwarder.cdc",
        [forwarder],
        [recipient.address, collectionPublicPath],
        expectedErrorMessage,
        expectedErrorType
    )
}

access(all) fun testCreateForwarder() {
    // Setup Collection in recipient
    let recipientSetupSuccess: Bool = txExecutor("setup_account.cdc", [recipient], [], nil, nil)
    Test.assertEqual(true, recipientSetupSuccess)

    // Create forwarder in forwarding account
    let forwarderSetupSuccess: Bool = txExecutor(
            "nft-forwarding/create_forwarder.cdc",
            [forwarder],
            [recipient.address, collectionPublicPath],
            nil,
            nil
        )

    Test.assertEqual(true, recipientSetupSuccess)
    Test.assertEqual(true, forwarderSetupSuccess)
}

access(all) fun testMintNFT() {

    let expectedCollectionLength: Int = 1

    let royaltySetupSuccess: Bool = txExecutor(
            "setup_account_to_receive_royalty.cdc",
            [admin],
            [/storage/flowTokenVault],
            nil,
            nil
        )
    Test.assertEqual(true, royaltySetupSuccess)

    // Minting to forwarder should forward minted NFT to recipient
    let mintSuccess: Bool = txExecutor(
            "mint_nft.cdc",
            [admin],
            [
                forwarder.address,
                "NFT Name",
                "NFT Description",
                "NFT Thumbnail",
                [0.05],
                ["Creator Royalty"],
                [admin.address]
            ],
            nil,
            nil
        )
    Test.assertEqual(true, mintSuccess)

    // TODO: Uncomment once TestAccount bug fixed
    // let forwardEventType = CompositeType(buildTypeIdentifier(admin, "NFTForwarding", "ForwardedNFTDeposit"))!
    // Test.assertEqual(1, blockchain.eventsOfType(forwardEventType).length)

    let actualCollectionLength = scriptExecutor(
            "get_collection_length.cdc",
            [recipient.address],
        ) as! Int? ?? panic("problem retrieving collection length from recipient at expected path")

    Test.assertEqual(expectedCollectionLength, actualCollectionLength)
}

access(all) fun testChangeForwarderRecipient() {

    let newRecipient = Test.createAccount()

    let newRecipientSetupSuccess: Bool = txExecutor("setup_account.cdc", [newRecipient], [], nil, nil)
    Test.assertEqual(true, newRecipientSetupSuccess)

    let changeForwardingRecipientSuccess: Bool = txExecutor(
            "nft-forwarding/change_forwarder_recipient.cdc",
            [forwarder],
            [newRecipient.address, collectionPublicPath],
            nil,
            nil
        )
    Test.assertEqual(true, changeForwardingRecipientSuccess)

    let collectionIDs = scriptExecutor(
            "get_collection_ids.cdc",
            [recipient.address, collectionPublicPath],
        ) as! [UInt64]? ?? panic("problem retrieving NFT IDs from recipient at expected path")
    let transferID = collectionIDs[0]

    let transferSuccess: Bool = txExecutor(
        "transfer_nft.cdc",
        [recipient],
        [admin.address, "ExampleNFT", forwarder.address, transferID],
        nil,
        nil
    )
    Test.assertEqual(true, transferSuccess)

    let oldRecipientCollectionLength = scriptExecutor(
            "get_collection_length.cdc",
            [recipient.address],
        ) as! Int? ?? panic("problem retrieving collection length from recipient at expected path")

    let newRecipientIDs = scriptExecutor(
            "get_collection_ids.cdc",
            [newRecipient.address, collectionPublicPath],
        ) as! [UInt64]? ?? panic("problem retrieving NFT IDs from new recipient at expected path")
    let actualTransferID = newRecipientIDs[0]

    Test.assertEqual(0, oldRecipientCollectionLength)
    Test.assertEqual(transferID, actualTransferID)
}

access(all) fun testUnlinkForwarderLinkCollection() {

    // Forwarder should not have NFTs in collection to start
    let beginForwarderCollectionLength = scriptExecutor(
            "get_collection_length_from_storage.cdc",
            [forwarder.address],
        ) as! Int? ?? panic("problem retrieving collection length from forwarder at expected path")
    Test.assertEqual(0, beginForwarderCollectionLength)

    // Unlink forwarder and relink ExampleNFT Collection
    let unlinkSuccess: Bool = txExecutor(
            "nft-forwarding/unlink_forwarder_link_collection.cdc",
            [forwarder],
            [collectionStoragePath, collectionPublicPath],
            nil,
            nil)
    Test.assertEqual(true, unlinkSuccess)

    // Minting to forwarder should now minted NFT to recipient
    let mintSuccess: Bool = txExecutor(
            "mint_nft.cdc",
            [admin],
            [
                forwarder.address,
                "NFT Name",
                "NFT Description",
                "NFT Thumbnail",
                [0.05],
                ["Creator Royalty"],
                [admin.address]
            ],
            nil,
            nil
        )    

    // Confirm minted NFT went to forwarder's collection
    let endForwarderCollectionLength = scriptExecutor(
            "get_collection_length.cdc",
            [forwarder.address],
        ) as! Int? ?? panic("problem retrieving NFT IDs from new forwarder at expected path")
    Test.assertEqual(1, endForwarderCollectionLength)

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/scripts/get_nft_metadata.cdc

```
/// This script checks all views from MetadataViews for
/// a given NFT. Used for testing only.

import "ExampleNFT"
import "MetadataViews"

pub struct NFT {
    pub let name: String
    pub let description: String
    pub let thumbnail: String
    pub let owner: Address
    pub let type: String
    pub let royalties: [MetadataViews.Royalty]
    pub let externalURL: String
    pub let serialNumber: UInt64
    pub let collectionPublicPath: PublicPath
    pub let collectionStoragePath: StoragePath
    pub let collectionProviderPath: PrivatePath
    pub let collectionPublic: String
    pub let collectionPublicLinkedType: String
    pub let collectionProviderLinkedType: String
    pub let collectionName: String
    pub let collectionDescription: String
    pub let collectionExternalURL: String
    pub let collectionSquareImage: String
    pub let collectionBannerImage: String
    pub let collectionSocials: {String: String}
    pub let edition: MetadataViews.Edition
    pub let traits: MetadataViews.Traits
    pub let medias: MetadataViews.Medias?
    pub let license: MetadataViews.License?
    pub let bridgedName: String
    pub let symbol: String
    pub let tokenURI: String

    init(
        name: String,
        description: String,
        thumbnail: String,
        owner: Address,
        nftType: String,
        royalties: [MetadataViews.Royalty],
        externalURL: String,
        serialNumber: UInt64,
        collectionPublicPath: PublicPath,
        collectionStoragePath: StoragePath,
        collectionProviderPath: PrivatePath,
        collectionPublic: String,
        collectionPublicLinkedType: String,
        collectionProviderLinkedType: String,
        collectionName: String,
        collectionDescription: String,
        collectionExternalURL: String,
        collectionSquareImage: String,
        collectionBannerImage: String,
        collectionSocials: {String: String},
        edition: MetadataViews.Edition,
        traits: MetadataViews.Traits,
        medias: MetadataViews.Medias?,
        license: MetadataViews.License?,
        bridgedName: String,
        symbol: String,
        tokenURI: String
    ) {
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.owner = owner
        self.type = nftType
        self.royalties = royalties
        self.externalURL = externalURL
        self.serialNumber = serialNumber
        self.collectionPublicPath = collectionPublicPath
        self.collectionStoragePath = collectionStoragePath
        self.collectionProviderPath = collectionProviderPath
        self.collectionPublic = collectionPublic
        self.collectionPublicLinkedType = collectionPublicLinkedType
        self.collectionProviderLinkedType = collectionProviderLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionExternalURL = collectionExternalURL
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.collectionSocials = collectionSocials
        self.edition = edition
        self.traits = traits
        self.medias = medias
        self.license = license
        self.bridgedName = bridgedName
        self.symbol = symbol
        self.tokenURI = tokenURI
    }
}

pub fun main(address: Address, id: UInt64): Bool {
    let account = getAccount(address)

    let collection = account
        .getCapability(ExampleNFT.CollectionPublicPath)
        .borrow<&{ExampleNFT.ExampleNFTCollectionPublic}>()
        ?? panic("Could not borrow a reference to the collection")

    let nft = collection.borrowExampleNFT(id: id)!

    // Get the basic display information for this NFT
    let display = MetadataViews.getDisplay(nft)!

    // Get the royalty information for the given NFT
    let royaltyView = MetadataViews.getRoyalties(nft)!

    let externalURL = MetadataViews.getExternalURL(nft)!

    let collectionDisplay = MetadataViews.getNFTCollectionDisplay(nft)!
    let nftCollectionView = MetadataViews.getNFTCollectionData(nft)!

    let nftEditionView = MetadataViews.getEditions(nft)!
    let serialNumberView = MetadataViews.getSerial(nft)!

    let owner: Address = nft.owner!.address!
    let nftType = nft.getType()

    let collectionSocials: {String: String} = {}
    for key in collectionDisplay.socials.keys {
        collectionSocials[key] = collectionDisplay.socials[key]!.url
    }

    let traits = MetadataViews.getTraits(nft)!

    let medias = MetadataViews.getMedias(nft)
    let license = MetadataViews.getLicense(nft)

    let bridgedMetadata = MetadataViews.getEVMBridgedMetadata(nft)!

    let nftMetadata = NFT(
        name: display.name,
        description: display.description,
        thumbnail: display.thumbnail.uri(),
        owner: owner,
        nftType: nftType.identifier,
        royalties: royaltyView.getRoyalties(),
        externalURL: externalURL.url,
        serialNumber: serialNumberView.number,
        collectionPublicPath: nftCollectionView.publicPath,
        collectionStoragePath: nftCollectionView.storagePath,
        collectionProviderPath: nftCollectionView.providerPath,
        collectionPublic: nftCollectionView.publicCollection.identifier,
        collectionPublicLinkedType: nftCollectionView.publicLinkedType.identifier,
        collectionProviderLinkedType: nftCollectionView.providerLinkedType.identifier,
        collectionName: collectionDisplay.name,
        collectionDescription: collectionDisplay.description,
        collectionExternalURL: collectionDisplay.externalURL.url,
        collectionSquareImage: collectionDisplay.squareImage.file.uri(),
        collectionBannerImage: collectionDisplay.bannerImage.file.uri(),
        collectionSocials: collectionSocials,
        edition: nftEditionView.infoList[0],
        traits: traits,
        medias: medias,
        license: license,
        bridgedName: bridgedMetadata.name,
        symbol: bridgedMetadata.symbol,
        tokenURI: bridgedMetadata.uri.uri()
    )

    assert("NFT Name" == nftMetadata.name)
    assert("NFT Description" == nftMetadata.description)
    assert("NFT Thumbnail" == nftMetadata.thumbnail)
    assert(Address(0x0000000000000007) == nftMetadata.owner)
    assert("A.0000000000000007.ExampleNFT.NFT" == nftMetadata.type)
    assert("Creator Royalty" == nftMetadata.royalties[0].description)
    assert(Address(0x0000000000000007) == nftMetadata.royalties[0].receiver.address)
    assert(0.05 == nftMetadata.royalties[0].cut)
    assert("https://example-nft.onflow.org/0" == nftMetadata.externalURL)
    assert((0 as UInt64) == nftMetadata.serialNumber)
    assert(/public/exampleNFTCollection == nftMetadata.collectionPublicPath)
    assert(/storage/exampleNFTCollection == nftMetadata.collectionStoragePath)
    assert(/private/exampleNFTCollection == nftMetadata.collectionProviderPath)
    assert("&A.0000000000000007.ExampleNFT.Collection{A.0000000000000007.ExampleNFT.ExampleNFTCollectionPublic}" == nftMetadata.collectionPublic)
    assert("&A.0000000000000007.ExampleNFT.Collection{A.0000000000000007.ExampleNFT.ExampleNFTCollectionPublic,A.0000000000000001.NonFungibleToken.CollectionPublic,A.0000000000000001.NonFungibleToken.Receiver,A.0000000000000007.MetadataViews.ResolverCollection}" == nftMetadata.collectionPublicLinkedType)
    assert("&A.0000000000000007.ExampleNFT.Collection{A.0000000000000007.ExampleNFT.ExampleNFTCollectionPublic,A.0000000000000001.NonFungibleToken.CollectionPublic,A.0000000000000001.NonFungibleToken.Provider,A.0000000000000007.MetadataViews.ResolverCollection}" == nftMetadata.collectionProviderLinkedType)
    assert("The Example Collection" == nftMetadata.collectionName)
    assert("This collection is used as an example to help you develop your next Flow NFT." == nftMetadata.collectionDescription)
    assert("https://example-nft.onflow.org" == nftMetadata.collectionExternalURL)
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == nftMetadata.collectionSquareImage)
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == nftMetadata.collectionBannerImage)
    assert({"twitter": "https://twitter.com/flow_blockchain"} == nftMetadata.collectionSocials)
    assert("Example NFT Edition" == nftMetadata.edition.name)
    assert((0 as UInt64) == nftMetadata.edition.number)
    assert(nil == nftMetadata.edition.max)
    assert("Common" == nftMetadata.traits.traits[3]!.rarity!.description)
    assert(10.0 == nftMetadata.traits.traits[3]!.rarity!.score)
    assert(100.0 == nftMetadata.traits.traits[3]!.rarity!.max)
    assert(nil == nftMetadata.medias)
    assert(nil == nftMetadata.license)
    assert("ExampleNFT" == nftMetadata.bridgedName)
    assert("XMPL" == nftMetadata.symbol, message: "Symbol is ".concat(nftMetadata.symbol))
    assert("https://example-nft.onflow.org/token-metadata/".concat(id.toString()).concat(".json") == nftMetadata.tokenURI)

    let coll <- nftCollectionView.createEmptyCollection()
    assert(0 == coll.getIDs().length)
    destroy <- coll

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_collection_length.cdc

```
import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

access(all) fun main(address: Address): Int {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection}>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    return collectionRef.getLength()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_views.cdc

```
/// This script checks all the supported views from
/// a given NFT. Used for testing only.

import "NonFungibleToken"
import "MetadataViews"
import "ExampleNFT"

access(all) fun main(address: Address, id: UInt64): [Type] {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")
    
    let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection}>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat("The account must initialize their account with this collection first!"))

    // Borrow a reference to a specific NFT in the collection
    let nft = collectionRef.borrowNFT(id)
        ?? panic("Could not get a reference to the ExampleNFT NFT with id ".concat(id.toString()))
    return nft.getViews()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/.github/ISSUE_TEMPLATE/feature-request.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/.github/ISSUE_TEMPLATE.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature, SC-Eng
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/setup_account_to_receive_royalty.cdc

```
/// This transaction is a template for a transaction
/// to create a new link in their account to be used for receiving royalties
/// This transaction can be used for any fungible token, which is specified by the `vaultPath` argument
///
/// If the account wants to receive royalties in FLOW, they'll use `/storage/flowTokenVault`
/// If they want to receive it in USDC, they would use FiatToken.VaultStoragePath
/// and so on.
/// The path used for the public link is a new path that in the future, is expected to receive
/// and generic token, which could be forwarded to the appropriate vault

import "FungibleToken"
import "MetadataViews"

transaction(vaultPath: StoragePath) {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {

        // Return early if the account doesn't have a FungibleToken Vault
        if signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultPath) == nil {
            panic("Cannot setup the signer account to receive royalties: A vault for the specified fungible token path "
                   .concat(vaultPath.toString())
                   .concat(" does not exist. The account should initialize that Fungible Token in their storage first!"))
        }

        if signer.storage.type(at: vaultPath) == nil {
            panic("A vault for the specified fungible token path ".concat(" does not exist."))
        }

        // Create a public capability to the Vault that only exposes
        // the deposit function through the Receiver interface
        signer.capabilities.unpublish(MetadataViews.getRoyaltyReceiverPublicPath())
        let vaultCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(vaultPath)
        signer.capabilities.publish(vaultCap, at: MetadataViews.getRoyaltyReceiverPublicPath())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_contract_views.cdc

```
/// This script checks all the supported views from
/// the ExampleNFT contract. Used for testing only.

import "ExampleNFT"
import "MetadataViews"

access(all) fun main(): [Type] {
    return ExampleNFT.getContractViews(resourceType: nil)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_nft_metadata.cdc

```
/// This script gets all the view-based metadata associated with the specified NFT
/// and returns it as a single struct

import "ExampleNFT"
import "MetadataViews"

access(all) struct NFT {
    access(all) let name: String
    access(all) let description: String
    access(all) let thumbnail: String
    access(all) let owner: Address
    access(all) let type: String
    access(all) let royalties: [MetadataViews.Royalty]
    access(all) let externalURL: String
    access(all) let serialNumber: UInt64
    access(all) let collectionPublicPath: PublicPath
    access(all) let collectionStoragePath: StoragePath
    access(all) let collectionPublic: String
    access(all) let collectionPublicLinkedType: String
    access(all) let collectionName: String
    access(all) let collectionDescription: String
    access(all) let collectionExternalURL: String
    access(all) let collectionSquareImage: String
    access(all) let collectionBannerImage: String
    access(all) let collectionSocials: {String: String}
    access(all) let edition: MetadataViews.Edition
    access(all) let traits: MetadataViews.Traits
    access(all) let medias: MetadataViews.Medias?
    access(all) let license: MetadataViews.License?
    access(all) let bridgedName: String
    access(all) let symbol: String
    access(all) let tokenURI: String

    init(
        name: String,
        description: String,
        thumbnail: String,
        owner: Address,
        nftType: String,
        royalties: [MetadataViews.Royalty],
        externalURL: String,
        serialNumber: UInt64,
        collectionPublicPath: PublicPath,
        collectionStoragePath: StoragePath,
        collectionPublic: String,
        collectionPublicLinkedType: String,
        collectionName: String,
        collectionDescription: String,
        collectionExternalURL: String,
        collectionSquareImage: String,
        collectionBannerImage: String,
        collectionSocials: {String: String},
        edition: MetadataViews.Edition,
        traits: MetadataViews.Traits,
        medias:MetadataViews.Medias?,
        license:MetadataViews.License?,
        bridgedName: String,
        symbol: String,
        tokenURI: String
    ) {
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.owner = owner
        self.type = nftType
        self.royalties = royalties
        self.externalURL = externalURL
        self.serialNumber = serialNumber
        self.collectionPublicPath = collectionPublicPath
        self.collectionStoragePath = collectionStoragePath
        self.collectionPublic = collectionPublic
        self.collectionPublicLinkedType = collectionPublicLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionExternalURL = collectionExternalURL
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.collectionSocials = collectionSocials
        self.edition = edition
        self.traits = traits
        self.medias = medias
        self.license = license
        self.bridgedName = bridgedName
        self.symbol = symbol
        self.tokenURI = tokenURI
    }
}

access(all) fun main(address: Address, id: UInt64): NFT {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")
    
    let collection = account.capabilities.borrow<&ExampleNFT.Collection>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    let nft = collection.borrowNFT(id)
        ?? panic("Could not borrow a reference to an ExampleNFT NFT with id ".concat(id.toString()))

    // Get the basic display information for this NFT
    let display = MetadataViews.getDisplay(nft)!

    // Get the royalty information for the given NFT
    let royaltyView = MetadataViews.getRoyalties(nft)!

    let externalURL = MetadataViews.getExternalURL(nft)!

    let collectionDisplay = MetadataViews.getNFTCollectionDisplay(nft)!
    let nftCollectionView = MetadataViews.getNFTCollectionData(nft)!

    let nftEditionView = MetadataViews.getEditions(nft)!
    let serialNumberView = MetadataViews.getSerial(nft)!

    let owner: Address = nft.owner!.address!
    let nftType = nft.getType()

    let collectionSocials: {String: String} = {}
    for key in collectionDisplay.socials.keys {
        collectionSocials[key] = collectionDisplay.socials[key]!.url
    }

    let traits = MetadataViews.getTraits(nft)!

    let medias = MetadataViews.getMedias(nft)
    let license = MetadataViews.getLicense(nft)

    let bridgedMetadata = MetadataViews.getEVMBridgedMetadata(nft)!

    return NFT(
        name: display.name,
        description: display.description,
        thumbnail: display.thumbnail.uri(),
        owner: owner,
        nftType: nftType.identifier,
        royalties: royaltyView.getRoyalties(),
        externalURL: externalURL.url,
        serialNumber: serialNumberView.number,
        collectionPublicPath: nftCollectionView.publicPath,
        collectionStoragePath: nftCollectionView.storagePath,
        collectionPublic: nftCollectionView.publicCollection.identifier,
        collectionPublicLinkedType: nftCollectionView.publicLinkedType.identifier,
        collectionName: collectionDisplay.name,
        collectionDescription: collectionDisplay.description,
        collectionExternalURL: collectionDisplay.externalURL.url,
        collectionSquareImage: collectionDisplay.squareImage.file.uri(),
        collectionBannerImage: collectionDisplay.bannerImage.file.uri(),
        collectionSocials: collectionSocials,
        edition: nftEditionView.infoList[0],
        traits: traits,
        medias: medias,
        license: license,
        bridgedName: bridgedMetadata.name,
        symbol: bridgedMetadata.symbol,
        tokenURI: bridgedMetadata.uri.uri()
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/CONTRIBUTING.md

# Contributing to the Non-Fungible Token Standard

The following is a set of guidelines for contributing to the Flow NFT standard. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request.

#### Table Of Contents

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Pull Requests](#pull-requests)

[Styleguides](#styleguides)

- [Git Commit Messages](#git-commit-messages)

[Additional Notes](#additional-notes)


## How Can I Contribute?

You are free to contribute however you want! You can submit a bug report in an issue, suggest an enhancment, or even just make a PR for us to review. We just ask that you are clear in your communication and documentation of all your work so we can understand how you are trying to help.

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported. If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible. When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include screenshots and animated GIFs** which show you following the described steps and clearly demonstrate the problem. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

- **What's the name and version of the OS you're using**?
- **What's the name and version of the flow-cli that you are using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**. Include copy/pasteable snippets which you use in those examples, as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Include screenshots and animated GIFs**. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.
- **Explain why this enhancement would be useful** to be included in the standard.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

Before contributing, make sure to examine the project to get familiar with the patterns and style already being used.

### Git Commit Messages

- Use the present tense ("Add feature" not "Added feature")
- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
- Limit the first line to 72 characters or less
- Reference issues and pull requests liberally after the first line


### Additional Notes

Thank you for your interest in contributing to the Flow Token Standards!




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/nft-forwarding/unlink_forwarder_link_collection.cdc

```

import "NonFungibleToken"
import "MetadataViews"
import "NFTForwarding"

// This transaction replaces NFTForwarder Receiver Capabilities with a collection to its public storage after having configured
// its NFTForwarder
///
transaction(collectionStoragePath: StoragePath, receiverPublicPath: PublicPath) {

    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {
        
        // a collection is already published, do nothing - remember .NFTForwarder only conforms to NFT.Receiver
        if signer.capabilities.get<&{NonFungibleToken.Collection}>(receiverPublicPath).check() {
            return
        }

        // otherwise, unpublish the published Capability
        signer.capabilities.unpublish(receiverPublicPath)

        // create & publish a capability for the collection
        let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionStoragePath)
        signer.capabilities.publish(collectionCap, at: receiverPublicPath)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_contract_storage_path.cdc

```
import "MetadataViews"
import "ViewResolver"

access(all) fun main(addr: Address, name: String): StoragePath? {
    let t = Type<MetadataViews.NFTCollectionData>()
    let borrowedContract = getAccount(addr).contracts.borrow<&{ViewResolver}>(name: name)
        ?? panic("Could not borrow ViewResolver reference to the contract. Make sure the provided contract name "
                  .concat(name).concat(" and address ").concat(addr.toString()).concat(" are correct!"))

    let view = borrowedContract.resolveContractView(resourceType: nil, viewType: t)
    if view == nil {
        return nil
    }

    let cd = view! as! MetadataViews.NFTCollectionData
    return cd.storagePath
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/changesets/changesets/blob/main/docs/common-questions.md

# Common Questions

A quick list of common questions you might want answered to understand what changesets is doing, without going into minutiae or workflow.

## Changesets are automatically generated

Changesets are generated by the `yarn changeset` or `npx @changesets/cli` command. As long as you are following a changeset release flow, you shouldn't have any problems.

## Each changeset is its own file

We use random human readable names by default for these files to avoid collisions when generating them, but there's no harm that will come from renaming them.

## Changesets are automatically removed

When `changeset version` or equivalent command is run, all the changeset files are removed. This is so we only ever use a changeset once. This makes the `.changeset` folder a very bad place to store any other information.

## Changesets are markdown files with YAML front matter

The two parts of the file are for different purposes. You should feel free to edit both parts as much as you want.

- The markdown text is a summary of the changes that will be prepended to your changelog when you next run your version command.
- The YAML front matter describes what should be versioned by the version command

## I want to edit the summary or package bump types - is it safe to do that?

Editing the summary or package bump types is completely safe. You can even write changesets without the command if you want.

## Can I manually delete changesets?

You can, but you should be aware this will remove the intent to release communicated by the changeset, and should be done with caution.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/.github/PULL_REQUEST_TEMPLATE.md

Closes: #???

## Description

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review.
-->

______

For contributor use:

- [ ] Targeted PR against `master` branch
- [ ] Linked to Github issue with discussion and accepted design OR link to spec that describes this work.
- [ ] Re-reviewed `Files changed` in the Github PR explorer




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/generic_destroy_nft.cdc

```
/// This transaction withdraws one or more NFTs from the signers collection and destroys them
/// The NFTs must all be of the same type

/// Imports to replace with "from {Address}"
import "NonFungibleToken"
import "MetadataViews"
import "Burner"

/// @param contractAddress: The address of the contract for the NFTs you want to destroy
///                         Example: For Top Shot on mainnet, 0x0b2a3299cc857e29
/// @param contractName: The name of the contract for the NFTs you want to destroy.
///                      Example: "TopShot", "AllDay", etc
/// @param nftTypeName: The name of the NFT type you want to destroy.
///                     99% of the time it is "NFT"
/// @param ids: An array of ID of the NFTs you would like to destroy

/// Replace each instance of the params above with the values that you want to use
/// Example (With Top Shot):
/// transaction(contractAddress: 0x0b2a3299cc857e29, contractName: "TopShot", nftTypeName: "NFT", ids: [14337, 337282, 3722711]) {

transaction(contractAddress: Address, contractName: String, nftTypeName: String, ids: [UInt64]) {

    /// The string representation of the NFT type
    let typeString: String

    /// The NFT type to be destroyed
    let type: Type?

    /// NFTCollectionData struct to get paths from
    let collectionData: MetadataViews.NFTCollectionData

    /// Reference to the owner's collection to destroy NFTs from
    let withdrawRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}

    prepare(signer: auth(BorrowValue) &Account) {
        // Borrow a reference to the nft contract deployed to the passed account
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{NonFungibleToken}>(name: contractName)
                ?? panic("Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name "
                          .concat(contractName).concat(" and address ").concat(contractAddress.toString()).concat(" are correct!"))

        // Get the string representation of the address without the 0x
        var addressString = contractAddress.toString()
        if addressString.length == 18 {
            addressString = addressString.slice(from: 2, upTo: 18)
        }

        self.typeString = "A.".concat(addressString).concat(".").concat(contractName).concat(".").concat(nftTypeName)
        self.type = CompositeType(self.typeString)
        
        assert(
            self.type != nil,
            message: "Could not create a type out of the contract name "
                    .concat(contractName)
                    .concat(" and address ")
                    .concat(addressString)
                    .concat("!")
        )

        // Use that reference to retrieve the NFTCollectionData view 
        self.collectionData = resolverRef.resolveContractView(resourceType: self.type!, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))

        // borrow a reference to the signer's NFT collection
        self.withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: self.collectionData.storagePath
            ) ?? panic("The signer does not store a "
                        .concat(contractName)
                        .concat(" Collection object at the path ")
                        .concat(self.collectionData.storagePath.toString())
                        .concat("The signer must initialize their account with this collection first!"))
    }

    execute {

        // iterate through the ids and burn each one
        for id in ids {

            if self.withdrawRef.borrowNFT(id) == nil { continue }

            let tempNFT <- self.withdrawRef.withdraw(withdrawID: id)

            assert(
                tempNFT.getType() == self.type!,
                message: "The type NFT that was withdrawn to destroy <"
                        .concat(tempNFT.getType().identifier)
                        .concat("> is not the type that was requested <")
                        .concat(self.typeString).concat(">.")
            )

            Burner.burn(<-tempNFT)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/destroy_nft.cdc

```
/// This transaction withdraws an NFT from the signers collection and destroys it

import "NonFungibleToken"
import "MetadataViews"
import "ExampleNFT"
import "Burner"

transaction(id: UInt64) {

    /// Reference that will be used for the owner's collection
    let collectionRef: auth(NonFungibleToken.Withdraw) &ExampleNFT.Collection

    prepare(signer: auth(BorrowValue) &Account) {
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")
            
        // borrow a reference to the owner's collection
        self.collectionRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &ExampleNFT.Collection>(
                from: collectionData.storagePath
            ) ?? panic("The signer does not store an ExampleNFT.Collection object at the path "
                        .concat(collectionData.storagePath.toString())
                        .concat(". The signer must initialize their account with this collection first!"))

    }

    execute {

        // withdraw the NFT from the owner's collection
        let nft <- self.collectionRef.withdraw(withdrawID: id)

        Burner.burn(<-nft)
    }

    post {
        !self.collectionRef.getIDs().contains(id): "The NFT with the specified ID should have been deleted."
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/borrow_nft.cdc

```
// This script borrows an NFT from a collection

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

access(all) fun main(address: Address, id: UInt64) {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection}>(
            collectionData.publicPath
            ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                        .concat(collectionData.publicPath.toString())
                        .concat(". The account must initialize their account with this collection first!"))

    // Borrow a reference to a specific NFT in the collection
    let _ = collectionRef.borrowNFT(id)
        ?? panic("The NFT with id ".concat(id.toString()).concat(" does not exist in the collection!"))
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/generic_transfer_with_address.cdc

```
import "NonFungibleToken"
import "MetadataViews"

#interaction (
  version: "1.0.0",
	title: "Generic NFT Transfer with Contract Address and Name",
	description: "Transfer any Non-Fungible Token by providing the contract address and name",
	language: "en-US",
)

/// Can pass in any contract address and name
/// This lets you choose the token you want to send because
/// the transaction gets the metadata from the provided contract.
///
/// @param to: The address to transfer the token to
/// @param id: The id of token to transfer
/// @param contractAddress: The address of the contract that defines the token being transferred
/// @param contractName: The name of the contract that defines the token being transferred. Ex: "ExampleNFT"
///
/// This transaction only works with NFTs that have the type name "NFT"
/// A different transaction is required for NFTs with a different type name
///
transaction(to: Address, id: UInt64, contractAddress: Address, contractName: String) {

    // The NFT resource to be transferred
    let tempNFT: @{NonFungibleToken.NFT}

    // NFTCollectionData struct to get paths from
    let collectionData: MetadataViews.NFTCollectionData

    prepare(signer: auth(BorrowValue) &Account) {

        // Borrow a reference to the nft contract deployed to the passed account
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{NonFungibleToken}>(name: contractName)
                ?? panic("Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name ("
                          .concat(contractName).concat(") and address (").concat(contractAddress.toString()).concat(") are correct!"))

        // Use that reference to retrieve the NFTCollectionData view 
        self.collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))


        // borrow a reference to the signer's NFT collection
        let withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: self.collectionData.storagePath
            ) ?? panic("The signer does not store a "
                        .concat(contractName)
                        .concat(" Collection object at the path ")
                        .concat(self.collectionData.storagePath.toString())
                        .concat(". The signer must initialize their account with this collection first!"))

        self.tempNFT <- withdrawRef.withdraw(withdrawID: id)

        // Get the string representation of the address without the 0x
        var addressString = contractAddress.toString()
        if addressString.length == 18 {
            addressString = addressString.slice(from: 2, upTo: 18)
        }
        let typeString: String = "A.".concat(addressString).concat(".").concat(contractName).concat(".NFT")
        let type = CompositeType(typeString)
        assert(
            type != nil,
            message: "Could not create a type out of the contract name "
                      .concat(contractName)
                      .concat(" and address ")
                      .concat(addressString)
                      .concat("!")
        )

        assert(
            self.tempNFT.getType() == type!,
            message: "The NFT that was withdrawn to transfer is not the type that was requested <"
                     .concat(typeString).concat(">.")
        )
    }

    execute {
        // get the recipients public account object
        let recipient = getAccount(to)

        // borrow a public reference to the receivers collection
        let receiverRef = recipient.capabilities.borrow<&{NonFungibleToken.Receiver}>(self.collectionData.publicPath)
            ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                        .concat(self.collectionData.publicPath.toString())
                        .concat(" that is capable of receiving a ")
                        .concat(contractName)
                        .concat(" NFT.")
                        .concat("The recipient must initialize their account with this collection and receiver first!"))

        // Deposit the NFT to the receiver
        receiverRef.deposit(token: <-self.tempNFT)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc

```
/**

## The Flow Non-Fungible Token standard

## `NonFungibleToken` contract

The interface that all Non-Fungible Token contracts should conform to.
If a user wants to deploy a new NFT contract, their contract should implement
The types defined here

/// Contributors (please add to this list if you contribute!):
/// - Joshua Hannan - https://github.com/joshuahannan
/// - Bastian Müller - https://twitter.com/turbolent
/// - Dete Shirley - https://twitter.com/dete73
/// - Bjarte Karlsen - https://twitter.com/0xBjartek
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Deniz Edincik - https://twitter.com/bluesign
///
/// Repo reference: https://github.com/onflow/flow-nft

## `NFT` resource interface

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource interface

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives developers the ability to define functions
that can use any type that implements these interfaces

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

import "ViewResolver"

/// The main NFT contract interface. Other NFT contracts will import
/// and implement this interface as well the interfaces defined in this interface
///
access(all) contract interface NonFungibleToken: ViewResolver {

    /// An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// An entitlement for allowing updates and update events for an NFT
    access(all) entitlement Update

    /// Event that contracts should emit when the metadata of an NFT is updated
    /// It can only be emitted by calling the `emitNFTUpdated` function
    /// with an `Update` entitled reference to the NFT that was updated
    /// The entitlement prevents spammers from calling this from other users' collections
    /// because only code within a collection or that has special entitled access
    /// to the collections methods will be able to get the entitled reference
    /// 
    /// The event makes it so that third-party indexers can monitor the events
    /// and query the updated metadata from the owners' collections.
    ///
    access(all) event Updated(type: String, id: UInt64, uuid: UInt64, owner: Address?)
    access(all) view fun emitNFTUpdated(_ nftRef: auth(Update) &{NonFungibleToken.NFT})
    {
        emit Updated(type: nftRef.getType().identifier, id: nftRef.id, uuid: nftRef.uuid, owner: nftRef.owner?.address)
    }


    /// Event that is emitted when a token is withdrawn,
    /// indicating the type, id, uuid, the owner of the collection that it was withdrawn from,
    /// and the UUID of the resource it was withdrawn from, usually a collection.
    ///
    /// If the collection is not in an account's storage, `from` will be `nil`.
    ///
    access(all) event Withdrawn(type: String, id: UInt64, uuid: UInt64, from: Address?, providerUUID: UInt64)

    /// Event that emitted when a token is deposited to a collection.
    /// Indicates the type, id, uuid, the owner of the collection that it was deposited to,
    /// and the UUID of the collection it was deposited to
    ///
    /// If the collection is not in an account's storage, `from`, will be `nil`.
    ///
    access(all) event Deposited(type: String, id: UInt64, uuid: UInt64, to: Address?, collectionUUID: UInt64)

    /// Interface that the NFTs must conform to
    ///
    access(all) resource interface NFT: ViewResolver.Resolver {

        /// unique ID for the NFT
        access(all) let id: UInt64

        /// Event that is emitted automatically every time a resource is destroyed
        /// The type information is included in the metadata event so it is not needed as an argument
        access(all) event ResourceDestroyed(id: UInt64 = self.id, uuid: UInt64 = self.uuid)

        /// createEmptyCollection creates an empty Collection that is able to store the NFT
        /// and returns it to the caller so that they can own NFTs
        ///
        /// @return A an empty collection that can store this NFT
        ///
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getLength() == 0: 
                    "NonFungibleToken.NFT.createEmptyCollection: Cannot create an empty collection! "
                    .concat("The created NonFungibleToken Collection has a non-zero length. ")
                    .concat(" A newly created collection must be empty!")
                result.isSupportedNFTType(type: self.getType()): 
                    "NonFungibleToken.NFT.createEmptyCollection: Cannot create an empty collection! "
                    .concat("The created NonFungibleToken Collection does not support NFTs of type <")
                    .concat(self.getType().identifier)
                    .concat(">. The collection must support NFTs of type <")
                    .concat(self.getType().identifier).concat(">.")
            }
        }

        /// Gets all the NFTs that this NFT directly owns
        ///
        /// @return A dictionary of all subNFTS keyed by type
        ///
        access(all) view fun getAvailableSubNFTS(): {Type: [UInt64]} {
            return {}
        }

        /// Get a reference to an NFT that this NFT owns
        /// Both arguments are optional to allow the NFT to choose
        /// how it returns sub NFTs depending on what arguments are provided
        /// For example, if `type` has a value, but `id` doesn't, the NFT 
        /// can choose which NFT of that type to return if there is a "default"
        /// If both are `nil`, then NFTs that only store a single NFT can just return
        /// that. This helps callers who aren't sure what they are looking for 
        ///
        /// @param type: The Type of the desired NFT
        /// @param id: The id of the NFT to borrow
        ///
        /// @return A structure representing the requested view.
        access(all) fun getSubNFT(type: Type, id: UInt64) : &{NonFungibleToken.NFT}? {
            return nil
        }
    }

    /// Interface to mediate withdrawals from a resource, usually a Collection
    ///
    access(all) resource interface Provider {

        // We emit withdraw events from the provider interface because conficting withdraw
        // events aren't as confusing to event listeners as conflicting deposit events

        /// withdraw removes an NFT from the collection and moves it to the caller
        /// It does not specify whether the ID is UUID or not
        ///
        /// @param withdrawID: The id of the NFT to withdraw from the collection
        /// @return @{NFT}: The NFT that was withdrawn
        ///
        access(Withdraw) fun withdraw(withdrawID: UInt64): @{NFT} {
            post {
                result.id == withdrawID: 
                    "NonFungibleToken.Provider.withdraw: Cannot withdraw NFT! "
                    .concat("The ID of the withdrawn NFT (")
                    .concat(result.id.toString())
                    .concat(") must be the same as the requested ID (")
                    .concat(withdrawID.toString())
                    .concat(").")
                emit Withdrawn(type: result.getType().identifier, id: result.id, uuid: result.uuid, from: self.owner?.address, providerUUID: self.uuid)
            }
        }
    }

    /// Interface to mediate deposits to the Collection
    ///
    access(all) resource interface Receiver {

        /// deposit takes an NFT as an argument and adds it to the Collection
        /// @param token: The NFT to deposit
        access(all) fun deposit(token: @{NFT})

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        /// @return A dictionary of types mapped to booleans indicating if this
        ///         reciever supports it
        access(all) view fun getSupportedNFTTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        /// @param type: An NFT type
        /// @return A boolean indicating if this receiver can recieve the desired NFT type
        access(all) view fun isSupportedNFTType(type: Type): Bool
    }

    /// Kept for backwards-compatibility reasons
    access(all) resource interface CollectionPublic {
        access(all) fun deposit(token: @{NFT})
        access(all) view fun getLength(): Int
        access(all) view fun getIDs(): [UInt64]
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void
        access(all) view fun borrowNFT(_ id: UInt64): &{NFT}?
    }

    /// Requirement for the concrete resource type in the implementing contract
    /// to implement this interface. Since this interface inherits from
    /// all the other necessary interfaces, resources that implement it do not 
    /// also need to include the other interfaces in their conformance lists
    ///
    access(all) resource interface Collection: Provider, Receiver, CollectionPublic, ViewResolver.ResolverCollection {

        /// Field that contains all the NFTs that the collection owns
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        /// deposit takes a NFT as an argument and stores it in the collection
        /// @param token: The NFT to deposit into the collection
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            pre {
                // We emit the deposit event in the `Collection` interface
                // because the `Collection` interface is almost always the final destination
                // of tokens and deposit emissions from custom receivers could be confusing
                // and hard to reconcile to event listeners
                emit Deposited(type: token.getType().identifier, id: token.id, uuid: token.uuid, to: self.owner?.address, collectionUUID: self.uuid)
            }
        }

        /// Gets the amount of NFTs stored in the collection
        /// @return An integer indicating the size of the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        /// Allows a given function to iterate through the list
        /// of owned NFT IDs in a collection without first
        /// having to load the entire list into memory
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void {
            self.ownedNFTs.forEachKey(f)
        }

        /// Borrows a reference to an NFT stored in the collection
        /// If the NFT with the specified ID is not in the collection,
        /// the function should return `nil` and not panic.
        ///
        /// @param id: The desired nft id in the collection to return a referece for.
        /// @return An optional reference to the NFT
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            post {
                (result == nil) || (result?.id == id): 
                    "NonFungibleToken.Collection.borrowNFT: Cannot borrow NFT reference! "
                    .concat("The ID of the returned reference (")
                    .concat(result!.id.toString())
                    .concat(") does not match the ID that was specified (")
                    .concat(id.toString())
                    .concat(")")
            }
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getType() == self.getType(): 
                    "NonFungibleToken.Collection.createEmptyCollection: Cannot create empty collection! "
                    .concat("The created collection type <")
                    .concat(result.getType().identifier)
                    .concat("> does not have the same type as the collection that was used to create it <")
                    .concat(self.getType().identifier)
                    .concat(">.")
                result.getLength() == 0:
                    "NonFungibleToken.Collection.createEmptyCollection: Cannot create empty collection! "
                    .concat("The created collection has a non-zero length.")
                    .concat(" A newly created collection must be empty!")
            }
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    /// @param nftType: The desired nft type to return a collection for.
    /// @return An array of NFT Types that the implementing contract defines.
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        post {
            result.getIDs().length == 0: 
                "NonFungibleToken.createEmptyCollection: Cannot create empty collection! "
                .concat("The created collection has a non-zero length. ")
                .concat("A newly created collection must be empty!")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_nft_view.cdc

```
import "ExampleNFT"
import "MetadataViews"
import "ViewResolver"

access(all) struct NFTView {
    access(all) let id: UInt64
    access(all) let uuid: UInt64
    access(all) let name: String
    access(all) let description: String
    access(all) let thumbnail: String
    access(all) let royalties: [MetadataViews.Royalty]
    access(all) let externalURL: String
    access(all) let collectionPublicPath: PublicPath
    access(all) let collectionStoragePath: StoragePath
    access(all) let collectionPublic: String
    access(all) let collectionPublicLinkedType: String
    access(all) let collectionName: String
    access(all) let collectionDescription: String
    access(all) let collectionExternalURL: String
    access(all) let collectionSquareImage: String
    access(all) let collectionBannerImage: String
    access(all) let collectionSocials: {String: String}
    access(all) let traits: MetadataViews.Traits

    init(
        id: UInt64,
        uuid: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        royalties: [MetadataViews.Royalty],
        externalURL: String,
        collectionPublicPath: PublicPath,
        collectionStoragePath: StoragePath,
        collectionPublic: String,
        collectionPublicLinkedType: String,
        collectionName: String,
        collectionDescription: String,
        collectionExternalURL: String,
        collectionSquareImage: String,
        collectionBannerImage: String,
        collectionSocials: {String: String},
        traits: MetadataViews.Traits
    ) {
        self.id = id
        self.uuid = uuid
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.royalties = royalties
        self.externalURL = externalURL
        self.collectionPublicPath = collectionPublicPath
        self.collectionStoragePath = collectionStoragePath
        self.collectionPublic = collectionPublic
        self.collectionPublicLinkedType = collectionPublicLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionExternalURL = collectionExternalURL
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.collectionSocials = collectionSocials
        self.traits = traits
    }
}

access(all) fun main(address: Address, id: UInt64): NFTView {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collection = account.capabilities.borrow<&ExampleNFT.Collection>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    let viewResolver = collection.borrowViewResolver(id: id) 
        ?? panic("Could not borrow resolver with given id ".concat(id.toString()))

    let nftView = MetadataViews.getNFTView(id: id, viewResolver : viewResolver)

    let collectionSocials: {String: String} = {}
    for key in nftView.collectionDisplay!.socials.keys {
        collectionSocials[key] = nftView.collectionDisplay!.socials[key]!.url
    }


    return NFTView(
        id: nftView.id,
        uuid: nftView.uuid,
        name: nftView.display!.name,
        description: nftView.display!.description,
        thumbnail: nftView.display!.thumbnail.uri(),
        royalties: nftView.royalties!.getRoyalties(),
        externalURL: nftView.externalURL!.url,
        collectionPublicPath: nftView.collectionData!.publicPath,
        collectionStoragePath: nftView.collectionData!.storagePath,
        collectionPublic: nftView.collectionData!.publicCollection.identifier,
        collectionPublicLinkedType: nftView.collectionData!.publicLinkedType.identifier,
        collectionName: nftView.collectionDisplay!.name,
        collectionDescription: nftView.collectionDisplay!.description,
        collectionExternalURL: nftView.collectionDisplay!.externalURL.url,
        collectionSquareImage: nftView.collectionDisplay!.squareImage.file.uri(),
        collectionBannerImage: nftView.collectionDisplay!.bannerImage.file.uri(),
        collectionSocials: collectionSocials,
        traits: nftView.traits!,
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/generic_transfer_with_paths.cdc

```
import "NonFungibleToken"

#interaction (
  version: "1.0.0",
	title: "Generic NFT Transfer with Paths",
	description: "Transfer any Non-Fungible Token by providing the paths for the source Collection and destination Collection",
	language: "en-US",
)

/// Can pass in any storage path and receiver path instead of just the default.
/// This lets you choose the token you want to send as well the capability you want to send it to.
///
/// Any token path can be passed as an argument here, so wallets should
/// should check argument values to make sure the intended token path is passed in
///
/// @param to: The address to transfer the token to
/// @param id: The id of the token to transfer
/// @param senderPathIdentifier: The string identifier of the storage path
///        where the token should be withdrawn from
/// @param receiverPathIdentifier: The string identifier of the public path
///        where the token should be deposited to
///
transaction(to: Address, id: UInt64, senderPathIdentifier: String, receiverPathIdentifier: String) {

    // The NFT resource to be transferred
    let tempNFT: @{NonFungibleToken.NFT}

    prepare(signer: auth(BorrowValue) &Account) {

        let storagePath = StoragePath(identifier: senderPathIdentifier)
            ?? panic("Could not construct a storage path from the provided path identifier string")

        // borrow a reference to the signer's NFT collection
        let withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: storagePath
            ) ?? panic("The signer does not store a NonFungibleToken Collection object at the path "
                        .concat(storagePath.toString())
                        .concat("The signer must initialize their account with this collection first!"))

        self.tempNFT <- withdrawRef.withdraw(withdrawID: id)
    }

    execute {
        let publicPath = PublicPath(identifier: receiverPathIdentifier)
            ?? panic("Could not construct a public path from the provided path identifier string \""
                      .concat(receiverPathIdentifier)
                      .concat("\"."))

        // get the recipients public account object
        let recipient = getAccount(to)

        // borrow a public reference to the receivers collection
        let receiverRef = recipient.capabilities.borrow<&{NonFungibleToken.Receiver}>(publicPath)
            ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                        .concat(publicPath.toString())
                        .concat(" that is capable of receiving a NFT.")
                        .concat("The recipient must initialize their account with this collection and receiver first!"))

        // Deposit the NFT to the receiver
        receiverRef.deposit(token: <-self.tempNFT)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_collection_data.cdc

```
import MetadataViews from "MetadataViews"
import ExampleNFT from "ExampleNFT"

access(all) fun main(): MetadataViews.NFTCollectionData? {
    return ExampleNFT.getCollectionData(nftType: Type<@ExampleNFT.NFT>()) as MetadataViews.NFTCollectionData?
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/scripts/resolve_nft_views.cdc

```
/// This script resolves all the supported views from
/// the ExampleNFT contract. Used for testing only.

import "ExampleNFT"
import "NonFungibleToken"
import "MetadataViews"

access(all) fun main(): Bool {
    // Call `resolveView` with invalid Type
    let view = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<String>())
    assert(nil == view)

    let collectionDisplay = ExampleNFT.resolveContractView(resourceType: nil, viewType: 
            Type<MetadataViews.NFTCollectionDisplay>()
        ) as! MetadataViews.NFTCollectionDisplay?
        ?? panic("ExampleNFT Collection did not resolve NFTCollectionDisplay view!")

    assert("The Example Collection" == collectionDisplay.name)
    assert("This collection is used as an example to help you develop your next Flow NFT." == collectionDisplay.description)
    assert("https://example-nft.onflow.org" == collectionDisplay.externalURL!.url)
    assert("https://twitter.com/flow_blockchain" == collectionDisplay.socials["twitter"]!.url)
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == collectionDisplay.squareImage.file.uri())
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == collectionDisplay.bannerImage.file.uri())

    let collectionData = (ExampleNFT.resolveContractView(resourceType: nil, viewType: 
        Type<MetadataViews.NFTCollectionData>()
    ) as! MetadataViews.NFTCollectionData?)!

    // The MetadataViews.NFTCollectionData returns a function (createEmptyCollection),
    // so it cannot be the return type of a script. That's why we perform
    // the assertions in this script.
    assert(ExampleNFT.CollectionStoragePath == collectionData.storagePath)
    assert(ExampleNFT.CollectionPublicPath == collectionData.publicPath)
    assert(Type<&ExampleNFT.Collection>() == collectionData.publicCollection)
    assert(Type<&ExampleNFT.Collection>() == collectionData.publicLinkedType)

    let coll <- collectionData.createEmptyCollection()
    assert(0 == coll.getLength())

    destroy <- coll

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md

---
status: implemented
flip: 636
authors: Bjarte Karslen (bjartek@find.xyz), Deniz Mert Edincik (Deniz@edincik.com), Brian Dilley (briandilley@briandilley.com)
sponsor: Peter Siemens (peter@dapperlabs.com)
updated: 2021-12-06
---

# FLIP 636: Non-Fungible Token Metadata

## Objective

This proposal will make it possible to create generic solutions that will interoperate
through views and not hard-coded NFT types. Want to create a marketplace? If you know
how to display a certain Type that defines a sellable Item, you can do so. And it will
work for any contract and any resource, not just a single one.

## Motivation

Currently there is no standard for defining NFT/resource metadata. At best, most implementations
employ a simple `{String: AnyStruct}` dictionary. Due to the various methods that NFT
authors use, it’s hard / impossible to create applications that use NFTs whether it be
for something as simple as viewing them or as complex as integrating them into a game
or application.

If you want to create an Auction contract on Flow today, you have to hardcode all the NFTs
you want to support. This will often lead to duplicated contracts and code and just lots
of things to maintain. This standard will enable you to create a single Auction contract
and define the Type of views you need to expose in your NFT in order to support the contract.
So it will enable a design-by-contract pattern where the creator of a contract can define
the views it requires and a NFT can tell what views they export.

All NFTs and contracts using NFTs on Flow are affected by this problem. This is most
visible in the number of contracts that Viv3 needs in order to support all their different
sellable items. With all the oncoming marketplaces/auction houses and things like that
coming to Flow, a good standard for NFTs will help everybody.

## User Benefit

We feel that a standard that authors can implement that enables easy consumption of metadata
will lead to more applications that integrate NFTs. This will make NFTs intrinsically more
useful and valuable to the end users holding the NFTs.

A user will be much more likely to transfer their NFT to other marketplaces and sell their NFT
in different ways with this solution. Without it, all marketplaces need to hardcode support
for all NFTs directly.

It will also open up the possibility to standardize on some shared structs like Royalty
and SaleItem/Auction.

Indirectly, users will benefit from the fact that Flow developers can put their development cycles to better use than integrating each new NFT contract to their platform.

## Design Proposal

The core of this proposal is to add the following interface and have the NFT resource implement it
```
pub resource interface ViewResolver {
  pub fun getViews() : [Type]
  pub fun resolveView(_ view:Type): AnyStruct?
}
```

We will also add default implementations for these methods so that no compatibility will be broken
for existing NFT solutions. The new NFT resource could look something like this:
```
pub resource NFT: INFT, ViewResolver {
    pub let id: UInt64
    pub fun getViews(): [Type] {
       return []
    }
    pub fun resolveView(_ view: Type): AnyStruct? {
        return nil
    }
}
```

We propose that all metadata be expressed in Cadence types. The `pub fun getViews(): [Type]`
method allows for discovery of the various types of metadata supported by the NFT by returning a `Type`
for each supported type of metadata. An instance of any supported type could then be retrieved by
calling the `pub fun resolveView(_ view: Type): AnyStruct?` method passing the desired type in as
an argument.

This proposal by no means precludes the use of member variable on the NFT resource itself. In fact,
ideally, all immutable data for an NFT is stored as immutable members of the NFT resource, and views
are resolved and created by accessing those immutable members.

### Supporting other resources besides NFTs

In order to support any other resource and resource collections, like marketplaces and fungible tokens, the following new interface is proposed:
```
pub resource interface ViewResolverCollection {
    pub fun borrowViewResolver(id: UInt64): &{ViewResolver}
    pub fun getIDs(): [UInt64]
}
```

This will allow any collection to be exposed as view resolvable.

For single resources that are stored as is like a fungible token or a profile contract you can just implement the `ViewResolver` interface directly.

### Basic Views

The most basic example is having `String` be a view. Think of this as `toString()` in Java or a `Stringer` implementation in Go. It is a way to view your NFT as a string.

The bigger brother of `String` would be `Display`. Here is how you could display an NFT in a wallet, marketplace or other user-facing application:
```
pub struct Display{
    pub let name: String
    pub let thumbnail: String
    pub let description: String

    // This is a field describing the source of this NFT. This could be Versus, Evolution, Chainmonsters, etc.
    pub let source: String

    init(name:String, thumbnail: String, description: String, source:String) {
        self.source=source
        self.name=name
        self.thumbnail=thumbnail
        self.description=description
    }
}
```

The data above is taken from what the [Blocto wallet](https://blocto.portto.io/) uses to display an NFT in their application.
 - Would it be wise to add some sort of link here to be able to know how to navigate to the source page for this resource?

### Other examples

For example, an NFT artwork implementation may want to allow for image data to be retrieved
as an `IPFSImage` struct:
```
struct IPFSImage {
    let url: String
    let ipfsHash: String
    let width: UInt32
    let height: UInt32
    let contentType: String
}
```

It could then be retrieved from the NFT using the following:
```
import ArtNFT from 0x01010101

let artwork = nft.resolveView(Type<ArtNFT.IPFSImage>()) as? ArtNFT.IPFSImage
```

Another suggestion for media from FIND is:
```
pub struct Media {
    pub let data: String
    pub let contentType: String
    pub let protocol: String

    init(data:String, contentType: String, protocol: String) {
        self.data=data
        self.protocol=protocol
        self.contentType=contentType
    }
}
```
Examples here are:

An image on IPFS:
data: QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4
contentType: image/jpeg
protocol: ipfs

An HTTP image:
data: https://test.find.xyz/find.png
contentType: image/jpeg
protocol: http

An on-chain image:
data: data:image/png;base64,SOMEPNGDATAURI/wD/
contentType: image/jpeg
protocol: data

The problem here is that the on-chain image can be quite large and you might not want to resolve those every time you fetch the media view. So what if we made a method on the struct that allowed you to retrieve the data/content instead?


The same NFT author may also want to expose other metadata about the artwork:
```
struct Artwork {
    let name: String
    let dateCreated: UInt64
    let medium: String
    let artistName: String
}

// ...

let artwork = nft.resolveView(Type<ArtNFT.Artwork>()) as? ArtNFT.Artwork
```

If an art piece had more than one image then they could be retrieved using an array type as such:
```
import ArtNFT from 0x01010101

// ...

let images = nft.resolveView(Type<[ArtNFT.IPFSImage]>()) as? [ArtNFT.IPFSImage]
```

Or if a more structured approach is desired the NFT author may want to create a composite struct:
```
struct ArtworkDetail {
    let artwork: Artwork
    let primaryImage: IPFSImage
    let secondaryImage: IPFSImage
}
```

Because this proposal relies on the Cadence type system, adding new view types for exposing various
types of metadata is trivial and very robust. A few examples that one might use as a view type are:

```
// an image
pub struct IPFSImage {
    pub let url: String
    pub let ipfsHash: String
    pub let width: UInt32
    pub let height: UInt32
    pub let contentType: String
}

// a video
pub struct IPFSVideo {
    pub let url: String
    pub let ipfsHash: String
    pub let width: UInt32
    pub let height: UInt32
    pub let codec: String
    pub let container: String
    pub let contentType: String
}

// a file stored on the blockchain
pub struct Mime {
    pub let type: String
    pub let bytes: [UInt8]
}

// a location on the planet
pub struct GeoPoint {
    pub let lat: UFix64
    pub let lng: UFix64
    pub let projection: String
}

// a file hosted by a web server with a hash for verifying its contents
pub struct URLWithHash {
    pub let url: String
    pub let hash: String?
    pub let hashAlgo: String?
}
```

## Drawbacks

This standard does not include any required ways to store the metadata, and therefore some of the metadata
could be dynamic, depending on how the NFTs are authored. This is a double edged sword; it allows for greater
flexibility, but also means that some of the metadata returned by an NFT’s view may not be immutable. This,
however, may be desirable. For instance, a game may allow an NFT to be used as a character in the game and
expose a view that exposes a member containing the character's health.

## Alternatives Considered

A number of alternatives were discussed [here](https://github.com/onflow/flow-nft/issues/9).

## Performance Implications

Due to the potentially dynamic nature of this proposal, the methods that return metadata views can be implemented
in any way that the NFT author sees fit which could lead to some non-performant implementations.

## Dependencies

This proposal builds on the existing NFT interface defined [here](https://github.com/onflow/flow-nft).

## Engineering Impact

Adhering to this standard will require contract authors to implement a few new methods as part of their NFT.
They will also likely need to import standard types into their contracts.

There may also need to be a committee, process, and code repository put in place for managing the standard metadata
types.

## Best Practices

NFT authors should do their best to implement as many views from the standard metadata set as appropriate for
their application.

NFT authors should document the views they support and contract creators should document the views they require.
It could be worth exploring a design-by-contract paradigm to formalize this in a forthcoming FLIP.

## Tutorials and Examples

The following examples show the flexibility of this proposal with varying implementations.

### Example 1

The Find project is going to be using metadata as lookup and index points. The project is available here:
https://github.com/findonflow/find

### Example 2

This example shows how you might implement this specification with the ability to add new view types to your NFT
contract after it has already been published through the use of a `ViewResolver` pattern.
[Gist available here](https://gist.github.com/briandilley/962e94682b7945d882fcd99702011ea4),
[Playground available here](https://play.onflow.org/a71203b9-a03a-47f9-ab70-7285fcf4c56a?type=account&id=0)

## Compatibility

Provided support for default methods on interfaces is added to Cadence, there are no backwards compatibility issues.
Short of that, NFT authors will need to add implementations for the new methods added to their contracts.

## User Impact

This feature can be rolled out with no fear of changes to the user. However documentation should be provided on how
they can change their contracts and add views.

## Related Issues

Defining how metadata stored is out of the scope of this proposal.

## Prior Art

None

## Questions and Discussion Topics

What post/pre conditions would be needed in the NFT methods (if any)?
Are the arguments strong enough?
Are more examples needed here or are the arguments strong enough?





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/scripts/get_cross_vm_nft_view.cdc

```
import "ExampleNFT"
import "NonFungibleToken"
import "MetadataViews"
import "CrossVMMetadataViews"
import "ViewResolver"
import "EVM"

access(all) struct NFTView {
    access(all) let id: UInt64
    access(all) let name: String
    access(all) let symbol: String
    access(all) let nftType: Type
    access(all) let cadenceContractAddress: Address
    access(all) let evmContractAddress: EVM.EVMAddress
    access(all) let nativeVM: CrossVMMetadataViews.VM
    access(all) let evmMetadata: String

    init(
        id: UInt64,
        name: String,
        symbol: String,
        nftType: Type,
        cadenceContractAddress: Address,
        evmContractAddress: EVM.EVMAddress,
        nativeVM: CrossVMMetadataViews.VM,
        evmMetadata: String
    ) {
        self.id = id
        self.name = name
        self.symbol = symbol
        self.nftType = nftType
        self.cadenceContractAddress = cadenceContractAddress
        self.evmContractAddress = evmContractAddress
        self.nativeVM = nativeVM
        self.evmMetadata = evmMetadata
    }
}

access(all) fun main(address: Address, id: UInt64): Bool {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

    let collection = account.capabilities.borrow<&ExampleNFT.Collection>(
            collectionData.publicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionData.publicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    let viewResolver = collection.borrowViewResolver(id: id) 
        ?? panic("Could not borrow resolver with given id ".concat(id.toString()))

    let evmBridgedMetadata = MetadataViews.getEVMBridgedMetadata(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMBridgedMetadata view"))
    let evmPointer = CrossVMMetadataViews.getEVMPointer(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMPointer view"))
    let evmBytesMetadata = CrossVMMetadataViews.getEVMBytesMetadata(viewResolver)
        ?? panic("Example NFT id ".concat(id.toString()).concat(" did not resolve EVMBytesMetadata view"))

    let decodedBytesMetadata = EVM.decodeABI(types: [Type<String>()], data: evmBytesMetadata.bytes.value)
    let bytesMetadataAsString = decodedBytesMetadata[0] as! String


    let nftViewResult = NFTView(
        id: id,
        name: evmBridgedMetadata.name,
        symbol: evmBridgedMetadata.symbol,
        nftType: evmPointer.cadenceType,
        cadenceContractAddress: evmPointer.cadenceContractAddress,
        evmContractAddress: evmPointer.evmContractAddress,
        nativeVM: evmPointer.nativeVM,
        evmMetadata: bytesMetadataAsString
    )

    let expectedEVMContractAddress = EVM.addressFromString("0x1234565789012345657890123456578901234565")
    let nft = viewResolver as! &{NonFungibleToken.NFT}
    let expectedDecodedMetadata = evmBridgedMetadata.uri.uri()

    assert("ExampleNFT" == nftViewResult.name)
    assert("XMPL" == nftViewResult.symbol)
    assert(Type<@ExampleNFT.NFT>() == nftViewResult.nftType)
    assert(Type<@ExampleNFT.NFT>().address == nftViewResult.cadenceContractAddress)
    assert(expectedEVMContractAddress.equals(nftViewResult.evmContractAddress))
    assert(CrossVMMetadataViews.VM.Cadence == nftViewResult.nativeVM)
    assert(expectedDecodedMetadata == nftViewResult.evmMetadata)

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/setup_account.cdc

```
/// This transaction is what an account would run
/// to set itself up to receive NFTs

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")

        // Return early if the account already has a collection
        if signer.storage.borrow<&ExampleNFT.Collection>(from: collectionData.storagePath) != nil {
            return
        }

        // Create a new empty collection
        let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())

        // save it to the account
        signer.storage.save(<-collection, to: collectionData.storagePath)

        // create a public capability for the collection
        signer.capabilities.unpublish(collectionData.publicPath)
        let collectionCap = signer.capabilities.storage.issue<&ExampleNFT.Collection>(collectionData.storagePath)
        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/docs/MetdataViews/MetadataViews_URI.md

# Struct `URI`

```cadence
pub struct URI {

    pub let baseURI: String?

    access(self) let value: String
}
```

View to represent a generic URI. May be used to represent the URI of
the NFT where the type of URI is not able to be determined (i.e. HTTP,
IPFS, etc.)

Implemented Interfaces:
  - `File`


### Initializer

```cadence
init(baseURI: String?, value: String?)
```


## Functions

### `uri()`

```cadence
view fun uri(): String
```
This function returns the uri for this file. If the `baseURI` is set,
this will be a concatenation of the `baseURI` and the `value`. If the
`baseURI` is not set, this will return the `value`.

Returns: The string containing the file uri

---





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/iterate_ids.cdc

```
import "NonFungibleToken"

access(all) fun main(ownerAddress: Address, limit: Int): Int {

    let response: [&{NonFungibleToken.NFT}] = []

    let account = getAuthAccount<auth(BorrowValue) &Account>(ownerAddress)

    account.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {

        if !type.isSubtype(of: Type<@{NonFungibleToken.Collection}>()) {

            return true
        }

        let storageCollection = account.storage.borrow<&{NonFungibleToken.Collection}>(from: path)!

        storageCollection.forEachID(fun (nftId: UInt64): Bool {

            let nft = storageCollection.borrowNFT(nftId)!

            response.append(nft)

            return response.length < limit
        })

        return response.length < limit
    })

    return response.length
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc

```
/*
    Description: Central Smart Contract for NBA TopShot

    This smart contract contains the core functionality for
    NBA Top Shot, created by Dapper Labs

    The contract manages the data associated with all the plays and sets
    that are used as templates for the Moment NFTs

    When a new Play wants to be added to the records, an Admin creates
    a new Play struct that is stored in the smart contract.

    Then an Admin can create new Sets. Sets consist of a public struct that
    contains public information about a set, and a private resource used
    to mint new moments based off of plays that have been linked to the Set.

    The admin resource has the power to do all of the important actions
    in the smart contract. When admins want to call functions in a set,
    they call their borrowSet function to get a reference
    to a set in the contract. Then, they can call functions on the set using that reference.

    In this way, the smart contract and its defined resources interact
    with great teamwork, just like the Indiana Pacers, the greatest NBA team
    of all time.

    When moments are minted, they are initialized with a MomentData struct and
    are returned by the minter.

    The contract also defines a Collection resource. This is an object that
    every TopShot NFT owner will store in their account
    to manage their NFT collection.

    The main Top Shot account will also have its own Moment collections
    it can use to hold its own moments that have not yet been sent to a user.

    Note: All state changing functions will panic if an invalid argument is
    provided or one of its pre-conditions or post conditions aren't met.
    Functions that don't modify state will simply return 0 or nil
    and those cases need to be handled by the caller.

    It is also important to remember that
    The Golden State Warriors blew a 3-1 lead in the 2016 NBA finals.

*/

import FungibleToken from 0xFUNGIBLETOKENADDRESS
import NonFungibleToken from 0xNFTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS
import ViewResolver from 0xVIEWRESOLVERADDRESS
import CrossVMMetadataViews from 0xCROSSVMMETADATAVIEWSADDRESS
import EVM from 0xEVMADDRESS

access(all) contract TopShot: NonFungibleToken {
    // -----------------------------------------------------------------------
    // TopShot deployment variables
    // -----------------------------------------------------------------------

    // The network the contract is deployed on
    access(all) view fun Network(): String { return ${NETWORK} }

    // The address to which royalties should be deposited
    access(all) view fun RoyaltyAddress(): Address { return 0xTOPSHOTROYALTYADDRESS }

    // The path to the Subedition Admin resource belonging to the Account
    // which the contract is deployed on
    access(all) view fun SubeditionAdminStoragePath(): StoragePath { return /storage/TopShotSubeditionAdmin}

    // -----------------------------------------------------------------------
    // TopShot contract Events
    // -----------------------------------------------------------------------

    // Emitted when a new Play struct is created
    access(all) event PlayCreated(id: UInt32, metadata: {String: String})
    // Emitted when a new series has been triggered by an admin
    access(all) event NewSeriesStarted(newCurrentSeries: UInt32)

    // Events for Set-Related actions
    //
    // Emitted when a new Set is created
    access(all) event SetCreated(setID: UInt32, series: UInt32)
    // Emitted when a new Play is added to a Set
    access(all) event PlayAddedToSet(setID: UInt32, playID: UInt32)
    // Emitted when a Play is retired from a Set and cannot be used to mint
    access(all) event PlayRetiredFromSet(setID: UInt32, playID: UInt32, numMoments: UInt32)
    // Emitted when a Set is locked, meaning Plays cannot be added
    access(all) event SetLocked(setID: UInt32)
    // Emitted when a Moment is minted from a Set
    access(all) event MomentMinted(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32, subeditionID: UInt32)

    // Events for Collection-related actions
    //
    // Emitted when a moment is withdrawn from a Collection
    access(all) event Withdraw(id: UInt64, from: Address?)
    // Emitted when a moment is deposited into a Collection
    access(all) event Deposit(id: UInt64, to: Address?)

    // Emitted when a Moment is destroyed
    access(all) event MomentDestroyed(id: UInt64)

    // Emitted when a Subedition is created
    access(all) event SubeditionCreated(subeditionID: UInt32, name: String, metadata: {String: String})

    // Emitted when a Subedition is linked to the specific Moment
    access(all) event SubeditionAddedToMoment(momentID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32)

    // -----------------------------------------------------------------------
    // TopShot contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // Series that this Set belongs to.
    // Series is a concept that indicates a group of Sets through time.
    // Many Sets can exist at a time, but only one series.
    access(all) var currentSeries: UInt32

    // Variable size dictionary of Play structs
    access(self) var playDatas: {UInt32: Play}

    // Variable size dictionary of SetData structs
    access(self) var setDatas: {UInt32: SetData}

    // Variable size dictionary of Set resources
    access(self) var sets: @{UInt32: Set}

    // The ID that is used to create Plays.
    // Every time a Play is created, playID is assigned
    // to the new Play's ID and then is incremented by 1.
    access(all) var nextPlayID: UInt32

    // The ID that is used to create Sets. Every time a Set is created
    // setID is assigned to the new set's ID and then is incremented by 1.
    access(all) var nextSetID: UInt32

    // The total number of Top shot Moment NFTs that have been created
    // Because NFTs can be destroyed, it doesn't necessarily mean that this
    // reflects the total number of NFTs in existence, just the number that
    // have been minted to date. Also used as global moment IDs for minting.
    access(all) var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // TopShot contract-level Composite Type definitions
    // -----------------------------------------------------------------------
    // These are just *definitions* for Types that this contract
    // and other accounts can use. These definitions do not contain
    // actual stored values, but an instance (or object) of one of these Types
    // can be created by this contract that contains stored values.
    // -----------------------------------------------------------------------

    // Play is a Struct that holds metadata associated
    // with a specific NBA play, like the legendary moment when
    // Ray Allen hit the 3 to tie the Heat and Spurs in the 2013 finals game 6
    // or when Lance Stephenson blew in the ear of Lebron James.
    //
    // Moment NFTs will all reference a single play as the owner of
    // its metadata. The plays are publicly accessible, so anyone can
    // read the metadata associated with a specific play ID
    //
    access(all) struct Play {
        // The unique ID for the Play
        access(all) let playID: UInt32

        // Stores all the metadata about the play as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        access(all) let metadata: {String: String}

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Play metadata cannot be empty"
            }
            self.playID = TopShot.nextPlayID
            self.metadata = metadata
        }

        /// This function is intended to backfill the Play on blockchain with a more detailed
        /// description of the Play. The benefit of having the description is that anyone would
        /// be able to know the story of the Play directly from Flow
        access(contract) fun updateTagline(tagline: String): UInt32 {
            self.metadata["Tagline"] = tagline

            TopShot.playDatas[self.playID] = self
            return self.playID
        }
    }

    // A Set is a grouping of Plays that have occured in the real world
    // that make up a related group of collectibles, like sets of baseball
    // or Magic cards. A Play can exist in multiple different sets.
    //
    // SetData is a struct that is stored in a field of the contract.
    // Anyone can query the constant information
    // about a set by calling various getters located
    // at the end of the contract. Only the admin has the ability
    // to modify any data in the private Set resource.
    //
    access(all) struct SetData {
        // Unique ID for the Set
        access(all) let setID: UInt32

        // Name of the Set
        // ex. "Times when the Toronto Raptors choked in the playoffs"
        access(all) let name: String

        // Series that this Set belongs to.
        // Series is a concept that indicates a group of Sets through time.
        // Many Sets can exist at a time, but only one series.
        access(all) let series: UInt32

        init(name: String) {
            pre {
                name.length > 0: "New Set name cannot be empty"
            }
            self.setID = TopShot.nextSetID
            self.name = name
            self.series = TopShot.currentSeries
        }
    }

    // Set is a resource type that contains the functions to add and remove
    // Plays from a set and mint Moments.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods.
    //
    // The admin can add Plays to a Set so that the set can mint Moments
    // that reference that playdata.
    // The Moments that are minted by a Set will be listed as belonging to
    // the Set that minted it, as well as the Play it references.
    //
    // Admin can also retire Plays from the Set, meaning that the retired
    // Play can no longer have Moments minted from it.
    //
    // If the admin locks the Set, no more Plays can be added to it, but
    // Moments can still be minted.
    //
    // If retireAll() and lock() are called back-to-back,
    // the Set is closed off forever and nothing more can be done with it.
    access(all) resource Set {
        // Unique ID for the set
        access(all) let setID: UInt32

        // Array of plays that are a part of this set.
        // When a play is added to the set, its ID gets appended here.
        // The ID does not get removed from this array when a Play is retired.
        access(contract) var plays: [UInt32]

        // Map of Play IDs that Indicates if a Play in this Set can be minted.
        // When a Play is added to a Set, it is mapped to false (not retired).
        // When a Play is retired, this is set to true and cannot be changed.
        access(contract) var retired: {UInt32: Bool}

        // Indicates if the Set is currently locked.
        // When a Set is created, it is unlocked
        // and Plays are allowed to be added to it.
        // When a set is locked, Plays cannot be added.
        // A Set can never be changed from locked to unlocked,
        // the decision to lock a Set it is final.
        // If a Set is locked, Plays cannot be added, but
        // Moments can still be minted from Plays
        // that exist in the Set.
        access(all) var locked: Bool

        // Mapping of Play IDs that indicates the number of Moments
        // that have been minted for specific Plays in this Set.
        // When a Moment is minted, this value is stored in the Moment to
        // show its place in the Set, eg. 13 of 60.
        access(contract) var numberMintedPerPlay: {UInt32: UInt32}

        init(name: String) {
            self.setID = TopShot.nextSetID
            self.plays = []
            self.retired = {}
            self.locked = false
            self.numberMintedPerPlay = {}

            // Create a new SetData for this Set and store it in contract storage
            TopShot.setDatas[self.setID] = SetData(name: name)
        }

        // addPlay adds a play to the set
        //
        // Parameters: playID: The ID of the Play that is being added
        //
        // Pre-Conditions:
        // The Play needs to be an existing play
        // The Set needs to be not locked
        // The Play can't have already been added to the Set
        //
        access(all) fun addPlay(playID: UInt32) {
            pre {
                TopShot.playDatas[playID] != nil: "Cannot add the Play to Set: Play doesn't exist."
                !self.locked: "Cannot add the play to the Set after the set has been locked."
                self.numberMintedPerPlay[playID] == nil: "The play has already beed added to the set."
            }

            // Add the Play to the array of Plays
            self.plays.append(playID)

            // Open the Play up for minting
            self.retired[playID] = false

            // Initialize the Moment count to zero
            self.numberMintedPerPlay[playID] = 0

            emit PlayAddedToSet(setID: self.setID, playID: playID)
        }

        // addPlays adds multiple Plays to the Set
        //
        // Parameters: playIDs: The IDs of the Plays that are being added
        //                      as an array
        //
        access(all) fun addPlays(playIDs: [UInt32]) {
            for play in playIDs {
                self.addPlay(playID: play)
            }
        }

        // retirePlay retires a Play from the Set so that it can't mint new Moments
        //
        // Parameters: playID: The ID of the Play that is being retired
        //
        // Pre-Conditions:
        // The Play is part of the Set and not retired (available for minting).
        //
        access(all) fun retirePlay(playID: UInt32) {
            pre {
                self.retired[playID] != nil: "Cannot retire the Play: Play doesn't exist in this set!"
            }

            if !self.retired[playID]! {
                self.retired[playID] = true

                emit PlayRetiredFromSet(setID: self.setID, playID: playID, numMoments: self.numberMintedPerPlay[playID]!)
            }
        }

        // retireAll retires all the plays in the Set
        // Afterwards, none of the retired Plays will be able to mint new Moments
        //
        access(all) fun retireAll() {
            for play in self.plays {
                self.retirePlay(playID: play)
            }
        }

        // lock() locks the Set so that no more Plays can be added to it
        //
        // Pre-Conditions:
        // The Set should not be locked
        access(all) fun lock() {
            if !self.locked {
                self.locked = true
                emit SetLocked(setID: self.setID)
            }
        }

        // mintMoment mints a new Moment and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        access(all) fun mintMoment(playID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this Play
            // to use as this Moment's serial number
            let numInPlay = self.numberMintedPerPlay[playID]!

            // Mint the new moment
            let newMoment: @NFT <- create NFT(
                serialNumber: numInPlay + UInt32(1),
                playID: playID,
                setID: self.setID,
                subeditionID: 0
            )

            // Increment the count of Moments minted for this Play
            self.numberMintedPerPlay[playID] = numInPlay + UInt32(1)

            return <-newMoment
        }

        // batchMintMoment mints an arbitrary quantity of Moments
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
        access(all) fun batchMintMoment(playID: UInt32, quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMoment(playID: playID))
                i = i + UInt64(1)
            }

            return <- newCollection
        }

        // mintMomentWithSubedition mints a new Moment with subedition and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //             subeditionID: The ID of the subedition within Edition that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        access(all) fun mintMomentWithSubedition(playID: UInt32, subeditionID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this subedition
            // to use as this Moment's serial number
            let subeditionRef = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            let numInSubedition = subeditionRef.getNumberMintedPerSubedition(
                setID: self.setID,
                playID: playID,
                subeditionID: subeditionID
            )

            // Mint the new moment
            let newMoment: @NFT <- create NFT(
                serialNumber: numInSubedition + UInt32(1),
                playID: playID,
                setID: self.setID,
                subeditionID: subeditionID
            )

            // Increment the count of Moments minted for this subedition
            subeditionRef.addToNumberMintedPerSubedition(
                setID: self.setID,
                playID: playID,
                subeditionID: subeditionID
            )

            subeditionRef.setMomentsSubedition(nftID: newMoment.id, subeditionID: subeditionID, setID: self.setID, playID: playID)

            self.numberMintedPerPlay[playID] = self.numberMintedPerPlay[playID]! + UInt32(1)

            return <- newMoment
        }

        // batchMintMomentWithSubedition mints an arbitrary quantity of Moments with subedition
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //             subeditionID: The ID of the subedition within Edition that the Moments references
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
        access(all) fun batchMintMomentWithSubedition(playID: UInt32, quantity: UInt64, subeditionID: UInt32): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMomentWithSubedition(playID: playID, subeditionID: subeditionID))
                i = i + UInt64(1)
            }

            return <-newCollection
        }

        access(all) view fun getPlays(): [UInt32] {
            return self.plays
        }

        access(all) view fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        access(all) view fun getNumMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    // Struct that contains all of the important data about a set
    // Can be easily queried by instantiating the `QuerySetData` object
    // with the desired set ID
    // let setData = TopShot.QuerySetData(setID: 12)
    //
    access(all) struct QuerySetData {
        access(all) let setID: UInt32
        access(all) let name: String
        access(all) let series: UInt32
        access(self) var plays: [UInt32]
        access(self) var retired: {UInt32: Bool}
        access(all) var locked: Bool
        access(self) var numberMintedPerPlay: {UInt32: UInt32}

        init(setID: UInt32) {
            pre {
                TopShot.sets[setID] != nil: "The set with the provided ID does not exist"
            }

            let set = (&TopShot.sets[setID] as &Set?)!
            let setData = TopShot.setDatas[setID]!

            self.setID = setID
            self.name = setData.name
            self.series = setData.series
            self.plays = set.getPlays()
            self.retired = set.getRetired()
            self.locked = set.locked
            self.numberMintedPerPlay = set.getNumMintedPerPlay()
        }

        access(all) view fun getPlays(): [UInt32] {
            return self.plays
        }

        access(all) view fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        access(all) view fun getNumberMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    access(all) struct MomentData {
        // The ID of the Set that the Moment comes from
        access(all) let setID: UInt32

        // The ID of the Play that the Moment references
        access(all) let playID: UInt32

        // The place in the edition that this Moment was minted
        // Otherwise know as the serial number
        access(all) let serialNumber: UInt32

        init(setID: UInt32, playID: UInt32, serialNumber: UInt32) {
            self.setID = setID
            self.playID = playID
            self.serialNumber = serialNumber
        }
    }

    // This is an implementation of a custom metadata view for Top Shot.
    // This view contains the play metadata.
    //
    access(all) struct TopShotMomentMetadataView {
        access(all) let fullName: String?
        access(all) let firstName: String?
        access(all) let lastName: String?
        access(all) let birthdate: String?
        access(all) let birthplace: String?
        access(all) let jerseyNumber: String?
        access(all) let draftTeam: String?
        access(all) let draftYear: String?
        access(all) let draftSelection: String?
        access(all) let draftRound: String?
        access(all) let teamAtMomentNBAID: String?
        access(all) let teamAtMoment: String?
        access(all) let primaryPosition: String?
        access(all) let height: String?
        access(all) let weight: String?
        access(all) let totalYearsExperience: String?
        access(all) let nbaSeason: String?
        access(all) let dateOfMoment: String?
        access(all) let playCategory: String?
        access(all) let playType: String?
        access(all) let homeTeamName: String?
        access(all) let awayTeamName: String?
        access(all) let homeTeamScore: String?
        access(all) let awayTeamScore: String?
        access(all) let seriesNumber: UInt32?
        access(all) let setName: String?
        access(all) let serialNumber: UInt32
        access(all) let playID: UInt32
        access(all) let setID: UInt32
        access(all) let numMomentsInEdition: UInt32?

        init(
            fullName: String?,
            firstName: String?,
            lastName: String?,
            birthdate: String?,
            birthplace: String?,
            jerseyNumber: String?,
            draftTeam: String?,
            draftYear: String?,
            draftSelection: String?,
            draftRound: String?,
            teamAtMomentNBAID: String?,
            teamAtMoment: String?,
            primaryPosition: String?,
            height: String?,
            weight: String?,
            totalYearsExperience: String?,
            nbaSeason: String?,
            dateOfMoment: String?,
            playCategory: String?,
            playType: String?,
            homeTeamName: String?,
            awayTeamName: String?,
            homeTeamScore: String?,
            awayTeamScore: String?,
            seriesNumber: UInt32?,
            setName: String?,
            serialNumber: UInt32,
            playID: UInt32,
            setID: UInt32,
            numMomentsInEdition: UInt32?
        ) {
            self.fullName = fullName
            self.firstName = firstName
            self.lastName = lastName
            self.birthdate = birthdate
            self.birthplace = birthplace
            self.jerseyNumber = jerseyNumber
            self.draftTeam = draftTeam
            self.draftYear = draftYear
            self.draftSelection = draftSelection
            self.draftRound = draftRound
            self.teamAtMomentNBAID = teamAtMomentNBAID
            self.teamAtMoment = teamAtMoment
            self.primaryPosition = primaryPosition
            self.height = height
            self.weight = weight
            self.totalYearsExperience = totalYearsExperience
            self.nbaSeason = nbaSeason
            self.dateOfMoment= dateOfMoment
            self.playCategory = playCategory
            self.playType = playType
            self.homeTeamName = homeTeamName
            self.awayTeamName = awayTeamName
            self.homeTeamScore = homeTeamScore
            self.awayTeamScore = awayTeamScore
            self.seriesNumber = seriesNumber
            self.setName = setName
            self.serialNumber = serialNumber
            self.playID = playID
            self.setID = setID
            self.numMomentsInEdition = numMomentsInEdition
        }
    }

    // The resource that represents the Moment NFTs
    //
    access(all) resource NFT: NonFungibleToken.NFT {
        // Global unique moment ID
        access(all) let id: UInt64

        // Struct of Moment metadata
        access(all) let data: MomentData

        init(serialNumber: UInt32, playID: UInt32, setID: UInt32, subeditionID: UInt32) {
            // Increment the global Moment IDs
            TopShot.totalSupply = TopShot.totalSupply + UInt64(1)

            self.id = TopShot.totalSupply

            // Set the metadata struct
            self.data = MomentData(setID: setID, playID: playID, serialNumber: serialNumber)

            emit MomentMinted(
                momentID: self.id,
                playID: playID,
                setID: self.data.setID,
                serialNumber: self.data.serialNumber,
                subeditionID: subeditionID
            )
        }

        // If the Moment is destroyed, emit an event to indicate
        // to outside observers that it has been destroyed
        access(all) event ResourceDestroyed(
            id: UInt64 = self.id,
            serialNumber: UInt32 =  self.data.serialNumber,
            playID: UInt32 =  self.data.playID,
            setID: UInt32 = self.data.setID
        )

        access(all) view fun name(): String {
            let fullName: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName") ?? ""
            let playType: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType") ?? ""
            return fullName
                .concat(" ")
                .concat(playType)
        }

        // The description of the Moment.
        // If the Tagline prop exists, use is as the description; else, build the description using set, series, and serial number.
        access(all) view fun description(): String {
            // Return early if the tagline is non-empty
            if let tagline = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Tagline") {
                return tagline
            }

            // Build the description using set name, series number, and serial number
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let serialNumber: String = self.data.serialNumber.toString()
            let seriesNumber: String = TopShot.getSetSeries(setID: self.data.setID)?.toString() ?? ""
            return "A series "
                .concat(seriesNumber)
                .concat(" ")
                .concat(setName)
                .concat(" moment with serial number ")
                .concat(serialNumber)
        }

        // All supported metadata views for the Moment including the Core NFT Views
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<TopShotMomentMetadataView>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<CrossVMMetadataViews.EVMPointer>(),
                Type<MetadataViews.EVMBridgedMetadata>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Medias>()
            ]
        }

        // resolves the view with the given type for the NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: MetadataViews.HTTPFile(url: self.thumbnail())
                    )
                // Custom metadata view unique to TopShot Moments
                case Type<TopShotMomentMetadataView>():
                    return TopShotMomentMetadataView(
                        fullName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName"),
                        firstName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FirstName"),
                        lastName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "LastName"),
                        birthdate: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthdate"),
                        birthplace: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthplace"),
                        jerseyNumber: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "JerseyNumber"),
                        draftTeam: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftTeam"),
                        draftYear: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftYear"),
                        draftSelection: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftSelection"),
                        draftRound: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftRound"),
                        teamAtMomentNBAID: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMomentNBAID"),
                        teamAtMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMoment"),
                        primaryPosition: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PrimaryPosition"),
                        height: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Height"),
                        weight: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Weight"),
                        totalYearsExperience: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TotalYearsExperience"),
                        nbaSeason: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "NbaSeason"),
                        dateOfMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DateOfMoment"),
                        playCategory: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayCategory"),
                        playType: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType"),
                        homeTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamName"),
                        awayTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamName"),
                        homeTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamScore"),
                        awayTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamScore"),
                        seriesNumber: TopShot.getSetSeries(setID: self.data.setID),
                        setName: TopShot.getSetName(setID: self.data.setID),
                        serialNumber: self.data.serialNumber,
                        playID: self.data.playID,
                        setID: self.data.setID,
                        numMomentsInEdition: TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID)
                    )
                case Type<MetadataViews.Editions>():
                    let name = self.getEditionName()
                    let max = TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID) ?? 0
                    let editionInfo = MetadataViews.Edition(name: name, number: UInt64(self.data.serialNumber), max: max > 0 ? UInt64(max) : nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        UInt64(self.data.serialNumber)
                    )
                case Type<MetadataViews.Royalties>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.Royalties>())
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(self.getMomentURL())
                case Type<MetadataViews.NFTCollectionData>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<CrossVMMetadataViews.EVMPointer>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<CrossVMMetadataViews.EVMPointer>())
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Project-defined ERC721 EVM contract stores baseURI, name, and symbol in its own contract storage
                    // Name, symbol, and baseURI below are only used for legacy bridge-deployed ERC721 contract
                    return MetadataViews.EVMBridgedMetadata(
                        name: "NBA Top Shot",
                        symbol: "NBAT",
                        uri: MetadataViews.URI(
                            baseURI: ${EVMBASEURI},
                            value: self.id.toString()
                        )
                    )
                case Type<MetadataViews.Traits>():
                    return self.resolveTraitsView()
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.mediumimage()
                                ),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.video()
                                ),
                                mediaType: "video/mp4"
                            )
                        ]
                    )
            }
            return nil
        }

        // resolves this NFT's Traits view
        access(all) fun resolveTraitsView(): MetadataViews.Traits {
            // sports radar team id
            let excludedNames: [String] = ["TeamAtMomentNBAID"]

            // Get subedition
            let subedition = TopShot.getSubeditionByNFTID(self.id)

            // Create a dictionary of this NFT's traits with default metadata
            var traits: {String: AnyStruct} = {
                "SeriesNumber": TopShot.getSetSeries(setID: self.data.setID),
                "SetName": TopShot.getSetName(setID: self.data.setID),
                "SerialNumber": self.data.serialNumber,
                "Locked": TopShotLocking.isLocked(nftRef: &self as &{NonFungibleToken.NFT}),
                "Subedition": subedition?.name ?? "Standard",
                "SubeditionID": subedition?.subeditionID ?? 0
            }

            // Add play specific data
            traits = self.mapPlayData(dict: traits)

            return MetadataViews.dictToTraits(dict: traits, excludedNames: excludedNames)
        }

        // Functions used for computing MetadataViews

        // mapPlayData helps build our trait map from play metadata
        // Returns: The trait map with all non-empty fields from play data added
        access(all) fun mapPlayData(dict: {String: AnyStruct}) : {String: AnyStruct} {
            let playMetadata = TopShot.getPlayMetaData(playID: self.data.playID) ?? {}
            for name in playMetadata.keys {
                let value = playMetadata[name] ?? ""
                if value != "" {
                    dict.insert(key: name, value)
                }
            }
            return dict
        }

        // getMomentURL
        // Returns: The computed external url of the moment
        access(all) view fun getMomentURL(): String {
            return "https://nbatopshot.com/moment/".concat(self.id.toString())
        }

        // getEditionName Moment's edition name is a combination of the Moment's setName and playID
        // `setName: #playID`
        access(all) view fun getEditionName(): String {
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let editionName = setName.concat(": #").concat(self.data.playID.toString())
            return editionName
        }

        access(all) view fun assetPath(): String {
            return "https://assets.nbatopshot.com/media/".concat(self.id.toString())
        }

        // returns a url to display an medium sized image
        access(all) view fun mediumimage(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("?width=512"), firstDelim: "&")
        }

        // a url to display a thumbnail associated with the moment
        access(all) view fun thumbnail(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("?width=256"), firstDelim: "&")
        }

        // a url to display a video associated with the moment
        access(all) view fun video(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("/video"), firstDelim: "?")
        }

        // appends and optional network param needed to resolve the media
        access(all) view fun appendOptionalParams(url: String, firstDelim: String): String {
            if TopShot.Network() == "testnet" {
                return url.concat(firstDelim).concat("testnet")
            }
            return url
        }

        // Create an empty Collection for TopShot NFTs and return it to the caller
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Plays, Sets, and Moments
    //
    access(all) resource Admin {
        // createPlay creates a new Play struct
        // and stores it in the Plays dictionary in the TopShot smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Player Name": "Kevin Durant", "Height": "7 feet"}
        //                               (because we all know Kevin Durant is not 6'9")
        //
        // Returns: the ID of the new Play object
        //
        access(all) fun createPlay(metadata: {String: String}): UInt32 {
            // Create the new Play
            var newPlay = Play(metadata: metadata)
            let newID = newPlay.playID

            // Increment the ID so that it isn't used again
            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)

            emit PlayCreated(id: newPlay.playID, metadata: metadata)

            // Store it in the contract storage
            TopShot.playDatas[newID] = newPlay

            return newID
        }

        /// Temporarily enabled so the description of the play can be backfilled
        /// Parameters: playID: The ID of the play to update
        ///             tagline: A string to be used as the tagline for the play
        /// Returns: The ID of the play
        access(all) fun updatePlayTagline(playID: UInt32, tagline: String): UInt32 {
            let tmpPlay = TopShot.playDatas[playID]
                ?? panic("playID does not exist")

            // Update the play's tagline
            tmpPlay.updateTagline(tagline: tagline)

            // Return the play's ID
            return playID
        }

        // createSet creates a new Set resource and stores it
        // in the sets mapping in the TopShot contract
        //
        // Parameters: name: The name of the Set
        //
        // Returns: The ID of the created set
        access(all) fun createSet(name: String): UInt32 {
            // Create the new Set
            var newSet <- create Set(name: name)

            // Increment the setID so that it isn't used again
            TopShot.nextSetID = TopShot.nextSetID + UInt32(1)

            let newID = newSet.setID

            emit SetCreated(setID: newSet.setID, series: TopShot.currentSeries)

            // Store it in the sets mapping field
            TopShot.sets[newID] <-! newSet

            return newID
        }

        // borrowSet returns a reference to a set in the TopShot
        // contract so that the admin can call methods on it
        //
        // Parameters: setID: The ID of the Set that you want to
        // get a reference to
        //
        // Returns: A reference to the Set with all of the fields
        // and methods exposed
        //
        access(all) view fun borrowSet(setID: UInt32): &Set {
            pre {
                TopShot.sets[setID] != nil: "Cannot borrow Set: The Set doesn't exist"
            }

            // Get a reference to the Set and return it
            // use `&` to indicate the reference to the object and type
            return (&TopShot.sets[setID] as &Set?)!
        }

        // startNewSeries ends the current series by incrementing
        // the series number, meaning that Moments minted after this
        // will use the new series number
        //
        // Returns: The new series number
        //
        access(all) fun startNewSeries(): UInt32 {
            // End the current series and start a new one
            // by incrementing the TopShot series number
            TopShot.currentSeries = TopShot.currentSeries + UInt32(1)

            emit NewSeriesStarted(newCurrentSeries: TopShot.currentSeries)

            return TopShot.currentSeries
        }

        // createSubeditionResource creates new SubeditionMap resource that
        // will be used to mint Moments with Subeditions
        access(all) fun createSubeditionAdminResource() {
            TopShot.account.storage.save<@SubeditionAdmin>(<- create SubeditionAdmin(), to: TopShot.SubeditionAdminStoragePath())
        }

        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        access(all) fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {
            let subeditionAdmin = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            subeditionAdmin.setMomentsSubedition(nftID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        access(all) fun createSubedition(name: String, metadata: {String: String}): UInt32 {
            let subeditionAdmin = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            return subeditionAdmin.createSubedition(name:name, metadata:metadata)
        }

        // createNewAdmin creates a new Admin resource
        //
        access(all) fun createNewAdmin(): @Admin {
            return <- create Admin()
        }
    }

    // This is the interface that users can cast their Moment Collection as
    // to allow others to deposit Moments into their Collection. It also allows for reading
    // the IDs of Moments in the Collection.
    /// Deprecated: This is no longer used for defining access control anymore.
    access(all) resource interface MomentCollectionPublic : NonFungibleToken.CollectionPublic {
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection})
        access(all) fun borrowMoment(id: UInt64): &NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTS
    //
    access(all) resource Collection: MomentCollectionPublic, NonFungibleToken.Collection {
        // Dictionary of Moment conforming tokens
        // NFT is a resource type with a UInt64 ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init() {
            self.ownedNFTs <- {}
        }

        // Return a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@NFT>()] = true
            return supportedTypes
        }

        // Return whether or not the given type is accepted by the collection
        // A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@NFT>() {
                return true
            }
            return false
        }

        // Return the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        // Create an empty Collection for TopShot NFTs and return it to the caller
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
        }

        // withdraw removes an Moment from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            // Borrow nft and check if locked
            let nft = self.borrowNFT(withdrawID)
                ?? panic("Cannot borrow: empty reference")

            if TopShotLocking.isLocked(nftRef: nft) {
                panic("Cannot withdraw: Moment is locked")
            }

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Moment does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: ids: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn moments
        //
        access(NonFungibleToken.Withdraw) fun batchWithdraw(ids: [UInt64]): @{NonFungibleToken.Collection} {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <- self.withdraw(withdrawID: id))
            }

            // Return the withdrawn tokens
            return <- batchCollection
        }

        // deposit takes a Moment and adds it to the Collections dictionary
        //
        // Paramters: token: the NFT to be deposited in the collection
        //
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            // Cast the deposited token as a TopShot NFT to make sure
            // it is the correct type
            let token <- token as! @NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection}) {
            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <- tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // lock takes a token id and a duration in seconds and locks
        // the moment for that duration
        access(NonFungibleToken.Update) fun lock(id: UInt64, duration: UFix64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            TopShot.emitNFTUpdated(&token as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT})

            // pass the token to the locking contract
            // store it again after it comes back
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.lockNFT(nft: <- token, duration: duration)

            destroy oldToken
        }

        // batchLock takes an array of token ids and a duration in seconds
        // it iterates through the ids and locks each for the specified duration
        access(NonFungibleToken.Update) fun batchLock(ids: [UInt64], duration: UFix64) {
            // Iterate through the ids and lock them
            for id in ids {
                self.lock(id: id, duration: duration)
            }
        }

        // unlock takes a token id and attempts to unlock it
        // TopShotLocking.unlockNFT contains business logic around unlock eligibility
        access(NonFungibleToken.Update) fun unlock(id: UInt64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            TopShot.emitNFTUpdated(&token as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT})

            // Pass the token to the TopShotLocking contract then get it back
            // Store it back to the ownedNFTs dictionary
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.unlockNFT(nft: <- token)

            destroy oldToken
        }

        // batchUnlock takes an array of token ids
        // it iterates through the ids and unlocks each if they are eligible
        access(NonFungibleToken.Update) fun batchUnlock(ids: [UInt64]) {
            // Iterate through the ids and unlocks them
            for id in ids {
                self.unlock(id: id)
            }
        }

        // destroyMoments destroys moments in this collection
        // unlocks the moments if they are locked
        //
        // Parameters: ids: An array of NFT IDs
        // to be destroyed from the Collection
        access(NonFungibleToken.Update) fun destroyMoments(ids: [UInt64]) {
            let topShotLockingAdmin = TopShot.account.storage.borrow<&TopShotLocking.Admin>(from: TopShotLocking.AdminStoragePath())
                ?? panic("No TopShotLocking admin resource in storage")

            for id in ids {
                // Remove the nft from the Collection
                let token <- self.ownedNFTs.remove(key: id)
                    ?? panic("Cannot destroy: Moment does not exist in collection: ".concat(id.toString()))

                // Emit a withdraw event here so that platforms do not have to understand TopShot-specific events to see ownership change
                // A withdraw without a corresponding deposit means the NFT in question has no owner address
                emit Withdraw(id: id, from: self.owner?.address)

                // does nothing if the moment is not locked
                topShotLockingAdmin.unlockByID(id: id)

                destroy token
            }
        }

        // getIDs returns an array of the IDs that are in the Collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT Returns a borrowed reference to a Moment in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any topshot specific data. Please use borrowMoment to
        // read Moment data.
        //
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        // borrowMoment returns a borrowed reference to a Moment
        // so that the caller can read data and call methods from it.
        // They can use this to read its setID, playID, serialNumber,
        // or any of the setData or Play data associated with it by
        // getting the setID or playID and reading those fields from
        // the smart contract.
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        access(all) view fun borrowMoment(id: UInt64): &NFT? {
            return self.borrowNFT(id) as! &NFT?
        }

        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }
    }

    // -----------------------------------------------------------------------
    // TopShot contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Moments in transactions.
    //
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        if nftType != Type<@NFT>() {
            panic("NFT type is not supported")
        }
        return <- create TopShot.Collection()
    }

    // getAllPlays returns all the plays in topshot
    //
    // Returns: An array of all the plays that have been created
    access(all) view fun getAllPlays(): [Play] {
        return TopShot.playDatas.values
    }

    // getPlayMetaData returns all the metadata associated with a specific Play
    //
    // Parameters: playID: The id of the Play that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    access(all) view fun getPlayMetaData(playID: UInt32): {String: String}? {
        return self.playDatas[playID]?.metadata
    }

    // getPlayMetaDataByField returns the metadata associated with a
    //                        specific field of the metadata
    //                        Ex: field: "Team" will return something
    //                        like "Memphis Grizzlies"
    //
    // Parameters: playID: The id of the Play that is being searched
    //             field: The field to search for
    //
    // Returns: The metadata field as a String Optional
    access(all) view fun getPlayMetaDataByField(playID: UInt32, field: String): String? {
        // Don't force a revert if the playID or field is invalid
        if let play = TopShot.playDatas[playID] {
            return play.metadata[field]
        }
        return nil
    }

    // getSetData returns the data that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The QuerySetData struct that has all the important information about the set
    access(all) fun getSetData(setID: UInt32): QuerySetData? {
        if TopShot.sets[setID] == nil {
            return nil
        }
        return QuerySetData(setID: setID)
    }

    // getSetName returns the name that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The name of the Set
    access(all) view fun getSetName(setID: UInt32): String? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.name
    }

    // getSetSeries returns the series that the specified Set
    //              is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The series that the Set belongs to
    access(all) view fun getSetSeries(setID: UInt32): UInt32? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.series
    }

    // getSetIDsByName returns the IDs that the specified Set name
    //                 is associated with.
    //
    // Parameters: setName: The name of the Set that is being searched
    //
    // Returns: An array of the IDs of the Set if it exists, or nil if doesn't
    access(all) fun getSetIDsByName(setName: String): [UInt32]? {
        var setIDs: [UInt32] = []

        // Iterate through all the setDatas and search for the name
        for setData in TopShot.setDatas.values {
            if setName == setData.name {
                // If the name is found, return the ID
                setIDs.append(setData.setID)
            }
        }

        // If the name isn't found, return nil
        // Don't force a revert if the setName is invalid
        if setIDs.length == 0 {
            return nil
        }
        return setIDs
    }

    // getPlaysInSet returns the list of Play IDs that are in the Set
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: An array of Play IDs
    access(all) view fun getPlaysInSet(setID: UInt32): [UInt32]? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.plays
    }

    // isEditionRetired returns a boolean that indicates if a Set/Play combo
    //                  (otherwise known as an edition) is retired.
    //                  If an edition is retired, it still remains in the Set,
    //                  but Moments can no longer be minted from it.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: Boolean indicating if the edition is retired or not
    access(all) fun isEditionRetired(setID: UInt32, playID: UInt32): Bool? {
        // Return the retired status for the play in the set if it exists
        if let setdata = self.getSetData(setID: setID) {
            return setdata.getRetired()[playID]
        }
        return nil
    }

    // isSetLocked returns a boolean that indicates if a Set
    //             is locked. If it's locked,
    //             new Plays can no longer be added to it,
    //             but Moments can still be minted from Plays the set contains.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: Boolean indicating if the Set is locked or not
    access(all) view fun isSetLocked(setID: UInt32): Bool? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.locked
    }

    // getNumMomentsInEdition return the number of Moments that have been
    //                        minted from a certain edition.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: The total number of Moments
    //          that have been minted from an edition
    access(all) fun getNumMomentsInEdition(setID: UInt32, playID: UInt32): UInt32? {
        // Return the number of moments minted for the play in the set if it exists
        if let setdata = self.getSetData(setID: setID) {
            return setdata.getNumberMintedPerPlay()[playID]
        }
        return nil
    }

    // getMomentsSubedition returns the Subedition the Moment belongs to
    //
    // Parameters: nftID: The ID of the NFT
    //
    // returns: UInt32? Subedition's ID if exists
    //
    access(all) view fun getMomentsSubedition(nftID: UInt64): UInt32? {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.getMomentsSubedition(nftID: nftID)
    }

    // getAllSubeditions returns all the subeditions in topshot subeditionAdmin resource
    //
    // Returns: An array of all the subeditions that have been created
    access(all) view fun getAllSubeditions(): &[Subedition] {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas.values
    }

    // getSubeditionByID returns the subedition struct entity
    //
    // Parameters: subeditionID: The id of the Subedition that is being searched
    //
    // Returns: The Subedition struct
    access(all) view fun getSubeditionByID(subeditionID: UInt32): &Subedition {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas[subeditionID]!
    }

    // getSubeditionByNFTID returns the subedition struct that the NFT belongs to
    //
    // Parameters: nftID: The id of the NFT that is being searched
    //
    // Returns: The subedition struct that the NFT belongs to
    access(all) view fun getSubeditionByNFTID(_ nftID: UInt64): &Subedition? {
        if let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath()) {
            if let subeditionID = subeditionAdmin.getMomentsSubedition(nftID: nftID) {
                return subeditionAdmin.subeditionDatas[subeditionID]
            }
        }
        return nil
    }

    // This script reads the public nextSubeditionID from the SubeditionAdmin resource and
    // returns that number to the caller
    //
    // Returns: UInt32
    // the next number in nextSubeditionID from the SubeditionAdmin resource
    access(all) view fun getNextSubeditionID(): UInt32 {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.nextSubeditionID
    }

    // SubeditionAdmin is a resource that allows Set to mint Moments with Subeditions
    //
    access(all) struct Subedition {
        access(all) let subeditionID: UInt32

        access(all) let name: String

        access(all) let metadata: {String: String}

        init(subeditionID: UInt32, name: String, metadata: {String: String}) {
            pre {
                name.length != 0: "New Subedition name cannot be empty"
            }
            self.subeditionID = subeditionID
            self.name = name
            self.metadata = metadata
        }
    }

    access(all) resource SubeditionAdmin {
        // Map of number of already minted Moments using Subedition.
        // When a new Moment with Subedition is minted, 1 is added to the
        // number in this map by the key, formed by concatinating of
        // SetID, PlayID and SubeditionID
        access(contract) let numberMintedPerSubedition: {String: UInt32}

        // Map of Subedition which the Moment belongs to.
        // This map updates after each minting.
        access(contract) let momentsSubedition: {UInt64: UInt32}

        // The ID that is used to create Subeditions.
        // Every time a Subeditions is created, subeditionID is assigned
        // to the new Subedition's ID and then is incremented by 1.
        access(contract) var nextSubeditionID: UInt32

        // Variable size dictionary of Subedition structs
        access(contract) let subeditionDatas: {UInt32: Subedition}

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        access(all) fun createSubedition(name: String, metadata: {String: String}): UInt32 {
            let newID = self.nextSubeditionID

            var newSubedition = Subedition(subeditionID: newID, name: name, metadata: metadata)

            self.nextSubeditionID = self.nextSubeditionID + UInt32(1)

            self.subeditionDatas[newID] = newSubedition

            emit SubeditionCreated(subeditionID: newID, name: name, metadata: metadata)

            return newID
        }

        // getMomentsSubedition function that return's wich Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //
        // returns: UInt32? Subedition's ID if exists
        //
        access(all) view fun getMomentsSubedition(nftID: UInt64): UInt32? {
            return self.momentsSubedition[nftID]
        }

        // getNumberMintedPerSubedition function that return's
        // the number of Moments that have been minted for this subedition
        // to use as this Moment's serial number
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        // returns: UInt32 Number of Moments, already minted for this Subedition
        //
        access(all) fun getNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32): UInt32 {
            let setPlaySubedition = self.getSetPlaySubeditionString(setID, playID, subeditionID)
            if !self.numberMintedPerSubedition.containsKey(setPlaySubedition) {
                self.numberMintedPerSubedition.insert(key: setPlaySubedition, UInt32(0))
                return UInt32(0)
            }
            return self.numberMintedPerSubedition[setPlaySubedition]!
        }

        // addToNumberMintedPerSubedition function that increments 1 to the
        // number of Moments that have been minted for this subedition
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        //
        access(contract) fun addToNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32) {
            let setPlaySubedition = self.getSetPlaySubeditionString(setID, playID, subeditionID)

            // Get number of moments minted for this subedition
            let numberMinted = self.numberMintedPerSubedition[setPlaySubedition]
                ?? panic("Could not find number of moments minted for specified Subedition!")

            // Increment the number of moments minted for this subedition
            self.numberMintedPerSubedition[setPlaySubedition] = numberMinted + UInt32(1)
        }

        // getSetPlaySubeditionString builds a string that is used as a key in the numberMintedPerSubedition map
        access(self) view fun getSetPlaySubeditionString(_ setID: UInt32, _ playID: UInt32, _ subeditionID: UInt32): String {
            return setID.toString().concat(playID.toString()).concat(subeditionID.toString())
        }


        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        access(all) fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {
            pre {
                !self.momentsSubedition.containsKey(nftID) : "Subedition for this moment already exists!"
            }

            self.momentsSubedition.insert(key: nftID, subeditionID)

            emit SubeditionAddedToMoment(momentID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        init() {
            self.momentsSubedition = {}
            self.numberMintedPerSubedition = {}
            self.subeditionDatas = {}
            self.nextSubeditionID = 1
        }
    }

    //------------------------------------------------------------
    // Contract MetadataViews
    //------------------------------------------------------------

    // getContractViews returns the metadata view types available for this contract
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<CrossVMMetadataViews.EVMPointer>(),
            Type<MetadataViews.Royalties>()
        ]
    }

    // resolveContractView resolves this contract's metadata views
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        post {
            result == nil || result!.getType() == viewType: "The returned view must be of the given type or nil"
        }
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: /storage/MomentCollection,
                    publicPath: /public/MomentCollection,
                    publicCollection: Type<&Collection>(),
                    publicLinkedType: Type<&Collection>(),
                    createEmptyCollectionFunction: (fun (): @{NonFungibleToken.Collection} {
                        return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let bannerImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/img/top-shot-logo-horizontal-white.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let squareImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/favicon/favicon.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "NBA Top Shot",
                    description: "NBA Top Shot is your chance to own, sell, and trade official digital collectibles of the NBA and WNBA's greatest plays and players",
                    externalURL: MetadataViews.ExternalURL("https://nbatopshot.com"),
                    squareImage: squareImage,
                    bannerImage: bannerImage,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/nbatopshot"),
                        "discord": MetadataViews.ExternalURL("https://discord.com/invite/nbatopshot"),
                        "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nbatopshot")
                    }
                )
            case Type<MetadataViews.Royalties>():
                let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                    getAccount(TopShot.RoyaltyAddress()).capabilities.get<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())!
                return MetadataViews.Royalties(
                    [
                        MetadataViews.Royalty(
                            receiver: royaltyReceiver,
                            cut: 0.05,
                            description: "NBATopShot marketplace royalty"
                        )
                    ]
                )
            case Type<CrossVMMetadataViews.EVMPointer>():
                return CrossVMMetadataViews.EVMPointer(
                    cadenceType: Type<@TopShot.NFT>(),
                    cadenceContractAddress: self.account.address,
                    evmContractAddress: EVM.addressFromString(${EVMCONTRACTADDRESS}),
                    nativeVM: CrossVMMetadataViews.VM.Cadence
                )
        }
        return nil
    }

    // -----------------------------------------------------------------------
    // TopShot initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.currentSeries = 0
        self.playDatas = {}
        self.setDatas = {}
        self.sets <- {}
        self.nextPlayID = 1
        self.nextSetID = 1
        self.totalSupply = 0

        // Put a new Collection in storage
        self.account.storage.save<@Collection>(<- create Collection(), to: /storage/MomentCollection)

        // Create and publish a capability for the collection
        self.account.capabilities.publish(
            self.account.capabilities.storage.issue<&Collection>(/storage/MomentCollection),
            at: /public/MomentCollection
        )

        // Put the Minter in storage
        self.account.storage.save<@Admin>(<- create Admin(), to: /storage/TopShotAdmin)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/transactions/upgrade_nft_contract.cdc

```

transaction(code: [UInt8]) {

    prepare(acct: auth(UpdateContract) &Account) {

        acct.contracts.update__experimental(name: "NonFungibleToken", code: code)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/docs/MetdataViews/MetadataViews.md

# Contract `MetadataViews`

```cadence
pub contract MetadataViews {
}
```

This contract implements the metadata standard proposed
in FLIP-0636.

Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md

Structs and resources can implement one or more
metadata types, called views. Each view type represents
a different kind of metadata, such as a creator biography
or a JPEG image file.
## Interfaces
    
### `Resolver`

```cadence
pub resource interface Resolver {
}
```
Provides access to a set of metadata views. A struct or
resource (e.g. an NFT) can implement this interface to provide access to
the views that it supports.

---
    
### `ResolverCollection`

```cadence
pub resource interface ResolverCollection {
}
```
A group of view resolvers indexed by ID.

---
    
### `File`

```cadence
pub struct interface File {
}
```
Generic interface that represents a file stored on or off chain. Files
can be used to references images, videos and other media.

---
## Structs & Resources

### `NFTView`

```cadence
pub struct NFTView {

    pub let id: UInt64

    pub let uuid: UInt64

    pub let display: Display?

    pub let externalURL: ExternalURL?

    pub let collectionData: NFTCollectionData?

    pub let collectionDisplay: NFTCollectionDisplay?

    pub let royalties: Royalties?

    pub let traits: Traits?
}
```
NFTView wraps all Core views along `id` and `uuid` fields, and is used
to give a complete picture of an NFT. Most NFTs should implement this
view.

---

### `Display`

```cadence
pub struct Display {

    pub let name: String

    pub let description: String

    pub let thumbnail: AnyStruct{File}
}
```
Display is a basic view that includes the name, description and
thumbnail for an object. Most objects should implement this view.

---

### `HTTPFile`

```cadence
pub struct HTTPFile {

    pub let url: String
}
```
View to expose a file that is accessible at an HTTP (or HTTPS) URL.

---

### `IPFSFile`

```cadence
pub struct IPFSFile {

    pub let cid: String

    pub let path: String?
}
```
View to expose a file stored on IPFS.
IPFS images are referenced by their content identifier (CID)
rather than a direct URI. A client application can use this CID
to find and load the image via an IPFS gateway.

---

### `URI`

```cadence
pub struct URI {

    pub let baseURI: String?

    access(self) let value: String
}
```
View to represent a generic URI. May be used to represent the URI of
the NFT where the type of URI is not able to be determined (i.e. HTTP,
IPFS, etc.).

---

### `Edition`

```cadence
pub struct Edition {

    pub let name: String?

    pub let number: UInt64

    pub let max: UInt64?
}
```
Optional view for collections that issue multiple objects
with the same or similar metadata, for example an X of 100 set. This
information is useful for wallets and marketplaces.
An NFT might be part of multiple editions, which is why the edition
information is returned as an arbitrary sized array

---

### `Editions`

```cadence
pub struct Editions {

    pub let infoList: [Edition]
}
```
Wrapper view for multiple Edition views

---

### `Serial`

```cadence
pub struct Serial {

    pub let number: UInt64
}
```
View representing a project-defined serial number for a specific NFT
Projects have different definitions for what a serial number should be
Some may use the NFTs regular ID and some may use a different
classification system. The serial number is expected to be unique among
other NFTs within that project

---

### `Royalty`

```cadence
pub struct Royalty {

    pub let receiver: Capability<&AnyResource{FungibleToken.Receiver}>

    pub let cut: UFix64

    pub let description: String
}
```
View that defines the composable royalty standard that gives marketplaces a
unified interface to support NFT royalties.

---

### `Royalties`

```cadence
pub struct Royalties {

    priv let cutInfos: [Royalty]
}
```
Wrapper view for multiple Royalty views.
Marketplaces can query this `Royalties` struct from NFTs
and are expected to pay royalties based on these specifications.

---

### `Media`

```cadence
pub struct Media {

    pub let file: AnyStruct{File}

    pub let mediaType: String
}
```
View to represent, a file with an correspoiding mediaType.

---

### `Medias`

```cadence
pub struct Medias {

    pub let items: [Media]
}
```
Wrapper view for multiple media views

---

### `License`

```cadence
pub struct License {

    pub let spdxIdentifier: String
}
```
View to represent a license according to https://spdx.org/licenses/
This view can be used if the content of an NFT is licensed.

---

### `ExternalURL`

```cadence
pub struct ExternalURL {

    pub let url: String
}
```
View to expose a URL to this item on an external site.
This can be used by applications like .find and Blocto to direct users
to the original link for an NFT.

---

### `NFTCollectionData`

```cadence
pub struct NFTCollectionData {

    pub let storagePath: StoragePath

    pub let publicPath: PublicPath

    pub let providerPath: PrivatePath

    pub let publicCollection: Type

    pub let publicLinkedType: Type

    pub let providerLinkedType: Type

    pub let createEmptyCollection: ((): @NonFungibleToken.Collection)
}
```
View to expose the information needed store and retrieve an NFT.
This can be used by applications to setup a NFT collection with proper
storage and public capabilities.

---

### `NFTCollectionDisplay`

```cadence
pub struct NFTCollectionDisplay {

    pub let name: String

    pub let description: String

    pub let externalURL: ExternalURL

    pub let squareImage: Media

    pub let bannerImage: Media

    pub let socials: {String: ExternalURL}
}
```
View to expose the information needed to showcase this NFT's
collection. This can be used by applications to give an overview and
graphics of the NFT collection this NFT belongs to.

---

### `Rarity`

```cadence
pub struct Rarity {

    pub let score: UFix64?

    pub let max: UFix64?

    pub let description: String?
}
```
View to expose rarity information for a single rarity
Note that a rarity needs to have either score or description but it can
have both

---

### `Trait`

```cadence
pub struct Trait {

    pub let name: String

    pub let value: AnyStruct

    pub let displayType: String?

    pub let rarity: Rarity?
}
```
View to represent a single field of metadata on an NFT.
This is used to get traits of individual key/value pairs along with some
contextualized data about the trait

---

### `Traits`

```cadence
pub struct Traits {

    pub let traits: [Trait]
}
```
Wrapper view to return all the traits on an NFT.
This is used to return traits as individual key/value pairs along with
some contextualized data about each trait.

---

### `EVMBridgedMetadata`

```cadence
pub struct EVMBridgedMetadata {

    pub let name: String

    pub let symbol: String

    pub let uri: {File}
}
```
This view may be used by Cadence-native projects to define their
contract- and token-level metadata according to EVM-compatible
formats. Several ERC standards (e.g. ERC20, ERC721, etc.) expose name
and symbol values to define assets as well as contract- & token-level
metadata view `tokenURI(uint256)` and `contractURI()` methods. This
view enables Cadence projects to define in their own contracts how
they would like their metadata to be defined when bridged to EVM.

---
## Functions

### `getNFTView()`

```cadence
fun getNFTView(id: UInt64, viewResolver: &{Resolver}): NFTView
```
Helper to get an NFT view

Parameters:
  - id : _The NFT id_
  - viewResolver : _A reference to the resolver resource_

Returns: A NFTView struct

---

### `getDisplay()`

```cadence
fun getDisplay(_: &{Resolver}): Display?
```
Helper to get Display in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Display struct

---

### `getEditions()`

```cadence
fun getEditions(_: &{Resolver}): Editions?
```
Helper to get Editions in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Editions struct

---

### `getSerial()`

```cadence
fun getSerial(_: &{Resolver}): Serial?
```
Helper to get Serial in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Serial struct

---

### `getRoyalties()`

```cadence
fun getRoyalties(_: &{Resolver}): Royalties?
```
Helper to get Royalties in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Royalties struct

---

### `getRoyaltyReceiverPublicPath()`

```cadence
fun getRoyaltyReceiverPublicPath(): PublicPath
```
Get the path that should be used for receiving royalties
This is a path that will eventually be used for a generic switchboard receiver,
hence the name but will only be used for royalties for now.

Returns: The PublicPath for the generic FT receiver

---

### `getMedias()`

```cadence
fun getMedias(_: &{Resolver}): Medias?
```
Helper to get Medias in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Medias struct

---

### `getLicense()`

```cadence
fun getLicense(_: &{Resolver}): License?
```
Helper to get License in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional License struct

---

### `getExternalURL()`

```cadence
fun getExternalURL(_: &{Resolver}): ExternalURL?
```
Helper to get ExternalURL in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional ExternalURL struct

---

### `getNFTCollectionData()`

```cadence
fun getNFTCollectionData(_: &{Resolver}): NFTCollectionData?
```
Helper to get NFTCollectionData in a way that will return an typed Optional

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional NFTCollectionData struct

---

### `getNFTCollectionDisplay()`

```cadence
fun getNFTCollectionDisplay(_: &{Resolver}): NFTCollectionDisplay?
```
Helper to get NFTCollectionDisplay in a way that will return a typed
Optional

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional NFTCollection struct

---

### `getRarity()`

```cadence
fun getRarity(_: &{Resolver}): Rarity?
```
Helper to get Rarity view in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Rarity struct

---

### `getTraits()`

```cadence
fun getTraits(_: &{Resolver}): Traits?
```
Helper to get Traits view in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Traits struct

---

### `dictToTraits()`

```cadence
fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits
```
Helper function to easily convert a dictionary to traits. For NFT
collections that do not need either of the optional values of a Trait,
this method should suffice to give them an array of valid traits.

keys that are not wanted to become `Traits`

Parameters:
  - dict : _The dictionary to be converted to Traits_
  - excludedNames : _An optional String array specifying the `dict`_

Returns: The generated Traits view

---





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-0636.
///
/// Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata, such as a creator biography
/// or a JPEG image file.
///
access(all) contract MetadataViews {

    /// Display is a basic view that includes the name, description and
    /// thumbnail for an object. Most objects should implement this view.
    ///
    access(all) struct Display {

        /// The name of the object.
        ///
        /// This field will be displayed in lists and therefore should
        /// be short an concise.
        ///
        access(all) let name: String

        /// A written description of the object.
        ///
        /// This field will be displayed in a detailed view of the object,
        /// so can be more verbose (e.g. a paragraph instead of a single line).
        ///
        access(all) let description: String

        /// A small thumbnail representation of the object.
        ///
        /// This field should be a web-friendly file (i.e JPEG, PNG)
        /// that can be displayed in lists, link previews, etc.
        ///
        access(all) let thumbnail: {File}

        view init(
            name: String,
            description: String,
            thumbnail: {File}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }
    }

    /// Helper to get Display in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Display struct
    ///
    access(all) fun getDisplay(_ viewResolver: &{ViewResolver.Resolver}) : Display? {
        if let view = viewResolver.resolveView(Type<Display>()) {
            if let v = view as? Display {
                return v
            }
        }
        return nil
    }

    /// Generic interface that represents a file stored on or off chain. Files
    /// can be used to references images, videos and other media.
    ///
    access(all) struct interface File {
        access(all) view fun uri(): String
    }

    /// View to expose a file that is accessible at an HTTP (or HTTPS) URL.
    ///
    access(all) struct HTTPFile: File {
        access(all) let url: String

        view init(url: String) {
            self.url = url
        }

        access(all) view fun uri(): String {
            return self.url
        }
    }

    /// View to expose a file stored on IPFS.
    /// IPFS images are referenced by their content identifier (CID)
    /// rather than a direct URI. A client application can use this CID
    /// to find and load the image via an IPFS gateway.
    ///
    access(all) struct IPFSFile: File {

        /// CID is the content identifier for this IPFS file.
        ///
        /// Ref: https://docs.ipfs.io/concepts/content-addressing/
        ///
        access(all) let cid: String

        /// Path is an optional path to the file resource in an IPFS directory.
        ///
        /// This field is only needed if the file is inside a directory.
        ///
        /// Ref: https://docs.ipfs.io/concepts/file-systems/
        ///
        access(all) let path: String?

        view init(cid: String, path: String?) {
            self.cid = cid
            self.path = path
        }

        /// This function returns the IPFS native URL for this file.
        /// Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls
        ///
        /// @return The string containing the file uri
        ///
        access(all) view fun uri(): String {
            if let path = self.path {
                return "ipfs://".concat(self.cid).concat("/").concat(path)
            }

            return "ipfs://".concat(self.cid)
        }
    }

    /// A struct to represent a generic URI. May be used to represent the URI of
    /// the NFT where the type of URI is not able to be determined (i.e. HTTP,
    /// IPFS, etc.)
    ///
    access(all) struct URI: File {
        /// The base URI prefix, if any. Not needed for all URIs, but helpful
        /// for some use cases For example, updating a whole NFT collection's
        /// image host easily
        ///
        access(all) let baseURI: String?
        /// The URI string value
        /// NOTE: this is set on init as a concatenation of the baseURI and the
        /// value if baseURI != nil
        ///
        access(self) let value: String

        access(all) view fun uri(): String {
            return self.value
        }

        init(baseURI: String?, value: String) {
            self.baseURI = baseURI
            self.value = baseURI != nil ? baseURI!.concat(value) : value
        }
    }

    access(all) struct Media {

        /// File for the media
        ///
        access(all) let file: {File}

        /// media-type comes on the form of type/subtype as described here 
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
        ///
        access(all) let mediaType: String

        view init(file: {File}, mediaType: String) {
          self.file=file
          self.mediaType=mediaType
        }
    }

    /// Wrapper view for multiple media views
    ///
    access(all) struct Medias {

        /// An arbitrary-sized list for any number of Media items
        access(all) let items: [Media]

        view init(_ items: [Media]) {
            self.items = items
        }
    }

    /// Helper to get Medias in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Medias struct
    ///
    access(all) fun getMedias(_ viewResolver: &{ViewResolver.Resolver}) : Medias? {
        if let view = viewResolver.resolveView(Type<Medias>()) {
            if let v = view as? Medias {
                return v
            }
        }
        return nil
    }

    /// View to represent a license according to https://spdx.org/licenses/
    /// This view can be used if the content of an NFT is licensed.
    ///
    access(all) struct License {
        access(all) let spdxIdentifier: String

        view init(_ identifier: String) {
            self.spdxIdentifier = identifier
        }
    }

    /// Helper to get License in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional License struct
    ///
    access(all) fun getLicense(_ viewResolver: &{ViewResolver.Resolver}) : License? {
        if let view = viewResolver.resolveView(Type<License>()) {
            if let v = view as? License {
                return v
            }
        }
        return nil
    }

    /// View to expose a URL to this item on an external site.
    /// This can be used by applications like .find and Blocto to direct users 
    /// to the original link for an NFT or a project page that describes the NFT collection.
    /// eg https://www.my-nft-project.com/overview-of-nft-collection
    ///
    access(all) struct ExternalURL {
        access(all) let url: String

        view init(_ url: String) {
            self.url=url
        }
    }

    /// Helper to get ExternalURL in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional ExternalURL struct
    ///
    access(all) fun getExternalURL(_ viewResolver: &{ViewResolver.Resolver}) : ExternalURL? {
        if let view = viewResolver.resolveView(Type<ExternalURL>()) {
            if let v = view as? ExternalURL {
                return v
            }
        }
        return nil
    }

    /// View that defines the composable royalty standard that gives marketplaces a 
    /// unified interface to support NFT royalties.
    ///
    access(all) struct Royalty {

        /// Generic FungibleToken Receiver for the beneficiary of the royalty
        /// Can get the concrete type of the receiver with receiver.getType()
        /// Recommendation - Users should create a new link for a FlowToken 
        /// receiver for this using `getRoyaltyReceiverPublicPath()`, and not 
        /// use the default FlowToken receiver. This will allow users to update 
        /// the capability in the future to use a more generic capability
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// Multiplier used to calculate the amount of sale value transferred to 
        /// royalty receiver. Note - It should be between 0.0 and 1.0 
        /// Ex - If the sale value is x and multiplier is 0.56 then the royalty 
        /// value would be 0.56 * x.
        /// Generally percentage get represented in terms of basis points
        /// in solidity based smart contracts while cadence offers `UFix64` 
        /// that already supports the basis points use case because its 
        /// operations are entirely deterministic integer operations and support 
        /// up to 8 points of precision.
        access(all) let cut: UFix64

        /// Optional description: This can be the cause of paying the royalty,
        /// the relationship between the `wallet` and the NFT, or anything else
        /// that the owner might want to specify.
        access(all) let description: String

        view init(receiver: Capability<&{FungibleToken.Receiver}>, cut: UFix64, description: String) {
            pre {
                cut >= 0.0 && cut <= 1.0 :
                    "MetadataViews.Royalty.init: Cannot initialize the Royalty Metadata View! "
                    .concat("The provided royalty cut value of ").concat(cut.toString())
                    .concat(" is invalid. ")
                    .concat("It should be within the valid range between 0 and 1. i.e [0,1]")
            }
            self.receiver = receiver
            self.cut = cut
            self.description = description
        }
    }

    /// Wrapper view for multiple Royalty views.
    /// Marketplaces can query this `Royalties` struct from NFTs 
    /// and are expected to pay royalties based on these specifications.
    ///
    access(all) struct Royalties {

        /// Array that tracks the individual royalties
        access(self) let cutInfos: [Royalty]

        access(all) view init(_ cutInfos: [Royalty]) {
            // Validate that sum of all cut multipliers should not be greater than 1.0
            var totalCut = 0.0
            for royalty in cutInfos {
                totalCut = totalCut + royalty.cut
            }
            assert(
                totalCut <= 1.0,
                message:
                    "MetadataViews.Royalties.init: Cannot initialize Royalties Metadata View! "
                    .concat(" The sum of cutInfos multipliers is ")
                    .concat(totalCut.toString())
                    .concat(" but it should not be greater than 1.0")
            )
            // Assign the cutInfos
            self.cutInfos = cutInfos
        }

        /// Return the cutInfos list
        ///
        /// @return An array containing all the royalties structs
        ///
        access(all) view fun getRoyalties(): [Royalty] {
            return self.cutInfos
        }
    }

    /// Helper to get Royalties in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Royalties struct
    ///
    access(all) fun getRoyalties(_ viewResolver: &{ViewResolver.Resolver}) : Royalties? {
        if let view = viewResolver.resolveView(Type<Royalties>()) {
            if let v = view as? Royalties {
                return v
            }
        }
        return nil
    }

    /// Get the path that should be used for receiving royalties
    /// This is a path that will eventually be used for a generic switchboard receiver,
    /// hence the name but will only be used for royalties for now.
    ///
    /// @return The PublicPath for the generic FT receiver
    ///
    access(all) view fun getRoyaltyReceiverPublicPath(): PublicPath {
        return /public/GenericFTReceiver
    }

    /// View to represent a single field of metadata on an NFT.
    /// This is used to get traits of individual key/value pairs along with some
    /// contextualized data about the trait
    ///
    access(all) struct Trait {
        // The name of the trait. Like Background, Eyes, Hair, etc.
        access(all) let name: String

        // The underlying value of the trait, the rest of the fields of a trait provide context to the value.
        access(all) let value: AnyStruct

        // displayType is used to show some context about what this name and value represent
        // for instance, you could set value to a unix timestamp, and specify displayType as "Date" to tell
        // platforms to consume this trait as a date and not a number
        access(all) let displayType: String?

        // Rarity can also be used directly on an attribute.
        //
        // This is optional because not all attributes need to contribute to the NFT's rarity.
        access(all) let rarity: Rarity?

        view init(name: String, value: AnyStruct, displayType: String?, rarity: Rarity?) {
            self.name = name
            self.value = value
            self.displayType = displayType
            self.rarity = rarity
        }
    }

    /// Wrapper view to return all the traits on an NFT.
    /// This is used to return traits as individual key/value pairs along with
    /// some contextualized data about each trait.
    access(all) struct Traits {
        access(all) let traits: [Trait]

        view init(_ traits: [Trait]) {
            self.traits = traits
        }
            
        /// Adds a single Trait to the Traits view
        /// 
        /// @param Trait: The trait struct to be added
        ///
        access(all) fun addTrait(_ t: Trait) {
            self.traits.append(t)
        }
    }

    /// Helper to get Traits view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Traits struct
    ///
    access(all) fun getTraits(_ viewResolver: &{ViewResolver.Resolver}) : Traits? {
        if let view = viewResolver.resolveView(Type<Traits>()) {
            if let v = view as? Traits {
                return v
            }
        }
        return nil
    }

    /// Helper function to easily convert a dictionary to traits. For NFT 
    /// collections that do not need either of the optional values of a Trait, 
    /// this method should suffice to give them an array of valid traits.
    ///
    /// @param dict: The dictionary to be converted to Traits
    /// @param excludedNames: An optional String array specifying the `dict`
    ///         keys that are not wanted to become `Traits`
    /// @return The generated Traits view
    ///
    access(all) fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits {
        // Collection owners might not want all the fields in their metadata included.
        // They might want to handle some specially, or they might just not want them included at all.
        if excludedNames != nil {
            for k in excludedNames! {
                dict.remove(key: k)
            }
        }

        let traits: [Trait] = []
        for k in dict.keys {
            let trait = Trait(name: k, value: dict[k]!, displayType: nil, rarity: nil)
            traits.append(trait)
        }

        return Traits(traits)
    }

    /// Optional view for collections that issue multiple objects
    /// with the same or similar metadata, for example an X of 100 set. This
    /// information is useful for wallets and marketplaces.
    /// An NFT might be part of multiple editions, which is why the edition
    /// information is returned as an arbitrary sized array
    ///
    access(all) struct Edition {

        /// The name of the edition
        /// For example, this could be Set, Play, Series,
        /// or any other way a project could classify its editions
        access(all) let name: String?

        /// The edition number of the object.
        /// For an "24 of 100 (#24/100)" item, the number is 24.
        access(all) let number: UInt64

        /// The max edition number of this type of objects.
        /// This field should only be provided for limited-editioned objects.
        /// For an "24 of 100 (#24/100)" item, max is 100.
        /// For an item with unlimited edition, max should be set to nil.
        ///
        access(all) let max: UInt64?

        view init(name: String?, number: UInt64, max: UInt64?) {
            if max != nil {
                assert(
                    number <= max!,
                    message:
                        "MetadataViews.Edition.init: Cannot intialize the Edition Metadata View! "
                        .concat("The provided edition number of ")
                        .concat(number.toString())
                        .concat(" cannot be greater than the max edition number of ")
                        .concat(max!.toString())
                        .concat(".")
                )
            }
            self.name = name
            self.number = number
            self.max = max
        }
    }

    /// Wrapper view for multiple Edition views
    ///
    access(all) struct Editions {

        /// An arbitrary-sized list for any number of editions
        /// that the NFT might be a part of
        access(all) let infoList: [Edition]

        view init(_ infoList: [Edition]) {
            self.infoList = infoList
        }
    }

    /// Helper to get Editions in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Editions struct
    ///
    access(all) fun getEditions(_ viewResolver: &{ViewResolver.Resolver}) : Editions? {
        if let view = viewResolver.resolveView(Type<Editions>()) {
            if let v = view as? Editions {
                return v
            }
        }
        return nil
    }

    /// View representing a project-defined serial number for a specific NFT
    /// Projects have different definitions for what a serial number should be
    /// Some may use the NFTs regular ID and some may use a different
    /// classification system. The serial number is expected to be unique among
    /// other NFTs within that project
    ///
    access(all) struct Serial {
        access(all) let number: UInt64

        view init(_ number: UInt64) {
            self.number = number
        }
    }

    /// Helper to get Serial in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Serial struct
    ///
    access(all) fun getSerial(_ viewResolver: &{ViewResolver.Resolver}) : Serial? {
        if let view = viewResolver.resolveView(Type<Serial>()) {
            if let v = view as? Serial {
                return v
            }
        }
        return nil
    }

    /// View to expose rarity information for a single rarity
    /// Note that a rarity needs to have either score or description but it can 
    /// have both
    ///
    access(all) struct Rarity {
        /// The score of the rarity as a number
        access(all) let score: UFix64?

        /// The maximum value of score
        access(all) let max: UFix64?

        /// The description of the rarity as a string.
        ///
        /// This could be Legendary, Epic, Rare, Uncommon, Common or any other string value
        access(all) let description: String?

        view init(score: UFix64?, max: UFix64?, description: String?) {
            if score == nil && description == nil {
                panic("MetadataViews.Rarity.init: Cannot initialize the Rarity Metadata View! "
                      .concat("The provided score and description are both `nil`. ")
                      .concat(" A Rarity needs to set score, description, or both"))
            }

            self.score = score
            self.max = max
            self.description = description
        }
    }

    /// Helper to get Rarity view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Rarity struct
    ///
    access(all) fun getRarity(_ viewResolver: &{ViewResolver.Resolver}) : Rarity? {
        if let view = viewResolver.resolveView(Type<Rarity>()) {
            if let v = view as? Rarity {
                return v
            }
        }
        return nil
    }

    /// NFTView wraps all Core views along `id` and `uuid` fields, and is used 
    /// to give a complete picture of an NFT. Most NFTs should implement this 
    /// view.
    ///
    access(all) struct NFTView {
        access(all) let id: UInt64
        access(all) let uuid: UInt64
        access(all) let display: MetadataViews.Display?
        access(all) let externalURL: MetadataViews.ExternalURL?
        access(all) let collectionData: NFTCollectionData?
        access(all) let collectionDisplay: NFTCollectionDisplay?
        access(all) let royalties: Royalties?
        access(all) let traits: Traits?

        view init(
            id : UInt64,
            uuid : UInt64,
            display : MetadataViews.Display?,
            externalURL : MetadataViews.ExternalURL?,
            collectionData : NFTCollectionData?,
            collectionDisplay : NFTCollectionDisplay?,
            royalties : Royalties?,
            traits: Traits?
        ) {
            self.id = id
            self.uuid = uuid
            self.display = display
            self.externalURL = externalURL
            self.collectionData = collectionData
            self.collectionDisplay = collectionDisplay
            self.royalties = royalties
            self.traits = traits
        }
    }

    /// Helper to get an NFT view 
    ///
    /// @param id: The NFT id
    /// @param viewResolver: A reference to the resolver resource
    /// @return A NFTView struct
    ///
    access(all) fun getNFTView(id: UInt64, viewResolver: &{ViewResolver.Resolver}) : NFTView {
        let nftView = viewResolver.resolveView(Type<NFTView>())
        if nftView != nil {
            return nftView! as! NFTView
        }

        return NFTView(
            id : id,
            uuid: viewResolver.uuid,
            display: MetadataViews.getDisplay(viewResolver),
            externalURL : MetadataViews.getExternalURL(viewResolver),
            collectionData : self.getNFTCollectionData(viewResolver),
            collectionDisplay : self.getNFTCollectionDisplay(viewResolver),
            royalties : self.getRoyalties(viewResolver),
            traits : self.getTraits(viewResolver)
        )
    }

    /// View to expose the information needed store and retrieve an NFT.
    /// This can be used by applications to setup a NFT collection with proper 
    /// storage and public capabilities.
    ///
    access(all) struct NFTCollectionData {
        /// Path in storage where this NFT is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose public capabilities of this NFT
        /// including standard NFT interfaces and metadataviews interfaces
        access(all) let publicPath: PublicPath

        /// The concrete type of the collection that is exposed to the public
        /// now that entitlements exist, it no longer needs to be restricted to a specific interface
        access(all) let publicCollection: Type

        /// Type that should be linked at the aforementioned public path
        access(all) let publicLinkedType: Type

        /// Function that allows creation of an empty NFT collection that is intended to store
        /// this NFT.
        access(all) let createEmptyCollection: fun(): @{NonFungibleToken.Collection}

        view init(
            storagePath: StoragePath,
            publicPath: PublicPath,
            publicCollection: Type,
            publicLinkedType: Type,
            createEmptyCollectionFunction: fun(): @{NonFungibleToken.Collection}
        ) {
            pre {
                publicLinkedType.isSubtype(of: Type<&{NonFungibleToken.Collection}>()):
                    "MetadataViews.NFTCollectionData.init: Cannot initialize the NFTCollectionData Metadata View! "
                    .concat("The Public linked type <")
                    .concat(publicLinkedType.identifier)
                    .concat("> is incorrect. It must be a subtype of the NonFungibleToken.Collection interface.")
            }
            self.storagePath=storagePath
            self.publicPath=publicPath
            self.publicCollection=publicCollection
            self.publicLinkedType=publicLinkedType
            self.createEmptyCollection=createEmptyCollectionFunction
        }
    }

    /// Helper to get NFTCollectionData in a way that will return an typed Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollectionData struct
    ///
    access(all) fun getNFTCollectionData(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionData? {
        if let view = viewResolver.resolveView(Type<NFTCollectionData>()) {
            if let v = view as? NFTCollectionData {
                return v
            }
        }
        return nil
    }

    /// View to expose the information needed to showcase this NFT's
    /// collection. This can be used by applications to give an overview and 
    /// graphics of the NFT collection this NFT belongs to.
    ///
    access(all) struct NFTCollectionDisplay {
        // Name that should be used when displaying this NFT collection.
        access(all) let name: String

        // Description that should be used to give an overview of this collection.
        access(all) let description: String

        // External link to a URL to view more information about this collection.
        access(all) let externalURL: MetadataViews.ExternalURL

        // Square-sized image to represent this collection.
        access(all) let squareImage: MetadataViews.Media

        // Banner-sized image for this collection, recommended to have a size near 1400x350.
        access(all) let bannerImage: MetadataViews.Media

        // Social links to reach this collection's social homepages.
        // Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            squareImage: MetadataViews.Media,
            bannerImage: MetadataViews.Media,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.description = description
            self.externalURL = externalURL
            self.squareImage = squareImage
            self.bannerImage = bannerImage
            self.socials = socials
        }
    }

    /// Helper to get NFTCollectionDisplay in a way that will return a typed 
    /// Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollection struct
    ///
    access(all) fun getNFTCollectionDisplay(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionDisplay? {
        if let view = viewResolver.resolveView(Type<NFTCollectionDisplay>()) {
            if let v = view as? NFTCollectionDisplay {
                return v
            }
        }
        return nil
    }
    /// This view may be used by Cadence-native projects to define their
    /// contract- and token-level metadata according to EVM-compatible formats.
    /// Several ERC standards (e.g. ERC20, ERC721, etc.) expose name and symbol
    /// values to define assets as well as contract- & token-level metadata view
    /// `tokenURI(uint256)` and `contractURI()` methods. This view enables
    /// Cadence projects to define in their own contracts how they would like
    /// their metadata to be defined when bridged to EVM.
    ///
    access(all) struct EVMBridgedMetadata {

        /// The name of the asset
        ///
        access(all) let name: String

        /// The symbol of the asset
        ///
        access(all) let symbol: String

        /// The URI of the asset - this can either be contract-level or
        /// token-level URI depending on where the metadata is resolved. It
        /// is recommended to reference EVM metadata standards for how to best
        /// prepare your view's formatted value.
        ///
        /// For example, while you may choose to take advantage of onchain
        /// metadata, as is the case for most Cadence NFTs, you may also choose
        /// to represent your asset's metadata in IPFS and assign this value as
        /// an IPFSFile struct pointing to that IPFS file. Alternatively, you
        /// may serialize your NFT's metadata and assign it as a JSON string
        /// data URL representating the NFT's onchain metadata at the time this
        /// view is resolved.
        ///
        access(all) let uri: {File}

        init(name: String, symbol: String, uri: {File}) {
            self.name = name
            self.symbol = symbol
            self.uri = uri
        }
    }

    access(all) fun getEVMBridgedMetadata(_ viewResolver: &{ViewResolver.Resolver}) : EVMBridgedMetadata? {
        if let view = viewResolver.resolveView(Type<EVMBridgedMetadata>()) {
            if let v = view as? EVMBridgedMetadata {
                return v
            }
        }
        return nil
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/example_nft_test.cdc

```
import Test
import BlockchainHelpers
import "test_helpers.cdc"
import "ViewResolver"
import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let recipient = Test.createAccount()

access(all) fun getCollectionIDs(from: Address, path: PublicPath): [UInt64] {
    var scriptResult = executeScript(
        "../transactions/scripts/get_collection_ids.cdc",
        [
            from,
            path
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    return scriptResult.returnValue! as! [UInt64]
}

access(all)
fun setup() {
    deploy("ViewResolver", "../contracts/ViewResolver.cdc")
    deploy("NonFungibleToken", "../contracts/NonFungibleToken.cdc")
    deploy("MetadataViews", "../contracts/MetadataViews.cdc")
    deploy("CrossVMMetadataViews", "../contracts/CrossVMMetadataViews.cdc")
    deploy("ExampleNFT", "../contracts/ExampleNFT.cdc")
    deploy("MaliciousNFT", "../contracts/test/MaliciousNFT.cdc")
}

access(all)
fun testSetupAccount() {
    var txResult = executeTransaction(
        "../transactions/setup_account.cdc",
        [],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    var scriptResult = executeScript(
        "../transactions/scripts/get_collection_length.cdc",
        [admin.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    var collectionLength = scriptResult.returnValue! as! Int
    Test.assertEqual(0, collectionLength)

    let newAccount = Test.createAccount()
    txResult = executeTransaction(
        "../transactions/setup_account_from_address.cdc",
        [admin.address, "ExampleNFT"],
        newAccount
    )
    Test.expect(txResult, Test.beSucceeded())

    scriptResult = executeScript(
        "../transactions/scripts/get_collection_length.cdc",
        [newAccount.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    collectionLength = scriptResult.returnValue! as! Int
    Test.assertEqual(0, collectionLength)
}

access(all)
fun testMintNFT() {
    var txResult = executeTransaction(
        "../transactions/setup_account_to_receive_royalty.cdc",
        [/storage/flowTokenVault],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/mint_nft.cdc",
        [
            recipient.address,
            "NFT Name",
            "NFT Description",
            "NFT Thumbnail",
            [0.05],
            ["Creator Royalty"],
            [admin.address]
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    let typ = Type<NonFungibleToken.Deposited>()
    let events = Test.eventsOfType(typ)
    Test.assertEqual(1, events.length)

    let depositEvent = events[0] as! NonFungibleToken.Deposited
    Test.assertEqual(recipient.address, depositEvent.to!)

    var collectionIDs = getCollectionIDs(from: recipient.address, path: /public/exampleNFTCollection)
    Test.assertEqual(1, collectionIDs.length)
}

access(all)
fun testTransferNFT() {
    var collectionIDs = getCollectionIDs(from: recipient.address, path: /public/exampleNFTCollection)
    Test.assertEqual(1, collectionIDs.length)

    let nftID: UInt64 = collectionIDs[0]
    var txResult = executeTransaction(
        "../transactions/transfer_nft.cdc",
        [
            admin.address,
            "ExampleNFT",
            admin.address,
            nftID
        ],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    var typ = Type<NonFungibleToken.Withdrawn>()
    var events = Test.eventsOfType(typ)
    Test.assertEqual(1, events.length)

    let withdrawEvent = events[0] as! NonFungibleToken.Withdrawn
    Test.assertEqual(nftID, withdrawEvent.id)
    Test.assertEqual(recipient.address, withdrawEvent.from!)

    typ = Type<NonFungibleToken.Deposited>()
    events = Test.eventsOfType(typ)
    Test.assertEqual(2, events.length)

    let depositEvent = events[1] as! NonFungibleToken.Deposited
    Test.assertEqual(nftID, depositEvent.id)
    Test.assertEqual(admin.address, depositEvent.to!)

    collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)
    Test.assertEqual([nftID] as [UInt64], collectionIDs)

    txResult = executeTransaction(
        "../transactions/generic_transfer_with_paths.cdc",
        [
            recipient.address,
            nftID,
            "exampleNFTCollection",
            "exampleNFTCollection"
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/transfer_nft.cdc",
        [
            admin.address,
            "ExampleNFT",
            admin.address,
            nftID
        ],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Other generic transfer transactions should succeed
    txResult = executeTransaction(
        "../transactions/generic_transfer_with_address.cdc",
        [recipient.address, nftID, admin.address, "ExampleNFT"],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/generic_transfer_with_address_and_type.cdc",
        [admin.address, nftID, admin.address, "ExampleNFT", "NFT"],
        recipient
    )
    Test.expect(txResult, Test.beSucceeded())

    // Should not be able to transfer an NFT from a malicious contract
    // that tries to trick the generic transaction
    txResult = executeTransaction(
        "../transactions/generic_transfer_with_address.cdc",
        [recipient.address, nftID, admin.address, "MaliciousNFT"],
        admin
    )
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "The NFT that was withdrawn to transfer is not the type that was requested <A.0000000000000007.MaliciousNFT.NFT>."
    )

    txResult = executeTransaction(
        "../transactions/generic_transfer_with_address_and_type.cdc",
        [recipient.address, nftID, admin.address, "MaliciousNFT", "NFT"],
        admin
    )
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "The NFT that was withdrawn to transfer is not the type that was requested <A.0000000000000007.MaliciousNFT.NFT>."
    )
}

access(all)
fun testTransferMissingNFT() {
    let txResult = executeTransaction(
        "../transactions/transfer_nft.cdc",
        [
            admin.address,
            "ExampleNFT",
            admin.address,
            10 as UInt64
        ],
        recipient
    )
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "ExampleNFT.Collection.withdraw: Could not withdraw an NFT with ID 10. Check the submitted ID to make sure it is one that this collection owns.",
    )
}

access(all)
fun testBorrowNFT() {
    var collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)

    var scriptResult = executeScript(
        "../transactions/scripts/borrow_nft.cdc",
        [
            admin.address,
            collectionIDs[0]
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testBorrowMissingNFT() {
    let scriptResult = executeScript(
        "../transactions/scripts/borrow_nft.cdc",
        [
            admin.address,
            10 as UInt64
        ]
    )
    Test.expect(scriptResult, Test.beFailed())
    Test.assertError(
        scriptResult,
        errorMessage: "The NFT with id 10 does not exist in the collection!"
    )
}

access(all)
fun testGetCollectionLength() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_collection_length.cdc",
        [admin.address]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let collectionLength = scriptResult.returnValue! as! Int
    Test.assertEqual(1, collectionLength)
}

access(all)
fun testGetIterator() {
    let scriptResult = executeScript(
        "../transactions/scripts/iterate_ids.cdc",
        [admin.address, 10]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let nftRefArrayLength = scriptResult.returnValue! as! Int
    Test.assertEqual(1, nftRefArrayLength)
}

access(all)
fun testGetContractStoragePath() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_contract_storage_path.cdc",
        [
            admin.address,
            "ExampleNFT"
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let storagePath = scriptResult.returnValue! as! StoragePath
    Test.assertEqual(/storage/exampleNFTCollection, storagePath)
}

access(all)
fun testGetMissingContractStoragePath() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_contract_storage_path.cdc",
        [
            admin.address,
            "ContractOne"
        ]
    )
    Test.expect(scriptResult, Test.beFailed())
    Test.assertError(
        scriptResult,
        errorMessage: "Could not borrow ViewResolver reference to the contract. Make sure the provided contract name ContractOne and address 0x0000000000000007 are correct!"
    )
}

access(all)
fun testGetNFTView() {
    var collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)

    var scriptResult = executeScript(
        "scripts/get_nft_view.cdc",
        [
            admin.address,
            collectionIDs[0]
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testGetCrossVMNFTView() {
    var collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)

    var scriptResult = executeScript(
        "scripts/get_cross_vm_nft_view.cdc",
        [
            admin.address,
            collectionIDs[0]
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testGetMissingNFTView() {
    let scriptResult = executeScript(
        "scripts/get_nft_view.cdc",
        [
            admin.address,
            10 as UInt64
        ]
    )

    Test.expect(scriptResult, Test.beFailed())
    Test.assertError(
        scriptResult,
        errorMessage: "unexpectedly found nil while forcing an Optional value"
    )
}

access(all)
fun testGetViews() {
    var collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)

    var scriptResult = executeScript(
        "../transactions/scripts/get_views.cdc",
        [
            admin.address,
            collectionIDs[0]
        ]
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let supportedViews = scriptResult.returnValue! as! [Type]
    let expectedViews = [
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Royalties>(),
        Type<MetadataViews.Editions>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Serial>(),
        Type<MetadataViews.Traits>(),
        Type<MetadataViews.EVMBridgedMetadata>()
    ]
    Test.assertEqual(expectedViews, supportedViews)
}

access(all)
fun testGetExampleNFTViews() {
    let scriptResult = executeScript(
        "../transactions/scripts/get_contract_views.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())

    let supportedViews = scriptResult.returnValue! as! [Type]
    let expectedViews = [
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.EVMBridgedMetadata>()
    ]
    Test.assertEqual(expectedViews, supportedViews)
}

access(all)
fun testResolveExampleNFTViews() {
    let scriptResult = executeScript(
        "scripts/resolve_nft_views.cdc",
        []
    )
    Test.expect(scriptResult, Test.beSucceeded())
}

access(all)
fun testBurnNFT() {

    var txResult = executeTransaction(
        "../transactions/mint_nft.cdc",
        [
            admin.address,
            "NFT Name",
            "NFT Description",
            "NFT Thumbnail",
            [0.05],
            ["Creator Royalty"],
            [admin.address]
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/mint_nft.cdc",
        [
            admin.address,
            "NFT Name",
            "NFT Description",
            "NFT Thumbnail",
            [0.05],
            ["Creator Royalty"],
            [admin.address]
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    var collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)
    Test.assertEqual(3, collectionIDs.length)

    txResult = executeTransaction(
        "../transactions/destroy_nft.cdc",
        [
            collectionIDs[0]
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    txResult = executeTransaction(
        "../transactions/generic_destroy_nft.cdc",
        [
            admin.address, "ExampleNFT", "NFT", collectionIDs
        ],
        admin
    )
    Test.expect(txResult, Test.beSucceeded())

    collectionIDs = getCollectionIDs(from: admin.address, path: /public/exampleNFTCollection)
    Test.assertEqual(0, collectionIDs.length)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/SECURITY.md


# Responsible Disclosure Policy

Flow was built from the ground up with security in mind. Our code, infrastructure, and development methodology helps us keep our users safe.

We really appreciate the community's help. Responsible disclosure of vulnerabilities helps to maintain the security and privacy of everyone.

If you care about making a difference, please follow the guidelines below.

# **Guidelines For Responsible Disclosure**

We ask that all researchers adhere to these guidelines [here](https://flow.com/flow-responsible-disclosure)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/tests/scripts/get_nft_view.cdc

```
/// This script checks the NFTView from MetadataViews for
/// a given NFT. Used for testing only.

import "ExampleNFT"
import "MetadataViews"
import "ViewResolver"

access(all) struct NFTView {
    access(all) let id: UInt64
    access(all) let uuid: UInt64
    access(all) let name: String
    access(all) let description: String
    access(all) let thumbnail: String
    access(all) let royalties: [MetadataViews.Royalty]
    access(all) let externalURL: String
    access(all) let collectionPublicPath: PublicPath
    access(all) let collectionStoragePath: StoragePath
    access(all) let collectionPublic: String
    access(all) let collectionPublicLinkedType: String
    access(all) let collectionName: String
    access(all) let collectionDescription: String
    access(all) let collectionExternalURL: String
    access(all) let collectionSquareImage: String
    access(all) let collectionBannerImage: String
    access(all) let collectionSocials: {String: String}
    access(all) let traits: MetadataViews.Traits

    init(
        id: UInt64,
        uuid: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        royalties: [MetadataViews.Royalty],
        externalURL: String,
        collectionPublicPath: PublicPath,
        collectionStoragePath: StoragePath,
        collectionPublic: String,
        collectionPublicLinkedType: String,
        collectionName: String,
        collectionDescription: String,
        collectionExternalURL: String,
        collectionSquareImage: String,
        collectionBannerImage: String,
        collectionSocials: {String: String},
        traits: MetadataViews.Traits
    ) {
        self.id = id
        self.uuid = uuid
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.royalties = royalties
        self.externalURL = externalURL
        self.collectionPublicPath = collectionPublicPath
        self.collectionStoragePath = collectionStoragePath
        self.collectionPublic = collectionPublic
        self.collectionPublicLinkedType = collectionPublicLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionExternalURL = collectionExternalURL
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.collectionSocials = collectionSocials
        self.traits = traits
    }
}

access(all) fun main(address: Address, id: UInt64): Bool {
    let account = getAccount(address)

    let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("ViewResolver does not resolve NFTCollectionData view")
    
    let collection = account.capabilities.borrow<&{ViewResolver.ResolverCollection}>(
            collectionData.publicPath
        ) ?? panic("Could not borrow a reference to the collection")

    let viewResolver = collection.borrowViewResolver(id: id)!

    let nftView = MetadataViews.getNFTView(id: id, viewResolver: viewResolver)

    let collectionSocials: {String: String} = {}
    for key in nftView.collectionDisplay!.socials.keys {
        collectionSocials[key] = nftView.collectionDisplay!.socials[key]!.url
    }


    let nftViewResult = NFTView(
        id: nftView.id,
        uuid: nftView.uuid,
        name: nftView.display!.name,
        description: nftView.display!.description,
        thumbnail: nftView.display!.thumbnail.uri(),
        royalties: nftView.royalties!.getRoyalties(),
        externalURL: nftView.externalURL!.url,
        collectionPublicPath: nftView.collectionData!.publicPath,
        collectionStoragePath: nftView.collectionData!.storagePath,
        collectionPublic: nftView.collectionData!.publicCollection.identifier,
        collectionPublicLinkedType: nftView.collectionData!.publicLinkedType.identifier,
        collectionName: nftView.collectionDisplay!.name,
        collectionDescription: nftView.collectionDisplay!.description,
        collectionExternalURL: nftView.collectionDisplay!.externalURL.url,
        collectionSquareImage: nftView.collectionDisplay!.squareImage.file.uri(),
        collectionBannerImage: nftView.collectionDisplay!.bannerImage.file.uri(),
        collectionSocials: collectionSocials,
        traits: nftView.traits!,
    )

    // assert((0 as UInt64) == nftViewResult.id)
    assert(nil != nftViewResult.uuid)
    assert("NFT Name" == nftViewResult.name)
    assert("NFT Description" == nftViewResult.description)
    assert("NFT Thumbnail" == nftViewResult.thumbnail)
    assert("Creator Royalty" == nftViewResult.royalties[0].description)
    assert(Address(0x0000000000000007) == nftViewResult.royalties[0].receiver.address)
    assert(0.05 == nftViewResult.royalties[0].cut)
    //assert("https://example-nft.onflow.org" == nftViewResult.externalURL)
    assert(/public/exampleNFTCollection == nftViewResult.collectionPublicPath)
    assert(/storage/exampleNFTCollection == nftViewResult.collectionStoragePath)
    assert("&A.0000000000000007.ExampleNFT.Collection" == nftViewResult.collectionPublic)
    assert("&A.0000000000000007.ExampleNFT.Collection" == nftViewResult.collectionPublicLinkedType)
    assert("The Example Collection" == nftViewResult.collectionName)
    assert("This collection is used as an example to help you develop your next Flow NFT." == nftViewResult.collectionDescription)
    assert("https://example-nft.onflow.org" == nftViewResult.collectionExternalURL)
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == nftViewResult.collectionSquareImage)
    assert("https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg" == nftViewResult.collectionBannerImage)
    assert({"twitter": "https://twitter.com/flow_blockchain"} == nftViewResult.collectionSocials)
    assert("Common" == nftViewResult.traits.traits[2]!.rarity!.description)
    assert(10.0 == nftViewResult.traits.traits[2]!.rarity!.score)
    assert(100.0 == nftViewResult.traits.traits[2]!.rarity!.max)

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/scripts/get_collection_ids.cdc

```
/// Script to get NFT IDs in an account's collection

import "NonFungibleToken"

access(all) fun main(address: Address, collectionPublicPath: PublicPath): [UInt64] {
    let account = getAccount(address)

    let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection}>(
            collectionPublicPath
    ) ?? panic("The account ".concat(address.toString()).concat(" does not have a NonFungibleToken Collection at ")
                .concat(collectionPublicPath.toString())
                .concat(". The account must initialize their account with this collection first!"))

    return collectionRef.getIDs()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/mint_nft.cdc

```
/// This script uses the NFTMinter resource to mint a new NFT
/// It must be run with the account that has the minter resource
/// stored in /storage/NFTMinter
///
/// The royalty arguments indicies must be aligned

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"
import "FungibleToken"

transaction(
    recipient: Address,
    name: String,
    description: String,
    thumbnail: String,
    cuts: [UFix64],
    royaltyDescriptions: [String],
    royaltyBeneficiaries: [Address]
) {

    /// local variable for storing the minter reference
    let minter: &ExampleNFT.NFTMinter

    /// Reference to the receiver's collection
    let recipientCollectionRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ExampleNFT contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction")
        
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("The signer does not store an ExampleNFT.Minter object at the path "
                     .concat(ExampleNFT.MinterStoragePath.toString())
                     .concat("The signer must initialize their account with this minter resource first!"))

        // Borrow the recipient's public NFT collection reference
        self.recipientCollectionRef = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                    .concat(collectionData.publicPath.toString())
                    .concat(" that is capable of receiving an NFT.")
                    .concat("The recipient must initialize their account with this collection and receiver first!"))
    }

    pre {
        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: "Array length should be equal for royalty related details"
    }

    execute {

        // Create the royalty details
        var count = 0
        var royalties: [MetadataViews.Royalty] = []
        while royaltyBeneficiaries.length > count {
            let beneficiary = royaltyBeneficiaries[count]
            let beneficiaryCapability = getAccount(beneficiary).capabilities.get<&{FungibleToken.Receiver}>(
                MetadataViews.getRoyaltyReceiverPublicPath()
            )

            if !beneficiaryCapability.check() {
                panic("The royalty beneficiary "
                       .concat(beneficiary.toString())
                       .concat(" does not have a FungibleToken Receiver configured at ")
                       .concat(MetadataViews.getRoyaltyReceiverPublicPath().toString())
                       .concat(". They should set up a FungibleTokenSwitchboard Receiver at this path to receive any type of Fungible Token"))
            }

            royalties.append(
                MetadataViews.Royalty(
                    receiver: beneficiaryCapability,
                    cut: cuts[count],
                    description: royaltyDescriptions[count]
                )
            )
            count = count + 1
        }


        // Mint the NFT and deposit it to the recipient's collection
        let mintedNFT <- self.minter.mintNFT(
            name: name,
            description: description,
            thumbnail: thumbnail,
            royalties: royalties
        )
        self.recipientCollectionRef.deposit(token: <-mintedNFT)
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/README.md

# Flow Non-Fungible Token Standard

This standard defines the minimum functionality required to
implement a safe, secure, and easy-to-use non-fungible token
contract on the [Flow blockchain](https://flow.com/)

The version of the contracts in the `master` branch is the
Cadence 1.0 version of the contracts and is not the same
as the ones that are currently deployed to testnet and mainnet.
See the `cadence-0.42` branch for the currently deployed versions.

## What is Cadence?

[Cadence is the resource-oriented programming language](https://cadence-lang.org/)
for developing smart contracts on Flow.

Before reading this standard,
we recommend completing the [Cadence tutorials](https://cadence-lang.org/docs/tutorial/first-steps)
to build a basic understanding of the programming language.

Resource-oriented programming, and by extension Cadence,
provides an ideal programming model for non-fungible tokens (NFTs).
Users are able to store their NFT objects directly in their accounts and transact
peer-to-peer. Learn more in this [blog post about resources](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e).

## Import Addresses

The `NonFungibleToken`, `ViewResolver`, and `MetadataViews` contracts are already deployed
on various networks. You can import them in your contracts from these addresses.
There is no need to deploy them yourself.

Note: With the emulator, you must use the -contracts flag to deploy these contracts.

| Network           | Contract Address     |
| ------------------| -------------------- |
| Emulator/Canary   | `0xf8d6e0586b0a20c7` |
| PreviewNet        | `0xb6763b4399a888c8` |
| Testnet/Crescendo | `0x631e88ae7f1d7c20` |
| Mainnet           | `0x1d7e57aa55817448` |

## Core Types

Contracts that implement the `NonFungibleToken` interface are expected
to utilize two resource interfaces:

- `NFT` - A resource interface that describes the structure of a single NFT.
- `Collection` - A resource interface that describes an object
  that can hold multiple NFTs of the same type and defines ways
  to deposit, withdraw, and query information about the stored NFTs.

  Users typically store one collection per NFT type, saved at a well-known location in their account storage.

  For example, all NBA Top Shot Moments owned by a single user are held in a [`TopShot.Collection`](https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc#L605) stored in their account at the path `/storage/MomentCollection`.

## Core Features

The `NonFungibleToken` contract defines the following set of functionality
that should be included in each implementation:

### Create a new NFT collection

Create a new collection using the `Token.createEmptyCollection(nftType: Type)` function.

This function MUST return an empty collection that contains no NFTs.

Users typically save new collections to a contract-defined location in their account
and public a capability to their collection.

### Withdraw an NFT

Withdraw an `NFT` from a `Collection` using the [`withdraw()`](contracts/ExampleNFT.cdc#L160) function.
This function emits the [`NonFungibleToken.Withdrawn`](contracts/NonFungibleToken.cdc#L78) event automatically.

### Deposit an NFT

Deposit an `NFT` into a `Collection` using the [`deposit()`](contracts/ExampleNFT.cdc#L169-L176) function.
This function emits the [`NonFungibleToken.Deposited`](contracts/NonFungibleToken.cdc#L86) event automatically.

#### ⚠️ Important

In order to comply with the deposit function in the interface,
an implementation MUST take a `@{NonFungibleToken.NFT}` resource as an argument.
This means that anyone can send a resource object that conforms to `{NonFungibleToken.NFT}` to a deposit function.
In an implementation, you MUST cast the `token` as your specific token type before depositing it or you will
deposit another token type into your collection. For example:

```cadence
/// `ExampleNFT` much be changed to the name of your contract
let token <- token as! @ExampleNFT.NFT
```

### List NFTs in an account

Return a list of NFTs in a `Collection` using the [`getIDs`](contracts/ExampleNFT.cdc#L179) function.

### Return the NFT type that a collection can accept in a deposit

Return types of NFTs that a `Collection` can accept in a deposit
using the [`getSupportedNFTTypes`](contracts/ExampleNFT.cdc#L143-L157) functions.

### Get Available SubNFTs, if any

Some NFTs can own other NFTs, the standard provides a [function](contracts/NonFungibleToken.cdc#L111-L131) that
projects can optionally implement to return information the owned NFTs.

## NFT Metadata

The primary documentation for metadata views is on [the Flow developer portal](https://developers.flow.com/build/advanced-concepts/metadata-views).
Please refer to that for the most thorough exploration of the views with examples.

NFT metadata is represented in a flexible and modular way using
the [standard proposed in FLIP-0636](https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md).

When writing an NFT contract,
you should implement the [`MetadataViews.Resolver`](contracts/MetadataViews.cdc#L3-L6) interface,
which allows your NFT to utilize one or more metadata types called views.

Each view represents a different type of metadata,
such as an on-chain creator biography or an off-chain video clip.
Views do not specify or require how to store your metadata, they only specify
the format to query and return them, so projects can still be flexible with how they store their data.

### How to read metadata

This example shows how to read basic information about an NFT
including the name, description, image and owner.

**Source: [get_nft_metadata.cdc](scripts/get_nft_metadata.cdc)**

### How to implement metadata

The [example NFT contract](contracts/ExampleNFT.cdc) shows a basic example
for how to implement metadata views.

### List of views

The views marked as `Core views` are considered the minimum required views to provide a full picture of any NFT. If you want your NFT to be able to be easily accessed and understood by third-party apps such as the [Flow NFT Catalog](https://nft-catalog.vercel.app/) it should implement all of them as a pre-requisite.

| Name        | Purpose                                    | Status      | Source                                              | Core view
| ----------- | ------------------------------------------ | ----------- | --------------------------------------------------- | --------------------------------------------------- |
| `NFTView`   | Basic view that includes the name, description and thumbnail. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L32-L65)  |
| `Display`   | Return the basic representation of an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L85-L120)  | :white_check_mark: |
| `HTTPFile`  | A file available at an HTTP(S) URL.        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L143-L155)  |
| `IPFSFile`  | A file stored in IPFS.                     | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L157-L195) |
| `Edition`   | Return information about one or more editions for an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L197-L229) |
| `Editions`  | Wrapper for multiple edition views.        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L176-L187)|
| `Serial`    | Serial number for an NFT.                  | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L258-L270)| :white_check_mark: |
| `Royalty`   | A Royalty Cut for a given NFT.             | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L286-L323) |
| `Royalties` | Wrapper for multiple Royalty views.        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L325-L352) | :white_check_mark: |
| `Media`     | Represents a file with a corresponding mediaType | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L378-L395)|
| `Medias`    | Wrapper for multiple Media views.          | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L397-L407)|
| `License`   | Represents a license according to https://spdx.org/licenses/ | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L423-L432)|
| `ExternalURL`| Exposes a URL to an NFT on an external site. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L448-L458)| :white_check_mark: |
| `NFTCollectionData` | Provides storage and retrieval information of an NFT | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L474-L531) | :white_check_mark: |
| `NFTCollectionDisplay` | Returns the basic representation of an NFT's Collection.  | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L547-L586) | :white_check_mark: |
| `Rarity`   | Expose rarity information for an NFT        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L603-L628)|
| `Trait`    | Represents a single field of metadata on an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L644-L671)|
| `Traits`   | Wrapper for multiple Trait views            | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L673-L690)| :white_check_mark: |

## How to propose a new view

Please open a issue or a pull request to propose a new metadata view
or changes to an existing view.

## Feedback

We'd love to hear from anyone who has feedback. For example:

- Are there any features that are missing from the standard?
- Are the current features defined in the best way possible?
- Are there any pre and post conditions that are missing?
- Are the pre and post conditions defined well enough? Error messages?
- Are there any other actions that need an event defined for them?
- Are the current event definitions clear enough and do they provide enough information?
- Are there any openings for bugs or vulnerabilities that we are not noticing?

Please create an issue in this repository if there is a feature that
you believe needs discussing or changing.

## Comparison to other standards on Ethereum

This standard covers much of the same ground as ERC-721 and ERC-1155,
but without most of the downsides.

- Tokens cannot be sent to contracts that don't understand how to use them, because an account needs to have a `Receiver` or `Collection` in its storage to receive tokens.
- If the recipient is a contract that has a stored `Collection`, the tokens can just be deposited to that Collection without having to do a clunky `approve`, `transferFrom`.
- Events are defined in the contract for withdrawing and depositing, so a recipient will always be notified that someone has sent them tokens with their own deposit event.
- This version can support batch transfers of NFTs. Even though it isn't explicitly defined in the contract, a batch transfer can be done within a transaction by just withdrawing all the tokens to transfer, then depositing them wherever they need to be, all atomically.
- Transfers can trigger actions because users can define custom `Receivers` to execute certain code when a token is sent.
- Easy ownership indexing: rather than iterating through all tokens to find which ones you own, you have them all stored in your account's collection and can get the list of the ones you own instantly.

## How to test the standard

If you want to test out these contracts, we recommend either testing them
with the [Flow Playground](https://play.flow.com)
or with the [Visual Studio Code Extension](https://github.com/onflow/flow/blob/master/docs/vscode-extension.md#cadence-visual-studio-code-extension).

If you are not making/testing any modifications to the standard contracts,
they are already deployed to the addresses listed above and you can just import
from those directly instead of deploying them yourself.

If you want to test changes to the standards, the steps to follow are:

1. Deploy `ViewResolver.cdc`
2. Deploy `NonFungibleToken.cdc`, importing `ViewResolver`.
3. Deploy `ExampleNFT.cdc`, importing `NonFungibleToken`.

Then you can experiment with some of the other transactions and scripts in `transactions/`
or even write your own. You'll need to replace some of the import address placeholders with addresses that you deploy to, as well as some of the transaction arguments.

## Running automated tests

You can find automated tests written in the
[Cadence testing framework](https://developers.flow.com/build/smart-contracts/testing)
in the `tests/` directory.
Use `flow test tests/test_example_nft.cdc` to run these tests.

More tests, written in Go, are in the `lib/go/test/` directory.
They use the transaction templates package that is contained in the `lib/go/templates/` directory.
To run the Go tests, you can run `make test` from the repository root.
Contract and transaction assets must be generated before individual tests can be run,
so if you are wanting to run the tests individually via `go test`,
you must run `make generate` from within the `lib/go/` directory
after every revision you make to the contract or transaction files.

## License

The works in these files:

- [ExampleNFT.cdc](contracts/ExampleNFT.cdc)
- [NonFungibleToken.cdc](contracts/NonFungibleToken.cdc)
- [MetadataViews.cdc](contracts/MetadataViews.cdc)
- [ViewResolver.cdc](contracts/ViewResolver.cdc)

are under the [Unlicense](LICENSE).





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/transfer_nft.cdc

```
/// This transaction is for transferring an ExampleNFT from one account to another

import "ViewResolver"
import "MetadataViews"
import "NonFungibleToken"

transaction(contractAddress: Address, contractName: String, recipient: Address, withdrawID: UInt64) {

    /// Reference to the withdrawer's collection
    let withdrawRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}

    /// Reference of the collection to deposit the NFT to
    let receiverRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        // borrow the NFT contract as ViewResolver reference
        let viewResolver = getAccount(contractAddress).contracts.borrow<&{ViewResolver}>(name: contractName)
            ?? panic("Could not borrow ViewResolver reference to the contract. Make sure the provided contract name ("
                      .concat(contractName).concat(") and address (").concat(contractAddress.toString()).concat(") are correct!"))

        // resolve the NFT collection data from the NFT contract
        let collectionData = viewResolver.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))

        // borrow a reference to the signer's NFT collection
        self.withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("The signer does not store a "
                        .concat(contractName)
                        .concat(".Collection object at the path ")
                        .concat(collectionData.storagePath.toString())
                        .concat("The signer must initialize their account with this collection first!"))

        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a public reference to the receivers collection
        let receiverCap = recipient.capabilities.get<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
        self.receiverRef = receiverCap.borrow()
            ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                    .concat(collectionData.publicPath.toString())
                    .concat(" that is capable of receiving an NFT.")
                    .concat("The recipient must initialize their account with this collection and receiver first!"))
    }

    execute {

        let nft <- self.withdrawRef.withdraw(withdrawID: withdrawID)
        self.receiverRef.deposit(token: <-nft)

    }

    post {
        !self.withdrawRef.getIDs().contains(withdrawID): "Original owner should not have the NFT anymore"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/CrossVMMetadataViews.cdc

```
import "ViewResolver"
import "EVM"

/// This contract implements views originally proposed in FLIP-318 supporting NFT collections
/// with project-defined implementations across both Cadence & EVM.
/// The View structs in this contract should be implemented in the same way that views from `MetadataViews` are implemented
/// 
access(all) contract CrossVMMetadataViews {

    /// An enum denoting a VM. For now, there are only two VMs on Flow, but this enum could be
    /// expanded in the event other VMs are supported on the network.
    ///
    access(all) enum VM : UInt8 {
        access(all) case Cadence
        access(all) case EVM
    }

    /// View resolved at contract & resource level pointing to the associated EVM implementation.
    /// NOTE: This view alone is not sufficient to validate an association across Cadence & EVM!
    /// Both the Cadence Type/contract *and* the EVM contract should point to each other, with the
    /// EVM pointer being facilitated by ICrossVM.sol contract interface methods. For more
    /// information and context, see FLIP-318: https://github.com/onflow/flips/issues/318
    ///
    access(all) struct EVMPointer {
        /// The associated Cadence Type defined in the contract that this view is returned from
        access(all) let cadenceType: Type
        /// The defining Cadence contract address
        access(all) let cadenceContractAddress: Address
        /// The associated EVM contract address that the Cadence contract will bridge to
        access(all) let evmContractAddress: EVM.EVMAddress
        /// Whether the asset is Cadence- or EVM-native. Native here meaning the VM in which the
        /// asset is originally distributed.
        access(all) let nativeVM: VM

        init(
            cadenceType: Type,
            cadenceContractAddress: Address,
            evmContractAddress: EVM.EVMAddress,
            nativeVM: VM
        ) {
            self.cadenceType = cadenceType
            self.cadenceContractAddress = cadenceContractAddress
            self.evmContractAddress = evmContractAddress
            self.nativeVM = nativeVM
        }
    }

    access(all) fun getEVMPointer(_ viewResolver: &{ViewResolver.Resolver}): EVMPointer? {
        if let view = viewResolver.resolveView(Type<EVMPointer>()) {
            if let v = view as? EVMPointer {
                return v
            }
        }
        return nil
    }

    /// View resolved at resource level denoting any metadata to be passed to the associated EVM
    /// contract at the time of bridging. This optional view would allow EVM side metadata to be
    /// updated based on current Cadence state. If the view is not supported, no bytes will be
    /// passed into EVM when bridging.
    ///
    access(all) struct EVMBytesMetadata {
        /// Returns the bytes to be passed to the EVM contract on `fulfillToEVM` call, allowing the
        /// EVM contract to update the metadata associated with the NFT. The corresponding Solidity
        /// `bytes` type allows the implementer greater flexibility by enabling them to pass
        /// arbitrary data between VMs.
        access(all) let bytes: EVM.EVMBytes

        init(bytes: EVM.EVMBytes) {
            self.bytes = bytes
        }
    }

    access(all) fun getEVMBytesMetadata(_ viewResolver: &{ViewResolver.Resolver}): EVMBytesMetadata? {
        if let view = viewResolver.resolveView(Type<EVMBytesMetadata>()) {
            if let v = view as? EVMBytesMetadata {
                return v
            }
        }
        return nil
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/ViewResolver.cdc

```
// Taken from the NFT Metadata standard, this contract exposes an interface to let 
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
access(all) contract interface ViewResolver {

    /// Function that returns all the Metadata Views implemented by the resolving contract.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there is an optional parameter to specify which resource type the caller
    /// is requesting views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type]

    /// Function that resolves a metadata view for this token.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there there is an optional parameter for specify which resource type the caller
    /// is looking for views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct?

    /// Provides access to a set of metadata views. A struct or 
    /// resource (e.g. an NFT) can implement this interface to provide access to 
    /// the views that it supports.
    ///
    access(all) resource interface Resolver {

        /// Same as getViews above, but on a specific NFT instead of a contract
        access(all) view fun getViews(): [Type]

        /// Same as resolveView above, but on a specific NFT instead of a contract
        access(all) fun resolveView(_ view: Type): AnyStruct?
    }

    /// A group of view resolvers indexed by ID.
    ///
    access(all) resource interface ResolverCollection {
        access(all) view fun borrowViewResolver(id: UInt64): &{Resolver}? {
            return nil
        }

        access(all) view fun getIDs(): [UInt64] {
            return []
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/docs/MetdataViews/MetadataViews_EVMBridgedMetadata.md

# Struct `EVMBridgedMetadata`

```cadence
pub struct EVMBridgedMetadata {

    pub let name: String

    pub let symbol: String

    pub let uri: {File}
}
```

This view may be used by Cadence-native projects to define contract-
and token-level metadata according to EVM-compatible formats. Several
ERC standards (e.g. ERC20, ERC721, etc.) expose name and symbol values
to define assets as well as contract- & token-level metadata view
`tokenURI(uint256)` and `contractURI()` methods. This view enables
Cadence projects to define in their own contracts how they would like
their metadata to be defined when bridged to EVM.

### Initializer

```cadence
init(name: String, symbol: String, uri: {File}) 
```

---





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/setup_account_from_address.cdc

```
import "NonFungibleToken"
import "MetadataViews"

#interaction (
  version: "1.0.0",
	title: "Generic FT Transfer with Contract Address and Name",
	description: "Transfer any Fungible Token by providing the contract address and name",
	language: "en-US",
)

/// This transaction is what an account would run
/// to set itself up to receive NFTs. This function
/// uses views to know where to set up the collection
/// in storage and to create the empty collection.
///
/// @param contractAddress: The address of the contract that defines the token being initialized
/// @param contractName: The name of the contract that defines the token being initialized. Ex: "ExampleNFT"

transaction(contractAddress: Address, contractName: String) {

    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        // Borrow a reference to the nft contract deployed to the passed account
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{NonFungibleToken}>(name: contractName)
                ?? panic("Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name ("
                         .concat(contractName).concat(") and address (").concat(contractAddress.toString()).concat(") are correct!"))

        // Use that reference to retrieve the NFTCollectionData view 
        let collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))

        // Create a new empty collections
        let emptyCollection <- collectionData.createEmptyCollection()

        // save it to the account
        signer.storage.save(<-emptyCollection, to: collectionData.storagePath)

        // create a public capability for the collection
        let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/setup_account_from_nft_reference.cdc

```
/// This transaction is what an account would run
/// to set itself up to receive NFTs. This function
/// uses views to know where to set up the collection
/// in storage and to create the empty collection.

import "NonFungibleToken"
import "MetadataViews"

transaction(address: Address, publicPath: PublicPath, id: UInt64) {

    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        let collection = getAccount(address).capabilities.borrow<&{NonFungibleToken.Collection}>(publicPath)
            ?? panic("Could not borrow a reference to the NonFungibleToken Collection for the account with Address "
                      .concat(address.toString())
                      .concat(" at path ")
                      .concat(publicPath.toString())
                      .concat(". The account needs to set up their collection first"))

        let nftRef = collection.borrowNFT(id)
            ?? panic("Could not borrow a reference to the desired NFT with id "
                      .concat(id.toString()))
        
        let collectionData = nftRef.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData

        // Create a new empty collections
        let emptyCollection <- collectionData.createEmptyCollection()

        // save it to the account
        signer.storage.save(<-emptyCollection, to: collectionData.storagePath)

        // create a public capability for the collection
        let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        signer.capabilities.publish(collectionCap, at: publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/utility/NFTForwarding.cdc

```
/// ## Non-Fungible Token Forwarding Contract
///
/// This contract enables a user to designate a recipient so NFTs could be forwarded
///
/// The NFTForwarder resource can be referenced just like any NonFungibleToken Collection,
/// allowing a sender to deposit NFTs as they usually would
///
/// However, in this implementation, any time a deposit is made, the deposited NFT is
/// additionally deposited to a predefined recipient Collection.
///
/// To create an NFTForwarder resource, an account calls the createNewNFTForwarder()
/// function, passing the Collection Capability to which NFTs will be forwarded.
///
import "NonFungibleToken"

access(all) contract NFTForwarding {

    access(all) entitlement Mutable

    access(all) event ForwardedNFTDeposit(id: UInt64, uuid: UInt64, from: Address?, fromUUID: UInt64, to: Address?, toUUID: UInt64)
    access(all) event UpdatedNFTForwarderRecipient(forwarderAddress: Address?, forwarderUUID: UInt64, newRecipientAddress: Address?, newRecipientUUID: UInt64)

    /// Canonical Storage and Public paths
    ///
    access(all) let StoragePath: StoragePath

    /// Resource that forwards deposited NFTs to a designated recipient's Collection
    ///
    access(all) resource NFTForwarder: NonFungibleToken.Receiver {

        /// Recipient to which NFTs will be forwarded
        ///
        access(self) var recipient: Capability<&{NonFungibleToken.Collection}>

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let recipientRef = self.borrowRecipientCollection()
                ?? panic("NFTForwarding.NFTForwarder.getSupportedNFTTypes: "
                        .concat("Could not borrow a reference to the recipient's NFT Collection!"))
            return recipientRef.getSupportedNFTTypes()
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           let types = self.getSupportedNFTTypes()
           if let supported = types[type] {
                return supported
           }
           return false
        }

        /// Allows for deposits of NFT resources, forwarding
        /// passed deposits to the designated recipient
        ///
        /// @param token: NFT to be deposited
        ///
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            post {
                recipientRef.getIDs().contains(id): 
                    "NFTForwarding.NFTForwarder.deposit: Could not forward deposited NFT! "
                    .concat("The recipient's collection did not contain the transferred NFT with ID ")
                    .concat(id.toString()).concat(" after function execution.")
            }

            let recipientRef = self.borrowRecipientCollection()
                ?? panic("Could not borrow reference to recipient's Collection!")
            let id = token.id
            let uuid = token.uuid

            recipientRef.deposit(token: <-token)

            emit ForwardedNFTDeposit(id: id, uuid: uuid, from: self.owner?.address, fromUUID: self.uuid, to: recipientRef.owner?.address, toUUID: recipientRef.uuid)
        }

        /// Enables reference retrieval of the recipient's Collection or nil
        ///
        /// @return a reference to the recipient's Collection or nil if the Capability is no longer valid
        ///
        access(all) view fun borrowRecipientCollection(): &{NonFungibleToken.Collection}? {
            return self.recipient.borrow() ?? nil
        }

        /// Function that allows resource owner to change the recipient of
        /// forwarded NFTs
        ///
        /// @param newRecipient: NonFungibleToken.Collection Capability
        ///
        access(Mutable) fun changeRecipient(_ newRecipient: Capability<&{NonFungibleToken.Collection}>) {
            pre {
                newRecipient.check():
                    "NFTForwarding.NFTForwarder.init: Could not borrow NFT Collection reference from the given Capability."
                    .concat(" Ensure the Capability is valid before initializing with recipient.check().")
            }

            self.recipient = newRecipient
            let recipientRef = self.recipient.borrow()!
            emit UpdatedNFTForwarderRecipient(forwarderAddress: self.owner?.address, forwarderUUID: self.uuid, newRecipientAddress: recipientRef.owner?.address, newRecipientUUID: recipientRef.uuid)
        }

        init(_ recipient: Capability<&{NonFungibleToken.Collection}>) {
            pre {
                recipient.check():
                    "NFTForwarding.NFTForwarder.init: Could not borrow NFT Collection reference from the given Capability."
                    .concat(" Ensure the Capability is valid before initializing with recipient.check().")
            }
            self.recipient = recipient
            let recipientRef = self.recipient.borrow()!
            emit UpdatedNFTForwarderRecipient(forwarderAddress: self.owner?.address, forwarderUUID: self.uuid, newRecipientAddress: recipientRef.owner?.address, newRecipientUUID: recipientRef.uuid)
        }
    }

    /// Creates a new NFTForwarder with the passed recipient capability
    ///
    /// @param recipient: NonFungibleToken.Collection Capability
    /// @return a new NFTForwarder resource
    ///
    access(all) fun createNewNFTForwarder(recipient: Capability<&{NonFungibleToken.Collection}>): @NFTForwarder {
        return <- create NFTForwarder(recipient)
    }

    init() {
        self.StoragePath = /storage/ExampleNFTForwarder
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc

```
/*
*
*  This is an example implementation of a Flow Non-Fungible Token
*  using the V2 standard.
*  It is not part of the official standard but it assumed to be
*  similar to how many NFTs would implement the core functionality.
*
*  This contract does not implement any sophisticated classification
*  system for its NFTs. It defines a simple NFT with minimal metadata.
*
*/

import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "CrossVMMetadataViews"
import "EVM"

access(all) contract ExampleNFT: NonFungibleToken {

    /// Standard Paths
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath

    /// Path where the minter should be stored
    /// The standard paths for the collection are stored in the collection resource type
    access(all) let MinterStoragePath: StoragePath

    /// Event to show when an NFT is minted
    access(all) event Minted(
        type: String,
        id: UInt64,
        uuid: UInt64,
        minterAddress: Address?,
        minterUUID: UInt64,
        name: String,
        description: String
    )

    /// We choose the name NFT here, but this type can have any name now
    /// because the interface does not require it to have a specific name any more
    access(all) resource NFT: NonFungibleToken.NFT {

        access(all) let id: UInt64

        /// From the Display metadata view
        access(all) let name: String
        access(all) let description: String
        access(all) let thumbnail: String

        /// For the Royalties metadata view
        access(self) let royalties: [MetadataViews.Royalty]

        /// Generic dictionary of traits the NFT has
        access(self) let metadata: {String: AnyStruct}

        init(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
        ) {
            self.id = self.uuid
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.royalties = royalties
            self.metadata = metadata
        }

        /// createEmptyCollection creates an empty Collection
        /// and returns it to the caller so that they can own NFTs
        /// @{NonFungibleToken.Collection}
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Example NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://example-nft.onflow.org/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    // foo is a trait with its own rarity
                    let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
                    let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
                    traitsView.addTrait(fooTrait)

                    return traitsView
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Implementing this view gives the project control over how the bridged NFT is represented as an
                    // ERC721 when bridged to EVM on Flow via the public infrastructure bridge.
                    // NOTE: If your NFT is a cross-VM NFT, meaning you control both your Cadence & EVM contracts and
                    //      registered your custom association with the VM bridge, it's recommended you use the 
                    //      CrossVMMetadata.EVMBytesMetadata view to define and pass metadata as EVMBytes into your
                    //      EVM contract at the time of bridging into EVM. For more information about cross-VM NFTs,
                    //      see FLIP-318: https://github.com/onflow/flips/issues/318

                    // Get the contract-level name and symbol values
                    let contractLevel = ExampleNFT.resolveContractView(
                            resourceType: nil,
                            viewType: Type<MetadataViews.EVMBridgedMetadata>()
                        ) as! MetadataViews.EVMBridgedMetadata?

                    if let contractMetadata = contractLevel {
                        // Compose the token-level URI based on a base URI and the token ID, pointing to a JSON file. This
                        // would be a file you've uploaded and are hosting somewhere - in this case HTTP, but this could be
                        // IPFS, S3, a data URL containing the JSON directly, etc.
                        let baseURI = "https://example-nft.onflow.org/token-metadata/"
                        let uriValue = self.id.toString().concat(".json")

                        return MetadataViews.EVMBridgedMetadata(
                            name: contractMetadata.name,
                            symbol: contractMetadata.symbol,
                            uri: MetadataViews.URI(
                                baseURI: baseURI, // defining baseURI results in a concatenation of baseURI and value
                                value: self.id.toString().concat(".json")
                            )
                        )
                    } else {
                        return nil
                    }
                case Type<CrossVMMetadataViews.EVMPointer>():
                    // This view is intended for NFT projects with corresponding NFT implementations in both Cadence and
                    // EVM. Resolving EVMPointer indicates the associated EVM implementation. Fully validating the
                    // cross-VM association would involve inspecting the associated EVM contract and ensuring that
                    // contract also points to the resolved Cadence type and contract address. For more information
                    // about cross-VM NFTs, see FLIP-318: https://github.com/onflow/flips/issues/318

                    return ExampleNFT.resolveContractView(resourceType: self.getType(), viewType: view)
                case Type<CrossVMMetadataViews.EVMBytesMetadata>():
                    // This view is intended for Cadence-native NFTs with corresponding ERC721 implementations. By
                    // resolving, you're able to pass arbitrary metadata into your EVM contract whenever an NFT is
                    // bridged which can be useful for Cadence NFTs with dynamic metadata values.
                    // See FLIP-318 for more information about cross-VM NFTs: https://github.com/onflow/flips/issues/318

                    // Here we encoded the EVMBridgedMetadata URI and encode the string as EVM bytes, but you could pass any
                    // Cadence values that can be abi encoded and decode them in your EVM contract as you wish. Within
                    // your EVM contract, you can abi decode the bytes and update metadata in your ERC721 contract as
                    // you see fit.
                    let bridgedMetadata = (self.resolveView(Type<MetadataViews.EVMBridgedMetadata>()) as! MetadataViews.EVMBridgedMetadata?)!
                    let uri = bridgedMetadata.uri.uri()
                    let encodedURI = EVM.encodeABI([uri])
                    let evmBytes = EVM.EVMBytes(value: encodedURI)
                    return CrossVMMetadataViews.EVMBytesMetadata(bytes: evmBytes)
            }
            return nil
        }
    }

    // Deprecated: Only here for backward compatibility.
    access(all) resource interface ExampleNFTCollectionPublic {}

    access(all) resource Collection: NonFungibleToken.Collection, ExampleNFTCollectionPublic {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an `UInt64` ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init () {
            self.ownedNFTs <- {}
        }

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@ExampleNFT.NFT>()] = true
            return supportedTypes
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            return type == Type<@ExampleNFT.NFT>()
        }

        /// withdraw removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("ExampleNFT.Collection.withdraw: Could not withdraw an NFT with ID "
                        .concat(withdrawID.toString())
                        .concat(". Check the submitted ID to make sure it is one that this collection owns."))

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @ExampleNFT.NFT
            let id = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken

            // This code is for testing purposes only
            // Do not add to your contract unless you have a specific
            // reason to want to emit the NFTUpdated event somewhere
            // in your contract
            let authTokenRef = (&self.ownedNFTs[id] as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT}?)!
            //authTokenRef.updateTransferDate(date: getCurrentBlock().timestamp)
            ExampleNFT.emitNFTUpdated(authTokenRef)
        }

        /// getIDs returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: self.CollectionStoragePath,
                    publicPath: self.CollectionPublicPath,
                    publicCollection: Type<&ExampleNFT.Collection>(),
                    publicLinkedType: Type<&ExampleNFT.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://example-nft.onflow.org"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                // Implementing this view gives the project control over how the bridged NFT is represented as an ERC721
                // when bridged to EVM on Flow via the public infrastructure bridge.

                // Compose the contract-level URI. In this case, the contract metadata is located on some HTTP host,
                // but it could be IPFS, S3, a data URL containing the JSON directly, etc.
                return MetadataViews.EVMBridgedMetadata(
                    name: "ExampleNFT",
                    symbol: "XMPL",
                    uri: MetadataViews.URI(
                        baseURI: nil, // setting baseURI as nil sets the given value as the uri field value
                        value: "https://example-nft.onflow.org/contract-metadata.json"
                    )
                )
            case Type<CrossVMMetadataViews.EVMPointer>():
                // This view is intended for NFT projects with corresponding NFT implementations in both Cadence and
                // EVM. Resolving EVMPointer indicates the associated EVM implementation. Fully validating the
                // cross-VM association would involve inspecting the associated EVM contract and ensuring that contract
                // also points to the resolved Cadence type and contract address. For more information about cross-VM
                // NFTs, see FLIP-318: https://github.com/onflow/flips/issues/318

                // Assigning a dummy EVM address and deserializing. Implementations would want to declare the actual
                // EVM address corresponding to their corresponding ERC721. If using a proxy in your EVM contracts, this
                // address should be your proxy's address.
                let evmContractAddress = EVM.addressFromString(
                        "0x1234565789012345657890123456578901234565"
                    )
                // Since this NFT is distributed in Cadence, it's declared as Cadence-native
                let nativeVM = CrossVMMetadataViews.VM.Cadence
                return CrossVMMetadataViews.EVMPointer(
                    cadenceType: Type<@ExampleNFT.NFT>(),
                    cadenceContractAddress: self.account.address,
                    evmContractAddress: evmContractAddress,
                    nativeVM: nativeVM
                )
        }
        return nil
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    access(all) resource NFTMinter {

        /// mintNFT mints a new NFT with a new ID
        /// and returns it to the calling context
        access(all) fun mintNFT(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty]
        ): @ExampleNFT.NFT {

            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp

            // this piece of metadata will be used to show embedding rarity into a trait
            metadata["foo"] = "bar"

            // create a new NFT
            var newNFT <- create NFT(
                name: name,
                description: description,
                thumbnail: thumbnail,
                royalties: royalties,
                metadata: metadata,
            )

            emit Minted(type: newNFT.getType().identifier,
                        id: newNFT.id,
                        uuid: newNFT.uuid,
                        minterAddress: self.owner?.address,
                        minterUUID: self.uuid,
                        name: name,
                        description: description)

            return <-newNFT
        }
    }

    init() {

        // Set the named paths
        self.CollectionStoragePath = /storage/exampleNFTCollection
        self.CollectionPublicPath = /public/exampleNFTCollection
        self.MinterStoragePath = /storage/exampleNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.storage.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        let collectionCap = self.account.capabilities.storage.issue<&ExampleNFT.Collection>(self.CollectionStoragePath)
        self.account.capabilities.publish(collectionCap, at: self.CollectionPublicPath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.storage.save(<-minter, to: self.MinterStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/transactions/generic_transfer_with_address_and_type.cdc

```
import "NonFungibleToken"
import "MetadataViews"

#interaction (
  version: "1.0.0",
	title: "Generic NFT Transfer with Contract Address and Name",
	description: "Transfer any Non-Fungible Token by providing the contract address and name and type name",
	language: "en-US",
)

/// Can pass in any contract address and name and NFT type name
/// This lets you choose the token you want to send because
/// the transaction gets the metadata from the provided contract.
///
/// @param to: The address to transfer the token to
/// @param id: The id of token to transfer
/// @param contractAddress: The address of the contract that defines the token being transferred
/// @param contractName: The name of the contract that defines the token being transferred. Ex: "ExampleNFT"
/// @param nftTypeName: The type name of the NFT that the user wants to transfer
///                 Ex: "NFT"
///
transaction(to: Address, id: UInt64, contractAddress: Address, contractName: String, nftTypeName: String) {

    // The NFT resource to be transferred
    let tempNFT: @{NonFungibleToken.NFT}

    // NFTCollectionData struct to get paths from
    let collectionData: MetadataViews.NFTCollectionData

    prepare(signer: auth(BorrowValue) &Account) {

        // Borrow a reference to the nft contract deployed to the passed account
        let resolverRef = getAccount(contractAddress)
            .contracts.borrow<&{NonFungibleToken}>(name: contractName)
                ?? panic("Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name "
                          .concat(contractName).concat(" and address ").concat(contractAddress.toString()).concat(" are correct!"))
        
        // Get the string representation of the address without the 0x
        var addressString = contractAddress.toString()
        if addressString.length == 18 {
            addressString = addressString.slice(from: 2, upTo: 18)
        }
        let typeString: String = "A.".concat(addressString).concat(".").concat(contractName).concat(".").concat(nftTypeName)
        let type = CompositeType(typeString)
        assert(
            type != nil,
            message: "Could not create a type out of the contract name "
                      .concat(contractName)
                      .concat(" and address ")
                      .concat(addressString)
                      .concat("!")
        )

        // Use that reference to retrieve the NFTCollectionData view 
        self.collectionData = resolverRef.resolveContractView(resourceType: type, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view. The ".concat(contractName).concat(" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction"))

        // borrow a reference to the signer's NFT collection
        let withdrawRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: self.collectionData.storagePath
            ) ?? panic("The signer does not store a "
                        .concat(contractName)
                        .concat(" Collection object at the path ")
                        .concat(self.collectionData.storagePath.toString())
                        .concat("The signer must initialize their account with this collection first!"))

        self.tempNFT <- withdrawRef.withdraw(withdrawID: id)

        assert(
            self.tempNFT.getType() == type!,
            message: "The NFT that was withdrawn to transfer is not the type that was requested <"
                     .concat(typeString).concat(">.")
        )
    }

    execute {
        // get the recipients public account object
        let recipient = getAccount(to)

        // borrow a public reference to the receivers collection
        let receiverRef = recipient.capabilities.borrow<&{NonFungibleToken.Receiver}>(self.collectionData.publicPath)
            ?? panic("The recipient does not have a NonFungibleToken Receiver at "
                        .concat(self.collectionData.publicPath.toString())
                        .concat(" that is capable of receiving a ")
                        .concat(contractName)
                        .concat(" NFT.")
                        .concat("The recipient must initialize their account with this collection and receiver first!"))

        // Deposit the NFT to the receiver
        receiverRef.deposit(token: <-self.tempNFT)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/.github/ISSUE_TEMPLATE/bug-report.md

---
name: Reporting a Problem/Bug
about: Reporting a Problem/Bug
title: ''
labels: bug, Feedback
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Problem

<what is the problem you've encountered?> 

### Steps to Reproduce 

<share any logs/screenshots or steps to replicate>

### Acceptance Criteria

<if any>
  
### Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/.changeset/README.md

# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/example-nft/get_ids.cdc

```
/// Script to get NFT IDs in an account's collection

import "NonFungibleToken"
import "ExampleNFT"

access(all) fun main(address: Address, collectionPublicPath: PublicPath): [UInt64] {
    let account = getAccount(address)

    let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection}>(
            collectionPublicPath
        ) ?? panic("Could not borrow capability from collection at specified path")

    return collectionRef.getIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-nft/setup_account.cdc

```
/// This transaction is what an account would run
/// to set itself up to receive NFTs

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // Return early if the account already has a collection
        if signer.storage.borrow<&ExampleNFT.Collection>(from: collectionData.storagePath) != nil {
            return
        }

        // Create a new empty collection
        let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())

        // save it to the account
        signer.storage.save(<-collection, to: collectionData.storagePath)

        // create a public capability for the collection
        signer.capabilities.unpublish(collectionData.publicPath)
        let collectionCap = signer.capabilities.storage.issue<&ExampleNFT.Collection>(collectionData.storagePath)
        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-nft/transfer_nft.cdc

```
/// This transaction is for transferring and NFT from
/// one account to another

import "NonFungibleToken"
import "ExampleNFT"

transaction(recipient: Address, withdrawID: UInt64) {

    /// Reference to the withdrawer's collection
    let withdrawRef: &ExampleNFT.Collection

    /// Reference of the collection to deposit the NFT to
    let depositRef: &{NonFungibleToken.CollectionPublic}

    prepare(signer: AuthAccount) {
        // borrow a reference to the signer's NFT collection
        self.withdrawRef = signer.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath)
            ?? panic("Account does not store an object at the specified path")

        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a public reference to the receivers collection
        self.depositRef = recipient.getCapability<&{NonFungibleToken.CollectionPublic}>(
                ExampleNFT.CollectionPublicPath
            ).borrow()
            ?? panic("Could not borrow a reference to the receiver's collection")

    }

    execute {

        // withdraw the NFT from the owner's collection
        let nft <- self.withdrawRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        self.depositRef.deposit(token: <-nft)
    }

    post {
        !self.withdrawRef.getIDs().contains(withdrawID): "Original owner should not have the NFT anymore"
        self.depositRef.getIDs().contains(withdrawID): "The reciever should now own the NFT"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/NFTCatalogAdmin.cdc

```
import "NFTCatalog"

// NFTCatalogAdmin
//
// An admin contract that defines an    admin resource and
// a proxy resource to receive a capability that lets you make changes to the NFT Catalog
// and manage proposals

access(all) contract NFTCatalogAdmin {

    access(all) entitlement CatalogActions

    // AddProposalAccepted
    // Emitted when a proposal to add a new catalog item has been approved by an admin
    access(all) event AddProposalAccepted(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    // UpdateProposalAccepted
    // Emitted when a proposal to update a catalog item has been approved by an admin
    access(all) event UpdateProposalAccepted(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    // ProposalRejected
    // Emitted when a proposal to add or update a catalog item has been rejected.
    access(all) event ProposalRejected(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    access(all) let AdminPrivatePath: PrivatePath
    access(all) let AdminStoragePath: StoragePath

    access(all) let AdminProxyPublicPath: PublicPath
    access(all) let AdminProxyStoragePath: StoragePath

    // Admin
    // Admin resource to manage NFT Catalog
    access(all) resource Admin {

        access(CatalogActions) fun addCatalogEntry(collectionIdentifier: String, metadata : NFTCatalog.NFTCatalogMetadata) {
            NFTCatalog.addCatalogEntry(collectionIdentifier: collectionIdentifier, metadata : metadata)
        }

        access(CatalogActions) fun updateCatalogEntry(collectionIdentifier : String , metadata : NFTCatalog.NFTCatalogMetadata) {
            NFTCatalog.updateCatalogEntry(collectionIdentifier: collectionIdentifier, metadata : metadata)
        }

        access(CatalogActions) fun removeCatalogEntry(collectionIdentifier : String) {
            NFTCatalog.removeCatalogEntry(collectionIdentifier : collectionIdentifier)
        }

        access(CatalogActions) fun removeCatalogEntryUnsafe(collectionIdentifier : String, nftTypeIdentifier: String) {
            NFTCatalog.removeCatalogEntryUnsafe(collectionIdentifier : collectionIdentifier, nftTypeIdentifier: nftTypeIdentifier)
        }

        access(CatalogActions) fun approveCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.status == "IN_REVIEW" : "Invalid Proposal"
            }
            let catalogProposalEntry = NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!
            let newCatalogProposalEntry = NFTCatalog.NFTCatalogProposal(collectionIdentifier : catalogProposalEntry.collectionIdentifier, metadata : catalogProposalEntry.metadata, message : catalogProposalEntry.message, status: "APPROVED", proposer: catalogProposalEntry.proposer)
            NFTCatalog.updateCatalogProposal(proposalID : proposalID, proposalMetadata : newCatalogProposalEntry)

            if NFTCatalog.getCatalogEntry(collectionIdentifier : NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.collectionIdentifier) == nil {
                NFTCatalog.addCatalogEntry(collectionIdentifier: newCatalogProposalEntry.collectionIdentifier, metadata : newCatalogProposalEntry.metadata)
                emit AddProposalAccepted(
                    proposer: newCatalogProposalEntry.proposer,
                    collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                    contractName : newCatalogProposalEntry.metadata.contractName,
                    contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                    displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
                )
            } else {
                NFTCatalog.updateCatalogEntry(collectionIdentifier: newCatalogProposalEntry.collectionIdentifier, metadata: newCatalogProposalEntry.metadata)
                emit UpdateProposalAccepted(
                    proposer: newCatalogProposalEntry.proposer,
                    collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                    contractName : newCatalogProposalEntry.metadata.contractName,
                    contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                    displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
                )
            }
        }

        access(CatalogActions) fun rejectCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.status == "IN_REVIEW" : "Invalid Proposal"
            }
            let catalogProposalEntry = NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!
            let newCatalogProposalEntry = NFTCatalog.NFTCatalogProposal(collectionIdentifier : catalogProposalEntry.collectionIdentifier, metadata : catalogProposalEntry.metadata, message : catalogProposalEntry.message, status: "REJECTED", proposer: catalogProposalEntry.proposer)
            NFTCatalog.updateCatalogProposal(proposalID : proposalID, proposalMetadata : newCatalogProposalEntry)
            emit ProposalRejected(
                proposer: newCatalogProposalEntry.proposer,
                collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                contractName : newCatalogProposalEntry.metadata.contractName,
                contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
            )
        }

        access(CatalogActions) fun removeCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
            }
            NFTCatalog.removeCatalogProposal(proposalID : proposalID)
        }

        init () {}

    }

    // AdminProxy
    // A proxy resource that can store
    // a capability to admin controls
    access(all) resource interface IAdminProxy {
        access(all) fun addCapability(capability : Capability<auth(CatalogActions) &Admin>)
        access(all) fun hasCapability() : Bool
    }

    access(all) resource AdminProxy : IAdminProxy {
        
        access(self) var capability : Capability<auth(CatalogActions) &Admin>?

        access(all) fun addCapability(capability : Capability<auth(CatalogActions) &Admin>) {
            pre {
                capability.check() : "Invalid Admin Capability"
                self.capability == nil : "Admin Proxy already set"
            }
            self.capability = capability
        }

        access(all) view fun getCapability() : Capability<auth(CatalogActions) &Admin>? {
            return self.capability
        }

        access(all) view fun hasCapability() : Bool {
            return self.capability != nil
        }

        init() {
            self.capability = nil
        }
        
    }

    access(all) fun createAdminProxy() : @AdminProxy {
        return <- create AdminProxy()
    }

    init () {
        self.AdminProxyPublicPath = /public/nftCatalogAdminProxy
        self.AdminProxyStoragePath = /storage/nftCatalogAdminProxy
        
        self.AdminPrivatePath = /private/nftCatalogAdmin
        self.AdminStoragePath = /storage/nftCatalogAdmin

        let admin    <- create Admin()

        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/buy_item.cdc

```
import ExampleToken from "ExampleToken"
import FungibleToken from "FungibleToken"
import NonFungibleToken from "NonFungibleToken"
import ExampleNFT from "ExampleNFT"
import NFTStorefrontV2 from "NFTStorefrontV2"
import MetadataViews from "MetadataViews"

/// Transaction facilitates the purcahse of listed NFT. It takes the storefront address, listing resource that need to be
/// purchased & a address that will takeaway the commission.
///
/// Buyer of the listing (,i.e. underling NFT) would authorize and sign the transaction and if purchase happens then
/// transacted NFT would store in buyer's collection.
///
transaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {

    let paymentVault: @{FungibleToken.Vault}
    let exampleNFTReceiver: &{NonFungibleToken.Receiver}
    let storefront: &{NFTStorefrontV2.StorefrontPublic}
    let listing: &{NFTStorefrontV2.ListingPublic}
    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?

    prepare(acct: auth(BorrowValue) &Account) {
        self.commissionRecipientCap = nil
        // Access the storefront public resource of the seller to purchase the listing.
        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
                NFTStorefrontV2.StorefrontPublicPath
            ) ?? panic("Could not borrow Storefront from provided address")

        // Borrow the listing
        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
            ?? panic("No Offer with that ID in Storefront")
        let price = self.listing.getDetails().salePrice

        // Access the vault of the buyer to pay the sale price of the listing.
        let mainVault = acct.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: /storage/exampleTokenVault)
            ?? panic("Cannot borrow ExampleToken vault from acct storage")
        self.paymentVault <- mainVault.withdraw(amount: price)

        // Access the buyer's NFT collection to store the purchased NFT.
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")
        self.exampleNFTReceiver = acct.capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("Cannot borrow NFT collection receiver from account")

        // Fetch the commission amt.
        let commissionAmount = self.listing.getDetails().commissionAmount

        if commissionRecipient != nil && commissionAmount != 0.0 {
            // Access the capability to receive the commission.
            let _commissionRecipientCap = getAccount(commissionRecipient!).capabilities.get<&{FungibleToken.Receiver}>(
                    /public/exampleTokenReceiver
                )
            assert(_commissionRecipientCap.check(), message: "Commission Recipient doesn't have exampletoken receiving capability")
            self.commissionRecipientCap = _commissionRecipientCap
        } else if commissionAmount == 0.0 {
            self.commissionRecipientCap = nil
        } else {
            panic("Commission recipient can not be empty when commission amount is non zero")
        }
    }

    execute {
        // Purchase the NFT
        let item <- self.listing.purchase(
            payment: <-self.paymentVault,
            commissionRecipient: self.commissionRecipientCap
        )
        // Deposit the NFT in the buyer's collection.
        self.exampleNFTReceiver.deposit(token: <-item)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/read_duplicate_listing_ids.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"
import ExampleNFT from "../contracts/utility/ExampleNFT.cdc"

/// This script returns an array of all the duplicate listingIDs for a given nftID.
///
access(all) fun main(account: Address, nftID: UInt64, listingID: UInt64): [UInt64] {
    return getAccount(account).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        )?.getDuplicateListingIDs(nftType: Type<@ExampleNFT.NFT>(), nftID: nftID, listingID: listingID)
        ?? panic("Could not borrow public storefront from address")
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/NFTCollectionPublicFactory.cdc

```
import "CapabilityFactory"
import "NonFungibleToken"

pub contract NFTCollectionPublicFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.CollectionPublic}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/README.md

## NFTStorefront v1 Transactions & Scripts

These transactions are for the v1 NFT Storefront standard and are purely for reference. NFT Storefront v2 provides a
richer user experience for listings management and numerous eco-system benefits.  





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/hybrid-custody/setup/linking/redeem_account.cdc

```
import "MetadataViews"

import "HybridCustody"
import "CapabilityFilter"

transaction(childAddress: Address, filterAddress: Address?, filterPath: PublicPath?) {
    prepare(acct: AuthAccount) {
        var filter: Capability<&{CapabilityFilter.Filter}>? = nil
        if filterAddress != nil && filterPath != nil {
            filter = getAccount(filterAddress!).getCapability<&{CapabilityFilter.Filter}>(filterPath!)
        }

        if acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {
            let m <- HybridCustody.createManager(filter: filter)
            acct.save(<- m, to: HybridCustody.ManagerStoragePath)

            acct.unlink(HybridCustody.ManagerPublicPath)
            acct.unlink(HybridCustody.ManagerPrivatePath)

            acct.link<&HybridCustody.Manager{HybridCustody.ManagerPrivate, HybridCustody.ManagerPublic}>(HybridCustody.ManagerPrivatePath, target: HybridCustody.ManagerStoragePath)
            acct.link<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(HybridCustody.ManagerPublicPath, target: HybridCustody.ManagerStoragePath)
        }

        let inboxName = HybridCustody.getChildAccountIdentifier(acct.address)
        let cap = acct.inbox.claim<&HybridCustody.ChildAccount{HybridCustody.AccountPrivate, HybridCustody.AccountPublic, MetadataViews.Resolver}>(inboxName, provider: childAddress)
            ?? panic("child account cap not found")

        let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager no found")

        manager.addAccount(cap: cap)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/FTBalanceFactory.cdc

```
import "CapabilityFactory"
import "FungibleToken"

pub contract FTBalanceFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Balance}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/cleanup_item.cdc

```
import "NFTStorefront"

transaction(listingResourceID: UInt64, storefrontAddress: Address) {

    let storefront: &{NFTStorefront.StorefrontPublic}

    prepare(acct: &Account) {
        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath
            ) ?? panic("Could not borrow Storefront from provided address")
    }

    execute {
        // Be kind and recycle
        self.storefront.cleanup(listingResourceID: listingResourceID)
    }

    post {
        self.storefront.getListingIDs().contains(listingResourceID) == false:
            "Listing was not successfully removed"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/FTAllFactory.cdc

```
import "CapabilityFactory"
import "FungibleToken"

pub contract FTAllFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/NFTProviderAndCollectionFactory.cdc

```
import "CapabilityFactory"
import "NonFungibleToken"

pub contract NFTProviderAndCollectionFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/hybrid-custody/sell_item_in_child_from_parent.cdc

```
import "NonFungibleToken"
import "MetadataViews"
import "FungibleToken"
import "FlowToken"

import "HybridCustody"

import "NFTStorefrontV2"

/// Cross-account NFT listing transaction
///
/// Lists an NFT located in the signer's child account for sale in the storefront of the signing parent account with
/// the parent account as beneficiary of the sale.
///
transaction(
    childAddress: Address,
    collectionProviderPath: PrivatePath,
    collectionPublicPath: PublicPath,
    nftTypeIdentifier: String,
    saleItemID: UInt64,
    saleItemPrice: UFix64,
    customID: String?,
    commissionAmount: UFix64,
    expiry: UInt64,
    marketplacesAddress: [Address]
) {
    let flowReceiverCap: Capability<&{FungibleToken.Receiver}>
    let providerCap: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefrontV2.Storefront
    var saleCuts: [NFTStorefrontV2.SaleCut]
    var marketplaceCaps: [Capability<&{FungibleToken.Receiver}>]
    let nftType: Type

    prepare(acct: AuthAccount) {
        self.saleCuts = []
        self.marketplaceCaps = []
        self.nftType = CompositeType(nftTypeIdentifier) ?? panic("Invalid NFT Type Identifier provided")
        
        // Configure Storefront if one doesn't yet exist
        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {
            acct.save(<-NFTStorefrontV2.createStorefront(), to: NFTStorefrontV2.StorefrontStoragePath)
            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(
                NFTStorefrontV2.StorefrontPublicPath,
                target: NFTStorefrontV2.StorefrontStoragePath
            )
        }
        // Borrow a reference to the signer's Storefront
        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)
            ?? panic("Missing or mis-typed NFTStorefront Storefront")

        // Get a FlowToken Receiver as beneficiary of listing & validate
        self.flowReceiverCap = acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
        assert(self.flowReceiverCap.check(), message: "Missing or mis-typed FlowToken receiver")

        // Get reference to the child account
        let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("Could not borrow reference to HybridCustody Manager")
        let childAccount = manager.borrowAccount(addr: childAddress)
            ?? panic("No child account exists for the given address")

        // Get the NFT provider capability from the child account & validate
        self.providerCap = childAccount.getCapability(
                path: collectionProviderPath,
                type: Type<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>()
            ) as! Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>?
            ?? panic("NFT Provider Capability is not accessible from child account for specified path")
        assert(self.providerCap.check(), message: "Missing or mis-typed Provider Capability")
        
        // Borrow the NFT as ViewResolver to get Royalties information
        let collection = getAccount(childAddress).getCapability<&{MetadataViews.ResolverCollection}>(
                collectionPublicPath
            ).borrow()
            ?? panic("Could not borrow a reference to the child account's collection")
        var totalRoyaltyCut = 0.0
        let effectiveSaleItemPrice = saleItemPrice - commissionAmount
        let resolver = collection.borrowViewResolver(id: saleItemID)
        assert(resolver.getType() == self.nftType, message: "NFT Type mismatch")

        // Check whether the NFT implements the MetadataResolver or not.
        if resolver.getViews().contains(Type<MetadataViews.Royalties>()) {
            let royaltiesRef = resolver.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
            for royalty in royalties {
                self.saleCuts.append(
                    NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice)
                )
                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice
            }
        }
        self.saleCuts.append(NFTStorefrontV2.SaleCut(
            receiver: self.flowReceiverCap,
            amount: effectiveSaleItemPrice - totalRoyaltyCut
        ))

        for marketplace in marketplacesAddress {
            // Here we are making a fair assumption that all given addresses would have
            // the capability to receive the `FlowToken`
            self.marketplaceCaps.append(
                getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            )
        }
    }

    execute {
        // Create listing
        self.storefront.createListing(
            nftProviderCapability: self.providerCap,
            nftType: self.nftType,
            nftID: saleItemID,
            salePaymentVaultType: Type<@FlowToken.Vault>(),
            saleCuts: self.saleCuts,
            marketplacesCapability: self.marketplaceCaps.length == 0 ? nil : self.marketplaceCaps,
            customID: customID,
            commissionAmount: commissionAmount,
            expiry: expiry
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/remove_item.cdc

```
import "NFTStorefront"

transaction(listingResourceID: UInt64) {
    
    let storefront: auth(NFTStorefront.RemoveListing) &NFTStorefront.Storefront

    prepare(acct: auth(BorrowValue) &Account) {
        self.storefront = acct.storage.borrow<auth(NFTStorefront.RemoveListing) &NFTStorefront.Storefront>(
                from: NFTStorefront.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront.Storefront")
    }

    execute {
        self.storefront.removeListing(listingResourceID: listingResourceID)
    }

    post {
        self.storefront.getListingIDs().contains(listingResourceID) == false:
            "Listing was not successfully removed"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/read_all_unique_ghost_listings.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// This script provides the array of listing resource Id which got ghosted It automatically skips the duplicate listing
/// as duplicate listings would get automatically delete once the primary one.
///
/// @param storefront Address of the storefront resource whose ghost listings get queried.
///
access(all) fun main(storefrontAddress: Address): [UInt64] {

    var duplicateListings: [UInt64] = []
    var ghostListings: [UInt64] = []

    let storefrontPublicRef = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        ) ?? panic("Given account does not has storefront resource")

    // Access all the listings under the given storefront account
    let availableListingIds = storefrontPublicRef.getListingIDs()
    // Iterate over available listings and find out which listing falls under ghost listing category.
    for id in availableListingIds {
        
        if !duplicateListings.contains(id) {
        
            let listingRef = storefrontPublicRef.borrowListing(listingResourceID: id)!
            // Note hasListingBecomeGhosted() returns false if the NFT is no longer available for sale
            // i.e. it's a ghost listing if false
            if !listingRef.hasListingBecomeGhosted() {
                ghostListings.append(id)
                let listingDetails = listingRef.getDetails()
                let dupListings = storefrontPublicRef.getDuplicateListingIDs(
                        nftType: listingDetails.nftType,
                        nftID: listingDetails.nftID,
                        listingID: id
                    )
                if dupListings.length > 0 {
                    duplicateListings.appendAll(dupListings)
                }
            }
        }
    }

    return ghostListings
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/read_allowed_commission_receivers.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"
import "FungibleToken"

/// This script returns the list of allowed commission receivers supported by the given listing Id.
///
access(all) fun main(account: Address, listingResourceID: UInt64): [Capability<&{FungibleToken.Receiver}>]? {
    let storefrontRef = getAccount(account).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        ) ?? panic("Could not borrow public storefront from address")

    let listing = storefrontRef.borrowListing(listingResourceID: listingResourceID)
        ?? panic("No item with that ID")
    
    return listing.getAllowedCommissionReceivers()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/tests/test_helpers.cdc

```
// Helper functions. All of the following were taken from
// https://github.com/onflow/Offers/blob/fd380659f0836e5ce401aa99a2975166b2da5cb0/lib/cadence/test/Offers.cdc
// - deploy
// - scriptExecutor
// - txExecutor

import Test

access(all)
fun deploy(_ contractName: String, _ path: String) {
    let err = Test.deployContract(
        name: contractName,
        path: path,
        arguments: [],
    )

    Test.expect(err, Test.beNil())
}

access(all)
fun scriptExecutor(_ scriptName: String, _ arguments: [AnyStruct]): AnyStruct? {
    let scriptCode = loadCode(scriptName, "scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    if let failureError = scriptResult.error {
        panic(
            "Failed to execute the script because -:  ".concat(failureError.message)
        )
    }

    return scriptResult.returnValue
}

access(all)
fun expectScriptFailure(
    _ scriptName: String,
    _ arguments: [AnyStruct],
    _ message: String
) {
    let scriptCode = loadCode(scriptName, "scripts")
    let scriptResult = Test.executeScript(scriptCode, arguments)

    Test.assertError(
        scriptResult,
        errorMessage: message
    )
}

/*
access(all)
fun txExecutor(
    _ txName: String,
    _ signers: [Test.Account],
    _ arguments: [AnyStruct],
    _ expectedError: String?
): Bool {
    let txCode = loadCode(txName, "transactions")

    let authorizers: [Address] = []
    for signer in signers {
        authorizers.append(signer.address)
    }

    let tx = Test.Transaction(
        code: txCode,
        authorizers: authorizers,
        signers: signers,
        arguments: arguments,
    )

    let txResult = Test.executeTransaction(tx)
    if let err = txResult.error {
        if let expectedErrorMessage = expectedError {
            Test.assertError(
                txResult,
                errorMessage: expectedErrorMessage
            )
            return true
        }
    } else {
        if let expectedErrorMessage = expectedError {
            panic("Expecting error - ".concat(expectedErrorMessage).concat(". While no error triggered"))
        }
    }

    Test.expect(txResult, Test.beSucceeded())
    return true
}
*/
access(all)
fun loadCode(_ fileName: String, _ baseDirectory: String): String {
    return Test.readFile("../".concat(baseDirectory).concat("/").concat(fileName))
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/NFTStorefront.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "Burner"

/// NB: This contract is no longer supported. NFT Storefront V2 is recommended
///
/// NFTStorefront. 
///
/// A general purpose sale support contract for Flow NonFungibleTokens.
/// 
/// Each account that wants to list NFTs for sale installs a Storefront,
/// and lists individual sales within that Storefront as Listings.
/// There is one Storefront per account, it handles sales of all NFT types
/// for that account.
///
/// Each Listing can have one or more "cut"s of the sale price that
/// goes to one or more addresses. Cuts can be used to pay listing fees
/// or other considerations.
/// Each NFT may be listed in one or more Listings, the validity of each
/// Listing can easily be checked.
/// 
/// Purchasers can watch for Listing events and check the NFT type and
/// ID to see if they wish to buy the listed item.
/// Marketplaces and other aggregators can watch for Listing events
/// and list items of interest.
///
access(all) contract NFTStorefront {

    access(all) entitlement CreateListing
    access(all) entitlement RemoveListing

    /// StorefrontInitialized
    /// A Storefront resource has been created.
    /// Event consumers can now expect events from this Storefront.
    /// Note that we do not specify an address: we cannot and should not.
    /// Created resources do not have an owner address, and may be moved
    /// after creation in ways we cannot check.
    /// ListingAvailable events can be used to determine the address
    /// of the owner of the Storefront (...its location) at the time of
    /// the listing but only at that precise moment in that precise transaction.
    /// If the seller moves the Storefront while the listing is valid, 
    /// that is on them.
    ///
    access(all) event StorefrontInitialized(storefrontResourceID: UInt64)

    /// StorefrontDestroyed
    /// A Storefront has been destroyed.
    /// Event consumers can now stop processing events from this Storefront.
    /// Note that we do not specify an address.
    ///
    access(all) event StorefrontDestroyed(storefrontResourceID: UInt64)

    /// ListingAvailable
    /// A listing has been created and added to a Storefront resource.
    /// The Address values here are valid when the event is emitted, but
    /// the state of the accounts they refer to may be changed outside of the
    /// NFTStorefront workflow, so be careful to check when using them.
    ///
    access(all) event ListingAvailable(
        storefrontAddress: Address,
        listingResourceID: UInt64,
        nftType: Type,
        nftID: UInt64,
        ftVaultType: Type,
        price: UFix64
    )

    /// ListingCompleted
    /// The listing has been resolved. It has either been purchased, or removed and destroyed.
    ///
    access(all) event ListingCompleted(
        listingResourceID: UInt64, 
        storefrontResourceID: UInt64, 
        purchased: Bool,
        nftType: Type,
        nftID: UInt64
    )

    /// StorefrontStoragePath
    /// The location in storage that a Storefront resource should be located.
    access(all) let StorefrontStoragePath: StoragePath

    /// StorefrontPublicPath
    /// The public location for a Storefront link.
    access(all) let StorefrontPublicPath: PublicPath


    /// SaleCut
    /// A struct representing a recipient that must be sent a certain amount
    /// of the payment when a token is sold.
    ///
    access(all) struct SaleCut {
        /// The receiver for the payment.
        /// Note that we do not store an address to find the Vault that this represents,
        /// as the link or resource that we fetch in this way may be manipulated,
        /// so to find the address that a cut goes to you must get this struct and then
        /// call receiver.borrow()!.owner.address on it.
        /// This can be done efficiently in a script.
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// The amount of the payment FungibleToken that will be paid to the receiver.
        access(all) let amount: UFix64

        /// initializer
        ///
        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }


    /// ListingDetails
    /// A struct containing a Listing's data.
    ///
    access(all) struct ListingDetails {
        /// The Storefront that the Listing is stored in.
        /// Note that this resource cannot be moved to a different Storefront,
        /// so this is OK. If we ever make it so that it *can* be moved,
        /// this should be revisited.
        access(all) var storefrontID: UInt64
        /// Whether this listing has been purchased or not.
        access(all) var purchased: Bool
        /// The Type of the NonFungibleToken.NFT that is being listed.
        access(all) let nftType: Type
        /// The ID of the NFT within that type.
        access(all) let nftID: UInt64
        /// The Type of the FungibleToken that payments must be made in.
        access(all) let salePaymentVaultType: Type
        /// The amount that must be paid in the specified FungibleToken.
        access(all) let salePrice: UFix64
        /// This specifies the division of payment between recipients.
        access(all) let saleCuts: [SaleCut]

        /// setToPurchased
        /// Irreversibly set this listing as purchased.
        ///
        access(contract) fun setToPurchased() {
            self.purchased = true
        }

        /// initializer
        ///
        init (
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            storefrontID: UInt64
        ) {
            self.storefrontID = storefrontID
            self.purchased = false
            self.nftType = nftType
            self.nftID = nftID
            self.salePaymentVaultType = salePaymentVaultType
            // Store the cuts
            assert(saleCuts.length > 0, message: "Listing must have at least one payment cut recipient")
            self.saleCuts = saleCuts

            // Calculate the total price from the cuts
            var salePrice = 0.0
            // Perform initial check on capabilities, and calculate sale price from cut amounts.
            for cut in self.saleCuts {
                // Make sure we can borrow the receiver.
                // We will check this again when the token is sold.
                cut.receiver.borrow()
                    ?? panic("Cannot borrow receiver")
                // Add the cut amount to the total price
                salePrice = salePrice + cut.amount
            }
            assert(salePrice > 0.0, message: "Listing must have non-zero price")

            // Store the calculated sale price
            self.salePrice = salePrice
        }
    }


    /// ListingPublic
    /// An interface providing a useful public interface to a Listing.
    ///
    access(all) resource interface ListingPublic {
        /// borrowNFT
        /// This will assert in the same way as the NFT standard borrowNFT()
        /// if the NFT is absent, for example if it has been sold via another listing.
        ///
        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}?

        /// purchase
        /// Purchase the listing, buying the token.
        /// This pays the beneficiaries and returns the token to the buyer.
        ///
        access(all) fun purchase(payment: @{FungibleToken.Vault}): @{NonFungibleToken.NFT}

        /// getDetails
        ///
        access(all) fun getDetails(): ListingDetails

    }


    /// Listing
    /// A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    /// and for the proceeds of that sale to be split between several recipients.
    /// 
    access(all) resource Listing: ListingPublic, Burner.Burnable {
        // Event to be emitted when this listing is destroyed.
        // If the listing has not been purchased, we regard it as completed here.
        // There is a separate event in purchase for purchased listings
        access(all) event ResourceDestroyed(
            listingResourceID: UInt64 = self.uuid,
            storefrontResourceID: UInt64 = self.details.storefrontID,
            purchased: Bool = self.details.purchased,
            nftType: String = self.details.nftType.identifier,
            nftID: UInt64 = self.details.nftID
        )

        access(contract) fun burnCallback() {
            // If the listing has not been purchased, we regard it as completed here.
            // Otherwise we regard it as completed in purchase().
            // This is because we destroy the listing in Storefront.removeListing()
            // or Storefront.cleanup() .
            // If we change this destructor, revisit those functions.
            if !self.details.purchased {
                emit ListingCompleted(
                    listingResourceID: self.uuid,
                    storefrontResourceID: self.details.storefrontID,
                    purchased: self.details.purchased,
                    nftType: self.details.nftType,
                    nftID: self.details.nftID
                )
            }
        }

        /// The simple (non-Capability, non-complex) details of the sale
        access(self) let details: ListingDetails

        /// A capability allowing this resource to withdraw the NFT with the given ID from its collection.
        /// This capability allows the resource to withdraw *any* NFT, so you should be careful when giving
        /// such a capability to a resource and always check its code to make sure it will use it in the
        /// way that it claims.
        access(contract) let nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        /// borrowNFT
        /// This will assert in the same way as the NFT standard borrowNFT()
        /// if the NFT is absent, for example if it has been sold via another listing.
        ///
        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}? {
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(self.getDetails().nftID)
            assert(ref != nil, message: "Could not borrow a reference to the NFT")
            assert(ref!.isInstance(self.getDetails().nftType), message: "token has wrong type")
            assert(ref?.id == self.getDetails().nftID, message: "token has wrong ID")
            return (ref as &{NonFungibleToken.NFT}?)
        }

        /// getDetails
        /// Get the details of the current state of the Listing as a struct.
        /// This avoids having more public variables and getter methods for them, and plays
        /// nicely with scripts (which cannot return resources). 
        ///
        access(all) fun getDetails(): ListingDetails {
            return self.details
        }
        
        /// purchase
        /// Purchase the listing, buying the token.
        /// This pays the beneficiaries and returns the token to the buyer.
        ///
        access(all) fun purchase(payment: @{FungibleToken.Vault}): @{NonFungibleToken.NFT} {
            pre {
                self.details.purchased == false: "listing has already been purchased"
                payment.isInstance(self.details.salePaymentVaultType): "payment vault is not requested fungible token"
                payment.balance == self.details.salePrice: "payment vault does not contain requested price"
            }

            // Make sure the listing cannot be purchased again.
            self.details.setToPurchased()


            // Fetch the token to return to the purchaser.
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)
            // Neither receivers nor providers are trustworthy, they must implement the correct
            // interface but beyond complying with its pre/post conditions they are not gauranteed
            // to implement the functionality behind the interface in any given way.
            // Therefore we cannot trust the Collection resource behind the interface,
            // and we must check the NFT resource it gives us to make sure that it is the correct one.
            assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the cut to the first valid receiver.
            // The first receiver should therefore either be the seller, or an agreed recipient for
            // any unpaid cuts.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment.
            for cut in self.details.saleCuts {
                if let receiver = cut.receiver.borrow() {
                   let paymentCut <- payment.withdraw(amount: cut.amount)
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            assert(residualReceiver != nil, message: "No valid payment receivers")

            // At this point, if all recievers were active and availabile, then the payment Vault will have
            // zero tokens left, and this will functionally be a no-op that consumes the empty vault
            residualReceiver!.deposit(from: <-payment)

            // If the listing is purchased, we regard it as completed here.
            // Otherwise we regard it as completed in the destructor.        

            emit ListingCompleted(
                listingResourceID: self.uuid,
                storefrontResourceID: self.details.storefrontID,
                purchased: self.details.purchased,
                nftType: self.details.nftType,
                nftID: self.details.nftID
            )

            return <-nft
        }

        /// initializer
        ///
        init (
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            storefrontID: UInt64
        ) {
            // Store the sale information
            self.details = ListingDetails(
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                storefrontID: storefrontID
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability

            // Check that the provider contains the NFT.
            // We will check it again when the token is sold.
            // We cannot move this into a function because initializers cannot call member functions.
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: "cannot borrow nftProviderCapability")

            let nft = provider!.borrowNFT(self.details.nftID)
            // This will precondition assert if the token is not available.
            assert(nft != nil, message: "Could not borrow a reference to the NFT")
            assert(nft!.isInstance(self.details.nftType), message: "token is not of specified type")
            assert(nft?.id == self.details.nftID, message: "token does not have specified ID")
        }
    }

    /// StorefrontManager
    /// An interface for adding and removing Listings within a Storefront,
    /// intended for use by the Storefront's own
    ///
    access(all) resource interface StorefrontManager {
        /// createListing
        /// Allows the Storefront owner to create and insert Listings.
        ///
        access(CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut]
        ): UInt64
        /// removeListing
        /// Allows the Storefront owner to remove any sale listing, acepted or not.
        ///
        access(RemoveListing) fun removeListing(listingResourceID: UInt64)
    }

    /// StorefrontPublic
    /// An interface to allow listing and borrowing Listings, and purchasing items via Listings
    /// in a Storefront.
    ///
    access(all) resource interface StorefrontPublic {
        access(all) view fun getListingIDs(): [UInt64]
        access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}? {
            post {
                result == nil || result!.getType() == Type<@Listing>():
                    "Cannot borrow a non-NFTStorefront.Listing!"
            }
        }
        access(all) fun cleanup(listingResourceID: UInt64)
   }

    /// Storefront
    /// A resource that allows its owner to manage a list of Listings, and anyone to interact with them
    /// in order to query their details and purchase the NFTs that they represent.
    ///
    access(all) resource Storefront: StorefrontManager, StorefrontPublic {
        // Event to be emitted when this storefront is destroyed.
        access(all) event ResourceDestroyed(
            storefrontResourceID: UInt64 = self.uuid
        )

        /// The dictionary of Listing uuids to Listing resources.
        access(self) var listings: @{UInt64: Listing}

        /// insert
        /// Create and publish a Listing for an NFT.
        ///
         access(CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut]
         ): UInt64 {
            let listing <- create Listing(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                storefrontID: self.uuid
            )

            let listingResourceID = listing.uuid
            let listingPrice = listing.getDetails().salePrice

            // Add the new listing to the dictionary.
            let oldListing <- self.listings[listingResourceID] <- listing
            // Note that oldListing will always be nil, but we have to handle it.

            Burner.burn(<-oldListing)

            emit ListingAvailable(
                storefrontAddress: self.owner?.address!,
                listingResourceID: listingResourceID,
                nftType: nftType,
                nftID: nftID,
                ftVaultType: salePaymentVaultType,
                price: listingPrice
            )

            return listingResourceID
        }
        

        /// removeListing
        /// Remove a Listing that has not yet been purchased from the collection and destroy it.
        ///
        access(RemoveListing) fun removeListing(listingResourceID: UInt64) {
            let listing <- self.listings.remove(key: listingResourceID)
                ?? panic("missing Listing")
    
            // This will emit a ListingCompleted event.
            Burner.burn(<-listing)
        }

        /// getListingIDs
        /// Returns an array of the Listing resource IDs that are in the collection
        ///
        access(all) view fun getListingIDs(): [UInt64] {
            return self.listings.keys
        }

        /// borrowSaleItem
        /// Returns a read-only view of the SaleItem for the given listingID if it is contained by this collection.
        ///
        access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}? {
            if self.listings[listingResourceID] != nil {
                return &self.listings[listingResourceID] as &{ListingPublic}?
            } else {
                return nil
            }
        }

        /// cleanup
        /// Remove an listing *if* it has been purchased.
        /// Anyone can call, but at present it only benefits the account owner to do so.
        /// Kind purchasers can however call it if they like.
        ///
        access(all) fun cleanup(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: "could not find listing with given id"
            }

            let listing <- self.listings.remove(key: listingResourceID)!
            assert(listing.getDetails().purchased == true, message: "listing is not purchased, only admin can remove")
            Burner.burn(<-listing)
        }

        /// constructor
        ///
        init () {
            self.listings <- {}

            // Let event consumers know that this storefront exists
            emit StorefrontInitialized(storefrontResourceID: self.uuid)
        }
    }

    /// createStorefront
    /// Make creating a Storefront publicly accessible.
    ///
    access(all) fun createStorefront(): @Storefront {
        return <-create Storefront()
    }

    init () {
        self.StorefrontStoragePath = /storage/NFTStorefront
        self.StorefrontPublicPath = /public/NFTStorefront
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/cleanup_expired_listings.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Transaction to facilitate the cleanup of the expired listings of a given storefront resource account holder. This
/// transaction facilitates the cleanup in pagination model where signer of the transaction will provide the
/// `fromIndex` & `toIndex` of `listingsIDs` array to remove the expired listings under the given range.
///
/// Cleanup is publicly accessible so can be executed by anyone.

transaction(fromIndex: UInt64, toIndex: UInt64, storefrontAddress: Address) {
    let storefront: &{NFTStorefrontV2.StorefrontPublic}

    prepare(acct: &Account) {
        // Access the storefront public resource of the seller to purchase the listing.
        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
                NFTStorefrontV2.StorefrontPublicPath
            ) ?? panic("Could not borrow Storefront from provided address")
    }

    execute {
        // Be kind and recycle
        self.storefront.cleanupExpiredListings(fromIndex: fromIndex, toIndex: toIndex)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/setup_nft_catalog.cdc

```
import NonFungibleToken from "../../../../contracts/utility/NonFungibleToken.cdc"
import MetadataViews from "../../../../contracts/utility/MetadataViews.cdc"
import NFTCatalog from "../../../../contracts/utility/NFTCatalog.cdc"
import ExampleNFT from "../../../../contracts/utility/ExampleNFT.cdc"
import NFTCatalogAdmin from "../../../../contracts/utility/NFTCatalogAdmin.cdc"

// This transaction sets up a fake NFT catalog for testing.

transaction {
    prepare(signer: AuthAccount) {
        let adminResource = signer.borrow<&NFTCatalogAdmin.Admin>(from: NFTCatalogAdmin.AdminStoragePath)!
        adminResource.addCatalogEntry(
            collectionIdentifier: "ExampleNFT", 
            metadata: NFTCatalog.NFTCatalogMetadata(
                contractName: "ExampleNFT", 
                contractAddress: 0xf8d6e0586b0a20c7, 
                nftType: Type<@ExampleNFT.NFT>(), 
                collectionData: NFTCatalog.NFTCollectionData(
                    storagePath: /storage/exampleNFTCollection, 
                    publicPath: /public/exampleNFTCollection, 
                    privatePath: /private/exampleNFTCollection,
                    publicLinkedType: Type<&ExampleNFT.Collection{ExampleNFT.ExampleNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    privateLinkedType: Type<&ExampleNFT.Collection{ExampleNFT.ExampleNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>()),
                collectionDisplay: MetadataViews.NFTCollectionDisplay(
                    name: "ExampleNFT", 
                    description: "ExampleNFT", 
                    externalURL: MetadataViews.ExternalURL("https://example.com/image.png"),
                    squareImage: MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                        ),
                        mediaType: "image/svg+xml"
                    ),
                    bannerImage: MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                        ),
                        mediaType: "image/svg+xml"
                    ),
                    socials: {})
            )
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/transfer_nft.cdc

```
import NonFungibleToken from "../../../../contracts/utility/NonFungibleToken.cdc"
import ExampleNFT from "../../../../contracts/utility/ExampleNFT.cdc"

/// This transaction is for transferring and NFT from
/// one account to another
transaction(recipient: Address, withdrawID: UInt64) {

    /// Reference to the withdrawer's collection
    let withdrawRef: &ExampleNFT.Collection

    /// Reference of the collection to deposit the NFT to
    let depositRef: &{NonFungibleToken.CollectionPublic}

    prepare(signer: AuthAccount) {
        // borrow a reference to the signer's NFT collection
        self.withdrawRef = signer
            .borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath)
            ?? panic("Account does not store an object at the specified path")

        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a public reference to the receivers collection
        self.depositRef = recipient
            .getCapability(ExampleNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not borrow a reference to the receiver's collection")

    }

    execute {

        // withdraw the NFT from the owner's collection
        let nft <- self.withdrawRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        self.depositRef.deposit(token: <-nft)
    }

    post {
        !self.withdrawRef.getIDs().contains(withdrawID): "Original owner should not have the NFT anymore"
        self.depositRef.getIDs().contains(withdrawID): "The reciever should now own the NFT"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/NFTCatalog.cdc

```
import "MetadataViews"

// NFTCatalog
//
// A general purpose NFT registry for Flow NonFungibleTokens.
//
// Each catalog entry stores data about the NFT including
// its collection identifier, nft type, storage and public paths, etc.
//
// To make an addition to the catalog you can propose an NFT and provide its metadata.
// An Admin can approve a proposal which would add the NFT to the catalog

access(all) contract NFTCatalog {
    // EntryAdded
    // An NFT collection has been added to the catalog
    access(all) event EntryAdded(
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        nftType : Type,
        storagePath: StoragePath,
        publicPath: PublicPath,
        publicLinkedType : Type,
        displayName : String,
        description: String,
        externalURL : String
    )

    // EntryUpdated
    // An NFT Collection has been updated in the catalog
    access(all) event EntryUpdated(
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        nftType : Type,
        storagePath: StoragePath,
        publicPath: PublicPath,
        publicLinkedType : Type,
        displayName : String,
        description: String,
        externalURL : String
    )

    // EntryRemoved
    // An NFT Collection has been removed from the catalog
    access(all) event EntryRemoved(collectionIdentifier : String, nftType: Type)

    // ProposalEntryAdded
    // A new proposal to make an addtion to the catalog has been made
    access(all) event ProposalEntryAdded(proposalID : UInt64, collectionIdentifier : String, message: String, status: String, proposer : Address)

    // ProposalEntryUpdated
    // A proposal has been updated
    access(all) event ProposalEntryUpdated(proposalID : UInt64, collectionIdentifier : String, message: String, status: String, proposer : Address)

    // ProposalEntryRemoved
    // A proposal has been removed from storage
    access(all) event ProposalEntryRemoved(proposalID : UInt64)

    access(all) let ProposalManagerStoragePath: StoragePath

    access(all) let ProposalManagerPublicPath: PublicPath

    access(self) let catalog: {String : NFTCatalog.NFTCatalogMetadata} // { collectionIdentifier -> Metadata }
    access(self) let catalogTypeData: {String : {String : Bool}} // Additional view to go from { NFT Type Identifier -> {Collection Identifier : Bool } }

    access(self) let catalogProposals : {UInt64 : NFTCatalogProposal} // { ProposalID : Metadata }

    access(self) var totalProposals : UInt64

    // NFTCatalogProposalManager
    // Used to authenticate proposals made to the catalog

    access(all) entitlement ProposalActionOwner

    access(all) resource NFTCatalogProposalManager {
            access(self) var currentProposalEntry: String?

            access(all) fun getCurrentProposalEntry(): String? {
                return self.currentProposalEntry
            }

            access(ProposalActionOwner) fun setCurrentProposalEntry(identifier: String?) {
                self.currentProposalEntry = identifier
            }

            init () {
                self.currentProposalEntry = nil
            }
    }


    access(all) resource Snapshot {
        access(all) var catalogSnapshot: {String : NFTCatalogMetadata}
        access(all) var shouldUseSnapshot: Bool

        access(all) fun setPartialSnapshot(_ snapshotKey: String, _ snapshotEntry: NFTCatalogMetadata) {
            self.catalogSnapshot[snapshotKey] = snapshotEntry
        }

        access(all) fun setShouldUseSnapshot(_ shouldUseSnapshot: Bool) {
            self.shouldUseSnapshot = shouldUseSnapshot
        }

        access(all) view fun getCatalogSnapshot(): {String : NFTCatalogMetadata} {
            return self.catalogSnapshot
        }

        init() {
            self.shouldUseSnapshot = false
            self.catalogSnapshot = {}
        }
    }

    access(all) fun createEmptySnapshot(): @Snapshot {
        return <- create Snapshot()
    }

    // NFTCollectionData
    // Represents information about an NFT collection resource
    // Note: Not suing the struct from Metadata standard due to
    // inability to store functions
    access(all) struct NFTCollectionData {

        access(all) let storagePath : StoragePath
        access(all) let publicPath : PublicPath
        access(all) let publicLinkedType: Type

        init(
            storagePath : StoragePath,
            publicPath : PublicPath,
            publicLinkedType : Type,
        ) {
            self.storagePath = storagePath
            self.publicPath = publicPath
            self.publicLinkedType = publicLinkedType
        }
    }

    // NFTCatalogMetadata
    // Represents data about an NFT
    access(all) struct NFTCatalogMetadata {
        access(all) let contractName : String
        access(all) let contractAddress : Address
        access(all) let nftType: Type
        access(all) let collectionData: NFTCollectionData
        access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay

        init (contractName : String, contractAddress : Address, nftType: Type, collectionData : NFTCollectionData, collectionDisplay : MetadataViews.NFTCollectionDisplay) {
            self.contractName = contractName
            self.contractAddress = contractAddress
            self.nftType = nftType
            self.collectionData = collectionData
            self.collectionDisplay = collectionDisplay
        }
    }

    // NFTCatalogProposal
    // Represents a proposal to the catalog
    // Includes data about an NFT
    access(all) struct NFTCatalogProposal {
        access(all) let collectionIdentifier : String
        access(all) let metadata : NFTCatalogMetadata
        access(all) let message : String
        access(all) let status : String
        access(all) let proposer : Address
        access(all) let createdTime : UFix64

        init(collectionIdentifier : String, metadata : NFTCatalogMetadata, message : String, status : String, proposer : Address) {
            self.collectionIdentifier = collectionIdentifier
            self.metadata = metadata
            self.message = message
            self.status = status
            self.proposer = proposer
            self.createdTime = getCurrentBlock().timestamp
        }
    }

    /*
        DEPRECATED
        If obtaining all elements from the catalog is essential, please
        use the getCatalogKeys and forEachCatalogKey methods instead.
     */
    access(all) view fun getCatalog() : {String : NFTCatalogMetadata} {
        let snapshot = self.account.storage.borrow<&NFTCatalog.Snapshot>(from: /storage/CatalogSnapshot)
        if snapshot != nil {
            let snapshot = snapshot!
            if snapshot.shouldUseSnapshot {
                return snapshot.getCatalogSnapshot()
            } else {
                return self.catalog
            }
        } else {
            return self.catalog
        }
    }

    access(all) view fun getCatalogKeys(): [String] {
        return self.catalog.keys
    }

    access(all) fun forEachCatalogKey(_ function: fun (String): Bool) {
        self.catalog.forEachKey(function)
    }

    access(all) view fun getCatalogEntry(collectionIdentifier : String) : NFTCatalogMetadata? {
        return self.catalog[collectionIdentifier]
    }

    access(all) view fun getCollectionsForType(nftTypeIdentifier: String) : {String : Bool}? {
        return self.catalogTypeData[nftTypeIdentifier]
    }

    access(all) view fun getCatalogTypeData() : {String : {String : Bool}} {
        return self.catalogTypeData
    }

    // Propose an NFT collection to the catalog
    // @param collectionIdentifier: The unique name assinged to this nft collection
    // @param metadata: The Metadata for the NFT collection that will be stored in the catalog
    // @param message: A message to the catalog owners
    // @param proposer: Who is making the proposition(the address needs to be verified)
    access(all) fun proposeNFTMetadata(collectionIdentifier : String, metadata : NFTCatalogMetadata, message : String, proposer : Address) : UInt64 {
        let proposerManagerRef = getAccount(proposer).capabilities.borrow<&NFTCatalogProposalManager>(
            NFTCatalog.ProposalManagerPublicPath
        ) ?? panic("Proposer needs to set up a manager")

        assert(proposerManagerRef.getCurrentProposalEntry()! == collectionIdentifier, message: "Expected proposal entry does not match entry for the proposer")

        let catalogProposal = NFTCatalogProposal(collectionIdentifier : collectionIdentifier, metadata : metadata, message : message, status: "IN_REVIEW", proposer: proposer)
        self.totalProposals = self.totalProposals + 1
        self.catalogProposals[self.totalProposals] = catalogProposal

        emit ProposalEntryAdded(proposalID : self.totalProposals, collectionIdentifier : collectionIdentifier, message: catalogProposal.message, status: catalogProposal.status, proposer: catalogProposal.proposer)
        return self.totalProposals
    }

    // Withdraw a proposal from the catalog
    // @param proposalID: The ID of proposal you want to withdraw
    access(all) fun withdrawNFTProposal(proposalID : UInt64) {
        pre {
            self.catalogProposals[proposalID] != nil : "Invalid Proposal ID"
        }
        let proposal = self.catalogProposals[proposalID]!
        let proposer = proposal.proposer

        let proposerManagerRef = getAccount(proposer).capabilities.borrow<&NFTCatalogProposalManager>(
            NFTCatalog.ProposalManagerPublicPath
        ) ?? panic("Proposer needs to set up a manager")

        assert(proposerManagerRef.getCurrentProposalEntry()! == proposal.collectionIdentifier, message: "Expected proposal entry does not match entry for the proposer")

        self.removeCatalogProposal(proposalID : proposalID)
    }

    access(all) view fun getCatalogProposals() : {UInt64 : NFTCatalogProposal} {
        return self.catalogProposals
    }

    access(all) view fun getCatalogProposalEntry(proposalID : UInt64) : NFTCatalogProposal? {
        return self.catalogProposals[proposalID]
    }

    access(all) view fun getCatalogProposalKeys() : [UInt64] {
        return self.catalogProposals.keys
    }

    access(all) fun forEachCatalogProposalKey(_ function: fun (UInt64): Bool) {
        self.catalogProposals.forEachKey(function)
    }

    access(all) fun createNFTCatalogProposalManager(): @NFTCatalogProposalManager {
        return <-create NFTCatalogProposalManager()
    }

    access(account) fun addCatalogEntry(collectionIdentifier : String, metadata: NFTCatalogMetadata) {
        pre {
            self.catalog[collectionIdentifier] == nil : "The nft name has already been added to the catalog"
        }

        self.addCatalogTypeEntry(collectionIdentifier : collectionIdentifier , metadata: metadata)

        self.catalog[collectionIdentifier] = metadata

        emit EntryAdded(
            collectionIdentifier : collectionIdentifier,
            contractName : metadata.contractName,
            contractAddress : metadata.contractAddress,
            nftType: metadata.nftType,
            storagePath: metadata.collectionData.storagePath,
            publicPath: metadata.collectionData.publicPath,
            publicLinkedType : metadata.collectionData.publicLinkedType,
            displayName : metadata.collectionDisplay.name,
            description: metadata.collectionDisplay.description,
            externalURL : metadata.collectionDisplay.externalURL.url
        )
    }

    access(account) fun updateCatalogEntry(collectionIdentifier : String , metadata: NFTCatalogMetadata) {
        pre {
            self.catalog[collectionIdentifier] != nil : "Invalid collection identifier"
        }
        // remove previous nft type entry
        self.removeCatalogTypeEntry(collectionIdentifier : collectionIdentifier , metadata: metadata)
        // add updated nft type entry
        self.addCatalogTypeEntry(collectionIdentifier : collectionIdentifier , metadata: metadata)

        self.catalog[collectionIdentifier] = metadata

        let nftType = metadata.nftType

        emit EntryUpdated(
            collectionIdentifier : collectionIdentifier,
            contractName : metadata.contractName,
            contractAddress : metadata.contractAddress,
            nftType: metadata.nftType,
            storagePath: metadata.collectionData.storagePath,
            publicPath: metadata.collectionData.publicPath,
            publicLinkedType : metadata.collectionData.publicLinkedType,
            displayName : metadata.collectionDisplay.name,
            description: metadata.collectionDisplay.description,
            externalURL : metadata.collectionDisplay.externalURL.url
        )
    }

    access(account) fun removeCatalogEntry(collectionIdentifier : String) {
        pre {
            self.catalog[collectionIdentifier] != nil : "Invalid collection identifier"
        }

        let removedType = self.removeCatalogTypeEntry(collectionIdentifier : collectionIdentifier , metadata: self.catalog[collectionIdentifier]!)
        self.catalog.remove(key: collectionIdentifier)

        emit EntryRemoved(collectionIdentifier : collectionIdentifier, nftType: removedType)
    }

    // This function is not preferred, and was used for the following issue:
    // https://github.com/onflow/cadence/issues/2649
    // If a contract's type is no longer resolvable in cadence and crashing,
    // this function can be used to remove it from the catalog.
    access(account) fun removeCatalogEntryUnsafe(collectionIdentifier: String, nftTypeIdentifier: String) {
        // Remove the catalog entry
        self.catalog.remove(key: collectionIdentifier)

        // Remove the type entry
        if (self.catalogTypeData[nftTypeIdentifier]!.keys.length == 1) {
            self.catalogTypeData.remove(key: nftTypeIdentifier)
        } else {
            self.catalogTypeData[nftTypeIdentifier]!.remove(key: collectionIdentifier)
        }
    }

    access(account) fun updateCatalogProposal(proposalID: UInt64, proposalMetadata : NFTCatalogProposal) {
        self.catalogProposals[proposalID] = proposalMetadata

        emit ProposalEntryUpdated(proposalID : proposalID, collectionIdentifier : proposalMetadata.collectionIdentifier, message: proposalMetadata.message, status: proposalMetadata.status, proposer: proposalMetadata.proposer)
    }

    access(account) fun removeCatalogProposal(proposalID : UInt64) {
        self.catalogProposals.remove(key : proposalID)

        emit ProposalEntryRemoved(proposalID : proposalID)
    }

    access(contract) fun addCatalogTypeEntry(collectionIdentifier : String , metadata: NFTCatalogMetadata) {
        if self.catalogTypeData[metadata.nftType.identifier] != nil {
            let typeData : {String : Bool} = self.catalogTypeData[metadata.nftType.identifier]!
            assert(self.catalogTypeData[metadata.nftType.identifier]![collectionIdentifier] == nil, message : "The nft name has already been added to the catalog")
            typeData[collectionIdentifier] = true
            self.catalogTypeData[metadata.nftType.identifier] = typeData
        } else {
            let typeData : {String : Bool} = {}
            typeData[collectionIdentifier] = true
            self.catalogTypeData[metadata.nftType.identifier] = typeData
        }
    }

    access(contract) fun removeCatalogTypeEntry(collectionIdentifier : String , metadata: NFTCatalogMetadata): Type {
        let prevMetadata = self.catalog[collectionIdentifier]!
        let prevCollectionsForType = self.catalogTypeData[prevMetadata.nftType.identifier]!
        prevCollectionsForType.remove(key : collectionIdentifier)
        if prevCollectionsForType.length == 0 {
            self.catalogTypeData.remove(key: prevMetadata.nftType.identifier)
        } else {
            self.catalogTypeData[prevMetadata.nftType.identifier] = prevCollectionsForType
        }

        return metadata.nftType
    }

    init() {
        self.ProposalManagerStoragePath = /storage/nftCatalogProposalManager
        self.ProposalManagerPublicPath = /public/nftCatalogProposalManager

        self.totalProposals = 0
        self.catalog = {}
        self.catalogTypeData = {}

        self.catalogProposals = {}
    }

}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/tests/NFTStorefrontV2_test.cdc

```
import Test
import "test_helpers.cdc"
import "FungibleToken"
import "NonFungibleToken"
import "NFTStorefrontV2"
import "ExampleNFT"
import "ExampleToken"
import "FlowToken"

access(all) let buyer = Test.createAccount()
access(all) let seller = Test.createAccount()
access(all) let marketplace = Test.createAccount()
access(all) let storefrontAccount = Test.getAccount(0x0000000000000007)
access(all) let exampleNFTAccount = Test.getAccount(0x0000000000000008)
access(all) let exampleTokenAccount = Test.getAccount(0x0000000000000009)
access(all) var nftCount = 1

access(all)
fun mintNFTToSeller() {
    // Mint some example NFTs
    let code = loadCode("mint_nft.cdc", "transactions/example-nft")
    let tx = Test.Transaction(
        code: code,
        authorizers: [exampleNFTAccount.address],
        signers: [exampleNFTAccount],
        arguments: [seller.address, "NFT".concat(nftCount.toString()), "nft descrip", "https://test", [], [], []]
    )
    nftCount = nftCount + 1
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all)
fun setup() {
    let serviceAccount = Test.serviceAccount()

    var err = Test.deployContract(
        name: "NFTStorefrontV2",
        path: "../contracts/NFTStorefrontV2.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "ExampleNFT",
        path: "../contracts/utility/ExampleNFT.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "ExampleToken",
        path: "../contracts/utility/ExampleToken.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    // Setup example token
    var code = loadCode("setup_account.cdc", "transactions/example-token")
    var tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
    
    tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    tx = Test.Transaction(
        code: code,
        authorizers: [marketplace.address],
        signers: [marketplace],
        arguments: []
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Setup example nft
    code = loadCode("setup_account.cdc", "transactions/example-nft")
    tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Mint some example tokens
    code = loadCode("mint_tokens.cdc", "transactions/example-token")
    tx = Test.Transaction(
        code: code,
        authorizers: [exampleTokenAccount.address],
        signers: [exampleTokenAccount],
        arguments: [buyer.address, 200.0],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    mintNFTToSeller()

    let typ = Type<NonFungibleToken.Deposited>()
    let events = Test.eventsOfType(typ)
    Test.assertEqual(1, events.length)
}

access(all) var listingIDPurchased: UInt64 = 0

access(all)
fun testSetupAccount() {
    let code = loadCode("setup_account.cdc", "transactions")
    let tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all) var listedNFTID: UInt64 = 0

access(all)
fun testSellItem() {
    var code = loadCode("get_ids.cdc", "scripts/example-nft")

    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]
    listedNFTID = nftID

    code = loadCode("sell_item.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0, // sale item price
            "Custom", // custom id
            0.1, // commission amount
            UInt64(2025908543), // 10 years in the future
            [] // Marketplaces address
        ],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all)
fun testBuyItem() {
    let getBalanceCode = loadCode("get_balance.cdc", "scripts/example-token")

    var result = Test.executeScript(getBalanceCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! UFix64), 0.0)

    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let listingID = (result.returnValue! as! [UInt64])[0]!
    listingIDPurchased = listingID

    // Test that script executions run as expected
    let allowedCommissionReceivers = scriptExecutor("read_allowed_commission_receivers.cdc", [seller.address, listingID])
    let listingDetails = scriptExecutor("read_listing_details.cdc", [seller.address, listingID])
    Test.assert(listingDetails != nil, message: "Received invalid result from reading listing details")
    let duplicateListingIDs = scriptExecutor("read_duplicate_listing_ids.cdc", [seller.address, listedNFTID, listingID])
    Test.assertEqual((duplicateListingIDs as! [UInt64]?)!.length, 0)

    let code = loadCode("buy_item.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            listingID, // listing resource id
            seller.address, // storefront address
            seller.address // commision recipient
        ],
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    result = Test.executeScript(getBalanceCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! UFix64), 10.0)
}


access(all)
fun testCleanupPurchasedListings() {
    let cleanupCode = loadCode("cleanup_purchased_listings.cdc", "transactions")
    
    // The listing ID should exist in the seller acount still
    // even though that it has been purchased at this point
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")

    // We can clean up the unused listing id from a different
    // signer account.
    let tx = Test.Transaction(
        code: cleanupCode,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [seller.address, listingIDPurchased]
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // The listing ID should not exist anymore in the seller account
    let result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 0)
}

access(all)
fun testCleanupGhostListings() {
    // Mint a new NFT
    mintNFTToSeller()

    // Get the newly minted NFT's ID
    var code = loadCode("get_ids.cdc", "scripts/example-nft")
    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]

    // Create a new listing for that ID.
    code = loadCode("sell_item.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0, // sale item price
            "Custom", // custom id
            0.1, // commission amount
            UInt64(2025908543), // 10 years in the future
            [] // Marketplaces address
        ],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let ghostedListingID = (result.returnValue! as! [UInt64])[0]

    // Check if the listing is ghosted.
    var listingIsAvailable = scriptExecutor("has_listing_become_ghosted.cdc", [seller.address, ghostedListingID])
    Test.assertEqual(listingIsAvailable!, true)

    // Burn the NFT
    let burnNFTCode = loadCode("burn_nft.cdc", "transactions/example-nft")
    tx = Test.Transaction(
        code: burnNFTCode,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID
        ]
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Check if the listing is ghosted.
    listingIsAvailable = scriptExecutor("has_listing_become_ghosted.cdc", [seller.address, ghostedListingID])
    Test.assertEqual(listingIsAvailable!, false)

    let allGhostListingIDs = scriptExecutor("read_all_unique_ghost_listings.cdc", [seller.address])
    Test.assertEqual((allGhostListingIDs as! [UInt64]?)!.length, 1)

    // Try cleaning up the ghost listing
    let cleanupGhostListingsCode = loadCode("cleanup_ghost_listing.cdc", "transactions")
    tx = Test.Transaction(
        code: cleanupGhostListingsCode,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [ghostedListingID, seller.address]
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
    
    // Confirm the listing was removed.
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 0)
}


access(all)
fun testSellItemWithMarketplaceCut() {
    mintNFTToSeller()

    var code = loadCode("get_ids.cdc", "scripts/example-nft")

    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]

    code = loadCode("sell_item_with_marketplace_cut.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0, // sale item price
            "Custom1", // custom id
            UInt64(2025908543), // 10 years in the future
            seller.address, // set the buyer as the marketplace sale cut receiver
            0.1 // Marketplaces address
        ],
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // The listing ID should exist in the seller acount
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
}

access(all)
fun testSellItemAndReplaceCurrentListing() {
    var getIDsCode = loadCode("get_ids.cdc", "scripts/example-nft")
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")

    var result = Test.executeScript(getIDsCode, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]

    // The listing ID should exist in the seller acount
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let originalListingID = (result.returnValue! as! [UInt64])[0]!

    let code = loadCode("sell_item_and_replace_current_listing.cdc", "transactions")
    let timestamp: UInt64 = UInt64(getCurrentBlock().timestamp) + 1000
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0, // sale item price
            "Custom1", // custom id
            0.1, // commission amount
            timestamp, // way in the past (testing expired listing next)
            [seller.address] // set the buyer as the marketplace sale cut receiver
        ],
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // The listing ID should still be different from before, but
    // replaced the previous one.
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let listingIDAfterRelist = (result.returnValue! as! [UInt64])[0]!
    Test.assert(originalListingID != listingIDAfterRelist, message: "Listing ID should be different from the original after relisting")
}

access(all)
fun testCleanupExpiredListings() {
    let cleanupExpiredListingsCode = loadCode("cleanup_expired_listings.cdc", "transactions")
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")

    // Attempt to cleanup expired listings, and no change should occur because listings aren't expired.
    var result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)

    let tx = Test.Transaction(
        code: cleanupExpiredListingsCode,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            UInt64(0), // fromIndex
            UInt64(0), // toIndex
            seller.address // storefrontAddress
        ]
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Ensure that the listing was not removed because it is not expired
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)

    // Move 20000 ms into the future, because the current expiration was set to the current timestamp + 1000
    // This should make the currently existing listing expired
    Test.moveTime(by: 2000.0) 

    // Attempt to cleanup expired listings again, and amount of listings should go to 0 now
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Ensure that the listing was removed because it should be expired now
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 0)

}

access(all)
fun testRemoveItem() {

    // list the new NFT for sale
    var code = loadCode("get_ids.cdc", "scripts/example-nft")

    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]

    code = loadCode("sell_item_with_marketplace_cut.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0, // sale item price
            "Custom1", // custom id
            UInt64(2025908543), // 10 years in the future
            seller.address, // set the buyer as the marketplace sale cut receiver
            0.1 // Marketplaces address
        ],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    let getListingIDCode = loadCode("read_storefront_ids.cdc", "scripts")
    result = Test.executeScript(getListingIDCode, [seller.address])
    let listingID = (result.returnValue! as! [UInt64])[0]

    // Remove the listing
    let removeItemCode = loadCode("remove_item.cdc", "transactions")
    tx = Test.Transaction(
        code: removeItemCode,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [listingID]
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Test that the proper events were emitted
    var typ = Type<NFTStorefrontV2.ListingCompleted>()
    var events = Test.eventsOfType(typ)
    Test.assertEqual(5, events.length)

    let completedEvent = events[4] as! NFTStorefrontV2.ListingCompleted
    Test.assertEqual(listingID, completedEvent.listingResourceID)
    Test.assertEqual(false, completedEvent.purchased)
    Test.assertEqual(Type<@ExampleNFT.NFT>(), completedEvent.nftType)
    Test.assertEqual(nftID, completedEvent.nftID)
    Test.assertEqual(Type<@FlowToken.Vault>(), completedEvent.salePaymentVaultType)
    Test.assertEqual(UFix64(10.0), completedEvent.salePrice)
    Test.assertEqual("Custom1", completedEvent.customID!)
    Test.assertEqual(UFix64(0.0), completedEvent.commissionAmount)
    Test.assertEqual(nil, completedEvent.commissionReceiver)
    Test.assertEqual(UInt64(2025908543), completedEvent.expiry)
}

access(all)
fun testSellMaliciousListing() {

    var err = Test.deployContract(
        name: "MaliciousStorefrontV2",
        path: "../contracts/utility/test/MaliciousStorefrontV2.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    var code = loadCode("../tests/transactions/create_malicious_listing_v2.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [exampleNFTAccount.address],
        signers: [exampleNFTAccount],
        arguments: [],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    var typ = Type<NFTStorefrontV2.ListingAvailable>()
    var events = Test.eventsOfType(typ)

    let listingEvent = events[events.length-1] as! NFTStorefrontV2.ListingAvailable
    let listingID = listingEvent.listingResourceID

    code = loadCode("buy_item.cdc", "transactions")
    tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            listingID, // listing resource id
            exampleNFTAccount.address, // storefront address
            exampleNFTAccount.address // commision recipient
        ],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "Cannot borrow a non-NFTStorefrontV2.Listing!"
    )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/hybrid-custody/setup/dev-setup/setup_nft_filter_and_factory_manager.cdc

```
import "CapabilityFilter"
import "CapabilityFactory"
import "NFTCollectionPublicFactory"
import "NFTProviderAndCollectionFactory"
import "NFTProviderFactory"
import "FTProviderFactory"

import "NonFungibleToken"
import "FungibleToken"

/* --- Helper Methods --- */
//
/// Returns a type identifier for an NFT Collection
///
access(all) fun deriveCollectionTypeIdentifier(_ contractAddress: Address, _ contractName: String): String {
    return "A.".concat(withoutPrefix(contractAddress.toString())).concat(".").concat(contractName).concat(".Collection")
}

/// Taken from AddressUtils private method
///
access(all) fun withoutPrefix(_ input: String): String{
    var address=input

    //get rid of 0x
    if address.length>1 && address.utf8[1] == 120 {
        address = address.slice(from: 2, upTo: address.length)
    }

    //ensure even length
    if address.length%2==1{
        address="0".concat(address)
    }
    return address
}

/* --- Transaction Block --- */
//
/// This transaction can be used by most developers implementing HybridCustody as the single pre-requisite transaction
/// to setup filter functionality between linked parent and child accounts.
///
/// Creates a CapabilityFactory Manager and CapabilityFilter.AllowlistFilter in the signing account (if needed), adding
/// NFTCollectionPublicFactory, NFTProviderAndCollectionFactory, & NFTProviderFactory to the CapabilityFactory Manager
/// and the Collection Type to the CapabilityFilter.AllowlistFilter
///
/// For more info, see docs at https://developers.onflow.org/docs/hybrid-custody/
////
transaction(nftContractAddress: Address, nftContractName: String) {
    prepare(acct: AuthAccount) {

        /* --- CapabilityFactory Manager configuration --- */
        //
        if acct.borrow<&AnyResource>(from: CapabilityFactory.StoragePath) == nil {
            let f <- CapabilityFactory.createFactoryManager()
            acct.save(<-f, to: CapabilityFactory.StoragePath)
        }

        if !acct.getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath).check() {
            acct.unlink(CapabilityFactory.PublicPath)
            acct.link<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath, target: CapabilityFactory.StoragePath)
        }

        assert(
            acct.getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath).check(),
            message: "CapabilityFactory is not setup properly"
        )

        let factoryManager = acct.borrow<&CapabilityFactory.Manager>(from: CapabilityFactory.StoragePath)
            ?? panic("CapabilityFactory Manager not found")

        // Add NFT-related Factories to the Manager
        factoryManager.updateFactory(Type<&{NonFungibleToken.CollectionPublic}>(), NFTCollectionPublicFactory.Factory())
        factoryManager.updateFactory(Type<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(), NFTProviderAndCollectionFactory.Factory())
        factoryManager.updateFactory(Type<&{NonFungibleToken.Provider}>(), NFTProviderFactory.Factory())

        /* --- AllowlistFilter configuration --- */
        //
        if acct.borrow<&CapabilityFilter.AllowlistFilter>(from: CapabilityFilter.StoragePath) == nil {
            acct.save(<-CapabilityFilter.create(Type<@CapabilityFilter.AllowlistFilter>()), to: CapabilityFilter.StoragePath)
        }

        if !acct.getCapability<&CapabilityFilter.AllowlistFilter{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath).check() {
            acct.unlink(CapabilityFilter.PublicPath)
            acct.link<&CapabilityFilter.AllowlistFilter{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath, target: CapabilityFilter.StoragePath)
        }

        assert(
            acct.getCapability<&CapabilityFilter.AllowlistFilter{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath).check(),
            message: "AllowlistFilter is not setup properly"
        )

        let filter = acct.borrow<&CapabilityFilter.AllowlistFilter>(from: CapabilityFilter.StoragePath)
            ?? panic("AllowlistFilter does not exist")

        // Construct an NFT Collection Type from the provided args & add to the AllowlistFilter
        let c = CompositeType(deriveCollectionTypeIdentifier(nftContractAddress, nftContractName))
            ?? panic("Problem constructing CompositeType from given NFT contract address and name")
        filter.addType(c)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/docs/index.md

# NFT Storefront

The NFT storefront is a general-purpose Cadence 
contract for trading NFTs on Flow.

`NFTStorefront` uses modern Cadence [run-time type](https://docs.onflow.org/cadence/language/run-time-types/)
facilities to implement a marketplace that can take any currency in order to vend any token in a safe and secure way. 
This means that only one instance of the contract is needed (see below for its address on Testnet and Mainnet), 
and its resources, transactions, and scripts can be used by any account to create any marketplace.

## Contract Addresses 

|Name|Testnet|Mainnet|
|----|-------|-------|
|[NFTStorefront](contracts/NFTStorefront.cdc)|[0x94b06cfca1d8a476](https://flow-view-source.com/testnet/account/0x94b06cfca1d8a476/contract/NFTStorefront)|[0x4eb8a10cb9f87357](https://flowscan.org/contract/A.4eb8a10cb9f87357.NFTStorefront)|

## Usage

Each account that wants to offer NFTs for sale installs a `Storefront`,
and then lists individual sales within that `Storefront` as `Listing` resources.

There is one `Storefront` per account that handles sales of all NFT types
for that account.

Each `Listing` can list one or more cut percentages.
Each cut is delivered to a predefined address. 
Cuts can be used to pay listing fees or other considerations.

Each NFT may be listed in one or more `Listing` resources.
The validity of each `Listing` can easily be checked.

Purchasers can watch for `Listing` events and check the NFT type and
ID to see if they wish to buy the offered item.

Marketplaces and other aggregators can watch for `Listing` events
and list items of interest.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/mint_nft.cdc

```
import NonFungibleToken from "../../../../contracts/utility/NonFungibleToken.cdc"
import ExampleNFT from "../../../../contracts/utility/ExampleNFT.cdc"
import MetadataViews from "../../../../contracts/utility/MetadataViews.cdc"
import FungibleToken from "../../../../contracts/utility/FungibleToken.cdc"

// This script uses the NFTMinter resource to mint a new NFT
// It must be run with the account that has the minter resource
// stored in /storage/NFTMinter

transaction(
    recipient: Address,
    name: String,
    description: String,
    thumbnail: String,
    cuts: [UFix64],
    royaltyDescriptions: [String],
    royaltyBeneficiaries: [Address] 
) {

    // local variable for storing the minter reference
    let minter: &ExampleNFT.NFTMinter

    let royalties: [MetadataViews.Royalty]


    prepare(signer: AuthAccount) {
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")
        
        // creating the royalty details
        var count = 0
        self.royalties = []
        while royaltyBeneficiaries.length > count {
            let beneficiary = royaltyBeneficiaries[count]
            let beneficiaryCapability = getAccount(beneficiary)
            .getCapability<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())

            // Make sure the royalty capability is valid before minting the NFT
            if !beneficiaryCapability.check() { panic("Beneficiary capability is not valid!") }

            self.royalties.append(
                MetadataViews.Royalty(
                    receiver: beneficiaryCapability,
                    cut: cuts[count],
                    description: royaltyDescriptions[count]
                )
            )
            count = count + 1
        }
    }

    pre {
        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: "Array length should be equal for royalty related details"
    }

    execute {

        // Borrow the recipient's public NFT collection reference
        let receiver = getAccount(recipient)
            .getCapability(ExampleNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // Mint the NFT and deposit it to the recipient's collection
        self.minter.mintNFT(
            recipient: receiver,
            name: name,
            description: description,
            thumbnail: thumbnail,
            royalties: self.royalties
        )
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc

```
import ExampleToken from "ExampleToken"
import FungibleToken from "FungibleToken"
import NonFungibleToken from "NonFungibleToken"
import ExampleNFT from "ExampleNFT"
import MetadataViews from "MetadataViews"
import NFTStorefrontV2 from "NFTStorefrontV2"

/// Transaction used to facilitate the creation of the listing under the signer's owned storefront resource.
/// It accepts the certain details from the signer,i.e. - 
///
/// `saleItemID` - ID of the NFT that is put on sale by the seller.
/// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.
/// `customID` - Optional string to represent identifier of the dapp.
/// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.
/// `expiry` - Unix timestamp at which created listing become expired.
/// `marketplacesAddress` - List of addresses that are allowed to get the commission.

/// If the given nft has a support of the RoyaltyView then royalties will added as the sale cut.

transaction(
    saleItemID: UInt64,
    saleItemPrice: UFix64,
    customID: String?,
    commissionAmount: UFix64,
    expiry: UInt64,
    marketplacesAddress: [Address]
) {
    
    let tokenReceiver: Capability<&{FungibleToken.Receiver}>
    let exampleNFTProvider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>
    let storefront: auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront
    var saleCuts: [NFTStorefrontV2.SaleCut]
    var marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]

    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, StorageCapabilities) &Account) {
        self.saleCuts = []
        self.marketplacesCapability = []

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // Receiver for the sale cut.
        self.tokenReceiver = acct.capabilities.get<&{FungibleToken.Receiver}>(/public/exampleTokenReceiver)
        assert(self.tokenReceiver.borrow() != nil, message: "Missing or mis-typed ExampleToken receiver")

        var nftProviderCap: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? = nil
        // check if there is an existing capability/capability controller for the storage path
        let nftCollectionControllers = acct.capabilities.storage.getControllers(forPath: collectionData.storagePath)
        for controller in nftCollectionControllers {
            if let maybeProviderCap = controller.capability as? Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? {
                nftProviderCap = maybeProviderCap
                break
            }
        }

        // if there are no capabilities created for that storage path
        // or if existing capability is no longer valid, issue a new one
        if nftProviderCap == nil || nftProviderCap?.check() ?? false {
            nftProviderCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        }
        assert(nftProviderCap?.check() ?? false, message: "Could not assign Provider Capability")

        self.exampleNFTProvider = nftProviderCap!

        let collection = acct.capabilities.borrow<&{NonFungibleToken.Collection}>(
                collectionData.publicPath
            ) ?? panic("Could not borrow a reference to the signer's collection")

        var totalRoyaltyCut = 0.0
        let effectiveSaleItemPrice = saleItemPrice - commissionAmount
        let nft = collection.borrowNFT(saleItemID)!
        // Check whether the NFT implements the MetadataResolver or not.
        if nft.getViews().contains(Type<MetadataViews.Royalties>()) {
            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
            for royalty in royalties {
                // TODO - Verify the type of the vault and it should exists
                self.saleCuts.append(
                    NFTStorefrontV2.SaleCut(
                        receiver: royalty.receiver,
                        amount: royalty.cut * effectiveSaleItemPrice
                    )
                )
                totalRoyaltyCut = totalRoyaltyCut + (royalty.cut * effectiveSaleItemPrice)
            }
        }
        // Append the cut for the seller.
        self.saleCuts.append(
            NFTStorefrontV2.SaleCut(
                receiver: self.tokenReceiver,
                amount: effectiveSaleItemPrice - totalRoyaltyCut
            )
        )

        self.storefront = acct.storage.borrow<auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront>(
                from: NFTStorefrontV2.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront Storefront")

        for marketplace in marketplacesAddress {
            // Here we are making a fair assumption that all given addresses would have
            // the capability to receive the `ExampleToken`
            self.marketplacesCapability.append(
                getAccount(marketplace).capabilities.get<&{FungibleToken.Receiver}>(/public/exampleTokenReceiver)
            )
        }
    }

    execute {
        // Create listing
        self.storefront.createListing(
            nftProviderCapability: self.exampleNFTProvider,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@ExampleToken.Vault>(),
            saleCuts: self.saleCuts,
            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,
            customID: customID,
            commissionAmount: commissionAmount,
            expiry: expiry
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/ExampleToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

access(all) contract ExampleToken: FungibleToken {

    /// The event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64, type: String)

    /// Total supply of ExampleTokens in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath
    access(all) let AdminStoragePath: StoragePath

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Example Fungible Token",
                    symbol: "EFT",
                    description: "This fungible token is used as an example to help you develop your next FT #onFlow.",
                    externalURL: MetadataViews.ExternalURL("https://example-ft.onflow.org"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/exampleTokenVault,
                    receiverPath: /public/exampleTokenReceiver,
                    metadataPath: /public/exampleTokenVault,
                    receiverLinkedType: Type<&ExampleToken.Vault>(),
                    metadataLinkedType: Type<&ExampleToken.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: ExampleToken.totalSupply
                )
        }
        return nil
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                ExampleToken.totalSupply = ExampleToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        access(all) view fun getViews(): [Type] {
            return ExampleToken.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return ExampleToken.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @ExampleToken.Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @ExampleToken.Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @ExampleToken.Vault {
            return <-create Vault(balance: 0.0)
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    access(all) resource Minter {
        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        access(all) fun mintTokens(amount: UFix64): @ExampleToken.Vault {
            ExampleToken.totalSupply = ExampleToken.totalSupply + amount
            emit TokensMinted(amount: amount, type: self.getType().identifier)
            return <-create Vault(balance: amount)
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @ExampleToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 1000.0

        self.VaultStoragePath = /storage/exampleTokenVault
        self.VaultPublicPath = /public/exampleTokenVault
        self.ReceiverPublicPath = /public/exampleTokenReceiver
        self.AdminStoragePath = /storage/exampleTokenAdmin 

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)

        // Create a public capability to the stored Vault that exposes
        // the `deposit` method and getAcceptedTypes method through the `Receiver` interface
        // and the `balance` method through the `Balance` interface
        //
        let exampleTokenCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(exampleTokenCap, at: self.VaultPublicPath)
        let receiverCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(receiverCap, at: self.ReceiverPublicPath)

        self.account.storage.save(<-vault, to: /storage/exampleTokenVault)

        let admin <- create Minter()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/MetadataViews.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-0636.
///
/// Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata, such as a creator biography
/// or a JPEG image file.
///
access(all) contract MetadataViews {

    /// Display is a basic view that includes the name, description and
    /// thumbnail for an object. Most objects should implement this view.
    ///
    access(all) struct Display {

        /// The name of the object.
        ///
        /// This field will be displayed in lists and therefore should
        /// be short an concise.
        ///
        access(all) let name: String

        /// A written description of the object.
        ///
        /// This field will be displayed in a detailed view of the object,
        /// so can be more verbose (e.g. a paragraph instead of a single line).
        ///
        access(all) let description: String

        /// A small thumbnail representation of the object.
        ///
        /// This field should be a web-friendly file (i.e JPEG, PNG)
        /// that can be displayed in lists, link previews, etc.
        ///
        access(all) let thumbnail: {File}

        view init(
            name: String,
            description: String,
            thumbnail: {File}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }
    }

    /// Helper to get Display in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Display struct
    ///
    access(all) fun getDisplay(_ viewResolver: &{ViewResolver.Resolver}) : Display? {
        if let view = viewResolver.resolveView(Type<Display>()) {
            if let v = view as? Display {
                return v
            }
        }
        return nil
    }

    /// Generic interface that represents a file stored on or off chain. Files
    /// can be used to references images, videos and other media.
    ///
    access(all) struct interface File {
        access(all) view fun uri(): String
    }

    /// View to expose a file that is accessible at an HTTP (or HTTPS) URL.
    ///
    access(all) struct HTTPFile: File {
        access(all) let url: String

        view init(url: String) {
            self.url = url
        }

        access(all) view fun uri(): String {
            return self.url
        }
    }

    /// View to expose a file stored on IPFS.
    /// IPFS images are referenced by their content identifier (CID)
    /// rather than a direct URI. A client application can use this CID
    /// to find and load the image via an IPFS gateway.
    ///
    access(all) struct IPFSFile: File {

        /// CID is the content identifier for this IPFS file.
        ///
        /// Ref: https://docs.ipfs.io/concepts/content-addressing/
        ///
        access(all) let cid: String

        /// Path is an optional path to the file resource in an IPFS directory.
        ///
        /// This field is only needed if the file is inside a directory.
        ///
        /// Ref: https://docs.ipfs.io/concepts/file-systems/
        ///
        access(all) let path: String?

        view init(cid: String, path: String?) {
            self.cid = cid
            self.path = path
        }

        /// This function returns the IPFS native URL for this file.
        /// Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls
        ///
        /// @return The string containing the file uri
        ///
        access(all) view fun uri(): String {
            if let path = self.path {
                return "ipfs://".concat(self.cid).concat("/").concat(path)
            }

            return "ipfs://".concat(self.cid)
        }
    }

    /// A struct to represent a generic URI. May be used to represent the URI of
    /// the NFT where the type of URI is not able to be determined (i.e. HTTP,
    /// IPFS, etc.)
    ///
    access(all) struct URI: File {
        /// The base URI prefix, if any. Not needed for all URIs, but helpful
        /// for some use cases For example, updating a whole NFT collection's
        /// image host easily
        ///
        access(all) let baseURI: String?
        /// The URI string value
        /// NOTE: this is set on init as a concatenation of the baseURI and the
        /// value if baseURI != nil
        ///
        access(self) let value: String

        access(all) view fun uri(): String {
            return self.value
        }

        init(baseURI: String?, value: String) {
            self.baseURI = baseURI
            self.value = baseURI != nil ? baseURI!.concat(value) : value
        }
    }

    access(all) struct Media {

        /// File for the media
        ///
        access(all) let file: {File}

        /// media-type comes on the form of type/subtype as described here 
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
        ///
        access(all) let mediaType: String

        view init(file: {File}, mediaType: String) {
          self.file=file
          self.mediaType=mediaType
        }
    }

    /// Wrapper view for multiple media views
    ///
    access(all) struct Medias {

        /// An arbitrary-sized list for any number of Media items
        access(all) let items: [Media]

        view init(_ items: [Media]) {
            self.items = items
        }
    }

    /// Helper to get Medias in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Medias struct
    ///
    access(all) fun getMedias(_ viewResolver: &{ViewResolver.Resolver}) : Medias? {
        if let view = viewResolver.resolveView(Type<Medias>()) {
            if let v = view as? Medias {
                return v
            }
        }
        return nil
    }

    /// View to represent a license according to https://spdx.org/licenses/
    /// This view can be used if the content of an NFT is licensed.
    ///
    access(all) struct License {
        access(all) let spdxIdentifier: String

        view init(_ identifier: String) {
            self.spdxIdentifier = identifier
        }
    }

    /// Helper to get License in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional License struct
    ///
    access(all) fun getLicense(_ viewResolver: &{ViewResolver.Resolver}) : License? {
        if let view = viewResolver.resolveView(Type<License>()) {
            if let v = view as? License {
                return v
            }
        }
        return nil
    }

    /// View to expose a URL to this item on an external site.
    /// This can be used by applications like .find and Blocto to direct users 
    /// to the original link for an NFT or a project page that describes the NFT collection.
    /// eg https://www.my-nft-project.com/overview-of-nft-collection
    ///
    access(all) struct ExternalURL {
        access(all) let url: String

        view init(_ url: String) {
            self.url=url
        }
    }

    /// Helper to get ExternalURL in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional ExternalURL struct
    ///
    access(all) fun getExternalURL(_ viewResolver: &{ViewResolver.Resolver}) : ExternalURL? {
        if let view = viewResolver.resolveView(Type<ExternalURL>()) {
            if let v = view as? ExternalURL {
                return v
            }
        }
        return nil
    }

    /// View that defines the composable royalty standard that gives marketplaces a 
    /// unified interface to support NFT royalties.
    ///
    access(all) struct Royalty {

        /// Generic FungibleToken Receiver for the beneficiary of the royalty
        /// Can get the concrete type of the receiver with receiver.getType()
        /// Recommendation - Users should create a new link for a FlowToken 
        /// receiver for this using `getRoyaltyReceiverPublicPath()`, and not 
        /// use the default FlowToken receiver. This will allow users to update 
        /// the capability in the future to use a more generic capability
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// Multiplier used to calculate the amount of sale value transferred to 
        /// royalty receiver. Note - It should be between 0.0 and 1.0 
        /// Ex - If the sale value is x and multiplier is 0.56 then the royalty 
        /// value would be 0.56 * x.
        /// Generally percentage get represented in terms of basis points
        /// in solidity based smart contracts while cadence offers `UFix64` 
        /// that already supports the basis points use case because its 
        /// operations are entirely deterministic integer operations and support 
        /// up to 8 points of precision.
        access(all) let cut: UFix64

        /// Optional description: This can be the cause of paying the royalty,
        /// the relationship between the `wallet` and the NFT, or anything else
        /// that the owner might want to specify.
        access(all) let description: String

        view init(receiver: Capability<&{FungibleToken.Receiver}>, cut: UFix64, description: String) {
            pre {
                cut >= 0.0 && cut <= 1.0 : "Cut value should be in valid range i.e [0,1]"
            }
            self.receiver = receiver
            self.cut = cut
            self.description = description
        }
    }

    /// Wrapper view for multiple Royalty views.
    /// Marketplaces can query this `Royalties` struct from NFTs 
    /// and are expected to pay royalties based on these specifications.
    ///
    access(all) struct Royalties {

        /// Array that tracks the individual royalties
        access(self) let cutInfos: [Royalty]

        access(all) view init(_ cutInfos: [Royalty]) {
            // Validate that sum of all cut multipliers should not be greater than 1.0
            var totalCut = 0.0
            for royalty in cutInfos {
                totalCut = totalCut + royalty.cut
            }
            assert(totalCut <= 1.0, message: "Sum of cutInfos multipliers should not be greater than 1.0")
            // Assign the cutInfos
            self.cutInfos = cutInfos
        }

        /// Return the cutInfos list
        ///
        /// @return An array containing all the royalties structs
        ///
        access(all) view fun getRoyalties(): [Royalty] {
            return self.cutInfos
        }
    }

    /// Helper to get Royalties in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Royalties struct
    ///
    access(all) fun getRoyalties(_ viewResolver: &{ViewResolver.Resolver}) : Royalties? {
        if let view = viewResolver.resolveView(Type<Royalties>()) {
            if let v = view as? Royalties {
                return v
            }
        }
        return nil
    }

    /// Get the path that should be used for receiving royalties
    /// This is a path that will eventually be used for a generic switchboard receiver,
    /// hence the name but will only be used for royalties for now.
    ///
    /// @return The PublicPath for the generic FT receiver
    ///
    access(all) view fun getRoyaltyReceiverPublicPath(): PublicPath {
        return /public/GenericFTReceiver
    }

    /// View to represent a single field of metadata on an NFT.
    /// This is used to get traits of individual key/value pairs along with some
    /// contextualized data about the trait
    ///
    access(all) struct Trait {
        // The name of the trait. Like Background, Eyes, Hair, etc.
        access(all) let name: String

        // The underlying value of the trait, the rest of the fields of a trait provide context to the value.
        access(all) let value: AnyStruct

        // displayType is used to show some context about what this name and value represent
        // for instance, you could set value to a unix timestamp, and specify displayType as "Date" to tell
        // platforms to consume this trait as a date and not a number
        access(all) let displayType: String?

        // Rarity can also be used directly on an attribute.
        //
        // This is optional because not all attributes need to contribute to the NFT's rarity.
        access(all) let rarity: Rarity?

        view init(name: String, value: AnyStruct, displayType: String?, rarity: Rarity?) {
            self.name = name
            self.value = value
            self.displayType = displayType
            self.rarity = rarity
        }
    }

    /// Wrapper view to return all the traits on an NFT.
    /// This is used to return traits as individual key/value pairs along with
    /// some contextualized data about each trait.
    access(all) struct Traits {
        access(all) let traits: [Trait]

        view init(_ traits: [Trait]) {
            self.traits = traits
        }
            
        /// Adds a single Trait to the Traits view
        /// 
        /// @param Trait: The trait struct to be added
        ///
        access(all) fun addTrait(_ t: Trait) {
            self.traits.append(t)
        }
    }

    /// Helper to get Traits view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Traits struct
    ///
    access(all) fun getTraits(_ viewResolver: &{ViewResolver.Resolver}) : Traits? {
        if let view = viewResolver.resolveView(Type<Traits>()) {
            if let v = view as? Traits {
                return v
            }
        }
        return nil
    }

    /// Helper function to easily convert a dictionary to traits. For NFT 
    /// collections that do not need either of the optional values of a Trait, 
    /// this method should suffice to give them an array of valid traits.
    ///
    /// @param dict: The dictionary to be converted to Traits
    /// @param excludedNames: An optional String array specifying the `dict`
    ///         keys that are not wanted to become `Traits`
    /// @return The generated Traits view
    ///
    access(all) fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits {
        // Collection owners might not want all the fields in their metadata included.
        // They might want to handle some specially, or they might just not want them included at all.
        if excludedNames != nil {
            for k in excludedNames! {
                dict.remove(key: k)
            }
        }

        let traits: [Trait] = []
        for k in dict.keys {
            let trait = Trait(name: k, value: dict[k]!, displayType: nil, rarity: nil)
            traits.append(trait)
        }

        return Traits(traits)
    }

    /// Optional view for collections that issue multiple objects
    /// with the same or similar metadata, for example an X of 100 set. This
    /// information is useful for wallets and marketplaces.
    /// An NFT might be part of multiple editions, which is why the edition
    /// information is returned as an arbitrary sized array
    ///
    access(all) struct Edition {

        /// The name of the edition
        /// For example, this could be Set, Play, Series,
        /// or any other way a project could classify its editions
        access(all) let name: String?

        /// The edition number of the object.
        /// For an "24 of 100 (#24/100)" item, the number is 24.
        access(all) let number: UInt64

        /// The max edition number of this type of objects.
        /// This field should only be provided for limited-editioned objects.
        /// For an "24 of 100 (#24/100)" item, max is 100.
        /// For an item with unlimited edition, max should be set to nil.
        ///
        access(all) let max: UInt64?

        view init(name: String?, number: UInt64, max: UInt64?) {
            if max != nil {
                assert(number <= max!, message: "The number cannot be greater than the max number!")
            }
            self.name = name
            self.number = number
            self.max = max
        }
    }

    /// Wrapper view for multiple Edition views
    ///
    access(all) struct Editions {

        /// An arbitrary-sized list for any number of editions
        /// that the NFT might be a part of
        access(all) let infoList: [Edition]

        view init(_ infoList: [Edition]) {
            self.infoList = infoList
        }
    }

    /// Helper to get Editions in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Editions struct
    ///
    access(all) fun getEditions(_ viewResolver: &{ViewResolver.Resolver}) : Editions? {
        if let view = viewResolver.resolveView(Type<Editions>()) {
            if let v = view as? Editions {
                return v
            }
        }
        return nil
    }

    /// View representing a project-defined serial number for a specific NFT
    /// Projects have different definitions for what a serial number should be
    /// Some may use the NFTs regular ID and some may use a different
    /// classification system. The serial number is expected to be unique among
    /// other NFTs within that project
    ///
    access(all) struct Serial {
        access(all) let number: UInt64

        view init(_ number: UInt64) {
            self.number = number
        }
    }

    /// Helper to get Serial in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Serial struct
    ///
    access(all) fun getSerial(_ viewResolver: &{ViewResolver.Resolver}) : Serial? {
        if let view = viewResolver.resolveView(Type<Serial>()) {
            if let v = view as? Serial {
                return v
            }
        }
        return nil
    }

    /// View to expose rarity information for a single rarity
    /// Note that a rarity needs to have either score or description but it can 
    /// have both
    ///
    access(all) struct Rarity {
        /// The score of the rarity as a number
        access(all) let score: UFix64?

        /// The maximum value of score
        access(all) let max: UFix64?

        /// The description of the rarity as a string.
        ///
        /// This could be Legendary, Epic, Rare, Uncommon, Common or any other string value
        access(all) let description: String?

        view init(score: UFix64?, max: UFix64?, description: String?) {
            if score == nil && description == nil {
                panic("A Rarity needs to set score, description or both")
            }

            self.score = score
            self.max = max
            self.description = description
        }
    }

    /// Helper to get Rarity view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Rarity struct
    ///
    access(all) fun getRarity(_ viewResolver: &{ViewResolver.Resolver}) : Rarity? {
        if let view = viewResolver.resolveView(Type<Rarity>()) {
            if let v = view as? Rarity {
                return v
            }
        }
        return nil
    }

    /// NFTView wraps all Core views along `id` and `uuid` fields, and is used 
    /// to give a complete picture of an NFT. Most NFTs should implement this 
    /// view.
    ///
    access(all) struct NFTView {
        access(all) let id: UInt64
        access(all) let uuid: UInt64
        access(all) let display: MetadataViews.Display?
        access(all) let externalURL: MetadataViews.ExternalURL?
        access(all) let collectionData: NFTCollectionData?
        access(all) let collectionDisplay: NFTCollectionDisplay?
        access(all) let royalties: Royalties?
        access(all) let traits: Traits?

        view init(
            id : UInt64,
            uuid : UInt64,
            display : MetadataViews.Display?,
            externalURL : MetadataViews.ExternalURL?,
            collectionData : NFTCollectionData?,
            collectionDisplay : NFTCollectionDisplay?,
            royalties : Royalties?,
            traits: Traits?
        ) {
            self.id = id
            self.uuid = uuid
            self.display = display
            self.externalURL = externalURL
            self.collectionData = collectionData
            self.collectionDisplay = collectionDisplay
            self.royalties = royalties
            self.traits = traits
        }
    }

    /// Helper to get an NFT view 
    ///
    /// @param id: The NFT id
    /// @param viewResolver: A reference to the resolver resource
    /// @return A NFTView struct
    ///
    access(all) fun getNFTView(id: UInt64, viewResolver: &{ViewResolver.Resolver}) : NFTView {
        let nftView = viewResolver.resolveView(Type<NFTView>())
        if nftView != nil {
            return nftView! as! NFTView
        }

        return NFTView(
            id : id,
            uuid: viewResolver.uuid,
            display: MetadataViews.getDisplay(viewResolver),
            externalURL : MetadataViews.getExternalURL(viewResolver),
            collectionData : self.getNFTCollectionData(viewResolver),
            collectionDisplay : self.getNFTCollectionDisplay(viewResolver),
            royalties : self.getRoyalties(viewResolver),
            traits : self.getTraits(viewResolver)
        )
    }

    /// View to expose the information needed store and retrieve an NFT.
    /// This can be used by applications to setup a NFT collection with proper 
    /// storage and public capabilities.
    ///
    access(all) struct NFTCollectionData {
        /// Path in storage where this NFT is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose public capabilities of this NFT
        /// including standard NFT interfaces and metadataviews interfaces
        access(all) let publicPath: PublicPath

        /// The concrete type of the collection that is exposed to the public
        /// now that entitlements exist, it no longer needs to be restricted to a specific interface
        access(all) let publicCollection: Type

        /// Type that should be linked at the aforementioned public path
        access(all) let publicLinkedType: Type

        /// Function that allows creation of an empty NFT collection that is intended to store
        /// this NFT.
        access(all) let createEmptyCollection: fun(): @{NonFungibleToken.Collection}

        view init(
            storagePath: StoragePath,
            publicPath: PublicPath,
            publicCollection: Type,
            publicLinkedType: Type,
            createEmptyCollectionFunction: fun(): @{NonFungibleToken.Collection}
        ) {
            pre {
                publicLinkedType.isSubtype(of: Type<&{NonFungibleToken.Collection}>()): "Public type must be a subtype of NonFungibleToken.Collection interface."
            }
            self.storagePath=storagePath
            self.publicPath=publicPath
            self.publicCollection=publicCollection
            self.publicLinkedType=publicLinkedType
            self.createEmptyCollection=createEmptyCollectionFunction
        }
    }

    /// Helper to get NFTCollectionData in a way that will return an typed Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollectionData struct
    ///
    access(all) fun getNFTCollectionData(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionData? {
        if let view = viewResolver.resolveView(Type<NFTCollectionData>()) {
            if let v = view as? NFTCollectionData {
                return v
            }
        }
        return nil
    }

    /// View to expose the information needed to showcase this NFT's
    /// collection. This can be used by applications to give an overview and 
    /// graphics of the NFT collection this NFT belongs to.
    ///
    access(all) struct NFTCollectionDisplay {
        // Name that should be used when displaying this NFT collection.
        access(all) let name: String

        // Description that should be used to give an overview of this collection.
        access(all) let description: String

        // External link to a URL to view more information about this collection.
        access(all) let externalURL: MetadataViews.ExternalURL

        // Square-sized image to represent this collection.
        access(all) let squareImage: MetadataViews.Media

        // Banner-sized image for this collection, recommended to have a size near 1400x350.
        access(all) let bannerImage: MetadataViews.Media

        // Social links to reach this collection's social homepages.
        // Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            squareImage: MetadataViews.Media,
            bannerImage: MetadataViews.Media,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.description = description
            self.externalURL = externalURL
            self.squareImage = squareImage
            self.bannerImage = bannerImage
            self.socials = socials
        }
    }

    /// Helper to get NFTCollectionDisplay in a way that will return a typed 
    /// Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollection struct
    ///
    access(all) fun getNFTCollectionDisplay(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionDisplay? {
        if let view = viewResolver.resolveView(Type<NFTCollectionDisplay>()) {
            if let v = view as? NFTCollectionDisplay {
                return v
            }
        }
        return nil
    }
    /// This view may be used by Cadence-native projects to define their
    /// contract- and token-level metadata according to EVM-compatible formats.
    /// Several ERC standards (e.g. ERC20, ERC721, etc.) expose name and symbol
    /// values to define assets as well as contract- & token-level metadata view
    /// `tokenURI(uint256)` and `contractURI()` methods. This view enables
    /// Cadence projects to define in their own contracts how they would like
    /// their metadata to be defined when bridged to EVM.
    ///
    access(all) struct EVMBridgedMetadata {

        /// The name of the asset
        ///
        access(all) let name: String

        /// The symbol of the asset
        ///
        access(all) let symbol: String

        /// The URI of the asset - this can either be contract-level or
        /// token-level URI depending on where the metadata is resolved. It
        /// is recommended to reference EVM metadata standards for how to best
        /// prepare your view's formatted value.
        ///
        /// For example, while you may choose to take advantage of onchain
        /// metadata, as is the case for most Cadence NFTs, you may also choose
        /// to represent your asset's metadata in IPFS and assign this value as
        /// an IPFSFile struct pointing to that IPFS file. Alternatively, you
        /// may serialize your NFT's metadata and assign it as a JSON string
        /// data URL representating the NFT's onchain metadata at the time this
        /// view is resolved.
        ///
        access(all) let uri: {File}

        init(name: String, symbol: String, uri: {File}) {
            self.name = name
            self.symbol = symbol
            self.uri = uri
        }
    }

    access(all) fun getEVMBridgedMetadata(_ viewResolver: &{ViewResolver.Resolver}) : EVMBridgedMetadata? {
        if let view = viewResolver.resolveView(Type<EVMBridgedMetadata>()) {
            if let v = view as? EVMBridgedMetadata {
                return v
            }
        }
        return nil
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/setup_account.cdc

```
import "NFTStorefront"

// This transaction installs the Storefront ressource in an account.

transaction {
    prepare(acct: auth(IssueStorageCapabilityController, PublishCapability, Storage) &Account) {

        // If the account doesn't already have a Storefront
        if acct.storage.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {

            // Create a new empty .Storefront
            let storefront <- NFTStorefront.createStorefront()
            
            // save it to the account
            acct.storage.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)

            // create a public capability for the .Storefront & publish
            let storefrontPublicCap = acct.capabilities.storage.issue<&{NFTStorefront.StorefrontPublic}>(
                    NFTStorefront.StorefrontStoragePath
                )
            acct.capabilities.publish(storefrontPublicCap, at: NFTStorefront.StorefrontPublicPath)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/NFTStorefrontV2.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "Burner"

/// NFTStorefrontV2
///
/// A general purpose sale support contract for NFTs that implement the Flow NonFungibleToken standard.
/// 
/// Each account that wants to list NFTs for sale installs a Storefront,
/// and lists individual sales within that Storefront as Listings.
/// There is one Storefront per account, it handles sales of all NFT types
/// for that account.
///
/// Each Listing can have one or more "cuts" of the sale price that
/// goes to one or more addresses. Cuts can be used to pay listing fees
/// or other considerations. 
/// Each Listing can include a commission amount that is paid to whoever facilitates
/// the purchase. The seller can also choose to provide an optional list of marketplace 
/// receiver capabilities. In this case, the commission amount must be transferred to
/// one of the capabilities in the list.
///
/// Each NFT may be listed in one or more Listings, the validity of each
/// Listing can easily be checked.
/// 
/// Purchasers can watch for Listing events and check the NFT type and
/// ID to see if they wish to buy the listed item.
/// Marketplaces and other aggregators can watch for Listing events
/// and list items of interest.
///
access(all) contract NFTStorefrontV2 {

    access(all) entitlement CreateListing
    access(all) entitlement RemoveListing

    /// StorefrontInitialized
    /// A Storefront resource has been created.
    /// Event consumers can now expect events from this Storefront.
    /// Note that we do not specify an address: we cannot and should not.
    /// Created resources do not have an owner address, and may be moved
    /// after creation in ways we cannot check.
    /// ListingAvailable events can be used to determine the address
    /// of the owner of the Storefront (...its location) at the time of
    /// the listing but only at that precise moment in that precise transaction.
    /// If the seller moves the Storefront while the listing is valid, 
    /// that is on them.
    ///
    access(all) event StorefrontInitialized(storefrontResourceID: UInt64)

    /// ListingAvailable
    /// A listing has been created and added to a Storefront resource.
    /// The Address values here are valid when the event is emitted, but
    /// the state of the accounts they refer to may change outside of the
    /// NFTStorefrontV2 workflow, so be careful to check when using them.
    ///
    access(all) event ListingAvailable(
        storefrontAddress: Address,
        listingResourceID: UInt64,
        nftType: Type,
        nftUUID: UInt64, 
        nftID: UInt64,
        salePaymentVaultType: Type,
        salePrice: UFix64,
        customID: String?,
        commissionAmount: UFix64,
        commissionReceivers: [Address]?,
        expiry: UInt64
    )

    /// ListingCompleted
    /// The listing has been resolved. It has either been purchased, removed or destroyed.
    ///
    access(all) event ListingCompleted(
        listingResourceID: UInt64, 
        storefrontResourceID: UInt64, 
        purchased: Bool,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        salePaymentVaultType: Type,
        salePrice: UFix64,
        customID: String?,
        commissionAmount: UFix64,
        commissionReceiver: Address?,
        expiry: UInt64
    )

    /// UnpaidReceiver
    /// A entitled receiver has not been paid during the sale of the NFT.
    ///
    access(all) event UnpaidReceiver(receiver: Address, entitledSaleCut: UFix64)

    /// StorefrontStoragePath
    /// The location in storage that a Storefront resource should be located.
    access(all) let StorefrontStoragePath: StoragePath

    /// StorefrontPublicPath
    /// The public location for a Storefront link.
    access(all) let StorefrontPublicPath: PublicPath


    /// SaleCut
    /// A struct representing a recipient that must be sent a certain amount
    /// of the payment when a token is sold.
    ///
    access(all) struct SaleCut {
        /// The receiver for the payment.
        /// Note that we do not store an address to find the Vault that this represents,
        /// as the link or resource that we fetch in this way may be manipulated,
        /// so to find the address that a cut goes to you must get this struct and then
        /// call receiver.borrow()!.owner.address on it.
        /// This can be done efficiently in a script.
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// The amount of the payment FungibleToken that will be paid to the receiver.
        access(all) let amount: UFix64

        /// initializer
        ///
        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }


    /// ListingDetails
    /// A struct containing a Listing's data.
    ///
    access(all) struct ListingDetails {
        /// The Storefront that the Listing is stored in.
        /// Note that this resource cannot be moved to a different Storefront,
        /// so this is OK. If we ever make it so that it *can* be moved,
        /// this should be revisited.
        access(all) var storefrontID: UInt64
        /// Whether this listing has been purchased or not.
        access(all) var purchased: Bool
        /// The Type of the NonFungibleToken.NFT that is being listed.
        access(all) let nftType: Type
        /// The Resource ID of the NFT which can only be set in the contract
        access(all) let nftUUID: UInt64
        /// The unique identifier of the NFT that will get sell.
        access(all) let nftID: UInt64
        /// The Type of the FungibleToken that payments must be made in.
        access(all) let salePaymentVaultType: Type
        /// The amount that must be paid in the specified FungibleToken.
        access(all) let salePrice: UFix64
        /// This specifies the division of payment between recipients.
        access(all) let saleCuts: [SaleCut]
        /// Allow different dapp teams to provide custom strings as the distinguished string
        /// that would help them to filter events related to their customID.
        access(all) var customID: String?
        /// Commission available to be claimed by whoever facilitates the sale.
        access(all) let commissionAmount: UFix64
        /// Expiry of listing
        access(all) let expiry: UInt64

        /// Irreversibly set this listing as purchased.
        ///
        access(contract) fun setToPurchased() {
            self.purchased = true
        }

        access(contract) fun setCustomID(customID: String?){
            self.customID = customID
        }

        /// Initializer
        ///
        init (
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            storefrontID: UInt64,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
        ) {

            pre {
                // Validate the expiry
                expiry > UInt64(getCurrentBlock().timestamp): "Expiry should be in the future"
                // Validate the length of the sale cut
                saleCuts.length > 0: "Listing must have at least one payment cut recipient"
            }

            self.storefrontID = storefrontID
            self.purchased = false
            self.nftType = nftType
            self.nftUUID = nftUUID
            self.nftID = nftID
            self.salePaymentVaultType = salePaymentVaultType
            self.customID = customID
            self.commissionAmount = commissionAmount
            self.expiry = expiry
            self.saleCuts = saleCuts

            // Calculate the total price from the cuts
            var salePrice = commissionAmount
            // Perform initial check on capabilities, and calculate sale price from cut amounts.
            for cut in self.saleCuts {
                // Make sure we can borrow the receiver.
                // We will check this again when the token is sold.
                cut.receiver.borrow()
                    ?? panic("Cannot borrow receiver")
                // Add the cut amount to the total price
                salePrice = salePrice + cut.amount
            }
            assert(salePrice > 0.0, message: "Listing must have non-zero price")

            // Store the calculated sale price
            self.salePrice = salePrice
        }
    }


    /// ListingPublic
    /// An interface providing a useful public interface to a Listing.
    ///
    access(all) resource interface ListingPublic {
        /// borrowNFT
        /// This will assert in the same way as the NFT standard borrowNFT()
        /// if the NFT is absent, for example if it has been sold via another listing.
        ///
        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}?

        /// purchase
        /// Purchase the listing, buying the token.
        /// This pays the beneficiaries and returns the token to the buyer.
        ///
        access(all) fun purchase(
            payment: @{FungibleToken.Vault}, 
            commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
        ): @{NonFungibleToken.NFT}

        /// getDetails
        /// Fetches the details of the listing.
        access(all) view fun getDetails(): ListingDetails

        /// getAllowedCommissionReceivers
        /// Fetches the allowed marketplaces capabilities or commission receivers.
        /// If it returns `nil` then commission is up to grab by anyone.
        access(all) view fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?

        /// hasListingBecomeGhosted
        /// Tells whether listed NFT is present in provided capability.
        /// If it returns `false` then it means listing becomes ghost or sold out.
        access(all) view fun hasListingBecomeGhosted(): Bool

    }


    /// Listing
    /// A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    /// and for the proceeds of that sale to be split between several recipients.
    /// 
    access(all) resource Listing: ListingPublic, Burner.Burnable {
        /// The simple (non-Capability, non-complex) details of the sale
        access(self) let details: ListingDetails

        /// A capability allowing this resource to withdraw the NFT with the given ID from its collection.
        /// This capability allows the resource to withdraw *any* NFT, so you should be careful when giving
        /// such a capability to a resource and always check its code to make sure it will use it in the
        /// way that it claims.
        access(contract) let nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        /// An optional list of marketplaces capabilities that are approved 
        /// to receive the marketplace commission.
        access(contract) let marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?

        access(contract) fun burnCallback() {
            // If the listing has not been purchased, we regard it as completed here.
            // Otherwise we regard it as completed in purchase().
            // This is because we destroy the listing in Storefront.removeListing()
            // or Storefront.cleanup() .
            // If we change this destructor, revisit those functions.
            if !self.details.purchased {
                emit ListingCompleted(
                    listingResourceID: self.uuid,
                    storefrontResourceID: self.details.storefrontID,
                    purchased: self.details.purchased,
                    nftType: self.details.nftType,
                    nftUUID: self.details.nftUUID,
                    nftID: self.details.nftID,
                    salePaymentVaultType: self.details.salePaymentVaultType,
                    salePrice: self.details.salePrice,
                    customID: self.details.customID,
                    commissionAmount: self.details.commissionAmount,
                    commissionReceiver: nil,
                    expiry: self.details.expiry
                )
            }
        }

        /// borrowNFT
        /// Return the reference of the NFT that is listed for sale.
        /// if the NFT is absent, for example if it has been sold via another listing.
        /// it will return nil.
        ///
        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}? {
            if let ref = self.nftProviderCapability.borrow()!.borrowNFT(self.details.nftID) {
                if ref.isInstance(self.details.nftType) && ref.id == self.details.nftID {
                    return ref
                }
            }

            return nil
        }

        /// getDetails
        /// Get the details of listing.
        ///
        access(all) view fun getDetails(): ListingDetails {
            return self.details
        }

        /// getAllowedCommissionReceivers
        /// Fetches the allowed marketplaces capabilities or commission receivers.
        /// If it returns `nil` then commission is up to grab by anyone.
        access(all) view fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]? {
            return self.marketplacesCapability
        }

        /// hasListingBecomeGhosted
        /// Tells whether listed NFT is present in provided capability.
        /// If it returns `false` then it means listing becomes ghost or sold out.
        access(all) view fun hasListingBecomeGhosted(): Bool {
            if let providerRef = self.nftProviderCapability.borrow() {
                return providerRef.borrowNFT(self.details.nftID) != nil
            }
            return false
        }

        /// purchase
        /// Purchase the listing, buying the token.
        /// This pays the beneficiaries and commission to the facilitator and returns extra token to the buyer.
        /// This also cleans up duplicate listings for the item being purchased.
        access(all) fun purchase(
            payment: @{FungibleToken.Vault}, 
            commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
        ): @{NonFungibleToken.NFT} {

            pre {
                self.details.purchased == false: "listing has already been purchased"
                payment.isInstance(self.details.salePaymentVaultType): "payment vault is not requested fungible token"
                payment.balance == self.details.salePrice: "payment vault does not contain requested price"
                self.details.expiry > UInt64(getCurrentBlock().timestamp): "Listing is expired"
                self.owner != nil : "Resource doesn't have the assigned owner"
            }
            
            // Make sure the listing cannot be purchased again.
            self.details.setToPurchased() 
            
            if self.details.commissionAmount > 0.0 {
                // If commission recipient is nil, Throw panic.
                let commissionReceiver = commissionRecipient ?? panic("Commission recipient can't be nil")
                if self.marketplacesCapability != nil {
                    var isCommissionRecipientHasValidType = false
                    var isCommissionRecipientAuthorised = false
                    for cap in self.marketplacesCapability! {
                        // Check 1: Should have the same type
                        if cap.getType() == commissionReceiver.getType() {
                            isCommissionRecipientHasValidType = true
                            // Check 2: Should have the valid market address that holds approved capability.
                            if cap.address == commissionReceiver.address && cap.check() {
                                isCommissionRecipientAuthorised = true
                                break
                            }
                        }
                    }
                    assert(isCommissionRecipientHasValidType, message: "Given recipient does not has valid type")
                    assert(isCommissionRecipientAuthorised, message: "Given recipient is not authorised to receive the commission")
                }
                let commissionPayment <- payment.withdraw(amount: self.details.commissionAmount)
                let recipient = commissionReceiver.borrow() ?? panic("Unable to borrow the recipient capability")
                recipient.deposit(from: <- commissionPayment)
            }
            // Fetch the token to return to the purchaser.
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)
            // Neither receivers nor providers are trustworthy, they must implement the correct
            // interface but beyond complying with its pre/post conditions they are not guaranteed
            // to implement the functionality behind the interface in any given way.
            // Therefore we cannot trust the Collection resource behind the interface,
            // and we must check the NFT resource it gives us to make sure that it is the correct one.
            assert(nft.getType() == self.details.nftType, message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Fetch the duplicate listing for the given NFT
            // Access the StoreFrontManager resource reference to remove the duplicate listings if purchase would happen successfully.
            let storeFrontPublicRef = getAccount(self.owner!.address).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
                    NFTStorefrontV2.StorefrontPublicPath
                ) ?? panic("Unable to borrow the storeFrontManager resource")
            let duplicateListings = storeFrontPublicRef.getDuplicateListingIDs(
                    nftType: self.details.nftType,
                    nftID: self.details.nftID,
                    listingID: self.uuid
                )

            // Let's force removal of the listing in this storefront for the NFT that is being purchased. 
            for listingID in duplicateListings {
                storeFrontPublicRef.cleanup(listingResourceID: listingID)
            }

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the cut to the first valid receiver.
            // The first receiver should therefore either be the seller, or an agreed recipient for
            // any unpaid cuts.
            var residualReceiver: &{FungibleToken.Receiver}? = nil
            // Pay the commission 
            // Pay each beneficiary their amount of the payment.

            for cut in self.details.saleCuts {
                if let receiver = cut.receiver.borrow() {
                   let paymentCut <- payment.withdraw(amount: cut.amount)
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                } else {
                    emit UnpaidReceiver(receiver: cut.receiver.address, entitledSaleCut: cut.amount)
                }
            }

            assert(residualReceiver != nil, message: "No valid payment receivers")

            // At this point, if all receivers were active and available, then the payment Vault will have
            // zero tokens left, and this will functionally be a no-op that consumes the empty vault
            residualReceiver!.deposit(from: <-payment)

            // If the listing is purchased, we regard it as completed here.
            // Otherwise we regard it as completed in the destructor.

            var commissionReceiver: Address?  = nil
            if (self.details.commissionAmount != 0.0) {
                commissionReceiver = commissionRecipient!.address
            }

            emit ListingCompleted(
                listingResourceID: self.uuid,
                storefrontResourceID: self.details.storefrontID,
                purchased: self.details.purchased,
                nftType: self.details.nftType,
                nftUUID: self.details.nftUUID,
                nftID: self.details.nftID,
                salePaymentVaultType: self.details.salePaymentVaultType,
                salePrice: self.details.salePrice,
                customID: self.details.customID,
                commissionAmount: self.details.commissionAmount,
                commissionReceiver: commissionReceiver,
                expiry: self.details.expiry
            )

            return <-nft
        }

        // destructor event
        //
        access(all) event ResourceDestroyed(
            listingResourceID: UInt64 = self.uuid,
            storefrontResourceID: UInt64 = self.details.storefrontID,
            purchased: Bool = self.details.purchased,
            nftType: String = self.details.nftType.identifier,
            nftUUID: UInt64 = self.details.nftUUID,
            nftID: UInt64 = self.details.nftID,
            salePaymentVaultType: String = self.details.salePaymentVaultType.identifier,
            salePrice: UFix64 = self.details.salePrice,
            customID: String? = self.details.customID,
            commissionAmount: UFix64 = self.details.commissionAmount,
            commissionReceiver: Address? = nil,
            expiry: UInt64 = self.details.expiry
        )

        /// initializer
        ///
        init (
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            storefrontID: UInt64,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
        ) {
            // Store the sale information
            self.details = ListingDetails(
                nftType: nftType,
                nftUUID: nftUUID,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                storefrontID: storefrontID,
                customID: customID,
                commissionAmount: commissionAmount,
                expiry: expiry
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability
            self.marketplacesCapability = marketplacesCapability

            // Check that the provider contains the NFT.
            // We will check it again when the token is sold.
            // We cannot move this into a function because initializers cannot call member functions.
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: "cannot borrow nftProviderCapability")

            // This will precondition assert if the token is not available.
            let nft = provider!.borrowNFT(self.details.nftID)
            assert(nft!.getType() == self.details.nftType, message: "token is not of specified type")
            assert(nft?.id == self.details.nftID, message: "token does not have specified ID")
        }
    }

    /// StorefrontManager
    /// An interface for adding and removing Listings within a Storefront,
    /// intended for use by the Storefront's owner
    ///
    access(all) resource interface StorefrontManager {
        /// createListing
        /// Allows the Storefront owner to create and insert Listings.
        ///
        access(CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
        ): UInt64

        /// removeListing
        /// Allows the Storefront owner to remove any sale listing, accepted or not.
        ///
        access(RemoveListing) fun removeListing(listingResourceID: UInt64)
    }

    /// StorefrontPublic
    /// An interface to allow listing and borrowing Listings, and purchasing items via Listings
    /// in a Storefront.
    ///
    access(all) resource interface StorefrontPublic {
        access(all) view fun getListingIDs(): [UInt64]
        access(all) fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
        access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}? {
            post {
                result == nil || result!.getType() == Type<@Listing>():
                    "Cannot borrow a non-NFTStorefrontV2.Listing!"
            }
        }
        access(all) fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
        access(contract) fun cleanup(listingResourceID: UInt64)
        access(all) fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64]
        access(all) fun cleanupPurchasedListings(listingResourceID: UInt64)
        access(all) fun cleanupGhostListings(listingResourceID: UInt64)
   }

    /// Storefront
    /// A resource that allows its owner to manage a list of Listings, and anyone to interact with them
    /// in order to query their details and purchase the NFTs that they represent.
    ///
    access(all) resource Storefront : StorefrontManager, StorefrontPublic {
        // Resource destroyed event
        access(all) event ResourceDestroyed(
            storefrontResourceID: UInt64 = self.uuid
        )

        /// The dictionary of Listing uuids to Listing resources.
        access(contract) var listings: @{UInt64: Listing}
        /// Dictionary to keep track of listing ids for same NFTs listing.
        /// nftType.identifier -> nftID -> [listing resource ID]
        access(contract) var listedNFTs: {String: {UInt64 : [UInt64]}}

        /// insert
        /// Create and publish a Listing for an NFT.
        ///
         access(CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
         ): UInt64 {
            
            // let's ensure that the seller does indeed hold the NFT being listed
            let collectionRef = nftProviderCapability.borrow()
                ?? panic("Could not borrow reference to collection")
            let nftRef = collectionRef.borrowNFT(nftID)
                ?? panic("Could not borrow a reference to the desired NFT ID")

            // Instead of letting an arbitrary value be set for the UUID of a given NFT, the contract
            // should fetch it itself     
            let uuid = nftRef.uuid
            let listing <- create Listing(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                marketplacesCapability: marketplacesCapability,
                storefrontID: self.uuid,
                customID: customID,
                commissionAmount: commissionAmount,
                expiry: expiry
            )
        
            let listingResourceID = listing.uuid
            let listingPrice = listing.getDetails().salePrice
            // Add the new listing to the dictionary.
            let oldListing <- self.listings[listingResourceID] <- listing
            // Note that oldListing will always be nil, but we have to handle it.

            Burner.burn(<-oldListing)

            // Add the `listingResourceID` in the tracked listings.
            self.addDuplicateListing(nftIdentifier: nftType.identifier, nftID: nftID, listingResourceID: listingResourceID)

            // Scraping addresses from the capabilities to emit in the event.
            var allowedCommissionReceivers : [Address]? = nil
            if let allowedReceivers = marketplacesCapability {
                // Small hack here to make `allowedCommissionReceivers` variable compatible to
                // array properties.
                allowedCommissionReceivers = []
                for receiver in allowedReceivers {
                    allowedCommissionReceivers!.append(receiver.address)
                }
            }

            emit ListingAvailable(
                storefrontAddress: self.owner?.address!,
                listingResourceID: listingResourceID,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                salePrice: listingPrice,
                customID: customID,
                commissionAmount: commissionAmount,
                commissionReceivers: allowedCommissionReceivers,
                expiry: expiry
            )

            return listingResourceID
        }

        /// addDuplicateListing
        /// Helper function that allows to add duplicate listing of given nft in a map.
        /// 
        access(contract) fun addDuplicateListing(nftIdentifier: String, nftID: UInt64, listingResourceID: UInt64) {
             if !self.listedNFTs.containsKey(nftIdentifier) {
                self.listedNFTs.insert(key: nftIdentifier, {nftID: [listingResourceID]})
            } else {
                if !self.listedNFTs[nftIdentifier]!.containsKey(nftID) {
                    self.listedNFTs[nftIdentifier]!.insert(key: nftID, [listingResourceID])
                } else {
                    self.listedNFTs[nftIdentifier]![nftID]!.append(listingResourceID)
                } 
            }
        }

        /// removeDuplicateListing
        /// Helper function that allows to remove duplicate listing of given nft from a map.
        /// 
        access(contract) fun removeDuplicateListing(nftIdentifier: String, nftID: UInt64, listingResourceID: UInt64) {
            // Remove the listing from the listedNFTs dictionary.
            let listingIndex = self.listedNFTs[nftIdentifier]![nftID]!.firstIndex(of: listingResourceID) ?? panic("Should contain the index")
            self.listedNFTs[nftIdentifier]![nftID]!.remove(at: listingIndex)
        }
        
        /// removeListing
        /// Remove a Listing that has not yet been purchased from the collection and destroy it.
        /// It can only be executed by the StorefrontManager resource owner.
        ///
        access(RemoveListing) fun removeListing(listingResourceID: UInt64) {
            let listing <- self.listings.remove(key: listingResourceID)
                ?? panic("missing Listing")
            let listingDetails = listing.getDetails()
            self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)
            // This will emit a ListingCompleted event.
            Burner.burn(<-listing)
        }

        /// getListingIDs
        /// Returns an array of the Listing resource IDs that are in the collection
        ///
        access(all) view fun getListingIDs(): [UInt64] {
            return self.listings.keys
        }

        /// getExistingListingIDs
        /// Returns an array of listing IDs of the given `nftType` and `nftID`.
        ///
        access(all) fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64] {
            if self.listedNFTs[nftType.identifier] == nil || self.listedNFTs[nftType.identifier]![nftID] == nil {
                return []
            }
            var listingIDs = self.listedNFTs[nftType.identifier]![nftID]!
            return listingIDs
        }

        /// cleanupPurchasedListings
        /// Allows anyone to remove already purchased listings.
        ///
        access(all) fun cleanupPurchasedListings(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: "could not find listing with given id"
                self.borrowListing(listingResourceID: listingResourceID)!.getDetails().purchased == true: "listing not purchased yet"
            }
            let listing <- self.listings.remove(key: listingResourceID)!
            let listingDetails = listing.getDetails()
            self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)

            Burner.burn(<-listing)
        }

        /// getDuplicateListingIDs
        /// Returns an array of listing IDs that are duplicates of the given `nftType` and `nftID`.
        ///
        access(all) fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64] {
            var listingIDs = self.getExistingListingIDs(nftType: nftType, nftID: nftID)

            // Verify that given listing Id also a part of the `listingIds`
            let doesListingExist = listingIDs.contains(listingID)
            // Find out the index of the existing listing.
            if doesListingExist {
                var index: Int = 0
                for id in listingIDs {
                    if id == listingID {
                        break
                    }
                    index = index + 1
                }
                listingIDs.remove(at:index)
                return listingIDs
            } 
           return []
        }

        /// cleanupExpiredListings
        /// Cleanup the expired listing by iterating over the provided range of indexes.
        ///
        access(all) fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64) {
            pre {
                fromIndex <= toIndex : "Incorrect start index"
                Int(toIndex - fromIndex) < self.getListingIDs().length : "Provided range is out of bound"
            }
            var index = fromIndex
            let listingsIDs = self.getListingIDs()
            while index <= toIndex {
                // There is a possibility that some index may not have the listing.
                // because of that instead of failing the transaction, Execution moved to next index or listing.
                
                if let listing = self.borrowListing(listingResourceID: listingsIDs[index]) {
                    if listing.getDetails().expiry <= UInt64(getCurrentBlock().timestamp) {
                        self.cleanup(listingResourceID: listingsIDs[index])
                    }
                }
                index = index + UInt64(1) 
            }
        } 

        /// borrowSaleItem
        /// Returns a read-only view of the SaleItem for the given listingID if it is contained by this collection.
        ///
        access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}? {
            return &self.listings[listingResourceID]
        }

        /// cleanup
        /// Remove an listing, When given listing is duplicate or expired
        /// Only contract is allowed to execute it.
        ///
        access(contract) fun cleanup(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: "Could not find listing with given id"
            }
            let listing <- self.listings.remove(key: listingResourceID)!
            let listingDetails = listing.getDetails()
            self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)

            Burner.burn(<-listing)
        }

        /// cleanupGhostListings
        /// Allow anyone to cleanup ghost listings
        /// Listings will become ghost listings if stored provider capability doesn't hold
        /// the NFT anymore.
        ///
        /// @param listingResourceID ID of the listing resource which would get removed if it become ghost listing.
        access(all) fun cleanupGhostListings(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: "Could not find listing with given id"
            }
            let listingRef = self.borrowListing(listingResourceID: listingResourceID)!
            let details = listingRef.getDetails()
            assert(!details.purchased, message: "Given listing is already purchased")
            assert(!listingRef.hasListingBecomeGhosted(), message: "Listing is not ghost listing")
            let listing <- self.listings.remove(key: listingResourceID)!
            let duplicateListings = self.getDuplicateListingIDs(nftType: details.nftType, nftID: details.nftID, listingID: listingResourceID)

            // Let's force removal of the listing in this storefront for the NFT that is being ghosted. 
            for listingID in duplicateListings {
                self.cleanup(listingResourceID: listingID)
            }
            Burner.burn(<-listing)
        }

        /// constructor
        ///
        init () {
            self.listings <- {}
            self.listedNFTs = {}

            // Let event consumers know that this storefront exists
            emit StorefrontInitialized(storefrontResourceID: self.uuid)
        }
    }

    /// createStorefront
    /// Make creating a Storefront publicly accessible.
    ///
    access(all) fun createStorefront(): @Storefront {
        return <-create Storefront()
    }

    init () {
        self.StorefrontStoragePath = /storage/NFTStorefrontV2
        self.StorefrontPublicPath = /public/NFTStorefrontV2
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/scripts-v1/verify_listed_nft_exists.cdc

```
import "NonFungibleToken"
import "NFTStorefront"

/// This script returns the details for a listing within a storefront
///
access(all) fun main(account: Address, listingResourceID: UInt64): Bool {
    let storefrontRef = getAccount(account).capabilities.borrow<&{NFTStorefront.StorefrontPublic}>(
            NFTStorefront.StorefrontPublicPath
        ) ?? panic("Could not borrow public storefront from address")

    let listing = storefrontRef.borrowListing(listingResourceID: listingResourceID)
        ?? panic("No listing with that ID")
    
    let nft: &{NonFungibleToken.NFT}? = listing.borrowNFT()

    return nft != nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/ViewResolver.cdc

```
// Taken from the NFT Metadata standard, this contract exposes an interface to let 
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
access(all) contract interface ViewResolver {

    /// Function that returns all the Metadata Views implemented by the resolving contract.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there is an optional parameter to specify which resource type the caller
    /// is requesting views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type]

    /// Function that resolves a metadata view for this token.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there there is an optional parameter for specify which resource type the caller
    /// is looking for views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct?

    /// Provides access to a set of metadata views. A struct or 
    /// resource (e.g. an NFT) can implement this interface to provide access to 
    /// the views that it supports.
    ///
    access(all) resource interface Resolver {

        /// Same as getViews above, but on a specific NFT instead of a contract
        access(all) view fun getViews(): [Type]

        /// Same as resolveView above, but on a specific NFT instead of a contract
        access(all) fun resolveView(_ view: Type): AnyStruct?
    }

    /// A group of view resolvers indexed by ID.
    ///
    access(all) resource interface ResolverCollection {
        access(all) view fun borrowViewResolver(id: UInt64): &{Resolver}? {
            return nil
        }

        access(all) view fun getIDs(): [UInt64] {
            return []
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/CapabilityFilter.cdc

```
/// CapabilityFilter defines `Filter`, an interface to sit on top of a ChildAccount's capabilities. Requested
/// capabilities will only return if the filter's `allowed` method returns true.
///
/// Along with the `Filter` interface are three implementations:
/// - `DenylistFilter`  - A filter which contains a mapping of denied Types
/// - `AllowlistFilter` - A filter which contains a mapping of allowed Types
/// - `AllowAllFilter`  - A passthrough, all requested capabilities are allowed
/// 
pub contract CapabilityFilter {
    
    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PublicPath: PublicPath
    pub let PrivatePath: PrivatePath

    /* --- Events --- */
    //
    pub event FilterUpdated(id: UInt64, filterType: Type, type: Type, active: Bool)

    /// `Filter` is a simple interface with methods to determine if a Capability is allowed and retrieve details about
    /// the Filter itself
    ///
    pub resource interface Filter {
        pub fun allowed(cap: Capability): Bool
        pub fun getDetails(): AnyStruct
    }

    /// `DenylistFilter` is a `Filter` which contains a mapping of denied Types
    ///
    pub resource DenylistFilter: Filter {

        /// Represents the underlying types which should not ever be returned by a RestrictedChildAccount. The filter
        /// will borrow a requested capability, and make sure that the type it gets back is not in the list of denied
        /// types
        access(self) let deniedTypes: {Type: Bool}

        /// Adds a type to the mapping of denied types with a value of true
        /// 
        /// @param type: The type to add to the denied types mapping
        ///
        pub fun addType(_ type: Type) {
            self.deniedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of denied types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.deniedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Removes all types from the mapping of denied types
        ///
        pub fun removeAllTypes() {
            for type in self.deniedTypes.keys {
                self.removeType(type)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return !self.deniedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types denied indexed on the `deniedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "deniedTypes": self.deniedTypes.keys
            }
        }

        init() {
            self.deniedTypes = {}
        }
    }

    /// `AllowlistFilter` is a `Filter` which contains a mapping of allowed Types
    ///
    pub resource AllowlistFilter: Filter {
        // allowedTypes
        // Represents the set of underlying types which are allowed to be 
        // returned by a RestrictedChildAccount. The filter will borrow
        // a requested capability, and make sure that the type it gets back is
        // in the list of allowed types
        access(self) let allowedTypes: {Type: Bool}

        /// Adds a type to the mapping of allowed types with a value of true
        /// 
        /// @param type: The type to add to the allowed types mapping
        ///
        pub fun addType(_ type: Type) {
            self.allowedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of allowed types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.allowedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Removes all types from the mapping of denied types
        ///
        pub fun removeAllTypes() {
            for type in self.allowedTypes.keys {
                self.removeType(type)
            }
        }
        
        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return self.allowedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types allowed indexed on the `allowedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "allowedTypes": self.allowedTypes.keys
            }
        }

        init() {
            self.allowedTypes = {}
        }
    }

    /// AllowAllFilter is a passthrough, all requested capabilities are allowed
    ///
    pub resource AllowAllFilter: Filter {
        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true since this filter is a passthrough
        ///
        pub fun allowed(cap: Capability): Bool {
            return true
        }
        
        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType()
            }
        }
    }

    /// Creates a new `Filter` of the given type
    ///
    /// @param t: The type of `Filter` to create
    /// @return: A new instance of the given `Filter` type
    ///
    pub fun create(_ t: Type): @AnyResource{Filter} {
        post {
            result.getType() == t
        }

        switch t {
            case Type<@AllowAllFilter>():
                return <- create AllowAllFilter()
            case Type<@AllowlistFilter>():
                return <- create AllowlistFilter()
            case Type<@DenylistFilter>():
                return <- create DenylistFilter()
        }

        panic("unsupported type requested: ".concat(t.identifier))
    }

    init() {
        let identifier = "CapabilityFilter_".concat(self.account.address.toString())
        
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/setup_account_to_receive_royalty.cdc

```

// This transaction is a template for a transaction
// to create a new link in their account to be used for receiving royalties
// This transaction can be used for any fungible token, which is specified by the `vaultPath` argument
// 
// If the account wants to receive royalties in FLOW, they'll use `/storage/flowTokenVault`
// If they want to receive it in USDC, they would use FiatToken.VaultStoragePath
// and so on. 
// The path used for the public link is a new path that in the future, is expected to receive
// and generic token, which could be forwarded to the appropriate vault

import FungibleToken from "../../../../contracts/utility/FungibleToken.cdc"
import MetadataViews from "../../../../contracts/utility/MetadataViews.cdc"

transaction(/**vaultPath: StoragePath*/) {

    prepare(signer: AuthAccount) {

        // Return early if the account doesn't have a FungibleToken Vault
        if signer.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault /**vaultPath*/) == nil {
            panic("A vault for the specified fungible token path does not exist")
        }

        // Create a public capability to the Vault that only exposes
        // the deposit function through the Receiver interface
        let capability = signer.link<&{FungibleToken.Receiver, FungibleToken.Balance}>(
            MetadataViews.getRoyaltyReceiverPublicPath(),
            target: /storage/flowTokenVault /**vaultPath*/  // js testing library doesn't support the dynamic value of the storage paths
        )!

        // Make sure the capability is valid
        if !capability.check() { panic("Beneficiary capability is not valid!") }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/NonFungibleToken.cdc

```
/**

## The Flow Non-Fungible Token standard

## `NonFungibleToken` contract

The interface that all Non-Fungible Token contracts should conform to.
If a user wants to deploy a new NFT contract, their contract should implement
The types defined here

/// Contributors (please add to this list if you contribute!):
/// - Joshua Hannan - https://github.com/joshuahannan
/// - Bastian Müller - https://twitter.com/turbolent
/// - Dete Shirley - https://twitter.com/dete73
/// - Bjarte Karlsen - https://twitter.com/0xBjartek
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Deniz Edincik - https://twitter.com/bluesign
///
/// Repo reference: https://github.com/onflow/flow-nft

## `NFT` resource interface

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource interface

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives developers the ability to define functions
that can use any type that implements these interfaces

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

import "ViewResolver"

/// The main NFT contract. Other NFT contracts will
/// import and implement the interfaces defined in this contract
///
access(all) contract interface NonFungibleToken: ViewResolver {

    /// An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// An entitlement for allowing updates and update events for an NFT
    access(all) entitlement Update

    /// Event that contracts should emit when the metadata of an NFT is updated
    /// It can only be emitted by calling the `emitNFTUpdated` function
    /// with an `Updatable` entitled reference to the NFT that was updated
    /// The entitlement prevents spammers from calling this from other users' collections
    /// because only code within a collection or that has special entitled access
    /// to the collections methods will be able to get the entitled reference
    /// 
    /// The event makes it so that third-party indexers can monitor the events
    /// and query the updated metadata from the owners' collections.
    ///
    access(all) event Updated(type: String, id: UInt64, uuid: UInt64, owner: Address?)
    access(all) view fun emitNFTUpdated(_ nftRef: auth(Update) &{NonFungibleToken.NFT})
    {
        emit Updated(type: nftRef.getType().identifier, id: nftRef.id, uuid: nftRef.uuid, owner: nftRef.owner?.address)
    }


    /// Event that is emitted when a token is withdrawn,
    /// indicating the type, id, uuid, the owner of the collection that it was withdrawn from,
    /// and the UUID of the resource it was withdrawn from, usually a collection.
    ///
    /// If the collection is not in an account's storage, `from` will be `nil`.
    ///
    access(all) event Withdrawn(type: String, id: UInt64, uuid: UInt64, from: Address?, providerUUID: UInt64)

    /// Event that emitted when a token is deposited to a collection.
    /// Indicates the type, id, uuid, the owner of the collection that it was deposited to,
    /// and the UUID of the collection it was deposited to
    ///
    /// If the collection is not in an account's storage, `from`, will be `nil`.
    ///
    access(all) event Deposited(type: String, id: UInt64, uuid: UInt64, to: Address?, collectionUUID: UInt64)

    /// Interface that the NFTs must conform to
    ///
    access(all) resource interface NFT: ViewResolver.Resolver {

        /// unique ID for the NFT
        access(all) let id: UInt64

        /// Event that is emitted automatically every time a resource is destroyed
        /// The type information is included in the metadata event so it is not needed as an argument
        access(all) event ResourceDestroyed(id: UInt64 = self.id, uuid: UInt64 = self.uuid)

        /// createEmptyCollection creates an empty Collection that is able to store the NFT
        /// and returns it to the caller so that they can own NFTs
        /// @return A an empty collection that can store this NFT
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getLength() == 0: "The created collection must be empty!"
                result.isSupportedNFTType(type: self.getType()): "The created collection must support this NFT type"
            }
        }

        /// Gets all the NFTs that this NFT directly owns
        /// @return A dictionary of all subNFTS keyed by type
        access(all) view fun getAvailableSubNFTS(): {Type: [UInt64]} {
            return {}
        }

        /// Get a reference to an NFT that this NFT owns
        /// Both arguments are optional to allow the NFT to choose
        /// how it returns sub NFTs depending on what arguments are provided
        /// For example, if `type` has a value, but `id` doesn't, the NFT 
        /// can choose which NFT of that type to return if there is a "default"
        /// If both are `nil`, then NFTs that only store a single NFT can just return
        /// that. This helps callers who aren't sure what they are looking for 
        ///
        /// @param type: The Type of the desired NFT
        /// @param id: The id of the NFT to borrow
        ///
        /// @return A structure representing the requested view.
        access(all) fun getSubNFT(type: Type, id: UInt64) : &{NonFungibleToken.NFT}? {
            return nil
        }
    }

    /// Interface to mediate withdrawals from a resource, usually a Collection
    ///
    access(all) resource interface Provider {

        // We emit withdraw events from the provider interface because conficting withdraw
        // events aren't as confusing to event listeners as conflicting deposit events

        /// withdraw removes an NFT from the collection and moves it to the caller
        /// It does not specify whether the ID is UUID or not
        /// @param withdrawID: The id of the NFT to withdraw from the collection
        access(Withdraw) fun withdraw(withdrawID: UInt64): @{NFT} {
            post {
                result.id == withdrawID: "The ID of the withdrawn token must be the same as the requested ID"
                emit Withdrawn(type: result.getType().identifier, id: result.id, uuid: result.uuid, from: self.owner?.address, providerUUID: self.uuid)
            }
        }
    }

    /// Interface to mediate deposits to the Collection
    ///
    access(all) resource interface Receiver {

        /// deposit takes an NFT as an argument and adds it to the Collection
        /// @param token: The NFT to deposit
        access(all) fun deposit(token: @{NFT})

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        /// @return A dictionary of types mapped to booleans indicating if this
        ///         reciever supports it
        access(all) view fun getSupportedNFTTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        /// @param type: An NFT type
        /// @return A boolean indicating if this receiver can recieve the desired NFT type
        access(all) view fun isSupportedNFTType(type: Type): Bool
    }

    /// Kept for backwards-compatibility reasons
    access(all) resource interface CollectionPublic {
        access(all) fun deposit(token: @{NFT})
        access(all) view fun getLength(): Int
        access(all) view fun getIDs(): [UInt64]
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void
        access(all) view fun borrowNFT(_ id: UInt64): &{NFT}?
    }

    /// Requirement for the concrete resource type
    /// to be declared in the implementing contract
    ///
    access(all) resource interface Collection: Provider, Receiver, CollectionPublic, ViewResolver.ResolverCollection {

        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        /// deposit takes a NFT as an argument and stores it in the collection
        /// @param token: The NFT to deposit into the collection
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            pre {
                // We emit the deposit event in the `Collection` interface
                // because the `Collection` interface is almost always the final destination
                // of tokens and deposit emissions from custom receivers could be confusing
                // and hard to reconcile to event listeners
                emit Deposited(type: token.getType().identifier, id: token.id, uuid: token.uuid, to: self.owner?.address, collectionUUID: self.uuid)
            }
        }

        /// Gets the amount of NFTs stored in the collection
        /// @return An integer indicating the size of the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        /// Allows a given function to iterate through the list
        /// of owned NFT IDs in a collection without first
        /// having to load the entire list into memory
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void {
            self.ownedNFTs.forEachKey(f)
        }

        /// Borrows a reference to an NFT stored in the collection
        /// If the NFT with the specified ID is not in the collection,
        /// the function should return `nil` and not panic.
        ///
        /// @param id: The desired nft id in the collection to return a referece for.
        /// @return An optional reference to the NFT
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            post {
                (result == nil) || (result?.id == id): 
                    "Cannot borrow NFT reference: The ID of the returned reference does not match the ID that was specified"
            }
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getType() == self.getType(): "The created collection does not have the same type as this collection"
                result.getLength() == 0: "The created collection must be empty!"
            }
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    /// @param nftType: The desired nft type to return a collection for.
    /// @return An array of NFT Types that the implementing contract defines.
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        post {
            result.getIDs().length == 0: "The created collection must be empty!"
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/tests/NFTStorefrontV1_test.cdc

```
import Test
import "test_helpers.cdc"
import "FungibleToken"
import "NonFungibleToken"
import "NFTStorefront"
import "ExampleNFT"

access(all) let buyer = Test.createAccount()
access(all) let seller = Test.createAccount()
access(all) let marketplace = Test.createAccount()
access(all) let storefrontAccount = Test.getAccount(0x0000000000000006)
access(all) let exampleNFTAccount = Test.getAccount(0x0000000000000008)
access(all) let exampleTokenAccount = Test.getAccount(0x0000000000000009)
access(all) var nftCount = 1

access(all)
fun setup() {
    let serviceAccount = Test.serviceAccount()

    var err = Test.deployContract(
        name: "NFTStorefront",
        path: "../contracts/NFTStorefront.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "ExampleNFT",
        path: "../contracts/utility/ExampleNFT.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "ExampleToken",
        path: "../contracts/utility/ExampleToken.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    // Setup example token
    var code = loadCode("setup_account.cdc", "transactions/example-token")
    var tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
    
    tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    tx = Test.Transaction(
        code: code,
        authorizers: [marketplace.address],
        signers: [marketplace],
        arguments: []
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Setup example nft
    code = loadCode("setup_account.cdc", "transactions/example-nft")
    tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Mint some example tokens
    code = loadCode("mint_tokens.cdc", "transactions/example-token")
    tx = Test.Transaction(
        code: code,
        authorizers: [exampleTokenAccount.address],
        signers: [exampleTokenAccount],
        arguments: [buyer.address, 200.0],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    mintNFTToSeller()

    let typ = Type<NonFungibleToken.Deposited>()
    let events = Test.eventsOfType(typ)
    Test.assertEqual(1, events.length)
}

access(all)
fun mintNFTToSeller() {
    // Mint some example NFTs
    let code = loadCode("mint_nft.cdc", "transactions/example-nft")
    let tx = Test.Transaction(
        code: code,
        authorizers: [exampleNFTAccount.address],
        signers: [exampleNFTAccount],
        arguments: [seller.address, "NFT".concat(nftCount.toString()), "nft descrip", "https://test", [], [], []]
    )
    nftCount = nftCount + 1
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all)
fun testSetupAccount() {
    let code = loadCode("setup_account.cdc", "transactions-v1")
    let tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [],
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all) var listedNFTID: UInt64 = 0

access(all)
fun testSellItem() {
    var code = loadCode("get_ids.cdc", "scripts/example-nft")

    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let nftID = (result.returnValue! as! [UInt64])[0]
    listedNFTID = nftID

    code = loadCode("sell_item.cdc", "transactions-v1")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0 // sale item price
        ]
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())
}

access(all)
fun testBorrowNFT() {
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "transactions-v1/scripts-v1")
    var result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let listingID = (result.returnValue! as! [UInt64])[0]!

    var code = loadCode("verify_listed_nft_exists.cdc", "transactions-v1/scripts-v1")
    result = Test.executeScript(code, [seller.address, listingID])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual(result.returnValue! as! Bool, true)
}

access(all)
fun testCleanupItem() {
    let getListingIDCode = loadCode("read_storefront_ids.cdc", "transactions-v1/scripts-v1")
    var result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let listingID = (result.returnValue! as! [UInt64])[0]!
    
    var code = loadCode("cleanup_item.cdc", "transactions-v1")
    var tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            listingID,
            seller.address
        ]
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beFailed()) // can not cleanup an unpurchased listing.
}

access(all)
fun testBuyItem() {
    let getBalanceCode = loadCode("get_balance.cdc", "scripts/example-token")

    var result = Test.executeScript(getBalanceCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! UFix64), 0.0)

    let getListingIDCode = loadCode("read_storefront_ids.cdc", "transactions-v1/scripts-v1")
    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 1)
    let listingID = (result.returnValue! as! [UInt64])[0]!

    // Test that script executions run as expected
    let readListingDetailsCode = loadCode("read_storefront_ids.cdc", "transactions-v1/scripts-v1")
    let listingDetails = Test.executeScript(readListingDetailsCode, [seller.address, listingID])
    Test.assert(listingDetails != nil, message: "Received invalid result from reading listing details")

    let code = loadCode("buy_item.cdc", "transactions-v1")
    var tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            listingID, // listing resource id
            seller.address // storefront address
        ]
    )
    let txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    result = Test.executeScript(getBalanceCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! UFix64), 10.0)

    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.expect(result, Test.beSucceeded())
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 0)
}

access(all)
fun testRemoveItem() {
    mintNFTToSeller()

    var code = loadCode("get_ids.cdc", "scripts/example-nft")
    var result = Test.executeScript(code, [seller.address, /public/exampleNFTCollection])
    let nftID = (result.returnValue! as! [UInt64])[0]
    listedNFTID = nftID

    code = loadCode("sell_item.cdc", "transactions-v1")
    var tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            nftID, // sale item id
            10.0 // sale item price
        ]
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    let getListingIDCode = loadCode("read_storefront_ids.cdc", "transactions-v1/scripts-v1")
    result = Test.executeScript(getListingIDCode, [seller.address])
    let listingID = (result.returnValue! as! [UInt64])[0]!

    code = loadCode("remove_item.cdc", "transactions-v1")
    tx = Test.Transaction(
        code: code,
        authorizers: [seller.address],
        signers: [seller],
        arguments: [
            listingID
        ]
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    // Test that the proper events were emitted
    var typ = Type<NFTStorefront.ListingCompleted>()
    var events = Test.eventsOfType(typ)
    Test.assertEqual(2, events.length)

    let completedEvent = events[1] as! NFTStorefront.ListingCompleted
    Test.assertEqual(listingID, completedEvent.listingResourceID)
    Test.assertEqual(false, completedEvent.purchased)
    Test.assertEqual(Type<@ExampleNFT.NFT>(), completedEvent.nftType)
    Test.assertEqual(nftID, completedEvent.nftID)

    result = Test.executeScript(getListingIDCode, [seller.address])
    Test.assertEqual((result.returnValue! as! [UInt64]).length, 0)
}

access(all)
fun testSellMaliciousListing() {

    var err = Test.deployContract(
        name: "MaliciousStorefrontV1",
        path: "../contracts/utility/test/MaliciousStorefrontV1.cdc",
        arguments: [],
    )
    Test.expect(err, Test.beNil())

    var code = loadCode("../tests/transactions/create_malicious_listing_v1.cdc", "transactions")
    var tx = Test.Transaction(
        code: code,
        authorizers: [exampleNFTAccount.address],
        signers: [exampleNFTAccount],
        arguments: [],
    )
    var txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beSucceeded())

    var typ = Type<NFTStorefront.ListingAvailable>()
    var events = Test.eventsOfType(typ)

    let listingEvent = events[events.length-1] as! NFTStorefront.ListingAvailable
    let listingID = listingEvent.listingResourceID

    code = loadCode("buy_item.cdc", "transactions-v1")
    tx = Test.Transaction(
        code: code,
        authorizers: [buyer.address],
        signers: [buyer],
        arguments: [
            listingID, // listing resource id
            exampleNFTAccount.address // storefront address
        ],
    )
    txResult = Test.executeTransaction(tx)
    Test.expect(txResult, Test.beFailed())
    Test.assertError(
        txResult,
        errorMessage: "Cannot borrow a non-NFTStorefront.Listing!"
    )
}




```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/FTReceiverBalanceFactory.cdc

```
import "CapabilityFactory"
import "FungibleToken"

pub contract FTReceiverBalanceFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Receiver, FungibleToken.Balance}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-nft/mint_nft.cdc

```
/// This script uses the NFTMinter resource to mint a new NFT
/// It must be run with the account that has the minter resource
/// stored in /storage/NFTMinter

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"
import "FungibleToken"

transaction(
    recipient: Address,
    name: String,
    description: String,
    thumbnail: String,
    cuts: [UFix64],
    royaltyDescriptions: [String],
    royaltyBeneficiaries: [Address]
) {

    /// local variable for storing the minter reference
    let minter: &ExampleNFT.NFTMinter

    /// Reference to the receiver's collection
    let recipientCollectionRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")
        
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Account does not store an object at the specified path")

        // Borrow the recipient's public NFT collection reference
        self.recipientCollectionRef = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(
                collectionData.publicPath
            ) ?? panic("Could not get receiver reference to the NFT Collection")
    }

    pre {
        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: "Array length should be equal for royalty related details"
    }

    execute {

        // // Create the royalty details
        // var count = 0
        // var royalties: [MetadataViews.Royalty] = []
        // while royaltyBeneficiaries.length > count {
        //     let beneficiary = royaltyBeneficiaries[count]
        //     let beneficiaryCapability = getAccount(beneficiary).capabilities.get<&{FungibleToken.Receiver}>(
        //             MetadataViews.getRoyaltyReceiverPublicPath()
        //         ) ?? panic("Beneficiary does not have Receiver configured at RoyaltyReceiverPublicPath")

        //     royalties.append(
        //         MetadataViews.Royalty(
        //             receiver: beneficiaryCapability,
        //             cut: cuts[count],
        //             description: royaltyDescriptions[count]
        //         )
        //     )
        //     count = count + 1
        // }


        // Mint the NFT and deposit it to the recipient's collection
        let mintedNFT <- self.minter.mintNFT(
            name: name,
            description: description,
            thumbnail: thumbnail,
            royalties: [] //royalties
        )
        self.recipientCollectionRef.deposit(token: <-mintedNFT)
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/example-token/get_balance.cdc

```
// This script reads the balance field
// of an account's ExampleToken Balance

import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

access(all) fun main(address: Address): UFix64 {
    let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get vault data view for the contract")

    return getAccount(address).capabilities.borrow<&{FungibleToken.Balance}>(
            vaultData.metadataPath
        )?.balance
        ?? panic("Could not borrow Balance reference to the Vault")
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/remove_item.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Transaction to facilitate the removal of listing by the listing owner. Listing owner should provide the
/// `listingResourceID` that needs to be removed.
///
transaction(listingResourceID: UInt64) {

    let storefront: auth(NFTStorefrontV2.RemoveListing) &{NFTStorefrontV2.StorefrontManager}

    prepare(acct: auth(BorrowValue) &Account) {
        self.storefront = acct.storage.borrow<auth(NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>(
                from: NFTStorefrontV2.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront.Storefront")
    }

    execute {
        self.storefront.removeListing(listingResourceID: listingResourceID)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/FungibleTokenMetadataViews.cdc

```
import "FungibleToken"
import "MetadataViews"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-1087.
/// 
/// Ref: https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md
/// 
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata.
///
access(all) contract FungibleTokenMetadataViews {

    /// FTView wraps FTDisplay and FTVaultData, and is used to give a complete 
    /// picture of a Fungible Token. Most Fungible Token contracts should 
    /// implement this view.
    ///
    access(all) struct FTView {
        access(all) let ftDisplay: FTDisplay?     
        access(all) let ftVaultData: FTVaultData?
        view init(
            ftDisplay: FTDisplay?,
            ftVaultData: FTVaultData?
        ) {
            self.ftDisplay = ftDisplay
            self.ftVaultData = ftVaultData
        }
    }

    /// Helper to get a FT view.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A FTView struct
    ///
    access(all) fun getFTView(viewResolver: &{ViewResolver.Resolver}): FTView {
        let maybeFTView = viewResolver.resolveView(Type<FTView>())
        if let ftView = maybeFTView {
            return ftView as! FTView
        }
        return FTView(
            ftDisplay: self.getFTDisplay(viewResolver),
            ftVaultData: self.getFTVaultData(viewResolver)
        )
    }

    /// View to expose the information needed to showcase this FT. 
    /// This can be used by applications to give an overview and 
    /// graphics of the FT.
    ///
    access(all) struct FTDisplay {
        /// The display name for this token.
        ///
        /// Example: "Flow"
        ///
        access(all) let name: String

        /// The abbreviated symbol for this token.
        ///
        /// Example: "FLOW"
        access(all) let symbol: String

        /// A description the provides an overview of this token.
        ///
        /// Example: "The FLOW token is the native currency of the Flow network."
        access(all) let description: String

        /// External link to a URL to view more information about the fungible token.
        access(all) let externalURL: MetadataViews.ExternalURL

        /// One or more versions of the fungible token logo.
        access(all) let logos: MetadataViews.Medias

        /// Social links to reach the fungible token's social homepages.
        /// Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            symbol: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            logos: MetadataViews.Medias,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.symbol = symbol
            self.description = description
            self.externalURL = externalURL
            self.logos = logos
            self.socials = socials
        }
    }

    /// Helper to get FTDisplay in a way that will return a typed optional.
    /// 
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional FTDisplay struct
    ///
    access(all) fun getFTDisplay(_ viewResolver: &{ViewResolver.Resolver}): FTDisplay? {
        if let maybeDisplayView = viewResolver.resolveView(Type<FTDisplay>()) {
            if let displayView = maybeDisplayView as? FTDisplay {
                return displayView
            }
        }
        return nil
    }

    /// View to expose the information needed store and interact with a FT vault.
    /// This can be used by applications to setup a FT vault with proper 
    /// storage and public capabilities.
    ///
    access(all) struct FTVaultData {
        /// Path in storage where this FT vault is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose the public receiver capability.
        access(all) let receiverPath: PublicPath

        /// Public path which must be linked to expose the balance and resolver public capabilities.
        access(all) let metadataPath: PublicPath

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring 
        /// the `FungibleToken.Receiver` interface.
        access(all) let receiverLinkedType: Type

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring 
        /// the `ViewResolver.Resolver` interfaces.
        access(all) let metadataLinkedType: Type

        /// Function that allows creation of an empty FT vault that is intended
        /// to store the funds.
        access(all) let createEmptyVault: fun(): @{FungibleToken.Vault}

        view init(
            storagePath: StoragePath,
            receiverPath: PublicPath,
            metadataPath: PublicPath,
            receiverLinkedType: Type,
            metadataLinkedType: Type,
            createEmptyVaultFunction: fun(): @{FungibleToken.Vault}
        ) {
            pre {
                receiverLinkedType.isSubtype(of: Type<&{FungibleToken.Receiver}>()): "Receiver public type must include FungibleToken.Receiver."
                metadataLinkedType.isSubtype(of: Type<&{FungibleToken.Vault}>()): "Metadata linked type must be a fungible token vault"
            }
            self.storagePath = storagePath
            self.receiverPath = receiverPath
            self.metadataPath = metadataPath
            self.receiverLinkedType = receiverLinkedType
            self.metadataLinkedType = metadataLinkedType
            self.createEmptyVault = createEmptyVaultFunction
        }
    }

    /// Helper to get FTVaultData in a way that will return a typed Optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional FTVaultData struct
    ///
    access(all) fun getFTVaultData(_ viewResolver: &{ViewResolver.Resolver}): FTVaultData? {
        if let view = viewResolver.resolveView(Type<FTVaultData>()) {
            if let v = view as? FTVaultData {
                return v
            }
        }
        return nil
    }

    /// View to expose the total supply of the Vault's token
    access(all) struct TotalSupply {
        access(all) let supply: UFix64

        view init(totalSupply: UFix64) {
            self.supply = totalSupply
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/FlowToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"
import "ViewResolver"

pub contract FlowToken: FungibleToken, ViewResolver {

    // Total supply of Flow tokens in existence
    pub var totalSupply: UFix64

    // Event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // Event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // Event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // Event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // Event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // Event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Event that is emitted when a new burner resource is created
    pub event BurnerCreated()

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {

        // holds the balance of a users tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FlowToken.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            if self.balance > 0.0 {
                FlowToken.totalSupply = FlowToken.totalSupply - self.balance
            }
        }

        /// Get all the Metadata Views implemented by FlowToken
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type]{
            return FlowToken.getViews()
        }

        /// Get a Metadata View from FlowToken
        ///
        /// @param view: The Type of the desired view.
        /// @return A structure representing the requested view.
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            return FlowToken.resolveView(view)
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @FungibleToken.Vault {
        return <-create Vault(balance: 0.0)
    }

    pub fun getViews(): [Type] {
        return [Type<FungibleTokenMetadataViews.FTView>(),
                Type<FungibleTokenMetadataViews.FTDisplay>(),
                Type<FungibleTokenMetadataViews.FTVaultData>()]
    }

    /// Get a Metadata View from FlowToken
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "FLOW Network Token",
                    symbol: "FLOW",
                    description: "FLOW is the protocol token that is required for transaction fees, storage fees, staking, and many applications built on the Flow Blockchain",
                    externalURL: MetadataViews.ExternalURL("https://flow.com"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/flowTokenVault,
                    receiverPath: /public/flowTokenReceiver,
                    metadataPath: /public/flowTokenBalance,
                    providerPath: /private/flowTokenVault,
                    receiverLinkedType: Type<&FlowToken.Vault{FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver}>(),
                    metadataLinkedType: Type<&FlowToken.Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                    providerLinkedType: Type<&FlowToken.Vault{FungibleToken.Provider}>(),
                    createEmptyVaultFunction: (fun (): @FungibleToken.Vault {
                        return <-FlowToken.createEmptyVault()
                    })
                )
        }
        return nil
    }

    pub resource Administrator {
        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }

        // createNewBurner
        //
        // Function that creates and returns a new burner resource
        //
        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <-create Burner()
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // the amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @FlowToken.Vault {
            pre {
                amount > UFix64(0): "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            FlowToken.totalSupply = FlowToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    // Burner
    //
    // Resource object that token admin accounts can hold to burn tokens.
    //
    pub resource Burner {

        // burnTokens
        //
        // Function that destroys a Vault instance, effectively burning the tokens.
        //
        // Note: the burned tokens are automatically subtracted from the
        // total supply in the Vault destructor.
        //
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @FlowToken.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    init(adminAccount: AuthAccount) {
        self.totalSupply = 0.0

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)
        adminAccount.save(<-vault, to: /storage/flowTokenVault)

        // Create a public capability to the stored Vault that only exposes
        // the `deposit` method through the `Receiver` interface
        //
        adminAccount.link<&FlowToken.Vault{FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver}>(
            /public/flowTokenReceiver,
            target: /storage/flowTokenVault
        )

        // Create a public capability to the stored Vault that only exposes
        // the `balance` field through the `Balance` interface
        //
        adminAccount.link<&FlowToken.Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
            /public/flowTokenBalance,
            target: /storage/flowTokenVault
        )

        let admin <- create Administrator()
        adminAccount.save(<-admin, to: /storage/flowTokenAdmin)

        // Emit an event that shows that the contract was initialized
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/ExampleNFT.cdc

```
/*
*
*  This is an example implementation of a Flow Non-Fungible Token
*  using the V2 standard.
*  It is not part of the official standard but it assumed to be
*  similar to how many NFTs would implement the core functionality.
*
*  This contract does not implement any sophisticated classification
*  system for its NFTs. It defines a simple NFT with minimal metadata.
*
*/

import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

access(all) contract ExampleNFT: NonFungibleToken {

    access(all) event Minted(newID: UInt64)

    /// Standard Paths
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath

    /// Path where the minter should be stored
    /// The standard paths for the collection are stored in the collection resource type
    access(all) let MinterStoragePath: StoragePath

    /// We choose the name NFT here, but this type can have any name now
    /// because the interface does not require it to have a specific name any more
    access(all) resource NFT: NonFungibleToken.NFT {

        access(all) let id: UInt64

        /// From the Display metadata view
        access(all) let name: String
        access(all) let description: String
        access(all) let thumbnail: String

        /// For the Royalties metadata view
        access(self) let royalties: [MetadataViews.Royalty]

        /// Generic dictionary of traits the NFT has
        access(self) let metadata: {String: AnyStruct}

        init(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
        ) {
            self.id = self.uuid
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.royalties = royalties
            self.metadata = metadata
        }

        /// createEmptyCollection creates an empty Collection
        /// and returns it to the caller so that they can own NFTs
        /// @{NonFungibleToken.Collection}
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Example NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://example-nft.onflow.org/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    // foo is a trait with its own rarity
                    let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
                    let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
                    traitsView.addTrait(fooTrait)

                    return traitsView
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Implementing this view gives the project control over how the bridged NFT is represented as an
                    // ERC721 when bridged to EVM on Flow via the public infrastructure bridge.

                    // Get the contract-level name and symbol values
                    let contractLevel = ExampleNFT.resolveContractView(
                            resourceType: nil,
                            viewType: Type<MetadataViews.EVMBridgedMetadata>()
                        ) as! MetadataViews.EVMBridgedMetadata?
                        ?? panic("Could not resolve contract-level EVMBridgedMetadata")
                    // Compose the token-level URI based on a base URI and the token ID, pointing to a JSON file. This
                    // would be a file you've uploaded and are hosting somewhere - in this case HTTP, but this could be
                    // IPFS, S3, a data URL containing the JSON directly, etc.
                    let baseURI = "https://example-nft.onflow.org/token-metadata/"
                    let uriValue = self.id.toString().concat(".json")

                    return MetadataViews.EVMBridgedMetadata(
                        name: contractLevel.name,
                        symbol: contractLevel.symbol,
                        uri: MetadataViews.URI(
                            baseURI: baseURI, // defining baseURI results in a concatenation of baseURI and value
                            value: self.id.toString().concat(".json")
                        )
                    )

            }
            return nil
        }
    }

    // Deprecated: Only here for backward compatibility.
    access(all) resource interface ExampleNFTCollectionPublic {}

    access(all) resource Collection: NonFungibleToken.Collection, ExampleNFTCollectionPublic {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an `UInt64` ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init () {
            self.ownedNFTs <- {}
        }

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@ExampleNFT.NFT>()] = true
            return supportedTypes
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            return type == Type<@ExampleNFT.NFT>()
        }

        /// withdraw removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @ExampleNFT.NFT
            let id = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken

            // This code is for testing purposes only
            // Do not add to your contract unless you have a specific
            // reason to want to emit the NFTUpdated event somewhere
            // in your contract
            let authTokenRef = (&self.ownedNFTs[id] as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT}?)!
            //authTokenRef.updateTransferDate(date: getCurrentBlock().timestamp)
            ExampleNFT.emitNFTUpdated(authTokenRef)
        }

        /// getIDs returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return (&self.ownedNFTs[id] as &{NonFungibleToken.NFT}?)
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: self.CollectionStoragePath,
                    publicPath: self.CollectionPublicPath,
                    publicCollection: Type<&ExampleNFT.Collection>(),
                    publicLinkedType: Type<&ExampleNFT.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://example-nft.onflow.org"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                // Implementing this view gives the project control over how the bridged NFT is represented as an ERC721
                // when bridged to EVM on Flow via the public infrastructure bridge.

                // Compose the contract-level URI. In this case, the contract metadata is located on some HTTP host,
                // but it could be IPFS, S3, a data URL containing the JSON directly, etc.
                return MetadataViews.EVMBridgedMetadata(
                    name: "ExampleNFT",
                    symbol: "XMPL",
                    uri: MetadataViews.URI(
                        baseURI: nil, // setting baseURI as nil sets the given value as the uri field value
                        value: "https://example-nft.onflow.org/contract-metadata.json"
                    )
                )
        }
        return nil
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    access(all) resource NFTMinter {

        /// mintNFT mints a new NFT with a new ID
        /// and returns it to the calling context
        access(all) fun mintNFT(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty]
        ): @ExampleNFT.NFT {

            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp

            // this piece of metadata will be used to show embedding rarity into a trait
            metadata["foo"] = "bar"

            // create a new NFT
            var newNFT <- create NFT(
                name: name,
                description: description,
                thumbnail: thumbnail,
                royalties: royalties,
                metadata: metadata,
            )

            emit Minted(newID: newNFT.id)

            return <-newNFT
        }
    }

    init() {

        // Set the named paths
        self.CollectionStoragePath = /storage/exampleNFTCollection
        self.CollectionPublicPath = /public/exampleNFTCollection
        self.MinterStoragePath = /storage/exampleNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.storage.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        let collectionCap = self.account.capabilities.storage.issue<&ExampleNFT.Collection>(self.CollectionStoragePath)
        self.account.capabilities.publish(collectionCap, at: self.CollectionPublicPath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.storage.save(<-minter, to: self.MinterStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/docs/documentation.md

### Overview

The `NFTStorefrontV2` contract makes it simple for Sellers to list NFTs in dApp specific marketplaces. DApp developers leverage the APIs provided by the contract to manage listings being offered for sale and to transact NFT trades. 

![dapps_1](https://user-images.githubusercontent.com/14581509/191749748-714f9d8f-cb41-4be4-a3d2-ec84cb8b5ffb.png)

Listings made through a specific dApp can be simultaneously listed on third-party marketplaces beyond that dApp. Well-known third-party marketplaces listen for compatible NFT listing events enabling the automation of listings into their marketplace UIs.

![dapps_2](https://user-images.githubusercontent.com/14581509/191753605-e1c48a57-0c3c-4509-808b-8fee4e7d32e8.png)

Marketplaces facilitate a NFT trade through direct interaction with seller storefront resources. Flow's account based model ensures that NFTs listed for sale remain in the Seller account until traded, regardless of how many listings are posted across any number of marketplaces, for the same NFT.

![marketplace_1](https://user-images.githubusercontent.com/14581509/191755699-fe0570cb-80a3-408c-8eef-4051e3209481.png)

**Contract basics**

`NFTStorefrontV2` is a general purpose sales support contract for NFTs. Each account that wants to list NFTs for sale creates a `Storefront` resource to store in their account and lists individual sales within that Storefront as `Listing`s. There is usually one `Storefront` per account stored at `/storage/NFTStorefrontV2` and the contract supports all tokens using the [`NonFungibleToken`](https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc) standard.

Each listing defines a price, optional 0-n sale cuts to be deducted, with each [`saleCut`](https://github.com/onflow/nft-storefront/blob/160e97aa802405ad26a3164bcaff0fde7ee52ad2/contracts/NFTStorefrontV2.cdc#L104) amount sent to the linked address. Listings can specify an optional list of marketplace [receiver capabilities](https://developers.flow.com/cadence/language/capability-based-access-control) used to pay commission to that marketplace at time of sale. Royalties are paid as a [`saleCut`](https://github.com/onflow/nft-storefront/blob/160e97aa802405ad26a3164bcaff0fde7ee52ad2/contracts/NFTStorefrontV2.cdc#L104) for NFTs supporting the [Royalty Metadata View](https://github.com/onflow/flow-nft/blob/21c254438910c8a4b5843beda3df20e4e2559625/contracts/MetadataViews.cdc#L335) standard. [`SaleCut`](https://github.com/onflow/nft-storefront/blob/160e97aa802405ad26a3164bcaff0fde7ee52ad2/contracts/NFTStorefrontV2.cdc#L104) generalizes support for alternative models of revenue sharing at time of sale. 

The same NFT can be referenced in one or more listings across multiple marketplaces and the contract provides APIs to manage listings across those.

Interested parties can globally track `Listing` events on-chain and filter by NFT type, ID and other characteristics to determine which are of interest, simplifying the process of publishing a listed NFT for sale within your dApp marketplace UI.

## Selling NFTs

The `NFTStorefrontV2` offers a standardized process and the APIs for creating and managing the listings for a seller's NFTs.

## Creating a listing using the NFTStorefrontV2 contract

Users are required to create the `Storefront` resource once only in their account after which the same resource can be re-used, see [example](https://github.com/onflow/nft-storefront/blob/main/transactions/setup_account.cdc).

Listed below are some different ways which you might list your NFTs for sale.

### **Scenario 1:** A basic NFT listing that unlocks peer-to-peer trading across Flow

Sellers can create a basic listing using the [sell_item](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc) transaction providing the `marketplacesAddress` with an empty array. The seller can optionally configure [commission](#commission) to the facilitator of sale. All listings made using the `NFTStorefrontV2` standard are broadcast on-chain through the `ListingAvailable` event. 

### **Scenario 2:** Simultaneously list your NFT in multiple marketplaces

Sellers typically create a listing by specifying one or more `marketplacesAddress` and the corresponding `commissionReceivers` required for them. It is assumed that the seller has first confirmed the correct address values for specific marketplaces and their expected commissions, which differs between vendors. On receiving `ListingAvailable` events, marketplaces select listings matching their address and minimum expected commission. This enables multiple marketplaces to each publish the same NFT for sale in their UI with the full confidence that they will earn their required commission from facilitating the sale.

Example - Bob wants to list on marketplace 0xA, 0xB & 0xC and is willing to offer 10% commission on the sale price of the listing to interested marketplaces. In this diagram we see that all the marketplaces accept his listing given the commission amount!

   ![scenario_3](https://user-images.githubusercontent.com/14581509/190966834-8eda4ec4-e9bf-49ef-9dec-3c47a236d281.png)

An alternate approach is to create separate listing for each marketplace using the [sell_item_with_marketplace_cut](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item_with_marketplace_cut.cdc) transaction. This is targeted towards marketplaces which select listings purely based on [`saleCut`](https://github.com/onflow/nft-storefront/blob/160e97aa802405ad26a3164bcaff0fde7ee52ad2/contracts/NFTStorefrontV2.cdc#L104) amounts.

### **Scenario 3:** Supporting multiple token types (eg: FLOW, FUSD, etc) for your NFT listings

The `NFTStorefrontV2` contract has no default support for multiple token types in an individual listing. The simplest way to solve this is to create multiple listings for the same NFT, one for each different token.

**Example -** Alice wants to sell a kitty and is open to receiving FLOW and FUSD

![scenario_1](https://user-images.githubusercontent.com/14581509/190966672-e1793fa3-112c-4273-b2a3-e81b8c94fd70.png)

Sellers can create a basic `Listing` using the [sell_item](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc) transaction which requires certain details including the receiving token type [Capability](https://developers.flow.com/cadence/language/capability-based-access-control). This capability will transact the specified tokens when the NFT is sold. More detailed specifics are available [here](#fun-createListing()). 

To accept a different token type for the same NFT sellers must specify an alternate __Receiver token type__, eg: `salePaymentVaultType`, in another listing. The only difference between the two listings is that `salePaymentVaultType` specifies different token types while the NFT being sold remains the same for both. Another more advanced option for handling multiple token types is using the [`FungibleTokenSwitchboard`](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc) standard.

### Considerations

1. ***Ghost listings*** - *Ghost listings are listings which don’t have an underlying NFT in the seller’s account. However, the listing is still available for buyers to attempt to purchase and which fails*. 

    Ghost listings occur for two reasons: 

    1. When a seller's NFT is sold in one marketplace but listings for that NFT in other marketplaces are not removed.
    2. When the seller transfers out the listed NFT from the account that made the listings.

    If ghost listings are not removed, they will eventually result in a prospective purchaser’s transaction to fail which is annoying in isolated cases. However, ghost listings negatively impact everyone's user experience when they are widespread. To address this and ensure that listings are always accurate the [`cleanupPurchasedListings`](#fun-cleanupPurchasedListings) function has been provided. 

    The recommended standard practice is for marketplaces to execute the `cleanupPurchasedListing` function after the sale has completed within the same transaction. This requires minimal gas, ensures the best experience for all participants in the marketplace ecosystem and also significantly minimizes the likelihood of transaction failure.

    Ghost listings which are not cleaned up may be specifically problematic for sellers in the unique case when a **previously sold or gifted** NFT returns to the seller’s account some time later. In this case, previously ghost listings for which purchase attempts would have failed, once again become enabled to facilitate purchases. Since some time may have passed since the listing was created, ghost listings remaining against NFTs returned to an account may implicitly make the listing available for purchase below market rates. 
    
    To mitigate this, the storefront contract provides global access to all seller's inventory of ghost listings using the [`read_all_unique_ghost_listings`](../scripts/read_all_unique_ghost_listings.cdc) script. Sellers who have active listings for an NFT are strongly advised to purge ghost listings using the [`cleanup_ghost_listing`](../transactions/cleanup_ghost_listing.cdc) transaction when the listed NFT is transferred to another account, not sold through a marketplace.


2. ***Expired listings*** `NFTStorefrontV2` introduces a safety measure to flag an NFT listing as expired after a certain period. This can be set during listing creation to prevent the purchase through the listing after expiry has been reached. Once expiry has been reached the listing can no longer facilitate the purchase of the NFT. 

    We recommend that using the [`cleanupExpiredListings`](#fun-cleanupExpiredListings) function to manage expired listings. 
    
    ***Note:*** We recommend that marketplaces and dApps filter out expired listings as they cannot be purchased.

## Purchasing NFTs

Purchasing NFTs through the `NFTStorefrontV2` is simple. The buyer has to provide the payment vault and the `commissionRecipient`, if applicable, during the purchase. The [`purchase`](#fun-purchase) API offered by the `Listing` facilitates the trade with the buyer in the seller's `Storefront`.

During the listing purchase all `saleCuts` are paid automatically. This also includes distributing [royalties](#enabling-creator-royalties-for-nfts) for that NFT, if applicable. If the vault provided by the buyer lacks sufficient funds then the transaction will fail.

### Considerations

1. ***Auto cleanup*** the `NFTStorefrontV2` standard automates the cleanup of duplicate listings at time of sale. However, if an NFT has a large number of duplicate listings, it may slow the purchase and, in the worst case, may trigger an out-of-gas error.

    ***Note:*** We recommend maintaining <= 50(TBD) duplicate listings of any given NFT.

2. ***Unsupported receiver capability*** A common pitfall during the purchase of an NFT is if `saleCut` receivers don’t have a supported receiver capability because that entitled sale cut would transfer to first valid sale cut receiver. To mitigate this we recommend using the generic receiver from the [`FungibleTokenSwitchboard`](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc) contract, adding capabilities to support whichever token types the beneficiary wishes to receive. 

## Enabling creator royalties for NFTs

The `NFTStorefrontV2` contract optionally supports paying royalties to the minter account for secondary resales of a NFT. When seller NFTs support the [Royalty Metadata View](https://github.com/onflow/flow-nft/blob/21c254438910c8a4b5843beda3df20e4e2559625/contracts/MetadataViews.cdc#L335), `NFTStorefrontV2` stores the royalty amount as a `saleCut` based on the specified royalty percentage of the sale price, calculated at the time of listing. The `saleCut` amount is only paid to the minter at the time of sale. 

```cadence
// Check whether the NFT implements the MetadataResolver or not.
if nft.getViews().contains(Type<MetadataViews.Royalties>()) {
		// Resolve the royalty view
    let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
	  // Fetch the royalties.
		let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
		// Append the royalties as the salecut
    for royalty in royalties {
        self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))
        totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice
    }
}
```

Complete transaction available [here](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc).

`saleCut` only supports a single token receiver type and therefore beneficiaries of a `saleCut` can only receive the token type used for the purchase. To support different token types for saleCuts we recommend using the [FungibleTokenSwitchboard](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc) contract.

***Note:*** We recommend that marketplaces honor creator royalties across the Flow ecosystem

## Enabling marketplace commissions for NFT sales

`NFTStorefrontV2` enables optional commissions on trades for marketplaces which require it as a condition to list a NFT for sale. Commission & commission receivers are set by the seller during initial listing creation. At time of purchase the commission amount is paid once only to the commission receiver matching the marketplace receiver address which facilitated the sale. For NFT listings in marketplaces which don't require commission, commission receivers can be set as `nil`. The default behavior when `commissionRecipient`s are set to `nil` with a commission amount >0 results in a discount for the buyer who is paid the commission.

![scenario_2](https://user-images.githubusercontent.com/14581509/190966499-c176203f-b6a6-4422-860f-1bf6f2bcdbb6.png).

## APIs & Events offered by NFTStorefrontV2

## Resource Interface `ListingPublic`

```cadence
resource interface ListingPublic {
    access(all) fun borrowNFT(): &{NonFungibleToken.NFT}?
    access(all) fun purchase(
        payment: @{FungibleToken.Vault}, 
        commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
      ): @{NonFungibleToken.NFT}
    access(all) view fun getDetails(): ListingDetails
    access(all) fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?
    access(all) fun hasListingBecomeGhosted(): Bool
}
```
An interface providing a useful public interface to a Listing.

### Functions

**fun `borrowNFT()`**

```cadence
fun borrowNFT(): &{NonFungibleToken.NFT}?
```
This will assert in the same way as the NFT standard borrowNFT()
if the NFT is absent, for example if it has been sold via another listing.

---

**fun `purchase()`**

```cadence
fun purchase(payment FungibleToken.Vault, commissionRecipient Capability<&{FungibleToken.Receiver}>?): @{NonFungibleToken.NFT}
```
Facilitates the purchase of the listing by providing the payment vault
and the commission recipient capability if there is a non-zero commission for the given listing.
Respective saleCuts are transferred to beneficiaries and funtion return underlying or listed NFT.

---

**fun `getDetails()`**

```cadence
fun getDetails(): ListingDetails
```
Fetches the details of the listings

---

**fun `getAllowedCommissionReceivers()`**

```cadence
fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?
```
Fetches the allowed marketplaces capabilities or commission receivers for the underlying listing.
If it returns `nil` then commission paid to the receiver by default.

---

**fun `hasListingBecomeGhosted()`**

```cadence
fun hasListingBecomeGhosted(): Bool
```
Tells whether a listed NFT that was put up for sale is still available in the provided listing.
If it returns `true` then it means the listing is "ghosted" because there is no available nft to fulfill the listing.

---

## Resource `Storefront`

```cadence
resource Storefront {
    access(Creatable) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
         ): UInt64
    access(Removable) fun removeListing(listingResourceID: UInt64)
    access(all) view fun getListingIDs(): [UInt64]
    access(all) fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
    access(all) fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
    access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}?
}
```
A resource that allows it's owner to manage a list of Listings, and anyone to interact with them
in order to query their details and purchase the NFTs that they represent.

Implemented Interfaces:
  - `StorefrontManager`
  - `StorefrontPublic`


### Initializer

```cadence
fun init()
```

### Functions

**fun `createListing()`**

```cadence
fun createListing(nftProviderCapability Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>, nftType Type, nftID UInt64, salePaymentVaultType Type, saleCuts [SaleCut], marketplacesCapability [Capability<&{FungibleToken.Receiver}>]?, customID String?, commissionAmount UFix64, expiry UInt64): UInt64
```
insert
Create and publish a Listing for a NFT.

---

**fun `removeListing()`**

```cadence
fun removeListing(listingResourceID UInt64)
```
removeListing
Remove a Listing that has not yet been purchased from the collection and destroy it.

---

**fun `getListingIDs()`**

```cadence
fun getListingIDs(): [UInt64]
```
getListingIDs
Returns an array of the Listing resource IDs that are in the collection

---

**fun `getDuplicateListingIDs()`**

```cadence
fun getDuplicateListingIDs(nftType Type, nftID UInt64, listingID UInt64): [UInt64]
```
getDuplicateListingIDs
Returns an array of listing IDs that are duplicates of the given `nftType` and `nftID`.

---

**fun `cleanupExpiredListings()`**

```cadence
fun cleanupExpiredListings(fromIndex UInt64, toIndex UInt64)
```
cleanupExpiredListings
Cleanup the expired listing by iterating over the provided range of indexes.

---

**fun `borrowListing()`**

```cadence
fun borrowListing(listingResourceID UInt64): &Listing{ListingPublic}?
```
borrowListing
Returns a read-only view of the listing for the given listingID if it is contained by this collection.

---

## Resource Interface `StorefrontPublic`

```cadence
resource interface StorefrontPublic {
    access(all) view fun getListingIDs(): [UInt64]
    access(all) fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
    access(all) view fun borrowListing(listingResourceID: UInt64): &{ListingPublic}?
    access(all) fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
    access(contract) fun cleanup(listingResourceID: UInt64)
    access(all) fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64]
    access(all) fun cleanupPurchasedListings(listingResourceID: UInt64)
    access(all) fun cleanupGhostListings(listingResourceID: UInt64)
}
```

StorefrontPublic
An interface to allow listing and borrowing Listings, and purchasing items via Listings
in a Storefront.

### Functions

**fun `getListingIDs()`**

```cadence
fun getListingIDs(): [UInt64]
```
getListingIDs Returns an array of the Listing resource IDs that are in the collection

---

**fun `getDuplicateListingIDs()`**

```cadence
fun getDuplicateListingIDs(nftType Type, nftID UInt64, listingID UInt64): [UInt64]
```
getDuplicateListingIDs Returns an array of listing IDs that are duplicates of the given nftType and nftID.

---

**fun `borrowListing()`**

```cadence
fun borrowListing(listingResourceID UInt64): &Listing{ListingPublic}?
```
borrowListing Returns a read-only view of the listing for the given listingID if it is contained by this collection.

---

**fun `cleanupExpiredListings()`**

```cadence
fun cleanupExpiredListings(fromIndex UInt64, toIndex UInt64)
```
cleanupExpiredListings Cleanup the expired listing by iterating over the provided range of indexes.

---

**fun `cleanupPurchasedListings()`**

```cadence
fun cleanupPurchasedListings(listingResourceID: UInt64)
```
cleanupPurchasedListings
Allows anyone to remove already purchased listings.

---

**fun `getExistingListingIDs()`**

```cadence
fun getExistingListingIDs(nftType Type, nftID UInt64): [UInt64]
```
getExistingListingIDs
Returns an array of listing IDs of the given `nftType` and `nftID`.

---

**fun `cleanupGhostListings()`**

```cadence
pub fun cleanupGhostListings(listingResourceID: UInt64)
```
cleanupGhostListings
Allow callers to clean up ghost listings for this seller. Listings which remain orphaned on marketplaces because the stored provider capability cannot acquire the NFT any more.

---

## Events

**event `StorefrontInitialized`**

```cadence
event StorefrontInitialized(storefrontResourceID: UInt64)
```
A Storefront resource has been created. Consumers can now expect events from this Storefront. Note that we do not specify an address: we cannot and should not. Created resources do not have an owner address, and may be moved
after creation in ways we cannot check. `ListingAvailable` events can be used to determine the address
of the owner of the Storefront at the time of the listing but only at that exact moment in that specific transaction. If the seller moves the Storefront while the listing is valid it will not be possible to transact trades for the assocaited listings.

---

**event `ResourceDestroyed`**

```cadence
event ResourceDestroyed(storefrontResourceID: UInt64 = self.uuid)
```
A Storefront has been destroyed. Event consumers can now stop processing events from this Storefront.
Note - we do not specify an address.

---

**event `ListingAvailable`**

```cadence
event ListingAvailable(storefrontAddress: Address, listingResourceID: UInt64, nftType: Type, nftUUID: UInt64, nftID: UInt64, salePaymentVaultType: Type, salePrice: UFix64, customID: String?, commissionAmount: UFix64, commissionReceivers: [Address]?, expiry: UInt64)
```

Above event gets emitted when a listing has been created and added to a Storefront resource. The Address values here are valid when the event is emitted, but the state of the accounts they refer to may change outside of the
`NFTStorefrontV2` workflow, so be careful to check when using them.

---

**event `ListingCompleted`**

```cadence
event ListingCompleted(listingResourceID: UInt64, storefrontResourceID: UInt64, purchased: Bool, nftType: Type, nftUUID: UInt64, nftID: UInt64, salePaymentVaultType: Type, salePrice: UFix64, customID: String?, commissionAmount: UFix64, commissionReceiver: Address?, expiry: UInt64)
```
The listing has been resolved. It has either been purchased, removed or destroyed.

---

**event `UnpaidReceiver`**

```cadence
event UnpaidReceiver(receiver: Address, entitledSaleCut: UFix64)
```
A entitled receiver has not been paid during the sale of the NFT.

---


**Holistic process flow diagram of NFTStorefrontV2 -** 

![NFT Storefront Process flow](https://user-images.githubusercontent.com/14581509/191960793-ff153e5d-2934-410c-b724-5c5dffd2c20f.png)


## Glossary

<a name="saleCut"></a>SaleCut - A struct consists a recipient and amount of token, eg: cut that must be sent to recipient when a NFT get sold.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/scripts-v1/read_listing_details.cdc

```
import "NFTStorefront"

/// This script returns the details for a listing within a storefront
///
access(all) fun main(account: Address, listingResourceID: UInt64): NFTStorefront.ListingDetails {
    let storefrontRef = getAccount(account).capabilities.borrow<&{NFTStorefront.StorefrontPublic}>(
            NFTStorefront.StorefrontPublicPath
        ) ?? panic("Could not borrow public storefront from address")

    let listing = storefrontRef.borrowListing(listingResourceID: listingResourceID)
        ?? panic("No listing with that ID")
    
    return listing.getDetails()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/FTProviderFactory.cdc

```
import "CapabilityFactory"
import "FungibleToken"

pub contract FTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item_with_marketplace_cut.cdc

```
import FlowToken from "FlowToken"
import FungibleToken from "../contracts/utility/FungibleToken.cdc"
import NonFungibleToken from "../contracts/utility/NonFungibleToken.cdc"
import ExampleNFT from "../contracts/utility/ExampleNFT.cdc"
import MetadataViews from "../contracts/utility/MetadataViews.cdc"
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Transaction used to facilitate the creation of the listing under the signer's owned storefront resource.
/// It accepts the certain details from the signer,i.e. - 
///
/// `saleItemID` - ID of the NFT that is put on sale by the seller.
/// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.
/// `customID` - Optional string to represent identifier of the dapp.
/// `expiry` - Unix timestamp at which created listing become expired.
/// `marketPlaceSaleCutReceiver` - Marketplace sale cut receiver.
/// `marketPlaceSaleCutPercentage` - Percentage of the sale price received by the marketplace.

/// If the given nft has a support of the RoyaltyView then royalties will added as the sale cut.

transaction(
    saleItemID: UInt64,
    saleItemPrice: UFix64,
    customID: String?,
    expiry: UInt64,
    marketPlaceSaleCutReceiver: Address,
    marketPlaceSaleCutPercentage: UFix64
) {
    let flowReceiver: Capability<&{FungibleToken.Receiver}>
    let exampleNFTProvider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>
    let storefront: auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront
    var saleCuts: [NFTStorefrontV2.SaleCut]
    var marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]

    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, StorageCapabilities) &Account) {

        self.saleCuts = []
        self.marketplacesCapability = []

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // Receiver for the sale cut.
        self.flowReceiver = acct.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
        assert(self.flowReceiver.borrow() != nil, message: "Missing or mis-typed FlowToken receiver")

        var nftProviderCap: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? = nil
        // check if there is an existing capability/capability controller for the storage path
        let nftCollectionControllers = acct.capabilities.storage.getControllers(forPath: collectionData.storagePath)
        for controller in nftCollectionControllers {
            if let maybeProviderCap = controller.capability as? Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? {
                nftProviderCap = maybeProviderCap
                break
            }
        }

        // if there are no capabilities created for that storage path
        // or if existing capability is no longer valid, issue a new one
        if nftProviderCap == nil || nftProviderCap?.check() ?? false {
            nftProviderCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        }
        assert(nftProviderCap?.check() ?? false, message: "Could not assign Provider Capability")

        self.exampleNFTProvider = nftProviderCap!

        let collection = acct.capabilities.borrow<&{NonFungibleToken.Collection}>(
                collectionData.publicPath
            ) ?? panic("Could not borrow a reference to the signer's collection")

        var totalRoyaltyCut = 0.0
        let nft = collection.borrowNFT(saleItemID)!
        // Check whether the NFT implements the MetadataResolver or not.
        if nft.getViews().contains(Type<MetadataViews.Royalties>()) {
            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
            for royalty in royalties {
                // TODO - Verify the type of the vault and it should exists
                self.saleCuts.append(
                    NFTStorefrontV2.SaleCut(
                        receiver: royalty.receiver,
                        amount: royalty.cut * saleItemPrice
                    )
                )
                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * saleItemPrice
            }
        }
        // Append the cut for the seller.
        self.saleCuts.append(
            NFTStorefrontV2.SaleCut(
                receiver: self.flowReceiver,
                amount: saleItemPrice - totalRoyaltyCut - saleItemPrice * marketPlaceSaleCutPercentage
            )
        )
        assert(self.exampleNFTProvider.borrow() != nil, message: "Missing or mis-typed ExampleNFT.Collection provider")

        self.storefront = acct.storage.borrow<auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront>(
                from: NFTStorefrontV2.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront Storefront")

        // Here we are making a fair assumption that all given addresses would have
        // the capability to receive the `FlowToken`
        let marketPlaceCapability = getAccount(marketPlaceSaleCutReceiver).capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)

        // Append the cut for the marketplace.
        self.saleCuts.append(
            NFTStorefrontV2.SaleCut(
                receiver: marketPlaceCapability,
                amount: saleItemPrice * marketPlaceSaleCutPercentage
            )
        )
    }

    execute {
        // Create listing
        self.storefront.createListing(
            nftProviderCapability: self.exampleNFTProvider,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@FlowToken.Vault>(),
            saleCuts: self.saleCuts,
            marketplacesCapability: nil,
            customID: customID,
            commissionAmount: 0.0,
            expiry: expiry
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/scripts/get_owned_nft_ids.cdc

```
import NonFungibleToken from "../../../../contracts/utility/NonFungibleToken.cdc"
import ExampleNFT from "../../../../contracts/utility/ExampleNFT.cdc"

pub fun main(address: Address): [UInt64] {
    let account = getAccount(address)

    let collectionRef = account
        .getCapability(ExampleNFT.CollectionPublicPath)
        .borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/cleanup_purchased_listings.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Transaction to facilitate the cleanup of the purchased listings of a given storefront resource account holder.
/// Cleanup is publicly accessible so can be executed by anyone.
///
transaction(storefrontAddress: Address, listingResourceID: UInt64) {

    let storefront: &{NFTStorefrontV2.StorefrontPublic}

    prepare(acct: &Account) {
        // Access the storefront public resource of the seller to purchase the listing.
        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
                NFTStorefrontV2.StorefrontPublicPath
            ) ?? panic("Could not borrow Storefront from provided address")
    }

    execute {
        // Be kind and recycle
        self.storefront.cleanupPurchasedListings(listingResourceID: listingResourceID)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/utility/setup_account_for_example_nft.cdc

```
/// This transaction is what an account would run
/// to set itself up to receive NFTs

import NonFungibleToken from "NonFungibleToken"
import ExampleNFT from "ExampleNFT"
import MetadataViews from "MetadataViews"

transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // Return early if the account already has a collection
        if signer.storage.borrow<&ExampleNFT.Collection>(from: collectionData.storagePath) != nil {
            return
        }

        // Create a new empty collection
        let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())

        // save it to the account
        signer.storage.save(<-collection, to: collectionData.storagePath)

        // create a public capability for the collection
        signer.capabilities.unpublish(collectionData.publicPath)
        let collectionCap = signer.capabilities.storage.issue<&ExampleNFT.Collection>(collectionData.storagePath)
        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/sell_item.cdc

```
import "ExampleToken"
import "FungibleToken"
import "NonFungibleToken"
import "ExampleNFT"
import "NFTStorefront"
import "MetadataViews"

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {

    let exampleTokenReceiver: Capability<&{FungibleToken.Receiver}>
    let exampleNFTProvider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>
    let storefront: auth(NFTStorefront.CreateListing) &NFTStorefront.Storefront

    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, StorageCapabilities) &Account) {

        let collectionDataOpt = ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
            ?? panic("Missing collection data")
        let collectionData = collectionDataOpt as! MetadataViews.NFTCollectionData

        self.exampleTokenReceiver = acct.capabilities.get<&{FungibleToken.Receiver}>(/public/exampleTokenReceiver)
        assert(self.exampleTokenReceiver.check(), message: "Missing or mis-typed ExampleToken Receiver")

        var nftProviderCap: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? = nil
        // check if there is an existing capability/capability controller for the storage path
        let nftCollectionControllers = acct.capabilities.storage.getControllers(forPath: collectionData.storagePath)
        for controller in nftCollectionControllers {
            if let maybeProviderCap = controller.capability as? Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? {
                nftProviderCap = maybeProviderCap
                break
            }
        }

        // if there are no capabilities created for that storage path
        // or if existing capability is no longer valid, issue a new one
        if nftProviderCap == nil || nftProviderCap?.check() ?? false {
            nftProviderCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        }
        assert(nftProviderCap?.check() ?? false, message: "Could not assign Provider Capability")

        self.exampleNFTProvider = nftProviderCap!

        // If the account doesn't already have a Storefront
        if acct.storage.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            // Save a new .Storefront to account storage
            acct.storage.save(
                <- NFTStorefront.createStorefront(),
                to: NFTStorefront.StorefrontStoragePath
            )
            // create a public capability for the .Storefront & publish
            let storefrontPublicCap = acct.capabilities.storage.issue<&{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontStoragePath
            )
            acct.capabilities.publish(storefrontPublicCap, at: NFTStorefront.StorefrontPublicPath)
        }

        self.storefront = acct.storage.borrow<auth(NFTStorefront.CreateListing) &NFTStorefront.Storefront>(
                from: NFTStorefront.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront Storefront")
    }

    execute {
        let saleCut = NFTStorefront.SaleCut(
            receiver: self.exampleTokenReceiver,
            amount: saleItemPrice
        )
        self.storefront.createListing(
            nftProviderCapability: self.exampleNFTProvider,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@ExampleToken.Vault>(),
            saleCuts: [saleCut]
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-token/mint_tokens.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is what the minter Account uses to mint new tokens
/// They provide the recipient address and amount to mint, and the tokens
/// are transferred to the address after minting

transaction(recipient: Address, amount: UFix64) {

    /// Reference to the Example Token Minter Resource object
    let tokenMinter: &ExampleToken.Minter

    /// Reference to the Fungible Token Receiver of the recipient
    let tokenReceiver: &{FungibleToken.Receiver}

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    prepare(signer: auth(BorrowValue) &Account) {
        self.supplyBefore = ExampleToken.totalSupply

        // Borrow a reference to the admin object
        self.tokenMinter = signer.storage.borrow<&ExampleToken.Minter>(from: ExampleToken.AdminStoragePath)
            ?? panic("Signer is not the token admin")

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")
    
        self.tokenReceiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow receiver reference to the Vault")
    }

    execute {

        // Create mint tokens
        let mintedVault <- self.tokenMinter.mintTokens(amount: amount)

        // Deposit them to the receiever
        self.tokenReceiver.deposit(from: <-mintedVault)
    }

    post {
        ExampleToken.totalSupply == self.supplyBefore + amount: "The total supply must be increased by the amount"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/utility/mint_example_nft.cdc

```
/// This script uses the NFTMinter resource to mint a new NFT
/// It must be run with the account that has the minter resource
/// stored in /storage/NFTMinter

import NonFungibleToken from "NonFungibleToken"
import ExampleNFT from "ExampleNFT"
import MetadataViews from "MetadataViews"
import FungibleToken from "FungibleToken"

transaction(
    recipient: Address,
    name: String,
    description: String,
    thumbnail: String,
    cuts: [UFix64],
    royaltyDescriptions: [String],
    royaltyBeneficiaries: [Address]
) {

    /// local variable for storing the minter reference
    let minter: &ExampleNFT.NFTMinter

    /// Reference to the receiver's collection
    let recipientCollectionRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Account does not store an object at the specified path")

        // Borrow the recipient's public NFT collection reference
        self.recipientCollectionRef = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(
                collectionData.publicPath
            ) ?? panic("Could not get receiver reference to the NFT Collection")
    }

    pre {
        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: "Array length should be equal for royalty related details"
    }

    execute {

        // // Create the royalty details
        // var count = 0
        // var royalties: [MetadataViews.Royalty] = []
        // while royaltyBeneficiaries.length > count {
        //     let beneficiary = royaltyBeneficiaries[count]
        //     let beneficiaryCapability = getAccount(beneficiary).capabilities.get<&{FungibleToken.Receiver}>(
        //             MetadataViews.getRoyaltyReceiverPublicPath()
        //         ) ?? panic("Beneficiary does not have Receiver configured at RoyaltyReceiverPublicPath")

        //     royalties.append(
        //         MetadataViews.Royalty(
        //             receiver: beneficiaryCapability,
        //             cut: cuts[count],
        //             description: royaltyDescriptions[count]
        //         )
        //     )
        //     count = count + 1
        // }


        // Mint the NFT and deposit it to the recipient's collection
        let mintedNFT <- self.minter.mintNFT(
            name: name,
            description: description,
            thumbnail: thumbnail,
            royalties: [] //royalties
        )
        self.recipientCollectionRef.deposit(token: <-mintedNFT)
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/test/MaliciousStorefrontV2.cdc

```
import "NFTStorefrontV2"
import "NonFungibleToken"
import "FungibleToken"
import "FungibleTokenMetadataViews"

/// Thanks to Austin Kline - https://twitter.com/austin_flowty
/// for discovering and reporting the vulnerability that this contract tests
///
/// This is a test contract that implements a malicious storefront
/// to try an sell an NFT with a different ID in the place
/// of a different listing
///
/// There is a test in NFTStorefrontV2_test.cdc that tests this case

access(all) contract MaliciousStorefrontV2 {
    access(all) let StorefrontStoragePath: StoragePath
    access(all) let StorefrontPublicPath: PublicPath

    access(all) resource Storefront: NFTStorefrontV2.StorefrontPublic {
        access(self) let storefrontCap: Capability<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>
        access(self) let listings: @{UInt64: Listing}


        access(all) view fun getListingIDs(): [UInt64] {
            return self.storefrontCap.borrow()!.getListingIDs()
        }

        access(all) fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64] {
            return self.storefrontCap.borrow()!.getDuplicateListingIDs(nftType: nftType, nftID: nftID, listingID: listingID)
        }

        access(all) view fun borrowListing(listingResourceID: UInt64): &{NFTStorefrontV2.ListingPublic}? {
            return &self.listings[listingResourceID]
        }

        access(all) fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64) {
            return self.storefrontCap.borrow()!.cleanupExpiredListings(fromIndex: fromIndex, toIndex: toIndex)
        }

        access(contract) fun cleanup(listingResourceID: UInt64) {
            return
        }

        access(all) fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64] {
            return self.storefrontCap.borrow()!.getExistingListingIDs(nftType: nftType, nftID: nftID)
        }

        access(all) fun cleanupPurchasedListings(listingResourceID: UInt64) {
            return self.storefrontCap.borrow()!.cleanupPurchasedListings(listingResourceID: listingResourceID)
        }

        access(all) fun cleanupGhostListings(listingResourceID: UInt64) {
            return self.storefrontCap.borrow()!.cleanupGhostListings(listingResourceID: listingResourceID)
        }

        access(NFTStorefrontV2.CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            maliciousNftId: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [NFTStorefrontV2.SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
        ): UInt64 {
            let storefront = self.storefrontCap.borrow()!
            let listingId = storefront.createListing(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                marketplacesCapability: marketplacesCapability,
                customID: customID,
                commissionAmount: commissionAmount,
                expiry: expiry
            )

            let maliciouslisting <- create Listing(
                storefrontCap: self.storefrontCap,
                listingResourceID: listingId,
                nftId: maliciousNftId,
                provider: nftProviderCapability
            )

            destroy self.listings.insert(key: listingId, <-maliciouslisting)

            return listingId
        }

        init(storefrontCap: Capability<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>) {
            self.storefrontCap = storefrontCap
            self.listings <- {}
        }
    }

    access(all) resource Listing: NFTStorefrontV2.ListingPublic {
        access(self) let storefrontCap: Capability<&NFTStorefrontV2.Storefront>

        // this id much match the id of the listing being impersonated
        access(self) let listingResourceID: UInt64

        // this is the id of the nft we are returning instead of the one that a user thinks is being purchased.
        access(self) let nftId: UInt64

        access(contract) let provider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}? {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.borrowNFT()
        }

        access(all) view fun getDetails(): NFTStorefrontV2.ListingDetails {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.getDetails()
        }

        access(all) view fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]? {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.getAllowedCommissionReceivers()
        }

        access(all) view fun hasListingBecomeGhosted(): Bool {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.hasListingBecomeGhosted()
        }

        // purchase will return the "wrong" nft
        access(all) fun purchase(
            payment: @{FungibleToken.Vault}, 
            commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
        ): @{NonFungibleToken.NFT} {
            let details = self.getDetails()
            assert(payment.balance == details.salePrice, message: "incorrect payment amount")
            assert(payment.getType() == details.salePaymentVaultType, message: "incorrect payment token type")

            let ftVaultData = payment.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>())! as! FungibleTokenMetadataViews.FTVaultData
            if let vault = MaliciousStorefrontV2.account.storage.borrow<&{FungibleToken.Vault}>(from: ftVaultData.storagePath) {
                vault.deposit(from: <- payment)
            } else {
                MaliciousStorefrontV2.account.storage.save(<-payment, to: ftVaultData.storagePath)
            }

            let nft <- self.provider.borrow()!.withdraw(withdrawID: self.nftId)
            return <- nft
        }

        init(
            storefrontCap: Capability<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>,
            listingResourceID: UInt64,
            nftId: UInt64,
            provider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
        ) {
            pre {
                provider.check(): "invalid provider capability"
                storefrontCap.check(): "invalid storefront cap"
            }

            let listing = storefrontCap.borrow()!.borrowListing(listingResourceID: listingResourceID) ?? panic("failed to borrow get impersonated listing")
            let details = listing.getDetails()

            self.storefrontCap = storefrontCap
            self.listingResourceID = listingResourceID
            self.nftId = nftId
            self.provider = provider

            assert(provider.borrow()!.borrowNFT(self.nftId) != nil, message: "could not borrow nftID")
            assert(details.nftID != self.nftId, message: "must not return the same id as the original listing")
        }
    }

    access(all) fun createStorefront(storefrontCap: Capability<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>): @Storefront {
        return <- create Storefront(storefrontCap: storefrontCap)
    }

    init() {
        self.StorefrontStoragePath = /storage/NFTStorefrontV2Malicious
        self.StorefrontPublicPath = /public/NFTStorefrontV2
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/setup_nft_account.cdc

```
import NonFungibleToken from "../../../../contracts/utility/NonFungibleToken.cdc"
import MetadataViews from "../../../../contracts/utility/MetadataViews.cdc"
import ExampleNFT from "../../../../contracts/utility/ExampleNFT.cdc"

// This transaction is what an account would run
// to set itself up to receive NFTs

transaction {

    prepare(signer: AuthAccount) {
        // Return early if the account already has a collection
        if signer.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath) != nil {
            return
        }

        // Create a new empty collection
        let collection <- ExampleNFT.createEmptyCollection()

        // save it to the account
        signer.save(<-collection, to: ExampleNFT.CollectionStoragePath)

        // create a public capability for the collection
        signer.link<&{NonFungibleToken.CollectionPublic, ExampleNFT.ExampleNFTCollectionPublic, MetadataViews.ResolverCollection}>(
            ExampleNFT.CollectionPublicPath,
            target: ExampleNFT.CollectionStoragePath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/flow-token/transfer_flow.cdc

```
import "FungibleToken"
import "FlowToken"

transaction(recipient: Address, amount: UFix64) {
    
    let providerVault: &FlowToken.Vault
    let receiver: &{FungibleToken.Receiver}
    
    prepare(signer: AuthAccount) {
        self.providerVault = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!
        self.receiver = getAccount(recipient).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            .borrow()
            ?? panic("Could not borrow receiver reference")
    }

    execute {
        self.receiver.deposit(
            from: <-self.providerVault.withdraw(
                amount: amount
            )
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/tests/transactions/create_malicious_listing_v1.cdc

```
import "ExampleNFT"
import "ExampleToken"
import "FungibleToken"
import "NonFungibleToken"
import "NFTStorefront"
import "MaliciousStorefrontV1"

transaction {
    prepare(acct: auth(Storage, Capabilities) &Account) {
        if acct.storage.borrow<&AnyResource>(from: NFTStorefront.StorefrontStoragePath) == nil {
            acct.storage.save(<-NFTStorefront.createStorefront(), to: NFTStorefront.StorefrontStoragePath)
        }

        if acct.storage.borrow<&AnyResource>(from: ExampleToken.VaultStoragePath) == nil {
            let vault <- ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())
            acct.storage.save(<-vault, to: ExampleToken.VaultStoragePath)

            acct.capabilities.publish(
                acct.capabilities.storage.issue<&ExampleToken.Vault>(ExampleToken.VaultStoragePath),
                at: ExampleToken.ReceiverPublicPath
            )
        }

        if acct.storage.borrow<&AnyResource>(from: ExampleNFT.CollectionStoragePath) == nil {
            let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
            acct.storage.save(<-collection, to: ExampleNFT.CollectionStoragePath)

            acct.capabilities.publish(
                acct.capabilities.storage.issue<&ExampleNFT.Collection>(ExampleNFT.CollectionStoragePath),
                at: ExampleNFT.CollectionPublicPath
            )
        }

        let storefrontCap = acct.capabilities.storage.issue<auth(NFTStorefront.CreateListing, NFTStorefront.RemoveListing) &NFTStorefront.Storefront>(NFTStorefront.StorefrontStoragePath)
        let providerCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(ExampleNFT.CollectionStoragePath)

        if acct.storage.borrow<&AnyResource>(from: MaliciousStorefrontV1.StorefrontStoragePath) == nil {
            acct.storage.save(<- MaliciousStorefrontV1.createStorefront(storefrontCap: storefrontCap), to: MaliciousStorefrontV1.StorefrontStoragePath)
            acct.capabilities.publish(
                acct.capabilities.storage.issue<&{NFTStorefront.StorefrontPublic}>(MaliciousStorefrontV1.StorefrontStoragePath),
                at: MaliciousStorefrontV1.StorefrontPublicPath
            )
        }

        let maliciousStorefront = acct.storage.borrow<auth(NFTStorefront.CreateListing) &MaliciousStorefrontV1.Storefront>(from: MaliciousStorefrontV1.StorefrontStoragePath)!
        let saleCut = NFTStorefront.SaleCut(
            receiver: acct.capabilities.get<&{FungibleToken.Receiver}>(ExampleToken.ReceiverPublicPath), 
            amount: 1.0
        )

        // borrow a reference to the NFTMinter resource in storage
        let minter = acct.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Account does not store an object at the specified path")

        let nft <- minter.mintNFT(
            name: "Legit NFT",
            description: "I'm the real one",
            thumbnail: "",
            royalties: []
        )

        let maliciousNft <- minter.mintNFT(
            name: "Not Fake",
            description: "Definitely Not Fake",
            thumbnail: "I swear",
            royalties: []
        )

        let nftId = nft.id
        let maliciousNftId = maliciousNft.id

        let collection = providerCap.borrow()!
        collection.deposit(token: <-nft)
        collection.deposit(token: <-maliciousNft)

        maliciousStorefront.createListing(
            nftProviderCapability: providerCap,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: nftId,
            maliciousNftId: maliciousNftId,
            salePaymentVaultType: Type<@ExampleToken.Vault>(),
            saleCuts: [saleCut],
            marketplacesCapability: nil,
            customID: nil,
            commissionAmount: 0.0,
            expiry: UInt64(getCurrentBlock().timestamp) + 1_000_000
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/has_listing_become_ghosted.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// This script tells whether the provided `listingID` under the provided `storefront` address
/// has a ghost listing.
access(all) fun main(storefrontAddress: Address, listingID: UInt64): Bool {
    let storefrontPublicRef = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        ) ?? panic("Given account does not has storefront resource")

    // Access the listing under the given storefront account
    let listingRef = storefrontPublicRef.borrowListing(listingResourceID: listingID)
         ?? panic("Provided listingID doesn't exist under the given storefront address")
    return listingRef.hasListingBecomeGhosted()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-nft/burn_nft.cdc

```
/// This transaction withdraws an NFT from the signers collection and destroys it

import "NonFungibleToken"
import "MetadataViews"
import "ExampleNFT"

transaction(id: UInt64) {

    /// Reference that will be used for the owner's collection
    let collectionRef: auth(NonFungibleToken.Withdraw) &ExampleNFT.Collection

    prepare(signer: auth(BorrowValue) &Account) {
        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")
            
        // borrow a reference to the owner's collection
        self.collectionRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &ExampleNFT.Collection>(
                from: collectionData.storagePath
            ) ?? panic("Account does not store an object at the specified path")

    }

    execute {

        // withdraw the NFT from the owner's collection
        let nft <- self.collectionRef.withdraw(withdrawID: id)

        destroy nft
    }

    post {
        !self.collectionRef.getIDs().contains(id): "The NFT with the specified ID should have been deleted"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/setup_account.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// This transaction installs the Storefront ressource in an account.
///
transaction {
    prepare(acct: auth(IssueStorageCapabilityController, PublishCapability, Storage) &Account) {

        // If the account doesn't already have a Storefront
        if acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {

            // Create a new empty Storefront
            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront
            
            // save it to the account
            acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)

            // create a public capability for the Storefront
            let storefrontPublicCap = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(
                    NFTStorefrontV2.StorefrontStoragePath
                )
            acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/hybrid-custody/setup/linking/setup_owned_account_and_publish_to_parent.cdc

```
#allowAccountLinking

import "MetadataViews"

import "HybridCustody"
import "CapabilityFactory"
import "CapabilityFilter"
import "CapabilityDelegator"

/// This transaction configures an OwnedAccount in the signer if needed, and proceeds to create a ChildAccount 
/// using CapabilityFactory.Manager and CapabilityFilter.Filter Capabilities from the given addresses. A
/// Capability on the ChildAccount is then published to the specified parent account. 
///
transaction(
        parent: Address,
        factoryAddress: Address,
        filterAddress: Address,
        name: String?,
        desc: String?,
        thumbnailURL: String?
    ) {
    
    prepare(acct: AuthAccount) {
        // Configure OwnedAccount if it doesn't exist
        if acct.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) == nil {
            var acctCap = acct.getCapability<&AuthAccount>(HybridCustody.LinkedAccountPrivatePath)
            if !acctCap.check() {
                acctCap = acct.linkAccount(HybridCustody.LinkedAccountPrivatePath)!
            }
            let ownedAccount <- HybridCustody.createOwnedAccount(acct: acctCap)
            acct.save(<-ownedAccount, to: HybridCustody.OwnedAccountStoragePath)
        }

        // check that paths are all configured properly
        acct.unlink(HybridCustody.OwnedAccountPrivatePath)
        acct.link<&HybridCustody.OwnedAccount{HybridCustody.BorrowableAccount, HybridCustody.OwnedAccountPublic, MetadataViews.Resolver}>(HybridCustody.OwnedAccountPrivatePath, target: HybridCustody.OwnedAccountStoragePath)

        acct.unlink(HybridCustody.OwnedAccountPublicPath)
        acct.link<&HybridCustody.OwnedAccount{HybridCustody.OwnedAccountPublic, MetadataViews.Resolver}>(HybridCustody.OwnedAccountPublicPath, target: HybridCustody.OwnedAccountStoragePath)

        let owned = acct.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")
        
        // Set the display metadata for the OwnedAccount
        if name != nil && desc != nil && thumbnailURL != nil {
            let thumbnail = MetadataViews.HTTPFile(url: thumbnailURL!)
            let display = MetadataViews.Display(name: name!, description: desc!, thumbnail: thumbnail!)
            owned.setDisplay(display)
        }

        // Get CapabilityFactory & CapabilityFilter Capabilities
        let factory = getAccount(factoryAddress).getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath)
        assert(factory.check(), message: "factory address is not configured properly")

        let filter = getAccount(filterAddress).getCapability<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filter.check(), message: "capability filter is not configured properly")

        // Finally publish a ChildAccount capability on the signing account to the specified parent
        owned.publishToParent(parentAddress: parent, factory: factory, filter: filter)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/lib/js/mocks/transactions/setup_catalog_admin_proxy.cdc

```
import NFTCatalogAdmin from "../../../../contracts/utility/NFTCatalog.cdc"

transaction() {
    
    prepare(acct: AuthAccount) {
        acct.save(<- NFTCatalogAdmin.createAdminProxy(), to: NFTCatalogAdmin.AdminProxyStoragePath)
        acct.link<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath, target: NFTCatalogAdmin.AdminProxyStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/HybridCustody.cdc

```
// Third-party imports
import "MetadataViews"

// HC-owned imports
import "CapabilityFactory"
import "CapabilityDelegator"
import "CapabilityFilter"

/// HybridCustody defines a framework for sharing accounts via account linking.
/// In the contract, there are three main resources:
///
/// 1. OwnedAccount - A resource which maintains an AuthAccount Capability, and handles publishing and revoking access
///    of that account via another resource called a ChildAccount
/// 2. ChildAccount - A second resource which exists on the same account as the OwnedAccount and contains the filters
///    and retrieval patterns governing the scope of parent account access. A Capability on this resource is shared to
///    the parent account, enabling Hybrid Custody access to the underlying account.
/// 3. Manager - A resource setup by the parent which manages all child accounts shared with it. The Manager resource
///    also maintains a set of accounts that it "owns", meaning it has a capability to the full OwnedAccount resource
///    and would then also be able to manage the child account's links as it sees fit.
/// 
/// Contributors (please add to this list if you contribute!):
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Ashley Daffin - https://twitter.com/web3ashlee
/// - Felipe Ribeiro - https://twitter.com/Frlabs33
///
/// Repo reference: https://github.com/onflow/hybrid-custody
///
pub contract HybridCustody {

    /* --- Canonical Paths --- */
    //
    // Note: Paths for ChildAccount & Delegator are derived from the parent's address
    //
    pub let OwnedAccountStoragePath: StoragePath
    pub let OwnedAccountPublicPath: PublicPath
    pub let OwnedAccountPrivatePath: PrivatePath

    pub let ManagerStoragePath: StoragePath
    pub let ManagerPublicPath: PublicPath
    pub let ManagerPrivatePath: PrivatePath

    pub let LinkedAccountPrivatePath: PrivatePath
    pub let BorrowableAccountPrivatePath: PrivatePath

    /* --- Events --- */
    //
    /// Manager creation event
    pub event CreatedManager(id: UInt64)
    /// OwnedAccount creation event
    pub event CreatedOwnedAccount(id: UInt64, child: Address)
    /// ChildAccount added/removed from Manager
    ///     active  : added to Manager
    ///     !active : removed from Manager
    pub event AccountUpdated(id: UInt64?, child: Address, parent: Address, active: Bool)
    /// OwnedAccount added/removed or sealed
    ///     active && owner != nil  : added to Manager 
    ///     !active && owner == nil : removed from Manager
    pub event OwnershipUpdated(id: UInt64, child: Address, previousOwner: Address?, owner: Address?, active: Bool)
    /// ChildAccount ready to be redeemed by emitted pendingParent
    pub event ChildAccountPublished(
        ownedAcctID: UInt64,
        childAcctID: UInt64,
        capDelegatorID: UInt64,
        factoryID: UInt64,
        filterID: UInt64,
        filterType: Type,
        child: Address,
        pendingParent: Address
    )
    /// OwnedAccount granted ownership to a new address, publishing a Capability for the pendingOwner
    pub event OwnershipGranted(ownedAcctID: UInt64, child: Address, previousOwner: Address?, pendingOwner: Address)
    /// Account has been sealed - keys revoked, new AuthAccount Capability generated
    pub event AccountSealed(id: UInt64, address: Address, parents: [Address])

    /// An OwnedAccount shares the BorrowableAccount capability to itelf with ChildAccount resources
    ///
    pub resource interface BorrowableAccount {
        access(contract) fun borrowAccount(): &AuthAccount
        pub fun check(): Bool
    }

    /// Public methods anyone can call on an OwnedAccount
    ///
    pub resource interface OwnedAccountPublic {
        /// Returns the addresses of all parent accounts
        pub fun getParentAddresses(): [Address]

        /// Returns associated parent addresses and their redeemed status - true if redeemed, false if pending
        pub fun getParentStatuses(): {Address: Bool}

        /// Returns true if the given address is a parent of this child and has redeemed it. Returns false if the given
        /// address is a parent of this child and has NOT redeemed it. Returns nil if the given address it not a parent
        /// of this child account.
        pub fun getRedeemedStatus(addr: Address): Bool?

        /// A callback function to mark a parent as redeemed on the child account.
        access(contract) fun setRedeemed(_ addr: Address)
    }

    /// Private interface accessible to the owner of the OwnedAccount
    ///
    pub resource interface OwnedAccountPrivate {
        /// Deletes the ChildAccount resource being used to share access to this OwnedAccount with the supplied parent
        /// address, and unlinks the paths it was using to reach the underlying account.
        pub fun removeParent(parent: Address): Bool

        /// Sets up a new ChildAccount resource for the given parentAddress to redeem. This child account uses the
        /// supplied factory and filter to manage what can be obtained from the child account, and a new
        /// CapabilityDelegator resource is created for the sharing of one-off capabilities. Each of these pieces of
        /// access control are managed through the child account.
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre {
                factory.check(): "Invalid CapabilityFactory.Getter Capability provided"
                filter.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Passes ownership of this child account to the given address. Once executed, all active keys on the child
        /// account will be revoked, and the active AuthAccount Capability being used by to obtain capabilities will be
        /// rotated, preventing anyone without the newly generated Capability from gaining access to the account.
        pub fun giveOwnership(to: Address)

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all
        /// parent accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an
        /// owner.
        /// USE WITH EXTREME CAUTION.
        pub fun seal()

        // setCapabilityFactoryForParent
        // Override the existing CapabilityFactory Capability for a given parent. This will allow the owner of the
        // account to start managing their own factory of capabilities to be able to retrieve
        pub fun setCapabilityFactoryForParent(parent: Address, cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            pre {
                cap.check(): "Invalid CapabilityFactory.Getter Capability provided"
            }
        }

        /// Override the existing CapabilityFilter Capability for a given parent. This will allow the owner of the
        /// account to start managing their own filter for retrieving Capabilities on Private Paths
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            pre {
                cap.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Adds a capability to a parent's managed @ChildAccount resource. The Capability can be made public,
        /// permitting anyone to borrow it.
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
        }

        /// Removes a Capability from the CapabilityDelegator used by the specified parent address
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability)

        /// Returns the address of this OwnedAccount
        pub fun getAddress(): Address
        
        /// Checks if this OwnedAccount is a child of the specified address
        pub fun isChildOf(_ addr: Address): Bool

        /// Returns all addresses which are parents of this OwnedAccount
        pub fun getParentAddresses(): [Address]

        /// Borrows this OwnedAccount's AuthAccount Capability
        pub fun borrowAccount(): &AuthAccount?

        /// Returns the current owner of this account, if there is one
        pub fun getOwner(): Address?

        /// Returns the pending owner of this account, if there is one
        pub fun getPendingOwner(): Address?

        /// A callback which is invoked when a parent redeems an owned account
        access(contract) fun setOwnerCallback(_ addr: Address)
        
        /// Destroys all outstanding AuthAccount capabilities on this owned account, and creates a new one for the
        /// OwnedAccount to use
        pub fun rotateAuthAccount()

        /// Revokes all keys on this account
        pub fun revokeAllKeys()
    }

    /// Public methods exposed on a ChildAccount resource. OwnedAccountPublic will share some methods here, but isn't
    /// necessarily the same.
    ///
    pub resource interface AccountPublic {
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getAddress(): Address
        pub fun getCapabilityFactoryManager(): &{CapabilityFactory.Getter}?
        pub fun getCapabilityFilter(): &{CapabilityFilter.Filter}?
    }

    /// Methods accessible to the designated parent of a ChildAccount
    ///
    pub resource interface AccountPrivate {
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        access(contract) fun redeemedCallback(_ addr: Address)
        access(contract) fun setManagerCapabilityFilter(_ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                managerCapabilityFilter == nil || managerCapabilityFilter!.check(): "Invalid Manager Capability Filter"
            }
        }
        access(contract) fun parentRemoveChildCallback(parent: Address)
    }

    /// Entry point for a parent to obtain, maintain and access Capabilities or perform other actions on child accounts
    ///
    pub resource interface ManagerPrivate {
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>)
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}?
        pub fun removeChild(addr: Address)
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>)
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}?
        pub fun removeOwned(addr: Address)
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            pre {
                cap == nil || cap!.check(): "Invalid Manager Capability Filter"
            }
        }
    }

    /// Functions anyone can call on a manager to get information about an account such as What child accounts it has
    /// Functions anyone can call on a manager to get information about an account such as what child accounts it has
    pub resource interface ManagerPublic {
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}?
        pub fun getChildAddresses(): [Address]
        pub fun getOwnedAddresses(): [Address]
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display?
        access(contract) fun removeParentCallback(child: Address)
    }

    /// A resource for an account which fills the Parent role of the Child-Parent account management Model. A Manager
    /// can redeem or remove child accounts, and obtain any capabilities exposed by the child account to them.
    ///
    pub resource Manager: ManagerPrivate, ManagerPublic, MetadataViews.Resolver {

        /// Mapping of restricted access child account Capabilities indexed by their address
        pub let childAccounts: {Address: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>}
        /// Mapping of unrestricted owned account Capabilities indexed by their address
        pub let ownedAccounts: {Address: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>}

        /// A bucket of structs so that the Manager resource can be easily extended with new functionality.
        pub let data: {String: AnyStruct}
        /// A bucket of resources so that the Manager resource can be easily extended with new functionality.
        pub let resources: @{String: AnyResource}

        /// An optional filter to gate what capabilities are permitted to be returned from a child account For example,
        /// Dapper Wallet parent account's should not be able to retrieve any FungibleToken Provider capabilities.
        pub var filter: Capability<&{CapabilityFilter.Filter}>?

        // display metadata for a child account exists on its parent
        pub let childAccountDisplays: {Address: MetadataViews.Display}

        /// Sets the Display on the ChildAccount. If nil, the display is removed.
        ///
        pub fun setChildAccountDisplay(address: Address, _ d: MetadataViews.Display?) {
            pre {
                self.childAccounts[address] != nil: "There is no child account with this address"
            }

            if d == nil {
                self.childAccountDisplays.remove(key: address)
                return
            }

            self.childAccountDisplays[address] = d
        }

        /// Adds a ChildAccount Capability to this Manager. If a default Filter is set in the manager, it will also be
        /// added to the ChildAccount
        ///
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.childAccounts[cap.address] == nil: "There is already a child account with this address"
            }

            let acct = cap.borrow()
                ?? panic("child account capability could not be borrowed")

            self.childAccounts[cap.address] = cap
            
            emit AccountUpdated(id: acct.uuid, child: cap.address, parent: self.owner!.address, active: true)

            acct.redeemedCallback(self.owner!.address)
            acct.setManagerCapabilityFilter(self.filter)
        }

        /// Sets the default Filter Capability for this Manager. Does not propagate to child accounts.
        ///
        pub fun setDefaultManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                cap == nil || cap!.check(): "supplied capability must be nil or check must pass"
            }

            self.filter = cap
        }
        
        /// Sets the Filter Capability for this Manager, propagating to the specified child account
        ///
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            let acct = self.borrowAccount(addr: childAddress) 
                ?? panic("child account not found")

            acct.setManagerCapabilityFilter(cap)
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeChild(addr: Address) {
            let cap = self.childAccounts.remove(key: addr)
                ?? panic("child account not found")

            self.childAccountDisplays.remove(key: addr)
            
            if !cap.check() {
                // Emit event if invalid capability
                emit AccountUpdated(id: nil, child: cap.address, parent: self.owner!.address, active: false)
                return
            }

            let acct = cap.borrow()!
            // Get the child account id before removing capability
            let id: UInt64 = acct.uuid

            acct.parentRemoveChildCallback(parent: self.owner!.address) 

            emit AccountUpdated(id: id, child: cap.address, parent: self.owner!.address, active: false)
        }

        /// Contract callback that removes a child account from the Manager's child accounts in the event a child
        /// account initiates unlinking parent from child
        ///
        access(contract) fun removeParentCallback(child: Address) {
            self.childAccounts.remove(key: child)
            self.childAccountDisplays.remove(key: child)
        }

        /// Adds an owned account to the Manager's list of owned accounts, setting the Manager account as the owner of
        /// the given account
        ///
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.ownedAccounts[cap.address] == nil: "There is already an owned account with this address"
            }

            let acct = cap.borrow()
                ?? panic("owned account capability could not be borrowed")

            // for safety, rotate the auth account capability to prevent any outstanding capabilities from the previous owner
            // and revoke all outstanding keys.
            acct.rotateAuthAccount()
            acct.revokeAllKeys()

            self.ownedAccounts[cap.address] = cap

            emit OwnershipUpdated(id: acct.uuid, child: cap.address, previousOwner: acct.getOwner(), owner: self.owner!.address, active: true)
            acct.setOwnerCallback(self.owner!.address)
        }

        /// Returns a reference to a child account
        ///
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to a child account's public AccountPublic interface
        ///
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to an owned account
        ///
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}? {
            if let cap = self.ownedAccounts[addr] {
                return cap.borrow()
            }

            return nil
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeOwned(addr: Address) {
            if let acct = self.ownedAccounts.remove(key: addr) {
                if acct.check() {
                    acct.borrow()!.seal()
                }
                let id: UInt64? = acct.borrow()?.uuid ?? nil

                emit OwnershipUpdated(id: id!, child: addr, previousOwner: self.owner!.address, owner: nil, active: false)
            }
            // Don't emit an event if nothing was removed
        }

        /// Removes the owned Capabilty on the specified account, relinquishing access to the account and publishes a
        /// Capability for the specified account. See `OwnedAccount.giveOwnership()` for more details on this method.
        /// 
        /// **NOTE:** The existence of this method does not imply that it is the only way to receive access to a
        /// OwnedAccount Capability or that only the labeled `to` account has said access. Rather, this is a convenient
        /// mechanism intended to easily transfer 'root' access on this account to another account and an attempt to
        /// minimize access vectors.
        ///
        pub fun giveOwnership(addr: Address, to: Address) {
            let acct = self.ownedAccounts.remove(key: addr)
                ?? panic("account not found")

            acct.borrow()!.giveOwnership(to: to)
        }

        /// Returns an array of child account addresses
        ///
        pub fun getChildAddresses(): [Address] {
            return self.childAccounts.keys
        }

        /// Returns an array of owned account addresses
        ///
        pub fun getOwnedAddresses(): [Address] {
            return self.ownedAccounts.keys
        }

        /// Retrieves the parent-defined display for the given child account
        ///
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display? {
            return self.childAccountDisplays[address]
        }

        /// Returns the types of supported views - none at this time
        ///
        pub fun getViews(): [Type] {
            return []
        }

        /// Resolves the given view if supported - none at this time
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            return nil
        }

        init(filter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
            }
            self.childAccounts = {}
            self.ownedAccounts = {}
            self.childAccountDisplays = {}
            self.filter = filter

            self.data = {}
            self.resources <- {}
        }

        destroy () {
            destroy self.resources
        }
    }

    /// The ChildAccount resource sits between a child account and a parent and is stored on the same account as the
    /// child account. Once created, a private capability to the child account is shared with the intended parent. The
    /// parent account will accept this child capability into its own manager resource and use it to interact with the
    /// child account.
    /// 
    /// Because the ChildAccount resource exists on the child account itself, whoever owns the child account will be
    /// able to manage all ChildAccount resources it shares, without worrying about whether the upstream parent can do
    /// anything to prevent it.
    /// 
    pub resource ChildAccount: AccountPrivate, AccountPublic, MetadataViews.Resolver {
        /// A Capability providing access to the underlying child account
        access(self) let childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>

        /// The CapabilityFactory Manager is a ChildAccount's way of limiting what types can be asked for by its parent
        /// account. The CapabilityFactory returns Capabilities which can be casted to their appropriate types once
        /// obtained, but only if the child account has configured their factory to allow it. For instance, a
        /// ChildAccount might choose to expose NonFungibleToken.Provider, but not FungibleToken.Provider
        pub var factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>

        /// The CapabilityFilter is a restriction put at the front of obtaining any non-public Capability. Some wallets
        /// might want to give access to NonFungibleToken.Provider, but only to **some** of the collections it manages,
        /// not all of them.
        pub var filter: Capability<&{CapabilityFilter.Filter}>

        /// The CapabilityDelegator is a way to share one-off capabilities from the child account. These capabilities
        /// can be public OR private and are separate from the factory which returns a capability at a given path as a 
        /// certain type. When using the CapabilityDelegator, you do not have the ability to specify which path a
        /// capability came from. For instance, Dapper Wallet might choose to expose a Capability to their Full TopShot
        /// collection, but only to the path that the collection exists in.
        pub let delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>

        /// managerCapabilityFilter is a component optionally given to a child account when a manager redeems it. If
        /// this filter is not nil, any Capability returned through the `getCapability` function checks that the
        /// manager allows access first.
        access(self) var managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?

        /// A bucket of structs so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// ChildAccount resources have a 1:1 association with parent accounts, the named parent Address here is the 
        /// one with a Capability on this resource.
        pub let parent: Address

        /// Returns the Address of the underlying child account
        ///
        pub fun getAddress(): Address {
            return self.childCap.address
        }

        /// Callback setting the child account as redeemed by the provided parent Address
        ///
        access(contract) fun redeemedCallback(_ addr: Address) {
            self.childCap.borrow()!.setRedeemed(addr)
        }

        /// Sets the given filter as the managerCapabilityFilter for this ChildAccount
        ///
        access(contract) fun setManagerCapabilityFilter(
            _ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?
        ) {
            self.managerCapabilityFilter = managerCapabilityFilter
        }

        /// Sets the CapabiltyFactory.Manager Capability
        ///
        pub fun setCapabilityFactory(cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            self.factory = cap
        }
 
        /// Sets the Filter Capability as the one provided
        ///
        pub fun setCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>) {
            self.filter = cap
        }

        /// The main function to a child account's capabilities from a parent account. When a PrivatePath type is used,
        /// the CapabilityFilter will be borrowed and the Capability being returned will be checked against it to
        /// ensure that borrowing is permitted. If not allowed, nil is returned.
        /// Also know that this method retrieves Capabilities via the CapabilityFactory path. To retrieve arbitrary 
        /// Capabilities, see `getPrivateCapFromDelegator()` and `getPublicCapFromDelegator()` which use the
        /// `Delegator` retrieval path.
        ///
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            let child = self.childCap.borrow() ?? panic("failed to borrow child account")

            let f = self.factory.borrow()!.getFactory(type)
            if f == nil {
                return nil
            }

            let acct = child.borrowAccount()
            let cap = f!.getCapability(acct: acct, path: path)

            // Check that private capabilities are allowed by either internal or manager filter (if assigned)
            // If not allowed, return nil
            if path.getType() == Type<PrivatePath>() && (
                self.filter.borrow()!.allowed(cap: cap) == false || 
                (self.getManagerCapabilityFilter()?.allowed(cap: cap) ?? true) == false
            ) {
                return nil
            }

            return cap
        }

        /// Retrieves a private Capability from the Delegator or nil none is found of the given type. Useful for
        /// arbitrary Capability retrieval
        ///
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            if let d = self.delegator.borrow() {
                return d.getPrivateCapability(type)
            }

            return nil
        }

        /// Retrieves a public Capability from the Delegator or nil none is found of the given type. Useful for
        /// arbitrary Capability retrieval
        ///
        pub fun getPublicCapFromDelegator(type: Type): Capability? {
            if let d = self.delegator.borrow() {
                return d.getPublicCapability(type)
            }
            return nil
        }

        /// Enables retrieval of public Capabilities of the given type from the specified path or nil if none is found.
        /// Callers should be aware this method uses the `CapabilityFactory` retrieval path.
        ///
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability? {
            return self.getCapability(path: path, type: type)
        }

        /// Returns a reference to the stored managerCapabilityFilter if one exists
        ///
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}? {
            return self.managerCapabilityFilter != nil ? self.managerCapabilityFilter!.borrow() : nil
        }

        /// Sets the child account as redeemed by the given Address
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            let acct = self.childCap.borrow()!.borrowAccount()
            if let o = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                o.setRedeemed(addr)
            }
        }

        /// Returns a reference to the stored delegator, generally used for arbitrary Capability retrieval
        ///
        pub fun borrowCapabilityDelegator(): &CapabilityDelegator.Delegator? {
            let path = HybridCustody.getCapabilityDelegatorIdentifier(self.parent)
            return self.childCap.borrow()!.borrowAccount().borrow<&CapabilityDelegator.Delegator>(
                from: StoragePath(identifier: path)!
            )
        }

        /// Returns a list of supported metadata views
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        /// Resolves a view of the given type if supported
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let childAddress = self.getAddress()
                    let manager = getAccount(self.parent).getCapability<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(HybridCustody.ManagerPublicPath)

                    if !manager.check() {
                        return nil
                    }

                    return manager!.borrow()!.getChildAccountDisplay(address: childAddress)
            }
            return nil
        }

        /// Callback to enable parent-initiated removal all the child account and its associated resources &
        /// Capabilities
        ///
        access(contract) fun parentRemoveChildCallback(parent: Address) {
            if !self.childCap.check() {
                return
            }

            let child: &AnyResource{HybridCustody.BorrowableAccount} = self.childCap.borrow()!
            if !child.check() {
                return
            }

            let acct = child.borrowAccount()
            if let ownedAcct = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                ownedAcct.removeParent(parent: parent)
            }
        }

        init(
            _ childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>,
            _ factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            _ filter: Capability<&{CapabilityFilter.Filter}>,
            _ delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>,
            _ parent: Address
        ) {
            pre {
                childCap.check(): "Provided childCap Capability is invalid"
                factory.check(): "Provided factory Capability is invalid"
                filter.check(): "Provided filter Capability is invalid"
                delegator.check(): "Provided delegator Capability is invalid"
            }
            self.childCap = childCap
            self.factory = factory
            self.filter = filter
            self.delegator = delegator
            self.managerCapabilityFilter = nil // this will get set when a parent account redeems
            self.parent = parent

            self.data = {}
            self.resources <- {}
        }

        /// Returns a capability to this child account's CapabilityFilter
        ///
        pub fun getCapabilityFilter(): &{CapabilityFilter.Filter}? {
            return self.filter.check() ? self.filter.borrow() : nil
        }

        /// Returns a capability to this child account's CapabilityFactory
        ///
        pub fun getCapabilityFactoryManager(): &{CapabilityFactory.Getter}? {
            return self.factory.check() ? self.factory.borrow() : nil
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// A resource which sits on the account it manages to make it easier for apps to configure the behavior they want 
    /// to permit. An OwnedAccount can be used to create ChildAccount resources and share them, publishing them to
    /// other addresses.
    /// 
    /// The OwnedAccount can also be used to pass ownership of an account off to another address, or to relinquish
    /// ownership entirely, marking the account as owned by no one. Note that even if there isn't an owner, the parent
    /// accounts would still exist, allowing a form of Hybrid Custody which has no true owner over an account, but
    /// shared partial ownership.
    ///
    pub resource OwnedAccount: OwnedAccountPrivate, BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver {
        /// Capability on the underlying account object
        access(self) var acct: Capability<&AuthAccount>

        /// Mapping of current and pending parents, true and false respectively
        pub let parents: {Address: Bool}
        /// Address of the pending owner, if one exists
        pub var pendingOwner: Address?
        /// Address of the current owner, if one exists
        pub var acctOwner: Address?
        /// Owned status of this account
        pub var currentlyOwned: Bool

        /// A bucket of structs so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// display is its own field on the OwnedAccount resource because only the owner of the child account should be
        /// able to set this field.
        access(self) var display: MetadataViews.Display?

        /// Callback that sets this OwnedAccount as redeemed by the parent
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            pre {
                self.parents[addr] != nil: "address is not waiting to be redeemed"
            }

            self.parents[addr] = true
        }

        /// Callback that sets the owner once redeemed
        ///
        access(contract) fun setOwnerCallback(_ addr: Address) {
            pre {
                self.pendingOwner == addr: "Address does not match pending owner!"
            }
            self.pendingOwner = nil
            self.acctOwner = addr
        }


        /// A helper method to make it easier to manage what parents an account has configured. The steps to sharing this
        /// OwnedAccount with a new parent are:
        /// 
        /// 1. Create a new CapabilityDelegator for the ChildAccount resource being created. We make a new one here because
        ///    CapabilityDelegator types are meant to be shared explicitly. Making one shared base-line of capabilities might
        ///    introduce unforseen behavior where an app accidentally shared something to all accounts when it only meant
        ///    to go to one of them. It is better for parent accounts to have less access than they might have anticipated,
        ///    than for a child to have given out access it did not intend to.
        /// 2. Create a new Capability<&{BorrowableAccount}> which has its own unique path for the parent to share this
        ///    child account with. We make new ones each time so that you can revoke access from one parent, without
        ///    destroying them all. A new link is made each time based on the address being shared to allow this
        ///    fine-grained control, but it is all managed by the OwnedAccount resource itself.
        /// 3. A new @ChildAccount resource is created and saved, using the CapabilityDelegator made in step one, and our
        ///    CapabilityFactory and CapabilityFilter Capabilities. Once saved, public and private links are configured for
        ///    the ChildAccount.
        /// 4. Publish the newly made private link to the designated parent's inbox for them to claim on their @Manager
        ///    resource.
        ///
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre{
                self.parents[parentAddress] == nil: "Address pending or already redeemed as parent"
            }
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parentAddress)

            let identifier = HybridCustody.getChildAccountIdentifier(parentAddress)
            let childAccountStorage = StoragePath(identifier: identifier)!

            let capDelegatorStorage = StoragePath(identifier: capDelegatorIdentifier)!
            let acct = self.borrowAccount()

            assert(acct.borrow<&AnyResource>(from: capDelegatorStorage) == nil, message: "conflicting resource found in capability delegator storage slot for parentAddress")
            assert(acct.borrow<&AnyResource>(from: childAccountStorage) == nil, message: "conflicting resource found in child account storage slot for parentAddress")

            if acct.borrow<&CapabilityDelegator.Delegator>(from: capDelegatorStorage) == nil {
                let delegator <- CapabilityDelegator.createDelegator()
                acct.save(<-delegator, to: capDelegatorStorage)
            }

            let capDelegatorPublic = PublicPath(identifier: capDelegatorIdentifier)!
            let capDelegatorPrivate = PrivatePath(identifier: capDelegatorIdentifier)!

            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic}>(
                capDelegatorPublic,
                target: capDelegatorStorage
            )
            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate,
                target: capDelegatorStorage
            )
            let delegator = acct.getCapability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate
            )
            assert(delegator.check(), message: "failed to setup capability delegator for parent address")

            let borrowableCap = self.borrowAccount().getCapability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>(
                HybridCustody.OwnedAccountPrivatePath
            )
            let childAcct <- create ChildAccount(borrowableCap, factory, filter, delegator, parentAddress)

            let childAccountPrivatePath = PrivatePath(identifier: identifier)!

            acct.save(<-childAcct, to: childAccountStorage)
            acct.link<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath, target: childAccountStorage)
            
            let delegatorCap = acct.getCapability<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath)
            assert(delegatorCap.check(), message: "Delegator capability check failed")

            acct.inbox.publish(delegatorCap, name: identifier, recipient: parentAddress)
            self.parents[parentAddress] = false

            emit ChildAccountPublished(
                ownedAcctID: self.uuid,
                childAcctID: delegatorCap.borrow()!.uuid,
                capDelegatorID: delegator.borrow()!.uuid,
                factoryID: factory.borrow()!.uuid,
                filterID: filter.borrow()!.uuid,
                filterType: filter.borrow()!.getType(),
                child: self.getAddress(),
                pendingParent: parentAddress
            )
        }

        /// Checks the validity of the encapsulated account Capability
        ///
        pub fun check(): Bool {
            return self.acct.check()
        }

        /// Returns a reference to the encapsulated account object
        ///
        pub fun borrowAccount(): &AuthAccount {
            return self.acct.borrow()!
        }

        /// Returns the addresses of all associated parents pending and active
        ///
        pub fun getParentAddresses(): [Address] {
            return self.parents.keys
        }

        /// Returns whether the given address is a parent of this account
        ///
        pub fun isChildOf(_ addr: Address): Bool {
            return self.parents[addr] != nil
        }

        /// Returns nil if the given address is not a parent, false if the parent has not redeemed the child account
        /// yet, and true if they have
        ///
        pub fun getRedeemedStatus(addr: Address): Bool? {
            return self.parents[addr]
        }

        /// Returns associated parent addresses and their redeemed status
        ///
        pub fun getParentStatuses(): {Address: Bool} {
            return self.parents
        }

        /// Unlinks all paths configured when publishing an account, and destroy's the @ChildAccount resource 
        /// configured for the provided parent address. Once done, the parent will not have any valid capabilities with
        /// which to access the child account.
        ///
        pub fun removeParent(parent: Address): Bool {
            if self.parents[parent] == nil {
                return false
            }
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)

            let acct = self.borrowAccount()
            acct.unlink(PrivatePath(identifier: identifier)!)
            acct.unlink(PublicPath(identifier: identifier)!)

            acct.unlink(PrivatePath(identifier: capDelegatorIdentifier)!)
            acct.unlink(PublicPath(identifier: capDelegatorIdentifier)!)

            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: identifier)!)
            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: capDelegatorIdentifier)!)

            self.parents.remove(key: parent)
            emit AccountUpdated(id: self.uuid, child: self.acct.address, parent: parent, active: false)

            let parentManager = getAccount(parent).getCapability<&Manager{ManagerPublic}>(HybridCustody.ManagerPublicPath)
            if parentManager.check() {
                parentManager.borrow()?.removeParentCallback(child: self.owner!.address)
            }

            return true
        }

        /// Returns the address of the encapsulated account
        ///
        pub fun getAddress(): Address {
            return self.acct.address
        }

        /// Returns the address of the pending owner if one is assigned. Pending owners are assigned when ownership has
        /// been granted, but has not yet been redeemed.
        ///
        pub fun getPendingOwner(): Address? {
            return self.pendingOwner
        }

        /// Returns the address of the current owner if one is assigned. Current owners are assigned when ownership has
        /// been redeemed.
        ///
        pub fun getOwner(): Address? {
            if !self.currentlyOwned {
                return nil
            }
            return self.acctOwner != nil ? self.acctOwner! : self.owner!.address
        }

        /// This method is used to transfer ownership of the child account to a new address.
        /// Ownership here means that one has unrestricted access on this OwnedAccount resource, giving them full
        /// access to the account.
        ///
        /// **NOTE:** The existence of this method does not imply that it is the only way to receive access to a
        /// OwnedAccount Capability or that only the labeled 'acctOwner' has said access. Rather, this is a convenient
        /// mechanism intended to easily transfer 'root' access on this account to another account and an attempt to
        /// minimize access vectors.
        ///
        pub fun giveOwnership(to: Address) {
            self.seal()
            
            let acct = self.borrowAccount()
            // Unlink existing owner's Capability if owner exists
            if self.acctOwner != nil {
                acct.unlink(
                    PrivatePath(identifier: HybridCustody.getOwnerIdentifier(self.acctOwner!))!
                )
            }
            // Link a Capability for the new owner, retrieve & publish
            let identifier =  HybridCustody.getOwnerIdentifier(to)
            let cap = acct.link<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>(
                    PrivatePath(identifier: identifier)!,
                    target: HybridCustody.OwnedAccountStoragePath
                ) ?? panic("failed to link child account capability")

            acct.inbox.publish(cap, name: identifier, recipient: to)

            self.pendingOwner = to
            self.currentlyOwned = true

            emit OwnershipGranted(ownedAcctID: self.uuid, child: self.acct.address, previousOwner: self.getOwner(), pendingOwner: to)
        }

        /// Revokes all keys on the underlying account
        ///
        pub fun revokeAllKeys() {
            let acct = self.borrowAccount()

            // Revoke all keys
            acct.keys.forEach(fun (key: AccountKey): Bool {
                if !key.isRevoked {
                    acct.keys.revoke(keyIndex: key.keyIndex)
                }
                return true
            })
        }

        /// Cancels all existing AuthAccount capabilities, and creates a new one. The newly created capability will 
        /// then be used by the child account for accessing its AuthAccount going forward.
        ///
        /// This is used when altering ownership of an account, and can also be used as a safeguard for anyone who
        /// assumes ownership of an account to guarantee that the previous owner doesn't maintain admin access to the
        /// account via other AuthAccount Capabilities.
        ///
        pub fun rotateAuthAccount() {
            let acct = self.borrowAccount()

            // Find all active AuthAccount capabilities so they can be removed after we make the new auth account cap
            let pathsToUnlink: [PrivatePath] = []
            acct.forEachPrivate(fun (path: PrivatePath, type: Type): Bool {
                if type.identifier == "Capability<&AuthAccount>" {
                    pathsToUnlink.append(path)
                }
                return true
            })

            // Link a new AuthAccount Capability
            // NOTE: This path cannot be sufficiently randomly generated, an app calling this function could build a
            // capability to this path before it is made, thus maintaining ownership despite making it look like they
            // gave it away. Until capability controllers, this method should not be fully trusted.
            let authAcctPath = "HybridCustodyRelinquished_"
                .concat(HybridCustody.account.address.toString())
                .concat(getCurrentBlock().height.toString())
                .concat(unsafeRandom().toString()) // ensure that the path is different from the previous one
            let acctCap = acct.linkAccount(PrivatePath(identifier: authAcctPath)!)!

            self.acct = acctCap
            let newAcct = self.acct.borrow()!

            // cleanup, remove all previously found paths. We had to do it in this order because we will be unlinking
            // the existing path which will cause a deference issue with the originally borrowed auth account
            for  p in pathsToUnlink {
                newAcct.unlink(p)
            }
        }

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the @OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all parent
        /// accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an owner.
        ///
        /// USE WITH EXTREME CAUTION.
        ///
        pub fun seal() {
            self.rotateAuthAccount()
            self.revokeAllKeys() // There needs to be a path to giving ownership that doesn't revoke keys   
            emit AccountSealed(id: self.uuid, address: self.acct.address, parents: self.parents.keys)
            self.currentlyOwned = false
        }

        /// Retrieves a reference to the ChildAccount associated with the given parent account if one exists.
        ///
        pub fun borrowChildAccount(parent: Address): &ChildAccount? {
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            return self.borrowAccount().borrow<&ChildAccount>(from: StoragePath(identifier: identifier)!)
        }

        /// Sets the CapabilityFactory Manager for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFactoryForParent(
            parent: Address,
            cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>
        ) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFactory(cap: cap)
        }

        /// Sets the Filter for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFilter(cap: cap)
        }

        /// Retrieves a reference to the Delegator associated with the given parent account if one exists.
        ///
        pub fun borrowCapabilityDelegatorForParent(parent: Address): &CapabilityDelegator.Delegator? {
            let identifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)
            return self.borrowAccount().borrow<&CapabilityDelegator.Delegator>(from: StoragePath(identifier: identifier)!)
        }

        /// Adds the provided Capability to the Delegator associated with the given parent account.
        ///
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.addCapability(cap: cap, isPublic: isPublic)
        }

        /// Removes the provided Capability from the Delegator associated with the given parent account.
        ///
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.removeCapability(cap: cap)
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return self.display
            }
            return nil
        }

        /// Sets this OwnedAccount's display to the one provided
        ///
        pub fun setDisplay(_ d: MetadataViews.Display) {
            self.display = d
        }

        init(
            _ acct: Capability<&AuthAccount>
        ) {
            self.acct = acct

            self.parents = {}
            self.pendingOwner = nil
            self.acctOwner = nil
            self.currentlyOwned = true

            self.data = {}
            self.resources <- {}
            self.display = nil
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// Utility function to get the path identifier for a parent address when interacting with a ChildAccount and its
    /// parents
    ///
    pub fun getChildAccountIdentifier(_ addr: Address): String {
        return "ChildAccount_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with a Delegator and its
    /// parents
    ///
    pub fun getCapabilityDelegatorIdentifier(_ addr: Address): String {
        return "ChildCapabilityDelegator_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with an OwnedAccount and its
    /// owners
    ///
    pub fun getOwnerIdentifier(_ addr: Address): String {
        return "HybridCustodyOwnedAccount_".concat(HybridCustody.account.address.toString()).concat(addr.toString())
    }

    /// Returns an OwnedAccount wrapping the provided AuthAccount Capability.
    ///
    pub fun createOwnedAccount(
        acct: Capability<&AuthAccount>
    ): @OwnedAccount {
        pre {
            acct.check(): "invalid auth account capability"
        }

        let ownedAcct <- create OwnedAccount(acct)
        emit CreatedOwnedAccount(id: ownedAcct.uuid, child: acct.borrow()!.address)
        return <- ownedAcct
    }

    /// Returns a new Manager with the provided Filter as default (if not nil).
    ///
    pub fun createManager(filter: Capability<&{CapabilityFilter.Filter}>?): @Manager {
        pre {
            filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
        }
        let manager <- create Manager(filter: filter)
        emit CreatedManager(id: manager.uuid)
        return <- manager
    }

    init() {
        let identifier = "HybridCustodyChild_".concat(self.account.address.toString())
        self.OwnedAccountStoragePath = StoragePath(identifier: identifier)!
        self.OwnedAccountPrivatePath = PrivatePath(identifier: identifier)!
        self.OwnedAccountPublicPath = PublicPath(identifier: identifier)!

        self.LinkedAccountPrivatePath = PrivatePath(identifier: "LinkedAccountPrivatePath_".concat(identifier))!
        self.BorrowableAccountPrivatePath = PrivatePath(identifier: "BorrowableAccountPrivatePath_".concat(identifier))!

        let managerIdentifier = "HybridCustodyManager_".concat(self.account.address.toString())
        self.ManagerStoragePath = StoragePath(identifier: managerIdentifier)!
        self.ManagerPublicPath = PublicPath(identifier: managerIdentifier)!
        self.ManagerPrivatePath = PrivatePath(identifier: managerIdentifier)!
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/NFTProviderFactory.cdc

```
import "CapabilityFactory"
import "NonFungibleToken"

pub contract NFTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.Provider}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/read_listing_details.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// This script returns the details for a listing within a storefront
///
access(all) fun main(account: Address, listingResourceID: UInt64): NFTStorefrontV2.ListingDetails {
    let storefrontRef = getAccount(account).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        ) ?? panic("Could not borrow public storefront from address")
    let listing = storefrontRef.borrowListing(listingResourceID: listingResourceID)
        ?? panic("No listing with that ID")
    
    return listing.getDetails()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item_and_replace_current_listing.cdc

```
import ExampleToken from "../contracts/utility/ExampleToken.cdc"
import FungibleToken from "../contracts/utility/FungibleToken.cdc"
import NonFungibleToken from "../contracts/utility/NonFungibleToken.cdc"
import ExampleNFT from "../contracts/utility/ExampleNFT.cdc"
import MetadataViews from "../contracts/utility/MetadataViews.cdc"
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Transaction used to facilitate the creation of the listing under the signer's owned storefront resource.
/// It accepts the certain details from the signer,i.e. - 
///
/// `saleItemID` - ID of the NFT that is put on sale by the seller.
/// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.
/// `customID` - Optional string to represent identifier of the dapp.
/// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.
/// `expiry` - Unix timestamp at which created listing become expired.
/// `marketplacesAddress` - List of addresses that are allowed to get the commission.

/// If the given nft has a support of the RoyaltyView then royalties will added as the sale cut.

transaction(
    saleItemID: UInt64,
    saleItemPrice: UFix64,
    customID: String?,
    commissionAmount: UFix64,
    expiry: UInt64,
    marketplacesAddress: [Address]
) {

    let tokenReceiver: Capability<&{FungibleToken.Receiver}>
    let exampleNFTProvider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>
    let storefront: auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront
    var saleCuts: [NFTStorefrontV2.SaleCut]
    var marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]

    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, StorageCapabilities) &Account) {
        self.saleCuts = []
        self.marketplacesCapability = []

        let collectionData = ExampleNFT.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")

        // Receiver for the sale cut.
        self.tokenReceiver = acct.capabilities.get<&{FungibleToken.Receiver}>(/public/exampleTokenReceiver)
        assert(self.tokenReceiver.borrow() != nil, message: "Missing or mis-typed ExampleToken receiver")

        var nftProviderCap: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? = nil
        // check if there is an existing capability/capability controller for the storage path
        let nftCollectionControllers = acct.capabilities.storage.getControllers(forPath: collectionData.storagePath)
        for controller in nftCollectionControllers {
            if let maybeProviderCap = controller.capability as? Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>? {
                nftProviderCap = maybeProviderCap
                break
            }
        }

        // if there are no capabilities created for that storage path
        // or if existing capability is no longer valid, issue a new one
        if nftProviderCap == nil || nftProviderCap?.check() ?? false {
            nftProviderCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                collectionData.storagePath
            )
        }
        assert(nftProviderCap?.check() ?? false, message: "Could not assign Provider Capability")

        self.exampleNFTProvider = nftProviderCap!

        let collection = acct.capabilities.borrow<&{NonFungibleToken.Collection}>(
                collectionData.publicPath
            ) ?? panic("Could not borrow a reference to the signer's collection")

        var totalRoyaltyCut = 0.0
        let effectiveSaleItemPrice = saleItemPrice - commissionAmount
        let nft = collection.borrowNFT(saleItemID)!
        // Check whether the NFT implements the MetadataResolver or not.
        if nft.getViews().contains(Type<MetadataViews.Royalties>()) {
            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
            for royalty in royalties {
                // TODO - Verify the type of the vault and it should exists
                self.saleCuts.append(
                    NFTStorefrontV2.SaleCut(
                        receiver: royalty.receiver,
                        amount: royalty.cut * effectiveSaleItemPrice
                    )
                )
                totalRoyaltyCut = totalRoyaltyCut + (royalty.cut * effectiveSaleItemPrice)
            }
        }
        // Append the cut for the seller.
        self.saleCuts.append(
            NFTStorefrontV2.SaleCut(
                receiver: self.tokenReceiver,
                amount: effectiveSaleItemPrice - totalRoyaltyCut
            )
        )
        assert(self.exampleNFTProvider.borrow() != nil, message: "Missing or mis-typed ExampleNFT.Collection provider")

        self.storefront = acct.storage.borrow<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>(
                from: NFTStorefrontV2.StorefrontStoragePath
            ) ?? panic("Missing or mis-typed NFTStorefront Storefront")

        for marketplace in marketplacesAddress {
            // Here we are making a fair assumption that all given addresses would have
            // the capability to receive the `ExampleToken`
            self.marketplacesCapability.append(
                getAccount(marketplace).capabilities.get<&{FungibleToken.Receiver}>(/public/exampleTokenReceiver)
            )
        }
    }

    execute {
        // check for existing listings of the NFT
        var existingListingIDs = self.storefront.getExistingListingIDs(
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: saleItemID
        )
        // remove existing listings
        for listingID in existingListingIDs {
            self.storefront.removeListing(listingResourceID: listingID)
        }
        // Create listing
        self.storefront.createListing(
            nftProviderCapability: self.exampleNFTProvider,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@ExampleToken.Vault>(),
            saleCuts: self.saleCuts,
            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,
            customID: customID,
            commissionAmount: commissionAmount,
            expiry: expiry
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/CapabilityDelegator.cdc

```
/// CapabilityDelegator is a contract used to share Capabiltities to other accounts. It is used by the
/// HybridCustody contract to allow more flexible sharing of Capabilities when an app wants to share things
/// that aren't the NFT-standard interface types.
/// 
/// Inside of CapabilityDelegator is a resource called `Delegator` which maintains a mapping of public and private
/// Capabilities. They cannot and should not be mixed. A public `Delegator` is able to be borrowed by anyone, whereas a
/// private `Delegator` can only be borrowed from the child account when you have access to the full `ChildAccount` 
/// resource.
///
pub contract CapabilityDelegator {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath
    
    /* --- Events --- */
    //
    pub event DelegatorCreated(id: UInt64)
    pub event DelegatorUpdated(id: UInt64, capabilityType: Type, isPublic: Bool, active: Bool)

    /// Private interface for Capability retrieval
    ///
    pub resource interface GetterPrivate {
        pub fun getPrivateCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type"
            }
        }
        pub fun findFirstPrivateType(_ type: Type): Type?
        pub fun getAllPrivate(): [Capability]
    }

    /// Exposes public Capability retrieval
    ///
    pub resource interface GetterPublic {
        pub fun getPublicCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type "
            }
        }

        pub fun findFirstPublicType(_ type: Type): Type?
        pub fun getAllPublic(): [Capability]
    }

    /// This Delegator is used to store Capabilities, partitioned by public and private access with corresponding
    /// GetterPublic and GetterPrivate conformances.AccountCapabilityController
    ///
    pub resource Delegator: GetterPublic, GetterPrivate {
        access(self) let privateCapabilities: {Type: Capability}
        access(self) let publicCapabilities: {Type: Capability}

        // ------ Begin Getter methods
        //
        /// Returns the public Capability of the given Type if it exists
        ///
        pub fun getPublicCapability(_ type: Type): Capability? {
            return self.publicCapabilities[type]
        }

        /// Returns the private Capability of the given Type if it exists
        ///
        ///
        /// @param type: Type of the Capability to retrieve
        /// @return Capability of the given Type if it exists, nil otherwise
        ///
        pub fun getPrivateCapability(_ type: Type): Capability? {
            return self.privateCapabilities[type]
        }

        /// Returns all public Capabilities
        ///
        /// @return List of all public Capabilities
        ///
        pub fun getAllPublic(): [Capability] {
            return self.publicCapabilities.values
        }

        /// Returns all private Capabilities
        ///
        /// @return List of all private Capabilities
        ///
        pub fun getAllPrivate(): [Capability] {
            return self.privateCapabilities.values
        }

        /// Returns the first public Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First public Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPublicType(_ type: Type): Type? {
            for t in self.publicCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }

        /// Returns the first private Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First private Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPrivateType(_ type: Type): Type? {
            for t in self.privateCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }
        // ------- End Getter methods

        /// Adds a Capability to the Delegator
        ///
        /// @param cap: Capability to add
        /// @param isPublic: Whether the Capability should be public or private
        ///
        pub fun addCapability(cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
            if isPublic {
                self.publicCapabilities.insert(key: cap.getType(), cap)
            } else {
                self.privateCapabilities.insert(key: cap.getType(), cap)
            }
            emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: isPublic, active: true)
        }

        /// Removes a Capability from the Delegator
        ///
        /// @param cap: Capability to remove
        ///
        pub fun removeCapability(cap: Capability) {
            if let removedPublic = self.publicCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: true, active: false)
            }
            
            if let removedPrivate = self.privateCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: false, active: false)
            }
        }

        init() {
            self.privateCapabilities = {}
            self.publicCapabilities = {}
        }
    }

    /// Creates a new Delegator and returns it
    /// 
    /// @return Newly created Delegator
    ///
    pub fun createDelegator(): @Delegator {
        let delegator <- create Delegator()
        emit DelegatorCreated(id: delegator.uuid)
        return <- delegator
    }
    
    init() {
        let identifier = "CapabilityDelegator_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/scripts/read_storefront_ids.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

// This script returns an array of all the nft uuids for sale through a Storefront

access(all) fun main(account: Address): [UInt64] {
    return getAccount(account).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
            NFTStorefrontV2.StorefrontPublicPath
        )?.getListingIDs()
        ?? panic("Could not borrow public storefront from address")
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/factories/FTReceiverFactory.cdc

```
import "CapabilityFactory"
import "FungibleToken"

pub contract FTReceiverFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Receiver}>(path)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/hybrid-custody/CapabilityFactory.cdc

```
/// # Capability Factory
///
/// This contract defines a Factory interface and a Manager resource to contain Factory implementations, as well as a
/// Getter interface for retrieval of contained Factories.
/// 
/// A Factory is defines a method getCapability() which defines the retrieval pattern of a Capability from a given
/// account at the specified path. This pattern arose out of a need to retrieve arbitrary & castable Capabilities from
/// an account under the static typing constraints inherent to Cadence.
///
/// The Manager resource is a container for Factories, and implements the Getter interface.
///
/// **Note:** It's generally an anti-pattern to pass around AuthAccount references; however, the need for castable
/// Capabilities is critical to the use case of Hybrid Custody. It's advised to use Factories sparingly and only for
/// cases where Capabilities must be castable by the caller.
///
pub contract CapabilityFactory {
    
    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath
    
    /// Factory structures a common interface for Capability retrieval from a given account at a specified path
    ///
    pub struct interface Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability
    }

    /// Getter defines an interface for retrieval of a Factory if contained within the implementing resource
    ///
    pub resource interface Getter {
        pub fun getSupportedTypes(): [Type]
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}?
    }

    /// Manager is a resource that contains Factories and implements the Getter interface for retrieval of contained
    /// Factories
    ///
    pub resource Manager: Getter {
        /// Mapping of Factories indexed on Type of Capability they retrieve
        pub let factories: {Type: {CapabilityFactory.Factory}}

        /// Retrieves a list of Types supported by contained Factories
        ///
        /// @return List of Types supported by the Manager
        ///
        pub fun getSupportedTypes(): [Type] {
            return self.factories.keys
        }

        /// Retrieves a Factory from the Manager, returning it or nil if it doesn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories[t]
        }

        /// Adds a Factory to the Manager, conditioned on the Factory not already existing
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to add
        ///
        pub fun addFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            pre {
                !self.factories.containsKey(t): "Factory of given type already exists"
            }
            self.factories[t] = f
        }

        /// Updates a Factory in the Manager, adding if it didn't already exist
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to replace existing Factory
        ///
        pub fun updateFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            self.factories[t] = f
        }

        /// Removes a Factory from the Manager, returning it or nil if it didn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun removeFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories.remove(key: t)
        }

        init () {
            self.factories = {}
        }
    }

    /// Creates a Manager resource
    ///
    /// @return Manager resource
    pub fun createFactoryManager(): @Manager {
        return <- create Manager()
    }

    init() {
        let identifier = "CapabilityFactory_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/buy_item.cdc

```
import "ExampleToken"
import "FungibleToken"
import "NonFungibleToken"
import "ExampleNFT"
import "NFTStorefront"
import "MetadataViews"

transaction(listingResourceID: UInt64, storefrontAddress: Address) {

    let paymentVault: @{FungibleToken.Vault}
    let exampleNFTReceiver: &{NonFungibleToken.Receiver}
    let storefront: &{NFTStorefront.StorefrontPublic}
    let listing: &{NFTStorefront.ListingPublic}

    prepare(acct: auth(BorrowValue) &Account) {
        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath
            ) ?? panic("Could not borrow StorefrontPublic from provided address")

        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
                    ?? panic("No Offer with that ID in Storefront")
        let price = self.listing.getDetails().salePrice

        let mainVault = acct.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: /storage/exampleTokenVault)
            ?? panic("Cannot borrow ExampleToken vault from acct storage")
        self.paymentVault <- mainVault.withdraw(amount: price)

        let collectionDataOpt = ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
            ?? panic("Missing collection data")
        let collectionData = collectionDataOpt as! MetadataViews.NFTCollectionData


        self.exampleNFTReceiver = acct.capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("Cannot borrow NFT collection receiver from account")
    }

    execute {
        let item <- self.listing.purchase(
            payment: <-self.paymentVault
        )

        self.exampleNFTReceiver.deposit(token: <-item)

        /*
        error: Execution failed:
        computation limited exceeded: 100
        */
        // Be kind and recycle
        self.storefront.cleanup(listingResourceID: listingResourceID)
    }

    //- Post to check item is in collection?
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/example-token/setup_account.cdc

```
// This transaction is a template for a transaction to allow
// anyone to add a Vault resource to their account so that
// they can use the exampleToken

import "FungibleToken"
import "ExampleToken"
import "ViewResolver"
import "FungibleTokenMetadataViews"

transaction () {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("ViewResolver does not resolve FTVaultData view")

        // Return early if the account already stores a ExampleToken Vault
        if signer.storage.borrow<&ExampleToken.Vault>(from: vaultData.storagePath) != nil {
            return
        }

        let vault <- ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())

        // Create a new ExampleToken Vault and put it in storage
        signer.storage.save(<-vault, to: vaultData.storagePath)

        // Create a public capability to the Vault that exposes the Vault interfaces
        let vaultCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)

        // Create a public Capability to the Vault's Receiver functionality
        let receiverCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions-v1/scripts-v1/read_storefront_ids.cdc

```
import "NFTStorefront"

/// This script returns an array of all the Listing IDs for sale through a Storefront
///
access(all) fun main(account: Address): [UInt64] {
    return getAccount(account).capabilities.borrow<&{NFTStorefront.StorefrontPublic}>(
            NFTStorefront.StorefrontPublicPath
        )?.getListingIDs()
        ?? panic("Could not borrow public storefront from address")
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/tests/transactions/create_malicious_listing_v2.cdc

```
import "ExampleNFT"
import "ExampleToken"
import "FungibleToken"
import "NonFungibleToken"
import "NFTStorefrontV2"
import "MaliciousStorefrontV2"

transaction {
    prepare(acct: auth(Storage, Capabilities) &Account) {
        if acct.storage.borrow<&AnyResource>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {
            acct.storage.save(<-NFTStorefrontV2.createStorefront(), to: NFTStorefrontV2.StorefrontStoragePath)
        }

        if acct.storage.borrow<&AnyResource>(from: ExampleToken.VaultStoragePath) == nil {
            let vault <- ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())
            acct.storage.save(<-vault, to: ExampleToken.VaultStoragePath)

            acct.capabilities.publish(
                acct.capabilities.storage.issue<&ExampleToken.Vault>(ExampleToken.VaultStoragePath),
                at: ExampleToken.ReceiverPublicPath
            )
        }

        if acct.storage.borrow<&AnyResource>(from: ExampleNFT.CollectionStoragePath) == nil {
            let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
            acct.storage.save(<-collection, to: ExampleNFT.CollectionStoragePath)

            acct.capabilities.publish(
                acct.capabilities.storage.issue<&ExampleNFT.Collection>(ExampleNFT.CollectionStoragePath),
                at: ExampleNFT.CollectionPublicPath
            )
        }

        let storefrontCap = acct.capabilities.storage.issue<auth(NFTStorefrontV2.CreateListing, NFTStorefrontV2.RemoveListing) &NFTStorefrontV2.Storefront>(NFTStorefrontV2.StorefrontStoragePath)
        let providerCap = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(ExampleNFT.CollectionStoragePath)

        if acct.storage.borrow<&AnyResource>(from: MaliciousStorefrontV2.StorefrontStoragePath) == nil {
            acct.storage.save(<- MaliciousStorefrontV2.createStorefront(storefrontCap: storefrontCap), to: MaliciousStorefrontV2.StorefrontStoragePath)
            acct.capabilities.publish(
                acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(MaliciousStorefrontV2.StorefrontStoragePath),
                at: MaliciousStorefrontV2.StorefrontPublicPath
            )
        }

        let maliciousStorefront = acct.storage.borrow<auth(NFTStorefrontV2.CreateListing) &MaliciousStorefrontV2.Storefront>(from: MaliciousStorefrontV2.StorefrontStoragePath)!
        let saleCut = NFTStorefrontV2.SaleCut(
            receiver: acct.capabilities.get<&{FungibleToken.Receiver}>(ExampleToken.ReceiverPublicPath), 
            amount: 1.0
        )

        // borrow a reference to the NFTMinter resource in storage
        let minter = acct.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Account does not store an object at the specified path")

        let nft <- minter.mintNFT(
            name: "Legit NFT",
            description: "I'm the real one",
            thumbnail: "",
            royalties: []
        )

        let maliciousNft <- minter.mintNFT(
            name: "Not Fake",
            description: "Definitely Not Fake",
            thumbnail: "I swear",
            royalties: []
        )

        let nftId = nft.id
        let maliciousNftId = maliciousNft.id

        let collection = providerCap.borrow()!
        collection.deposit(token: <-nft)
        collection.deposit(token: <-maliciousNft)

        maliciousStorefront.createListing(
            nftProviderCapability: providerCap,
            nftType: Type<@ExampleNFT.NFT>(),
            nftID: nftId,
            maliciousNftId: maliciousNftId,
            salePaymentVaultType: Type<@ExampleToken.Vault>(),
            saleCuts: [saleCut],
            marketplacesCapability: nil,
            customID: nil,
            commissionAmount: 0.0,
            expiry: UInt64(getCurrentBlock().timestamp) + 1_000_000
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/test/MaliciousStorefrontV1.cdc

```
import "NFTStorefront"
import "NonFungibleToken"
import "FungibleToken"
import "FungibleTokenMetadataViews"

/// Thanks to Austin Kline - https://twitter.com/austin_flowty
/// for discovering and reporting the vulnerability that this contract tests
///
/// This is a test contract that implements a malicious storefront
/// to try an sell an NFT with a different ID in the place
/// of a different listing
///
/// There is a test in NFTStorefrontV1_test.cdc that tests this case

access(all) contract MaliciousStorefrontV1 {
    access(all) let StorefrontStoragePath: StoragePath
    access(all) let StorefrontPublicPath: PublicPath

    access(all) resource Storefront: NFTStorefront.StorefrontPublic {
        access(self) let storefrontCap: Capability<auth(NFTStorefront.CreateListing, NFTStorefront.RemoveListing) &NFTStorefront.Storefront>
        access(self) let listings: @{UInt64: Listing}


        access(all) view fun getListingIDs(): [UInt64] {
            return self.storefrontCap.borrow()!.getListingIDs()
        }

        access(all) view fun borrowListing(listingResourceID: UInt64): &{NFTStorefront.ListingPublic}? {
            return &self.listings[listingResourceID]
        }

        access(all) fun cleanup(listingResourceID: UInt64) {
            return
        }

        access(NFTStorefront.CreateListing) fun createListing(
            nftProviderCapability: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>,
            nftType: Type,
            nftID: UInt64,
            maliciousNftId: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [NFTStorefront.SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
        ): UInt64 {
            let storefront = self.storefrontCap.borrow()!
            let listingId = storefront.createListing(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts
            )

            let maliciouslisting <- create Listing(
                storefrontCap: self.storefrontCap,
                listingResourceID: listingId,
                nftId: maliciousNftId,
                provider: nftProviderCapability
            )

            destroy self.listings.insert(key: listingId, <-maliciouslisting)

            return listingId
        }

        init(storefrontCap: Capability<auth(NFTStorefront.CreateListing, NFTStorefront.RemoveListing) &NFTStorefront.Storefront>) {
            self.storefrontCap = storefrontCap
            self.listings <- {}
        }
    }

    access(all) resource Listing: NFTStorefront.ListingPublic {
        access(self) let storefrontCap: Capability<&NFTStorefront.Storefront>

        // this id much match the id of the listing being impersonated
        access(self) let listingResourceID: UInt64

        // this is the id of the nft we are returning instead of the one that a user thinks is being purchased.
        access(self) let nftId: UInt64

        access(contract) let provider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        access(all) fun borrowNFT(): &{NonFungibleToken.NFT}? {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.borrowNFT()
        }

        access(all) fun getDetails(): NFTStorefront.ListingDetails {
            return self.storefrontCap.borrow()!.borrowListing(listingResourceID: self.listingResourceID)!.getDetails()
        }

        // purchase will return the "wrong" nft
        access(all) fun purchase(
            payment: @{FungibleToken.Vault}
        ): @{NonFungibleToken.NFT} {
            let details = self.getDetails()
            assert(payment.balance == details.salePrice, message: "incorrect payment amount")
            assert(payment.getType() == details.salePaymentVaultType, message: "incorrect payment token type")

            let ftVaultData = payment.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>())! as! FungibleTokenMetadataViews.FTVaultData
            if let vault = MaliciousStorefrontV1.account.storage.borrow<&{FungibleToken.Vault}>(from: ftVaultData.storagePath) {
                vault.deposit(from: <- payment)
            } else {
                MaliciousStorefrontV1.account.storage.save(<-payment, to: ftVaultData.storagePath)
            }

            let nft <- self.provider.borrow()!.withdraw(withdrawID: self.nftId)
            return <- nft
        }

        init(
            storefrontCap: Capability<auth(NFTStorefront.CreateListing, NFTStorefront.RemoveListing) &NFTStorefront.Storefront>,
            listingResourceID: UInt64,
            nftId: UInt64,
            provider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
        ) {
            pre {
                provider.check(): "invalid provider capability"
                storefrontCap.check(): "invalid storefront cap"
            }

            let listing = storefrontCap.borrow()!.borrowListing(listingResourceID: listingResourceID) ?? panic("failed to borrow get impersonated listing")
            let details = listing.getDetails()

            self.storefrontCap = storefrontCap
            self.listingResourceID = listingResourceID
            self.nftId = nftId
            self.provider = provider

            assert(provider.borrow()!.borrowNFT(self.nftId) != nil, message: "could not borrow nftID")
            assert(details.nftID != self.nftId, message: "must not return the same id as the original listing")
        }
    }

    access(all) fun createStorefront(storefrontCap: Capability<auth(NFTStorefront.CreateListing, NFTStorefront.RemoveListing) &NFTStorefront.Storefront>): @Storefront {
        return <- create Storefront(storefrontCap: storefrontCap)
    }

    init() {
        self.StorefrontStoragePath = /storage/NFTStorefrontV1Malicious
        self.StorefrontPublicPath = /public/NFTStorefront
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/transactions/cleanup_ghost_listing.cdc

```
import NFTStorefrontV2 from "../contracts/NFTStorefrontV2.cdc"

/// Below transaction help to remove the ghost listing for the given storefront.
///
/// @param listingResourceID Id of the listing resource that would get deleted if it found ghost listing.
/// @param storefrontOwner Address of the storefront resource, Owner of the given `listingResourceID`
///
transaction(listingResourceID: UInt64, storefrontAddress: Address) {

    let storefrontPublicRef: &{NFTStorefrontV2.StorefrontPublic}   

    prepare(acct: &Account) {
        // Access the storefront public resource of the seller to purchase the listing.
        self.storefrontPublicRef = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(
                NFTStorefrontV2.StorefrontPublicPath
            ) ?? panic("Could not borrow Storefront from provided address")
    }

    execute {
        self.storefrontPublicRef.cleanupGhostListings(listingResourceID: listingResourceID)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/README.md

# NFT Storefront Contract Standard

The version of the contracts in the `main` branch is the
Cadence 1.0 version of the contracts and is not the same
as the ones that are currently deployed to testnet and mainnet.
See the `cadence-0.42` branch for the currently deployed versions.

The NFT Storefront contract standard is a cornerstone of the Open Marketplace ecosystem on Flow. An open market ecosystem promotes the 
free flow of NFT listings across the network, emitted as events and consumed by other marketplaces (or any other consumer). Marketplaces may filter 
listings consumed based on commission rates they may receive. Listings may be created with variable commission, royalties or other fractional revenue, paying to multiple accounts. NFT listings are not NFTs, they are Resources which can be transacted with using the `purchase` [function](https://github.com/onflow/nft-storefront/blob/jp-update-structure/contracts/NFTStorefrontV2.cdc#L300) to obtain the token indicated by the listing. 

The NFTStorefront contract lets you create a non-custodial NFT marketplace to simplify integration with off-chain applications/UIs. The contract supports sellers who want to list and manage NFTs for sale simultaneously across any number of marketplaces. Listing expiry, orphaned and ghost listing cleanup are also of value for integrators to minimize overheads and ensure the best UX. 

Marketplaces and sellers also benefit from the robust security guarantees of Flow's account model when trading NFTs. Through this standard a NFT trade takes place from peer-to-peer, directly from the Storefront Resource in the sellers account to the purchasers account. At the same time, the standard ensures that marketplaces or other recipients may receive royalties, fees or commissions with no risk to the seller.

Sellers or marketplaces can optionally configure their NFTStorefront to be limited or closed. However, those wishing to participate in the Open Marketplace ecosystem on Flow are required to use the NFTStorefront standard. 

Detailed docs: [docs/documentation.md](docs/documentation.md)

## Contract Addresses 

|Name|Testnet|Previewnet|Mainnet|
|----|-------|------|-------|
|[NFTStorefront](contracts/NFTStorefront.cdc)|[0x94b06cfca1d8a476](https://flow-view-source.com/testnet/account/0x94b06cfca1d8a476/contract/NFTStorefront)|[0x6df5e52755433994](contracts/NFTStorefront.cdc)|[0x4eb8a10cb9f87357](https://flowscan.org/contract/A.4eb8a10cb9f87357.NFTStorefront)|
|[NFTStorefrontV2 (recommended)](contracts/NFTStorefrontV2.cdc)|[0x2d55b98eb200daef](https://flow-view-source.com/testnet/account/0x2d55b98eb200daef/contract/NFTStorefrontV2)|[0x6df5e52755433994](contracts/NFTStorefrontV2.cdc)|[0x4eb8a10cb9f87357](https://flowscan.org/contract/A.4eb8a10cb9f87357.NFTStorefrontV2)|

## Usage

Each account that wants to offer NFTs for sale installs a `Storefront`,
and then lists individual sales within that `Storefront` as `Listing` resources.

There is one `Storefront` per account that handles sales of all NFT types
for that account.

Each `Listing` can list one or more cut percentages.
Each cut is delivered to a predefined address. 
Cuts can be used to pay listing fees or other considerations.

Each NFT may be listed in one or more `Listing` resources.
The validity of each `Listing` can easily be checked.

Purchasers can watch for `Listing` events and check the NFT type and
ID to see if they wish to buy the offered item.

Marketplaces and other aggregators can watch for `Listing` events
and list items of interest.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/nft-storefront/blob/main/contracts/utility/FungibleToken.cdc

```
/**

# The Flow Fungible Token standard

## `FungibleToken` contract

The Fungible Token standard is no longer an interface
that all fungible token contracts would have to conform to.

If a users wants to deploy a new token contract, their contract
does not need to implement the FungibleToken interface, but their tokens
do need to implement the interfaces defined in this contract.

## `Vault` resource interface

Each fungible token resource type needs to implement the `Vault` resource interface.

## `Provider`, `Receiver`, and `Balance` resource interfaces

These interfaces declare pre-conditions and post-conditions that restrict
the execution of the functions in the Vault.

They are separate because it gives the user the ability to share
a reference to their Vault that only exposes the fields functions
in one or more of the interfaces.

It also gives users the ability to make custom resources that implement
these interfaces to do various things with the tokens.
For example, a faucet can be implemented by conforming
to the Provider interface.

*/

import "ViewResolver"
import "Burner"

/// FungibleToken
///
/// Fungible Token implementations should implement the fungible token
/// interface.
access(all) contract interface FungibleToken: ViewResolver {

    // An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// The event that is emitted when tokens are withdrawn from a Vault
    access(all) event Withdrawn(type: String, amount: UFix64, from: Address?, fromUUID: UInt64, withdrawnUUID: UInt64, balanceAfter: UFix64)

    /// The event that is emitted when tokens are deposited to a Vault
    access(all) event Deposited(type: String, amount: UFix64, to: Address?, toUUID: UInt64, depositedUUID: UInt64, balanceAfter: UFix64)

    /// Event that is emitted when the global burn method is called with a non-zero balance
    access(all) event Burned(type: String, amount: UFix64, fromUUID: UInt64)

    /// Balance
    ///
    /// The interface that provides standard functions\
    /// for getting balance information
    ///
    access(all) resource interface Balance {
        access(all) var balance: UFix64
    }

    /// Provider
    ///
    /// The interface that enforces the requirements for withdrawing
    /// tokens from the implementing type.
    ///
    /// It does not enforce requirements on `balance` here,
    /// because it leaves open the possibility of creating custom providers
    /// that do not necessarily need their own balance.
    ///
    access(all) resource interface Provider {

        /// Function to ask a provider if a specific amount of tokens
        /// is available to be withdrawn
        /// This could be useful to avoid panicing when calling withdraw
        /// when the balance is unknown
        /// Additionally, if the provider is pulling from multiple vaults
        /// it only needs to check some of the vaults until the desired amount
        /// is reached, potentially helping with performance.
        /// 
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool

        /// withdraw subtracts tokens from the implementing resource
        /// and returns a Vault with the removed tokens.
        ///
        /// The function's access level is `access(Withdraw)`
        /// So in order to access it, one would either need the object itself
        /// or an entitled reference with `Withdraw`.
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    "Withdrawal amount must be the same as the balance of the withdrawn Vault"
            }
        }
    }

    /// Receiver
    ///
    /// The interface that enforces the requirements for depositing
    /// tokens into the implementing type.
    ///
    /// We do not include a condition that checks the balance because
    /// we want to give users the ability to make custom receivers that
    /// can do custom things with the tokens, like split them up and
    /// send them to different places.
    ///
    access(all) resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        access(all) fun deposit(from: @{Vault})

        /// getSupportedVaultTypes returns a dictionary of Vault types
        /// and whether the type is currently supported by this Receiver
        access(all) view fun getSupportedVaultTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the Receiver
        /// A vault that can accept any type should just return true by default
        access(all) view fun isSupportedVaultType(type: Type): Bool
    }

    /// Vault
    ///
    /// Ideally, this interface would also conform to Receiver, Balance, Transferor, Provider, and Resolver
    /// but that is not supported yet
    ///
    access(all) resource interface Vault: Receiver, Provider, Balance, ViewResolver.Resolver, Burner.Burnable {

        /// Field that tracks the balance of a vault
        access(all) var balance: UFix64

        /// Called when a fungible token is burned via the `Burner.burn()` method
        /// Implementations can do any bookkeeping or emit any events
        /// that should be emitted when a vault is destroyed.
        /// Many implementations will want to update the token's total supply
        /// to reflect that the tokens have been burned and removed from the supply.
        /// Implementations also need to set the balance to zero before the end of the function
        /// This is to prevent vault owners from spamming fake Burned events.
        access(contract) fun burnCallback() {
            pre {
                emit Burned(type: self.getType().identifier, amount: self.balance, fromUUID: self.uuid)
            }
            post {
                self.balance == 0.0: "The balance must be set to zero during the burnCallback method so that it cannot be spammed"
            }
            self.balance = 0.0
        }

        /// getSupportedVaultTypes returns a dictionary of vault types and whether this receiver accepts the indexed type
        /// The default implementation is included here because vaults are expected
        /// to only accepted their own type, so they have no need to provide an implementation
        /// for this function
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            // Below check is implemented to make sure that run-time type would
            // only get returned when the parent resource conforms with `FungibleToken.Vault`. 
            if self.getType().isSubtype(of: Type<@{FungibleToken.Vault}>()) {
                return {self.getType(): true}
            } else {
                // Return an empty dictionary as the default value for resource who don't
                // implement `FungibleToken.Vault`, such as `FungibleTokenSwitchboard`, `TokenForwarder` etc.
                return {}
            }
        }

        /// Checks if the given type is supported by this Vault
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// withdraw subtracts `amount` from the Vault's balance
        /// and returns a new Vault with the subtracted balance
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            pre {
                self.balance >= amount:
                    "Amount withdrawn must be less than or equal than the balance of the Vault"
            }
            post {
                result.getType() == self.getType(): "Must return the same vault type as self"
                // use the special function `before` to get the value of the `balance` field
                // at the beginning of the function execution
                //
                self.balance == before(self.balance) - amount:
                    "New Vault balance must be the difference of the previous balance and the withdrawn Vault balance"
                emit Withdrawn(
                        type: result.getType().identifier,
                        amount: amount,
                        from: self.owner?.address,
                        fromUUID: self.uuid,
                        withdrawnUUID: result.uuid,
                        balanceAfter: self.balance
                )
            }
        }

        /// deposit takes a Vault and adds its balance to the balance of this Vault
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            // Assert that the concrete type of the deposited vault is the same
            // as the vault that is accepting the deposit
            pre {
                from.isInstance(self.getType()): 
                    "Cannot deposit an incompatible token type"
            }
            post {
                emit Deposited(
                        type: before(from.getType().identifier),
                        amount: before(from.balance),
                        to: self.owner?.address,
                        toUUID: self.uuid,
                        depositedUUID: before(from.uuid),
                        balanceAfter: self.balance
                )
                self.balance == before(self.balance) + before(from.balance):
                    "New Vault balance must be the sum of the previous balance and the deposited Vault"
            }
        }

        /// createEmptyVault allows any user to create a new Vault that has a zero balance
        ///
        access(all) fun createEmptyVault(): @{Vault} {
            post {
                result.balance == 0.0: "The newly created Vault must have zero balance"
                result.getType() == self.getType(): "The newly created Vault must have the same type as the creating vault"
            }
        }
    }

    /// createEmptyVault allows any user to create a new Vault that has a zero balance
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{FungibleToken.Vault} {
        post {
            result.getType() == vaultType: "The returned vault does not match the desired type"
            result.balance == 0.0: "The newly created Vault must have zero balance"
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/get_factory_address.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Returns the EVM address of the FlowEVMBridgeFactory solidity contract
///
/// @return The EVM address of the FlowEVMBridgeFactory contract as hex string (without 0x prefix)
///
access(all) fun main(): String {
    return FlowEVMBridgeUtils.getBridgeFactoryEVMAddress().toString()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeConfig.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"

/// This contract is used to store configuration information shared by FlowEVMBridge contracts
///
access(all)
contract FlowEVMBridgeConfig {

    /******************
        Entitlements
    *******************/

    access(all) entitlement Gas
    access(all) entitlement Fee
    access(all) entitlement Pause
    access(all) entitlement Blocklist

    /*************
        Fields
    **************/

    /// Amount of FLOW paid to onboard a Type or EVMAddress to the bridge
    access(all)
    var onboardFee: UFix64
    /// Flat rate fee for all bridge requests
    access(all)
    var baseFee: UFix64
    /// Default ERC20.decimals() value
    access(all)
    let defaultDecimals: UInt8
    /// The gas limit for all EVM calls related to bridge operations
    access(all)
    var gasLimit: UInt64
    /// Flag enabling pausing of bridge operations
    access(self)
    var paused: Bool
    /// Mapping of Type to its associated EVMAddress. The contained struct values also store the operational status of
    /// the association, allowing for pausing of operations by Type
    access(self) let registeredTypes: {Type: TypeEVMAssociation}
    /// Reverse mapping of registeredTypes. Note the EVMAddress is stored as a hex string since the EVMAddress type
    /// as of contract development is not a hashable or equatable type and making it so is not supported by Cadence
    access(self)
    let evmAddressHexToType: {String: Type}
    /// Mapping of Type to its associated EVMAddress as relevant to the bridge
    access(self)
    let typeToTokenHandlers: @{Type: {FlowEVMBridgeHandlerInterfaces.TokenHandler}}

    /********************
        Path Constants
    *********************/

    /// StoragePath where bridge Cadence Owned Account is stored
    access(all)
    let coaStoragePath: StoragePath
    /// StoragePath where bridge config Admin is stored
    access(all)
    let adminStoragePath: StoragePath
    /// PublicPath where a public Capability on the bridge config Admin is exposed
    access(all)
    let adminPublicPath: PublicPath
    /// StoragePath to store the Provider capability used as a bridge fee Provider
    access(all)
    let providerCapabilityStoragePath: StoragePath

    /*************
        Events
    **************/

    /// Emitted whenever the onboarding fee is updated
    ///
    access(all)
    event BridgeFeeUpdated(old: UFix64, new: UFix64, isOnboarding: Bool)
    /// Emitted whenever a TokenHandler is configured
    ///
    access(all)
    event HandlerConfigured(targetType: String, targetEVMAddress: String?, isEnabled: Bool)
    /// Emitted whenever the bridge is paused or unpaused globally - true for paused, false for unpaused
    ///
    access(all)
    event BridgePauseStatusUpdated(paused: Bool)
    /// Emitted whenever a specific asset is paused or unpaused - true for paused, false for unpaused
    ///
    access(all)
    event AssetPauseStatusUpdated(paused: Bool, type: String, evmAddress: String)
    /// Emitted whenever an association is updated
    ///
    access(all)
    event AssociationUpdated(type: String, evmAddress: String)

    /*************
        Getters
     *************/

    /// Returns whether all bridge operations are currently paused or active
    ///
    access(all)
    view fun isPaused(): Bool {
        return self.paused
    }

    /// Returns whether operations for a given Type are paused. A return value of nil indicates the Type is not yet
    /// onboarded to the bridge.
    ///
    access(all)
    view fun isTypePaused(_ type: Type): Bool? {
        if !self.typeHasTokenHandler(type) {
            // Most all assets will fall into this block - check if the asset is onboarded and paused
            return self.registeredTypes[type]?.isPaused ?? nil
        }
        // If the asset has a TokenHandler, return true if either the Handler is paused or the type is paused
        return self.borrowTokenHandler(type)!.isEnabled() == false || self.registeredTypes[type]?.isPaused == true
    }

    /// Retrieves the EVMAddress associated with a given Type if it has been onboarded to the bridge
    ///
    access(all)
    view fun getEVMAddressAssociated(with type: Type): EVM.EVMAddress? {
        if !self.typeHasTokenHandler(type) {
            return self.registeredTypes[type]?.evmAddress
        }
        return self.borrowTokenHandler(type)!.getTargetEVMAddress()
    }

    /// Retrieves the type associated with a given EVMAddress if it has been onboarded to the bridge
    ///
    access(all)
    view fun getTypeAssociated(with evmAddress: EVM.EVMAddress): Type? {
        let evmAddressHex = evmAddress.toString()
        return self.evmAddressHexToType[evmAddressHex]
    }

    /// Returns whether the given EVMAddress is currently blocked from onboarding to the bridge
    ///
    access(all)
    view fun isEVMAddressBlocked(_ evmAddress: EVM.EVMAddress): Bool {
        return self.borrowEVMBlocklist().isBlocked(evmAddress)
    }

    /// Returns whether the given Cadence Type is currently blocked from onboarding to the bridge
    ///
    access(all)
    view fun isCadenceTypeBlocked(_ type: Type): Bool {
        return self.borrowCadenceBlocklist().isBlocked(type)
    }

    /****************************
        Bridge Account Methods
     ****************************/

    /// Enables bridge contracts to add new associations between types and EVM addresses
    ///
    access(account)
    fun associateType(_ type: Type, with evmAddress: EVM.EVMAddress) {
        pre {
            self.getEVMAddressAssociated(with: type) == nil:
            "Type ".concat(type.identifier).concat(" already associated with an EVMAddress ")
                .concat(self.registeredTypes[type]!.evmAddress.toString())
            self.getTypeAssociated(with: evmAddress) == nil:
            "EVMAddress ".concat(evmAddress.toString()).concat(" already associated with Type ")
                .concat(self.evmAddressHexToType[evmAddress.toString()]!.identifier)
        }
        self.registeredTypes[type] = TypeEVMAssociation(associated: evmAddress)
        let evmAddressHex = evmAddress.toString()
        self.evmAddressHexToType[evmAddressHex] = type

        emit AssociationUpdated(type: type.identifier, evmAddress: evmAddressHex)
    }

    /// Returns whether the given Type has a TokenHandler configured
    ///
    access(account)
    view fun typeHasTokenHandler(_ type: Type): Bool {
        return self.typeToTokenHandlers[type] != nil
    }

    /// Returns whether the given EVMAddress has a TokenHandler configured
    ///
    access(account)
    view fun evmAddressHasTokenHandler(_ evmAddress: EVM.EVMAddress): Bool {
        let associatedType = self.getTypeAssociated(with: evmAddress)
        return associatedType != nil ? self.typeHasTokenHandler(associatedType!) : false
    }

    /// Adds a TokenHandler to the bridge configuration
    ///
    access(account)
    fun addTokenHandler(_ handler: @{FlowEVMBridgeHandlerInterfaces.TokenHandler}) {
        pre {
            handler.getTargetType() != nil: "Cannot configure Handler without a target Cadence Type set"
            self.getEVMAddressAssociated(with: handler.getTargetType()!) == nil:
                "Cannot configure Handler for Type that has already been onboarded to the bridge"
            self.borrowTokenHandler(handler.getTargetType()!) == nil:
                "Cannot configure Handler for Type that already has a Handler configured"
        }
        let type = handler.getTargetType()!
        var targetEVMAddressHex: String? = nil
        if let targetEVMAddress = handler.getTargetEVMAddress() {
            targetEVMAddressHex = targetEVMAddress.toString()

            let associatedType = self.getTypeAssociated(with: targetEVMAddress)
            assert(
                associatedType == nil,
                message: "Handler target EVMAddress is already associated with a different Type"
            )
            self.associateType(type, with: targetEVMAddress)
        }

        emit HandlerConfigured(
            targetType: type.identifier,
            targetEVMAddress: targetEVMAddressHex,
            isEnabled: handler.isEnabled()
        )

        self.typeToTokenHandlers[type] <-! handler
    }

    /// Returns an unentitled reference to the TokenHandler associated with the given Type
    ///
    access(account)
    view fun borrowTokenHandler(
        _ type: Type
    ): &{FlowEVMBridgeHandlerInterfaces.TokenHandler}? {
        return &self.typeToTokenHandlers[type]
    }

    /// Returns an entitled reference to the TokenHandler associated with the given Type
    ///
    access(self)
    view fun borrowTokenHandlerAdmin(
        _ type: Type
    ): auth(FlowEVMBridgeHandlerInterfaces.Admin) &{FlowEVMBridgeHandlerInterfaces.TokenHandler}? {
        return &self.typeToTokenHandlers[type]
    }

    /// Returns an entitled reference to the bridge EVMBlocklist
    ///
    access(self)
    view fun borrowEVMBlocklist(): auth(Blocklist) &EVMBlocklist {
        return self.account.storage.borrow<auth(Blocklist) &EVMBlocklist>(from: /storage/evmBlocklist)
            ?? panic("Missing or mis-typed EVMBlocklist in storage")
    }

    /// Returns an entitled reference to the bridge CadenceBlocklist
    ///
    access(self)
    view fun borrowCadenceBlocklist(): auth(Blocklist) &CadenceBlocklist {
        return self.account.storage.borrow<auth(Blocklist) &CadenceBlocklist>(from: /storage/cadenceBlocklist)
            ?? panic("Missing or mis-typed CadenceBlocklist in storage")
    }

    /*****************
        Constructs
     *****************/

    /// Entry in the registeredTypes mapping, associating a Type with an EVMAddress and its operational status. Since
    /// the registeredTypes mapping is indexed on Type, this struct does not additionally store the Type to reduce
    /// redundant storage.
    ///
    access(all) struct TypeEVMAssociation {
        /// The EVMAddress associated with the Type
        access(all) let evmAddress: EVM.EVMAddress
        /// Flag indicating whether operations for the associated Type are paused
        access(all) var isPaused: Bool

        init(associated evmAddress: EVM.EVMAddress) {
            self.evmAddress = evmAddress
            self.isPaused = false
        }

        /// Pauses operations for this association
        ///
        access(contract) fun pause() {
            self.isPaused = true
        }

        /// Unpauses operations for this association
        ///
        access(contract) fun unpause() {
            self.isPaused = false
        }
    }

    /// EVMBlocklist resource stores a mapping of EVM addresses that are blocked from onboarding to the bridge
    ///
    access(all) resource EVMBlocklist {
        /// Mapping of serialized EVM addresses to their blocked status
        ///
        access(all) let blocklist: {String: Bool}

        init() {
            self.blocklist = {}
        }

        /// Returns whether the given EVM address is blocked from onboarding to the bridge
        ///
        access(all) view fun isBlocked(_ evmAddress: EVM.EVMAddress): Bool {
            return self.blocklist[evmAddress.toString()] ?? false
        }

        /// Blocks the given EVM address from onboarding to the bridge
        ///
        access(Blocklist) fun block(_ evmAddress: EVM.EVMAddress) {
            self.blocklist[evmAddress.toString()] = true
        }

        /// Removes the given EVM address from the blocklist
        ///
        access(Blocklist) fun unblock(_ evmAddress: EVM.EVMAddress) {
            self.blocklist.remove(key: evmAddress.toString())
        }
    }

    /// CadenceBlocklist resource stores a mapping of Cadence Types that are blocked from onboarding to the bridge
    ///
    access(all) resource CadenceBlocklist {
        /// Mapping of serialized Cadence Type to their blocked status
        ///
        access(all) let blocklist: {Type: Bool}

        init() {
            self.blocklist = {}
        }

        /// Returns whether the given Type is blocked from onboarding to the bridge
        ///
        access(all) view fun isBlocked(_ type: Type): Bool {
            return self.blocklist[type] ?? false
        }

        /// Blocks the given Type from onboarding to the bridge
        ///
        access(Blocklist) fun block(_ type: Type) {
            self.blocklist[type] = true
        }

        /// Removes the given type from the blocklist
        ///
        access(Blocklist) fun unblock(_ type: Type) {
            self.blocklist.remove(key: type)
        }
    }

    /*****************
        Config Admin
     *****************/

    /// Admin resource enables updates to the bridge fees
    ///
    access(all)
    resource Admin {

        /// Sets the TokenMinter for the given Type. If a TokenHandler does not exist for the given Type, the operation
        /// reverts. The provided minter must be of the expected type for the TokenHandler and the handler cannot have
        /// a minter already set.
        ///
        /// @param targetType: Cadence type indexing the relevant TokenHandler
        /// @param minter: TokenMinter minter to set for the TokenHandler
        ///
        access(all)
        fun setTokenHandlerMinter(targetType: Type, minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}) {
            pre {
                FlowEVMBridgeConfig.typeHasTokenHandler(targetType):
                    "Cannot set minter for Type that does not have a TokenHandler configured"
                FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType) != nil:
                    "No handler found for target Type"
                FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType)!.getExpectedMinterType() == minter.getType():
                    "Invalid minter type"
            }
            FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType)!.setMinter(<-minter)
        }

        /// Sets the gas limit for all EVM calls related to bridge operations
        ///
        /// @param lim the new gas limit
        ///
        access(Gas)
        fun setGasLimit(_ limit: UInt64) {
            FlowEVMBridgeConfig.gasLimit = limit
        }

        /// Updates the onboarding fee
        ///
        /// @param new: UFix64 - new onboarding fee
        ///
        /// @emits BridgeFeeUpdated with the old and new rates and isOnboarding set to true
        ///
        access(Fee)
        fun updateOnboardingFee(_ new: UFix64) {
            emit BridgeFeeUpdated(old: FlowEVMBridgeConfig.onboardFee, new: new, isOnboarding: true)
            FlowEVMBridgeConfig.onboardFee = new
        }

        /// Updates the base fee
        ///
        /// @param new: UFix64 - new base fee
        ///
        /// @emits BridgeFeeUpdated with the old and new rates and isOnboarding set to false
        ///
        access(Fee)
        fun updateBaseFee(_ new: UFix64) {
            emit BridgeFeeUpdated(old: FlowEVMBridgeConfig.baseFee, new: new, isOnboarding: false)
            FlowEVMBridgeConfig.baseFee = new
        }

        /// Pauses the bridge, preventing all bridge operations
        ///
        access(Pause)
        fun pauseBridge() {
            if FlowEVMBridgeConfig.isPaused() {
                return
            }
            FlowEVMBridgeConfig.paused = true
            emit BridgePauseStatusUpdated(paused: true)
        }

        /// Unpauses the bridge, allowing bridge operations to resume
        ///
        access(Pause)
        fun unpauseBridge() {
            if !FlowEVMBridgeConfig.isPaused() {
                return
            }
            FlowEVMBridgeConfig.paused = false
            emit BridgePauseStatusUpdated(paused: false)
        }

        /// Pauses all operations for a given asset type
        ///
        access(Pause)
        fun pauseType(_ type: Type) {
            let association = &FlowEVMBridgeConfig.registeredTypes[type] as &TypeEVMAssociation?
                ?? panic("Type not associated with an EVM Address")

            if association.isPaused {
                return
            }

            association.pause()

            let evmAddress = association.evmAddress.toString()
            emit AssetPauseStatusUpdated(paused: true, type: type.identifier, evmAddress: evmAddress)
        }

        /// Unpauses all operations for a given asset type
        ///
        access(Pause)
        fun unpauseType(_ type: Type) {
            let association = &FlowEVMBridgeConfig.registeredTypes[type] as &TypeEVMAssociation?
                ?? panic("Type not associated with an EVM Address")

            if !association.isPaused {
                return
            }

            association.unpause()
            let evmAddress = association.evmAddress.toString()
            emit AssetPauseStatusUpdated(paused: false, type: type.identifier, evmAddress: evmAddress)
        }

        /// Sets the target EVM contract address on the handler for a given Type, associating the Cadence type with the
        /// provided EVM address. If a TokenHandler does not exist for the given Type, the operation reverts.
        ///
        /// @param targetType: Cadence type to associate with the target EVM address
        /// @param targetEVMAddress: target EVM address to associate with the Cadence type
        ///
        /// @emits HandlerConfigured with the target Type, target EVM address, and whether the handler is enabled
        ///
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setHandlerTargetEVMAddress(targetType: Type, targetEVMAddress: EVM.EVMAddress) {
            pre {
                FlowEVMBridgeConfig.getEVMAddressAssociated(with: targetType) == nil:
                    "Type already associated with an EVM Address"
                FlowEVMBridgeConfig.getTypeAssociated(with: targetEVMAddress) == nil:
                    "EVM Address already associated with another Type"
            }
            post {
                FlowEVMBridgeConfig.getEVMAddressAssociated(with: targetType)!.equals(targetEVMAddress):
                "Problem associating target Type and target EVM Address"
            }
            FlowEVMBridgeConfig.associateType(targetType, with: targetEVMAddress)

            let handler = FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType)
                ?? panic("No handler found for target Type")
            handler.setTargetEVMAddress(targetEVMAddress)

            emit HandlerConfigured(
                targetType: targetType.identifier,
                targetEVMAddress: targetEVMAddress.toString(),
                isEnabled: handler.isEnabled()
            )
        }

        /// Enables the TokenHandler for the given Type. If a TokenHandler does not exist for the given Type, the
        /// operation reverts.
        ///
        /// @param targetType: Cadence type indexing the relevant TokenHandler
        ///
        /// @emits HandlerConfigured with the target Type, target EVM address, and whether the handler is enabled
        ///
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun enableHandler(targetType: Type) {
            let handler = FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType)
                ?? panic("No handler found for target Type ".concat(targetType.identifier))
            handler.enableBridging()

            let targetEVMAddressHex = handler.getTargetEVMAddress()?.toString()
                ?? panic("Handler cannot be enabled without a target EVM Address")

            emit HandlerConfigured(
                targetType: handler.getTargetType()!.identifier,
                targetEVMAddress: targetEVMAddressHex,
                isEnabled: handler.isEnabled()
            )
        }

        /// Disables the TokenHandler for the given Type. If a TokenHandler does not exist for the given Type, the
        /// operation reverts.
        ///
        /// @param targetType: Cadence type indexing the relevant TokenHandler
        ///
        /// @emits HandlerConfigured with the target Type, target EVM address, and whether the handler is enabled
        ///
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun disableHandler(targetType: Type) {
            let handler = FlowEVMBridgeConfig.borrowTokenHandlerAdmin(targetType)
                ?? panic("No handler found for target Type".concat(targetType.identifier))
            handler.disableBridging()

            emit HandlerConfigured(
                targetType: handler.getTargetType()!.identifier,
                targetEVMAddress: handler.getTargetEVMAddress()?.toString(),
                isEnabled: handler.isEnabled()
            )
        }
    }

    init() {
        self.onboardFee = 0.0
        self.baseFee = 0.0
        self.defaultDecimals = 18
        self.gasLimit = 15_000_000
        self.paused = true

        self.registeredTypes = {}
        self.evmAddressHexToType = {}

        self.typeToTokenHandlers <- {}

        self.adminStoragePath = /storage/flowEVMBridgeConfigAdmin
        self.adminPublicPath = /public/flowEVMBridgeConfigAdmin
        self.coaStoragePath = /storage/evm
        self.providerCapabilityStoragePath = /storage/bridgeFlowVaultProvider

        // Create & save Admin, issuing a public unentitled Admin Capability
        self.account.storage.save(<-create Admin(), to: self.adminStoragePath)
        let adminCap = self.account.capabilities.storage.issue<&Admin>(self.adminStoragePath)
        self.account.capabilities.publish(adminCap, at: self.adminPublicPath)

        // Initialize the blocklists
        self.account.storage.save(<-create EVMBlocklist(), to: /storage/evmBlocklist)
        self.account.storage.save(<-create CadenceBlocklist(), to: /storage/cadenceBlocklist)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/destroy_coa.cdc

```
import "Burner"
import "EVM"

/// !!! CAUTION: Destroys the COA in the signer's account !!!
///
transaction {
    prepare(signer: auth(LoadValue, StorageCapabilities, UnpublishCapability) &Account) {
        // Unpublish the COA capability
        signer.capabilities.unpublish(/public/evm)

        // Delete all COA capabilities
        signer.capabilities.storage.forEachController(forPath: /storage/evm, fun (controller: &StorageCapabilityController): Bool {
            controller.delete()
            return true
        })

        // Destroy the COA
        let coa <- signer.storage.load<@EVM.CadenceOwnedAccount>(from: /storage/evm)!
        Burner.burn(<-coa)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/resolve_locked_nft_metadata.cdc

```
import "NonFungibleToken"
import "MetadataViews"

import "FlowEVMBridgeNFTEscrow"
import "FlowEVMBridgeUtils"

/// Resolves the view for the requested locked NFT or nil if the NFT is not locked
/// NOTE: This functionality is not available via the escrow contract as `resolveView` is not a `view` method, but the
///     escrow contract does provide the necessary functionality to resolve the view from the context of a script
///
/// @param bridgeAddress: The address of the bridge contract (included as the VM bridge address varies across networks)
/// @param nftTypeIdentifier: The identifier of the NFT type
/// @param id: The ERC721 id of the escrowed NFT
/// @param viewIdentifier: The identifier of the view to resolve
///
/// @return The resolved view if the NFT is escrowed & the view is resolved by it or nil if the NFT is not locked
///
access(all) fun main(bridgeAddress: Address, nftTypeIdentifier: String, id: UInt256, viewIdentifier: String): AnyStruct? {
    // Construct runtime types from provided identifiers
    let nftType: Type = CompositeType(nftTypeIdentifier) ?? panic("Malformed NFT type identifier=".concat(nftTypeIdentifier))
    let view: Type = CompositeType(viewIdentifier) ?? panic("Malformed view type identifier=".concat(viewIdentifier))

    // Derive the Locker path for the given NFT type
    let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: nftType)
        ?? panic("Problem deriving Locker path for NFT type identifier=".concat(nftTypeIdentifier))

    // Borrow the locker from the bridge account's storage
    if let locker = getAuthAccount<auth(BorrowValue) &Account>(bridgeAddress).storage.borrow<&FlowEVMBridgeNFTEscrow.Locker>(
        from: lockerPath
    ) {
        // Retrieve the NFT type's cadence ID from the locker
        if let cadenceID = locker.getCadenceID(from: id) {
            // Resolve the requested view for the given NFT type, returning nil if the view is not supported or the NFT
            // is not locked in escrow
            return locker.borrowViewResolver(id: cadenceID)?.resolveView(view)
        }
    }

    // Return nil if no locker was found for the given NFT type
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flips/blob/main/application/20231222-evm-vm-bridge.md

---
status: implemented
flip: 237
title: Flow EVM VM Bridge
authors: Giovanni Sanchez (giovanni.sanchez@dapperlabs.com)
sponsor: Jerome Pimmel (jerome.pimmel@dapperlabs.com)
updated: 2023-12-22
---

# FLIP 237: Flow VM Bridge

> A contract protocol enabling arbitrary token bridging atomically between Flow and FlowEVM

<details>

<summary>Table of contents</summary>

- [Objective](#objective)
- [Motivation](#motivation)
- [User Benefit](#user-benefit)
- [Bridge Specification](#bridge-specification)
  - [Cadence to EVM](#cadence-to-evm)
  - [EVM to Cadence](#evm-to-cadence)
- [Context](#context)
- [Overview](#overview)
- [Bridge Onboarding](#bridge-onboarding)
- [In Aggregate](#in-aggregate)
- [Implementation Details](#implementation-details)
  - [Contract Roles \& Concerns](#contract-roles--concerns)
  - [Case Studies](#case-studies)
  - [Interfaces](#interfaces)
  - [Special Cases](#special-cases)
  - [Considerations](#considerations)
  - [Drawbacks](#drawbacks)
  - [Considered Alternatives](#considered-alternatives)
  - [Performance Implications](#performance-implications)
  - [Examples](#examples)
  - [Compatibility](#compatibility)
- [Prior Art](#prior-art)
- [Source Code](#source-code)
</details>

## Objective

This proposal outlines a contract-based protocol enabling the automated bridging of arbitrary Fungible (FT) and
Non-Fungible tokens (NFT) from Cadence into FlowEVM into the corresponding ERC-20 and ERC-721 token types. In the
opposite direction, it supports bridging of arbitrary FlowEVM ERC-20 and ERC-721 tokens into the corresponding
Cadence FT or NFT token types.

To facilitate users bridging tokens between VMs, the protocol internalizes capabilities to deploy new token contracts in
either VM state as needed. It serves as a request router & corresponding contract registrar to guarantee the
synchronization integrity of assets being bridged across VM states. It additionally automates account and contract calls
to enforce source VM asset burn or lock and target VM token mint or unlock. `CadenceOwnedAccounts` (COAs) introduced
in the [EVM support FLIP proposal](https://github.com/onflow/flips/pull/225) enable the Flow VM Bridge to operate across
both state spaces within the same, atomic transaction resulting in instantaneous asset exchange. 

## Motivation

The success and viability of EVM on Flow depends on the ability for assets to move unimpeded between VM states. The Flow
VM bridge resolves the need for token portability at the platform level. Its design is consistent with cross-chain
bridging protocols common in Web 3 in order to ensure onchain transparency. A generalized solution which addresses
scalability and security concerns arising from arbitrary token bridging can better ensure the security of users on the
platform.

## User Benefit

An efficient, easy to use bridge which modifies state across VMs simultaneously in a single transaction reduces
complexity for builders and improves end-user experience for the essential economic activity of moving tokens across
VMs. The abstraction afforded to users by the bridge means that multiple EVM transaction steps can be bundled together
using Cadence to securely realize bridging as a single transaction. The availability of a secure and proven platform
capability for cross-VM bridging can ensure a consistent, higher security bar than leaving developers to implement
project specific token bridges. It also significantly reduces the effort required of developers wishing to build
applications which need to bridge tokens between VMs for an optimal user experience.

## Bridge Specification

Specification outline of the Flow VM bridge for bi-directional flow of FT and NFTs between VM states. While the spec
references NFTs, the VM bridge will treat both FTs and NFTs alike, with the caveat that NFTs have more complexity due to
their more detailed metadata which needs to be made to work for both VMs. With that said, many FTs on Flow define useful
onchain contract-level metadata, so we may also choose to bridge select metadata for FTs as well.

### Cadence to EVM

Breakdown of the steps required to bridge a token across VMs from Cadence to EVM. 

#### VM bridge contract functionality

* Configure EVM-defining contract if needed
* Maintain Flow <-> EVM contract relationships
* Provide utility methods for information lookup about contracts for either state space

#### Prerequisites to user actions

1. Confirm counterparty contract deployed state, else deploy
2. Setup and configure NFT metadata
3. Safety/integrity checks as needed

#### Cadence transaction: bridge a Cadence NFT to CadenceOwnedAccount

1. Ensure prerequisites
2. Store NFT into VM bridge Cadence contract escrow
3. EVM transaction: mint corresponding NFT in EVM contract or transfer if the NFT already exists

### EVM to Cadence

Sequential breakdown of the flow for a user bridging a token from EVM to Flow. The high level paths below are broken
down into their respective forks to help with understanding.

#### VM bridge contract functionality

* Initialize Cadence NFT contract
* Maintain Flow <-> EVM contract relationships
* Provide utility methods for information lookup about contracts for either state space

**Path 1: Cadence originated NFT returning to Cadence**

#### Cadence transaction: COA A bridges an EVM NFT back to Cadence

* COA A calls bridge to request bridging of EVM NFT back into Cadence
* Bridge contract calls into EVM to confirm COA A is the owner of the requested NFT. If so, process continues; otherwise
  reverts
* Bridge executes the protected `safeTransfer` call provided by COA A, transferring the ERC721 token to the bridge
  for escrow
* Bridge contract unlocks corresponding Cadence NFT from VM bridge contract escrow storage
* Returns NFT on call to bridge contract

#### Cadence transaction: COA B bought COA A's EVM NFT on FlowEVM, and then wants to bridge it back to Cadence

* COA B calls bridge contract to request bridging of EVM NFT back into Cadence
* Bridge contract calls into EVM to confirm COA B is the owner of the requested NFT. If so, process continues; otherwise
  reverts
* Bridge executes the protected `safeTransfer` call provided by COA A, transferring the ERC721 token to the bridge for
  escrow
* Contract unlocks corresponding Cadence NFT from VM bridge contract escrow storage
* Returns NFT on call to bridge contract

**Path 2: EVM originated NFT bridging to Cadence**

#### Prerequisite steps to user actions

* Defining corresponding Cadence contract must been deployed to the bridge. This is done via bridge contract templates
  where the deployed contract is "owned" by the bridge and actions on it orchestrated by contract logic.

#### Cadence transaction: COA A wants to bridge an EVM NFT to Cadence

* Ensure prerequisites 
* Within the Cadence call to bridge, a protected `safeTransfer` call is included, transferring the ERC721 from the
  caller to the bridge escrow
* Bridge checks that the named owner is the owner of the NFT on EVM side before executing approval to Bridge account COA
  address
* Bridge ensures transfer was successful
* Bridge validates its ownership of the NFT on EVM side after transfer, thus locking NFT to be bridged
* Bridge unlocks the Cadence NFT if escrowed, otherwise mints NFT 
from the bridge-owned NFT contract and returns it to the caller
* Collection is configured if necessary and deposited to COA A's account

# Design Proposal

## Context

It's helpful to understand that the entrypoint to FlowEVM is mediated by the [`CadenceOwnedAccount`
(COA)](https://github.com/onflow/flips/pull/225). This Cadence resource provides access to FlowEVM, enabling encoded
calls into EVM originating from the calling COA's EVM address. In short, it's a resource that also functions as an EVM
account whose access is controlled by resource ownership instead of an offchain signature.

COAs are the only cross-VM objects universally available from Cadence. This type provides the means to use Solidity's
identity-based approach for access and enables any address to receive assets; callers bridging *to* FlowEVM from Cadence
may transfer tokens to any EVM address. In the opposite direction, only COAs may initiate bridging *from* EVM since
there is not yet a mechanism to initiate Cadence state change from the EVM environment.

Hopefully, this context clarifies that bridging in either direction - Cadence -> EVM & EVM -> Cadence - is at all times
initiated via call to the bridge's Cadence contracts.

It's also interesting to note that any project could build an asset-specific bridge between VMs using the same
primitives and toolsets leveraged for the design below. However, the intention for this bridge is to provide public
infrastructure to seamlessly and permissionlessly move assets between VMs without requiring the support of the asset
developers while maintaining a high security bar for all users of the bridge.

## Overview

Given the variety of problem components and drivers of complexity - namely storage and the potential spam vector -
initial designs targeted a distributed approach. Based on feedback alleviating concerns around storage and the
complexity introduced by said distribution, this iteration aggregates all bridge-related contracts & resources in a
single account.

Updates to this implementation also include deeper integration with the CadenceOwnedAccount resource (COA), enabling
asset bridging via a simple interface available directly from a COA.

The central bridge contract will act as a secondary (to the COA interface) entry point for bridge requests,
orchestrating asset onboarding deployments & configuration, and minting/burning + lock/unlock as needed to fulfill
requests. Deployed contracts are “owned” by the bridge, but owner interactions are mediated by contract logic on either
end in addition to multi-sig patterns consistent with other core network infrastructure accounts.

On the EVM side, a central contract factory will instantiate ERC20 & ERC721 contracts as directed by calls from the
bridge’s COA. This factory will also implement a number of helper methods to give the bridge contracts visibility into the
EVM environment. These methods might include things like retrieving an asset’s interface conformance, determining if EVM
contracts are bridge-owned, validating asset ownership, etc. so the COA has a central trusted source of truth for
critical state assertions.

> :information_source: An important conceptual point worth noting is that bridge requests are only initiated via
> Cadence. Since EVM cannot initiate state change in the Cadence environment, bridging in either direction is always
> performed via calls on Cadence resources and contracts.

## Bridge Onboarding

Given some asset in either Cadence or EVM, there is necessarily some source contract that defines it. The environment in
which that source contract resides is the environment to which the asset is considered “native”.

In order for the bridge to fulfill a given request, it’s necessary for a defining contract to exist in the target VM, a
known association between source and target contracts to exist, and for the bridge to have some mechanism for either
escrow or minting/burning.

Due to how contract deployments function with relationship to state availability, this deployment and configuration must
be completed in a distinct transaction prior to fulfilling bridge requests. **The bridge cannot fulfill a request in the
same transaction in which it also deploys the target contract as the deployed contract will not exist in the state space
until after the transaction is complete.**

This configuration process will be termed “onboarding”, and an asset for which the bridge is configured to handle will
be considered “onboarded”. This action, unless a project has explicitly disabled bridging, can be executed by anyone as
its protected by contract logic. In virtually all cases, the bridge will deploy and own a contract in the non-native
environment enabling it to perform privileged functions such as minting and updating metadata, again protected by bridge
contract logic.

There is a small minority of assets that do not conform to the standard configuration and require special handling based
on business or protocol requirements. What follows addresses call flows for the vast majority of NFT bridge requests.
See [Special Cases](#special-cases) below for more information and context on such assets.

## In Aggregate

Diagrams depicting the call flows for both Flow- and EVM-native NFTs bridging according to the proposed design are
included later in this FLIP. Beside those pictured, auxiliary contracts will exist to support bridge operations such as
interfaces, utilities, configuration, etc., but the are not pictured below as they are not critical to high-level
bridging operations. Immediately below is a birds-eye view of the contract suite across VMs.

![FlowEVM VM Bridge Design Overview](20231222-evm-vm-bridge-resources/overview.png) *Bridge functionality is enabled
directly on the COA resource for simplicity, with call passing through the EVM contract to a routing resource to the
central VM bridge. The central bridge contract then handles bridging requests dependent on whether the asset is an NFT
or FT, whether the asset is Cadence- or EVM-native, and the direction of the request. Due to the need to special case
some assets, Handlers are built in to the bridge enabling custom passthroughs based on non-standard business logic. For
most all assets, at asset onboarding, the bridge performs contract initialization on either side of the VM by
dynamically deploying EVM or Cadence contracts and maintaining associations between source and target contract
definitions.*

## Implementation Details

### Contract Roles & Concerns

#### Flow

- **EVM Contract Integration (EVM & EVMBridgeRouter)**
  - Enable COA to bridge FT/NFTs between VMs
  - Route requests from COAs to VM bridge

- **Bridge**
  - Unified entry point for bridging assets between VMs
  - Unified query point for NFT escrow contracts & to assess Cadence x EVM contract associations
  - Owning (via contract COA) all deployed contracts on EVM side
  - Escrowing (via contract COA) all assets on EVM side when bridged to Flow
  - Initializing BridgedFT & BridgedNFT contracts defining EVM-native assets when first bridged to Cadence
- **FT/NFT Escrow**
  - Lock tokens bridging to EVM
  - Unlock tokens bridging from EVM
  - Serve query requests about locked tokens - e.g. resolving token metadata
- **Bridged FT/NFT**
  - Define EVM-native tokens bridged from EVM to Flow
  - Point to the corresponding EVM-native contract
  - Maintain up-to-date token metadata with source ERC20/721 as ground truth

#### EVM

> :information_source: Note: Self-defined locking functionality is not required as “locked” assets will simply be
> transferred to the FlowEVMBridge.COA.EVMAddress

- **FlowBridgeDeploymentRegistry**
  - Maintain a registry of all bridge-deployed EVM contracts
- **ERC20Deployer**
  - Deploys EVM-defining implementations of fungible tokens as ERC20 from template
- **ERC721Deployer**
  - Deploys EVM-defining implementations of non-fungible tokens as ERC721 from template

- **FlowBridgeFactory**
  - Deploys new instances of FlowBridgedFT/NFT via deployers
  - Passes through the named registry for knowledge of all bridge-deployed EVM contract addresses & their Cadence token
    identifier correspondence
  - Aids visibility of bridge contract into the EVM environment with assistive methods - isERC721, isERC20, etc.

- **FlowBridgedFT/NFT**
  - Define Cadence-native tokens bridged from Cadence to EVM
  - Point to the corresponding Cadence-native contract
  - Contain bridged token metadata updated at time of last bridging

### Case Studies

The task of bridging FTs & NFTs between VMs can be split into four distinct cases, each with their own unique path. An
asset can either be Cadence- or EVM-native, and it can either be bridged from Cadence to EVM or EVM to Cadence. The
following sections outline an NFT bridge path for each case.

> :information_source: A note about bridge "onboarding" - assets moving from one VM to another must at minimum have
> contracts defining them in their target VM. These contracts must be deployed in a transaction preceding the movement
> of the asset as deployed contracts are not available in the Cadence's state space until the deploying transaction has
> finalized. Thus, onboarding cannot be done on the fly and must be a discrete step of the bridging process.

#### Cadence-Native NFT Onboarding

1. Pre-flight checks: Assert the type is supported, hasn't opted out, requires onboarding, and fee provider can provide
   onboarding fee
2. Withdraw onboard fee from given fee Provider & deposit to bridge Vault
3. Does the bridge have a custom Handler for this type? a. If so, revert as a Handler implies custom configuration.
    b. Otherwise, continue
4. Is this an NFT or FT? - NFT, continue as NFT
5. Deploy ERC721 from factory, passing on identifying information from the type & its defining Cadence contract
    a. Factory retains deployed address & Cadence type identifier in mapping & reverse mapping
    b. Returns the deployed ERC721 address
6. Call to BridgeNFTEscrow to initialize escrow locker, passing on the type and deployed ERC721 address
7. Associate the type with the deployed ERC721 address

![Cadence-native NFT Onboarding](20231222-evm-vm-bridge-resources/cadence_native_nft_onboarding.png)

#### Cadence-Native: Cadence -> EVM

*Lock in Cadence & Mint/Transfer in EVM*

1. Pre-flight checks: Assert the type is supported, has been onboarded, and fee provider can provide onboarding fee
2. Get a URI for the NFT
    - Default to project-specified URI
    - If not defined, serialize the NFT as JSON data URL
3. Lock NFT in escrow
4. Calculate the bridge fee based on flat fee + storage usage
5. Withdraw onboard fee from given fee Provider & deposit to bridge Vault
6. Get the token's corresponding ERC721 contract address
5. Execute the bridge
    - Check if the ERC721 is factory-deployed - Cadence-native: return true
        - If the token exists, transfer and update the URI
        - Otherwise mint the token to the recipient with the URI
    - Otherwise transfer the token to the recipient


![Cadence-native Cadence to EVM](20231222-evm-vm-bridge-resources/cadence_native_nft_to_evm.png)

#### Cadence-Native: EVM -> Cadence

*Unlock in Cadence & Transfer in EVM*

1. Pre-flight checks: Assert the type is supported, has been onboarded, and fee provider can provide onboarding fee
2. Withdraw the bridge fee from the given Provider & deposit to bridge Vault
3. Get the requested type's associated EVM contract address
4. Assert the caller is the requested ERC721 token owner or approved
5. Execute the provided protected callback
6. Assert that now the bridge COA is the ERC721 token owner after executing the protected callback
7. Derive the requested type's contract address & name & attempt to borrow the contract as EVMBridgeMinter
8. Get the tokenURI from the ERC721 contract
9. If the corresponding Cadence NFT is in escrow, unlock the NFT
    - If the defining Cadence contract is EVMBridgeMinter, update the token URI <- false in this case
10. Return the unlocked NFT


![Cadence-native EVM to Cadence](20231222-evm-vm-bridge-resources/cadence_native_nft_from_evm.png)

#### EVM-Native NFT Onboarding

1. Pre-flight checks: Assert the contract address is supported ERC, hasn't opted out, requires onboarding, and fee provider can provide onboarding fee
2. Withdraw onboard fee from given fee Provider & deposit to bridge Vault
3. Does the bridge have a custom Handler for this EVM Address?
    a. If so, revert as a Handler implies custom configuration.
    b. Otherwise, continue
4. Is this an ERC20 or ERC721? - ERC721, continue as ERC721
5. Deploy BridgedNFT Cadence contract from template, passing on identifying information from the ERC721 contract & deriving Cadence contract name
6. Associate the deployed NFT type with the ERC721 address
7. Initialize escrow for the deployed NFT type

![EVM-native NFT Onboarding](20231222-evm-vm-bridge-resources/evm_native_nft_onboarding.png)

#### EVM-Native: EVM -> Cadence

*Mint/Unlock in Cadence & Transfer in EVM*

1. Pre-flight checks: Assert the type is supported, has been onboarded, and fee provider can provide onboarding fee
2. Withdraw the bridge fee from the given Provider & deposit to bridge Vault
3. Get the requested type's associated EVM contract address
4. Assert the caller is the requested ERC721 token owner or approved
5. Execute the provided protected callback
6. Assert that now the bridge COA is the ERC721 token owner after executing the protected callback
7. Derive the requested type's contract address & name & attempt to borrow the contract as EVMBridgeMinter
8. Get the tokenURI from the ERC721 contract
9. If the corresponding Cadence NFT is in escrow, unlock the NFT <- false in this case
10. Otherwise, mint a new NFT with the ERC721 URI & define the source contract's ERC721 ID and return

![Cadence-native Cadence to EVM](20231222-evm-vm-bridge-resources/evm_native_nft_from_evm.png)

#### EVM-Native: Flow -> EVM

*Lock in Flow & Transfer in EVM*

1. Assert the asset is either an NFT or FT & has been onboarded  (it will be by construction)
2. Determine if asset is FT or NFT
    - Check if resource is an instance of FT.Vault or NFT.NFT (excluding overlapping instances, at least for POC)
3. Determine if asset is Flow or EVM-native
    - Check if resource is defined in bridge-hosted NFT or NFT contract - if so, EVM-native, else Flow-native
4. Borrow the relevant BridgedNFT contract
5. Borrow the BridgedNFT contract from the NFT type identifier & passthrough bridge request
6. BridgedNFT burns the NFT
7. BridgedNFT calls to EVM contract, transferring NFT to defined recipient
8. BridgedNFT confirms recipient is owner of the NFT post-transfer

![Flow-native Flow to EVM](20231222-evm-vm-bridge-resources/evm_native_nft_to_evm.png)

### Interfaces

<details>

<summary>EVM.cdc</summary>

```cadence
access(all)
contract EVM {
    // The following encompasses updates proposed to the EVM contract to integrate the COA resource with the VM Bridge
    //
    access(all) entitlement Bridge

    access(all)
    resource CadenceOwnedAccount: Addressable {
        /* ... existing implementation ... */

        /* COA Additions */
        //
        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill
        /// the bridge request
        access(all)
        fun depositNFT(
            nft: @{NonFungibleToken.NFT},
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill
        /// the bridge request
        access(Owner | Bridge)
        fun withdrawNFT(
            type: Type,
            id: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{NonFungibleToken.NFT}
        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill
        /// the bridge request
        access(all)
        fun depositTokens(
            from: @{FungibleToken.Vault},
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill
        /// the bridge request
        access(Owner | Bridge)
        fun withdrawTokens(
            type: Type,
            amount: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{FungibleToken.Vault}
    }
    /// Returns a reference to the BridgeAccessor designated for internal bridge requests
    access(self)
    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}

    /// Interface for a resource which acts as an entrypoint to the VM bridge. This is implemented in a bridge contract
    /// and Capability on it is saved in the BridgeRouter resource within the EVM account's storage.
    access(all)
    resource interface BridgeAccessor {
        /// Endpoint enabling the bridging of an NFT to EVM
        access(Bridge)
        fun depositNFT(
            nft: @{NonFungibleToken.NFT},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Endpoint enabling the bridging of an NFT from EVM
        access(Bridge)
        fun withdrawNFT(
            caller: auth(Call) &CadenceOwnedAccount,
            type: Type,
            id: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{NonFungibleToken.NFT}
        /// Endpoint enabling the bridging of an fungible tokens to EVM
        access(Bridge)
        fun depositTokens(
            from: @{FungibleToken.Vault},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Endpoint enabling the bridging of an fungible tokens from EVM
        access(Bridge)
        fun withdrawTokens(
            caller: auth(Call) &CadenceOwnedAccount,
            type: Type,
            amount: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{FungibleToken.Vault}
    }

    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource
    access(all)
    resource interface BridgeRouter {
        /// Returns a reference to the BridgeAccessor designated for internal bridge requests
        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}
        /// Sets the BridgeAccessor Capability in the BridgeRouter
        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {
            pre {
                accessor.check(): "Invalid BridgeAccessor Capability provided"
                emit BridgeAccessorUpdated(
                    routerType: self.getType(),
                    routerUUID: self.uuid,
                    routerAddress: self.owner?.address ?? panic("Router must have an owner to be identified"),
                    accessorType: accessor.borrow()!.getType(),
                    accessorUUID: accessor.borrow()!.uuid,
                    accessorAddress: accessor.address
                )
            }
        }
    }
}
```
</details>

<details>

<summary>FlowEVMBridgeAccessor.cdc</summary>

```cadence
/// This contract defines a mechanism for routing bridge requests from the EVM contract to the Flow-EVM bridge contract
access(all)
contract FlowEVMBridgeAccessor {

    access(all) let StoragePath: StoragePath
    
    /// BridgeAccessor implementation used by the EVM contract to route bridge calls from COA resources
    access(all)
    resource BridgeAccessor : EVM.BridgeAccessor {
        /// Passes along the bridge request to dedicated bridge contract
        access(EVM.Bridge)
        fun depositNFT(
            nft: @{NonFungibleToken.NFT},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Passes along the bridge request to the dedicated bridge contract, returning the bridged NFT
        access(EVM.Bridge)
        fun withdrawNFT(
            caller: auth(EVM.Call) &EVM.CadenceOwnedAccount,
            type: Type,
            id: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{NonFungibleToken.NFT}
        /// Passes along the bridge request to dedicated bridge contract
        access(EVM.Bridge)
        fun depositTokens(
            vault: @{FungibleToken.Vault},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        /// Passes along the bridge request to the dedicated bridge contract, returning the bridged NFT
        access(EVM.Bridge)
        fun withdrawTokens(
            caller: auth(EVM.Call) &EVM.CadenceOwnedAccount,
            type: Type,
            amount: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{FungibleToken.Vault}
        /// Returns a BridgeRouter resource in which to store a Capability on this BridgeAccessor
        access(EVM.Bridge) fun createBridgeRouter(): @BridgeRouter
    }

    /// BridgeRouter implementation used by the EVM contract to capture a BridgeAccessor Capability and route bridge
    /// calls from COA resources to the FlowEVMBridge contract
    access(all) resource BridgeRouter : EVM.BridgeRouter {
        /// Capability to the BridgeAccessor resource, initialized to nil
        access(self) var bridgeAccessorCap: Capability<auth(EVM.Bridge) &{EVM.BridgeAccessor}>?

        access(EVM.Bridge) fun setBridgeAccessorCap(_ cap: Capability<auth(EVM.Bridge) &{EVM.BridgeAccessor}>) {
            pre {
                cap.check(): "BridgeAccessor capability already set"
            }
        }
        /// Returns an EVM.Bridge entitled reference to the underlying BridgeAccessor resource
        access(EVM.Bridge) view fun borrowBridgeAccessor(): auth(EVM.Bridge) &{EVM.BridgeAccessor}
    }
}
```
</details>

<details>
<summary>IFlowEVMNFTBridge.cdc</summary>

```cadence
access(all) contract interface IFlowEVMNFTBridge {
    
    /* Events */
    //
    /// Broadcasts an NFT was bridged from Cadence to EVM
    access(all)
    event BridgedNFTToEVM(
        type: Type,
        id: UInt64,
        evmID: UInt256,
        to: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )
    /// Broadcasts an NFT was bridged from EVM to Cadence
    access(all)
    event BridgedNFTFromEVM(
        type: Type,
        id: UInt64,
        evmID: UInt256,
        caller: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )

    /* Getters */
    //
    /// Returns the EVM address associated with the provided type
    access(all) view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress?
    /// Returns the EVM address of the bridge coordinating COA
    access(all) view fun getBridgeCOAEVMAddress(): EVM.EVMAddress

    /* Public Bridge Entrypoints */
    //
    /// Public entrypoint to bridge NFTs from Cadence to EVM.
    access(all) fun bridgeNFTToEVM(
        token: @{NonFungibleToken.NFT},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            emit BridgedNFTToEVM(
                type: token.getType(),
                id: token.id,
                evmID: CrossVMNFT.getEVMID(from: &token as &{NonFungibleToken.NFT}) ?? UInt256(token.id),
                to: FlowEVMBridgeUtils.getEVMAddressAsHexString(address: to),
                evmContractAddress: FlowEVMBridgeUtils.getEVMAddressAsHexString(
                    address: self.getAssociatedEVMAddress(with: token.getType())
                        ?? panic("Could not find EVM Contract address associated with provided NFT")
                ), bridgeAddress: self.account.address
            )
        }
    }

    /// Public entrypoint to bridge NFTs from EVM to Cadence
    access(account) fun bridgeNFTFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        id: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{NonFungibleToken.NFT} {
        post {
            emit BridgedNFTFromEVM(
                type: result.getType(),
                id: result.id,
                evmID: id,
                caller: FlowEVMBridgeUtils.getEVMAddressAsHexString(address: owner),
                evmContractAddress: FlowEVMBridgeUtils.getEVMAddressAsHexString(
                    address: self.getAssociatedEVMAddress(with: result.getType())
                        ?? panic("Could not find EVM Contract address associated with provided NFT")
                ), bridgeAddress: self.account.address
            )
        }
    }
}
```
</details>

<details>
<summary>IFlowEVMTokenBridge.cdc</summary>

```cadence
access(all) contract interface IFlowEVMTokenBridge {
    
    /* Events */
    //
    /// Broadcasts fungible tokens were bridged from Cadence to EVM
    access(all) event BridgedTokensToEVM(
        type: Type,
        ufixAmount: UFix64,
        uintAmount: UInt256,
        to: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )
    /// Broadcasts fungible tokens were bridged from EVM to Cadence
    access(all) event BridgedTokensFromEVM(
        type: Type,
        ufixAmount: UFix64,
        uintAmount: UInt256,
        caller: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )

    /* Getters */
    //
    /// Returns the EVM address associated with the provided type
    access(all) view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress?
    /// Returns the EVM address of the bridge coordinating COA
    access(all) view fun getBridgeCOAEVMAddress(): EVM.EVMAddress

    /* Public Bridge Entrypoints */
    //
    /// Public entrypoint to bridge fungibleTokens from Cadence to EVM.
    access(all) fun bridgeTokensToEVM(
        tokens: @{FungibleToken.Vault},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            emit BridgedTokensToEVM(
                type: tokens.getType(),
                ufixAmount: tokens.balance,
                uintAmount: FlowEVMBridgeUtils.ufix64ToUInt256(value: tokens.balance, decimals: 8),
                to: FlowEVMBridgeUtils.getEVMAddressAsHexString(address: to),
                evmContractAddress: FlowEVMBridgeUtils.getEVMAddressAsHexString(
                    address: self.getAssociatedEVMAddress(with: token.getType())
                        ?? panic("Could not find EVM Contract address associated with provided NFT")
                ), bridgeAddress: self.account.address
            )
        }
    }

    /// Public entrypoint to bridge fungible tokens from EVM to Cadence
    access(account) fun bridgeTokensFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        amount: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{FungibleToken.Vault} {
        post {
            emit BridgedTokensFromEVM(
                type: result.getType(),
                ufixAmount: result.balance,
                uintAmount: amount,
                caller: FlowEVMBridgeUtils.getEVMAddressAsHexString(address: owner),
                evmContractAddress: FlowEVMBridgeUtils.getEVMAddressAsHexString(
                    address: self.getAssociatedEVMAddress(with: result.getType())
                        ?? panic("Could not find EVM Contract address associated with provided NFT")
                ), bridgeAddress: self.account.address
            )
        }
    }
}
```
</details>

<details>
<summary>FlowEVMBridge.cdc</summary>

```cadence
access(all) contract FlowEVMBridge : IFlowEVMNFTBridge, IFlowEVMTokenBridge {

    /* Events */
    //
    /// Emitted any time a new asset type is onboarded to the bridge
    access(all)
    event Onboarded(type: Type, cadenceContractAddress: Address, evmContractAddress: String)
    /// Denotes a defining contract was deployed to the bridge accountcode
    access(all)
    event BridgeDefiningContractDeployed(
        contractName: String,
        assetName: String,
        symbol: String,
        isERC721: Bool,
        evmContractAddress: String
    )

    /* Onboarding */
    //
    /// Onboards a given asset by type to the bridge. Since we're onboarding by Cadence Type, the asset must be defined
    /// in a third-party contract. Attempting to onboard a bridge-defined asset will result in an error as the asset has
    /// already been onboarded to the bridge.
    access(all) fun onboardByType(_ type: Type, feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}) {
        pre {
            feeProvider.isAvailableToWithdraw(amount: FlowEVMBridgeConfig.onboardFee):
                "Insufficient fee available via feeProvider"
            self.typeRequiresOnboarding(type) == true: "Onboarding is not needed for this type"
            FlowEVMBridgeUtils.isCadenceNative(type: type): "Only Cadence-native assets can be onboarded by Type"
        }
    }
    /// Onboards a given EVM contract to the bridge. Since we're onboarding by EVM Address, the asset must be defined in
    /// a third-party EVM contract. Attempting to onboard a bridge-defined asset will result in an error as onboarding
    /// is not required.
    access(all) fun onboardByEVMAddress(
        _ address: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            feeProvider.isAvailableToWithdraw(amount: FlowEVMBridgeConfig.onboardFee):
                "Insufficient fee available via feeProvider"
        }
    }

    /* Public NFT Handling */
    //
    /// Public entrypoint to bridge NFTs from Cadence to EVM.
    ///
    /// @param token: The NFT to be bridged
    /// @param to: The NFT recipient in FlowEVM
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun bridgeNFTToEVM(
        token: @{NonFungibleToken.NFT},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            !token.isInstance(Type<@{FungibleToken.Vault}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(token.getType()) == false: "NFT must first be onboarded"
        }
    }

    /// Public entrypoint to bridge NFTs from EVM to Cadence
    ///
    /// @param owner: The EVM address of the NFT owner. Current ownership and successful transfer (via
    ///     `protectedTransferCall`) is validated before the bridge request is executed.
    /// @param type: The Cadence Type of the NFT to be bridged
    /// @param id: The NFT ID to bridged
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the NFT from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    /// @returns The bridged NFT
    ///
    access(account)
    fun bridgeNFTFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        id: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{NonFungibleToken.NFT} {
        pre {
            feeProvider.isAvailableToWithdraw(amount: FlowEVMBridgeUtils.calculateBridgeFee(used: 0, includeBase: true)):
                "Insufficient fee paid"
            !type.isSubtype(of: Type<@{FungibleToken.Vault}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(type) == false: "NFT must first be onboarded"
        }

    /* Public FT Handling */
    //
    /// Public entrypoint to bridge NFTs from Flow to EVM - cross-account bridging supported
    ///
    /// @param vault: The FungibleToken Vault to be bridged
    /// @param to: The recipient of tokens in FlowEVM
    /// @param tollFee: The fee paid for bridging
    ///
    access(all) fun bridgeTokensToEVM(vault: @{FungibleToken.Vault}, to: EVM.EVMAddress, tollFee: @FlowToken.Vault) {
        pre {
            tollFee.balance == self.tollAmount: "Insufficient fee paid"
            vault.isInstance(of: Type<&{NonFungibleToken.NFT}>) == false: "Mixed asset types are not yet supported"
        }
        // Handle based on whether Flow- or EVM-native & passthrough to internal method
    }

    /// Public entrypoint to bridge fungible tokens from EVM to Flow
    ///
    /// @param caller: The caller executing the bridge - must be passed to check EVM state pre- & post-call in scope
    /// @param type: The Cadence Type of the tokens to be bridged
    /// @param amount: The amount of tokens to bridge
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the tokens from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    access(account) fun bridgeTokensFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        amount: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{FungibleToken.Vault} {
        pre {
            feeProvider.isAvailableToWithdraw(amount: FlowEVMBridgeUtils.calculateBridgeFee(used: 0, includeBase: true)):
                "Insufficient fee paid"
            !type.isSubtype(of: Type<@{NonFungibleToken.NFT}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(type) == false: "NFT must first be onboarded"
        }
    }

    /* Public Getters */
    //
    /// Returns the EVM address associated with the provided type
    access(all) view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress?
    /// Returns the EVM address of the bridge coordinating COA
    access(all) view fun getBridgeCOAEVMAddress(): EVM.EVMAddress
    /// Returns whether an asset needs to be onboarded to the bridge
    access(all) view fun typeRequiresOnboarding(_ type: Type): Bool?
    /// Returns whether an EVM-native asset needs to be onboarded to the bridge
    access(all) fun evmAddressRequiresOnboarding(_ address: EVM.EVMAddress): Bool?

    /* Internal Helpers */
    //
    /// Deploys templated EVM contract via Solidity Factory contract supporting bridging of a given asset type
    access(self)
    fun deployEVMContract(forAssetType: Type): EVM.EVMAddress
    /// Deploys templated ERC721 contract supporting EVM-native asset bridging to Cadence
    access(self) fun deployERC721(_ forNFTType: Type): EVM.EVMAddress
    /// Deploys templated ERC721 contract supporting EVM-native asset bridging to Cadence
    access(self) fun deployERC20(_ forFTType: Type): EVM.EVMAddress
    /// Helper for deploying templated defining contract supporting EVM-native asset bridging to Cadence
    /// Deploys either NFT or FT contract depending on the provided type
    access(self) fun deployDefiningContract(evmContractAddress: EVM.EVMAddress)
}
```

</details>

<details>
<summary>FlowEVMBridgeConfig.cdc</summary>

```cadence
/// This contract is used to store configuration information shared by FlowEVMBridge contracts. May also serve as
/// repository of other shared configuration-related values
///
access(all) contract FlowEVMBridgeConfig {

    /* Contract values */
    //
    /// Amount of FLOW paid to onboard a Type or EVMAddress to the bridge
    access(all) var onboardFee: UFix64
    /// Flat rate fee for all bridge requests
    access(all) var baseFee: UFix64
    /// Fee rate per storage unit consumed by bridged assets
    access(all) var storageRate: UFix64
    /// Mapping of Type to its associated EVMAddress as relevant to the bridge
    access(self) let typeToEVMAddress: {Type: EVM.EVMAddress}
    /// Mapping of Type to special-case Handlers for custom bridge handling
    access(self) let handlers: @{Type: {BridgeHandler.Handler}}
    /// Mapping of EVMAddress values to whether onboarding explicitly disabled for associated contracts
    access(self) let evmFilters: {EVM.EVMAddress: Bool}
    
    /* Path Constants */
    //
    /// StoragePath where bridge Cadence Owned Account is stored
    access(all) let coaStoragePath: StoragePath
    /// StoragePath where bridge config Admin is stored
    access(all) let adminStoragePath: StoragePath
    /// Cannonical StoragePath for the ScopedProvider capability in caller accounts
    access(all) let providerCapabilityStoragePath: StoragePath

    /* Events */
    //
    /// Emitted whenever the onboarding fee is updated
    access(all) event BridgeFeeUpdated(old: UFix64, new: UFix64, isOnboarding: Bool)
    /// Emitted whenever baseFee or storageRate is updated
    access(all) event StorageRateUpdated(old: UFix64, new: UFix64)

    /* Getters */
    //
    /// Retrieves the EVMAddress associated with a given Type if it has been onboarded to the bridge
    access(all)
    view fun getEVMAddressAssociated(with type: Type): EVM.EVMAddress? {
        return self.typeToEVMAddress[type]
    }

    /* Bridge Account Methods */
    //
    /// Enables bridge contracts to update the typeToEVMAddress mapping
    access(account)
    fun associateType(_ type: Type, with evmAddress: EVM.EVMAddress) {
        self.typeToEVMAddress[type] = evmAddress
    }
    
    /* Config Admin */
    //
    // Admin resource enabling updating fee amounts
    access(all) resource Admin {
        /// Updates the onboarding fee
        access(all) fun updateOnboardingFee(_ new: UFix64)
        /// Updates the base fee
        access(all) fun updateBaseFee(_ new: UFix64)
        /// Updates the storage rate
        access(all) fun updateStorageRate(_ new: UFix64)
    }
}
```

</details>

<details>
<summary>FlowEVMBridgeUtils.cdc</summary>

```cadence
/// Util contract serving all bridge contracts
access(all) contract FlowEVMBridgeUtils {

    /// Address of the bridge factory Solidity contract
    access(all) let bridgeFactoryEVMAddress: EVM.EVMAddress
    /// Delimeter used to derive contract names
    access(self) let delimiter: String
    /// Mapping containing contract name prefixes
    access(self) let contractNamePrefixes: {Type: {String: String}}

    /* Public Bridge Utils */
    //
    /// Returns an EVMAddress as a hex string without a 0x prefix
    access(all) view fun getEVMAddressAsHexString(address: EVM.EVMAddress): String
    /// Returns an EVMAddress as a hex string without a 0x prefix, truncating the string's last 20 bytes if exceeded
    access(all) fun getEVMAddressFromHexString(address: String): EVM.EVMAddress?
    /// Validates the Vault used to pay the bridging fee
    access(all) view fun calculateBridgeFee(used: UInt64, includeBase: Bool): UFix64
    /// Returns whether the given type is allowed to be bridged as defined by the BridgePermissions contract interface.
    /// If the type's defining contract does not implement BridgePermissions, the method returns true as the bridge
    /// operates permissionlessly by default. Otherwise, the result of {BridgePermissions}.allowsBridging() is returned
    access(all) view fun typeAllowsBridging(_ type: Type): Bool
    /// Returns whether the given address has opted out of enabling bridging for its defined assets. Reverts on EVM call
    /// failure.
    access(all) fun evmAddressAllowsBridging(_ address: EVM.EVMAddress): Bool
    /// Identifies if an asset is Cadence- or EVM-native, defined by whether a bridge contract defines it or not
    access(all) fun isCadenceNative(type: Type): Bool
    /// Identifies if an asset is Cadence- or EVM-native, defined by whether a bridge-owned contract defines it or not
    access(all) fun isEVMNative(evmContractAddress: EVM.EVMAddress): Bool
    /// Determines if the given EVM contract address was deployed by the bridge by querying the factory contract
    /// Reverts on EVM call failure.
    access(all) fun isEVMContractBridgeOwned(evmContractAddress: EVM.EVMAddress): Bool
    /// Identifies if an asset is ERC721 && not ERC20
    access(all) fun isERC721(evmContractAddress: EVM.EVMAddress): Bool
    /// Identifies if an asset is ERC20 and not ERC721
    access(all) fun isERC20(evmContractAddress: EVM.EVMAddress): Bool
    /// Returns whether the given type is either an NFT or FT exclusively
    access(all) view fun isValidFlowAsset(type: Type): Bool
    /// Determines if the owner is in fact the owner of the NFT at the ERC721 contract address
    access(all) fun isOwnerOrApproved(ofNFT: UInt64, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool
    /// Determines if the owner has sufficient funds to bridge the given amount at the ERC20 contract address
    access(all) fun hasSufficientBalance(amount: UFix64, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool


    /* EVM Call Wrappers */
    //
    /// Retrieves the NFT/FT name from the given EVM contract address - applies for both ERC20 & ERC721
    access(all) fun getName(evmContractAddress: EVM.EVMAddress): String
    /// Retrieves the NFT/FT symbol from the given EVM contract address - applies for both ERC20 & ERC721
    access(all) fun getSymbol(evmContractAddress: EVM.EVMAddress): String
    /// Retrieves the number of decimals for a given ERC20 contract address
    /// Retrieves the NFT/FT symbol from the given EVM contract address - applies for both ERC20 & ERC721
    access(all) fun getTokenURI(evmContractAddress: EVM.EVMAddress, id: UInt256): String
    /// Retrieves the contract URI from the given EVM contract address.
    access(all) fun getContractURI(evmContractAddress: EVM.EVMAddress): String?
    /// Retrieves the number of decimals for a given ERC20 contract address.
    access(all) fun getTokenDecimals(evmContractAddress: EVM.EVMAddress): UInt8

    /// Determines if the provided owner address is either the owner or approved for the NFT in the ERC721 contract
    access(all)
    fun isOwnerOrApproved(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool
    /// Returns whether the given owner is the owner of the given NFT.
    access(all)
    fun isOwner(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool
    /// Returns whether the given owner is approved for the given NFT.
    access(all)
    fun isApproved(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool
    /// Determines if the owner has sufficient funds to bridge the given amount at the ERC20 contract address
    access(all)
    fun hasSufficientBalance(amount: UFix64, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool
    
    /* Derivation Utils */
    //
    /// Derives the Cadence contract name for a given Type
    access(all) fun deriveLockerContractName(fromType: Type): String?
    /// Derives the Cadence contract name for a given EVM asset
    access(all) fun deriveBridgedAssetContractName(fromEVMContract: EVM.EVMAddress): String?

    /* Math Utils */
    //
    /// Raises the base to the exponent
    access(all) view fun pow(base: UInt256, exponent: UInt8): UInt256
    /// Converts a UInt256 to a UFix64
    access(all) view fun uint256ToUFix64(value: UInt256, decimals: UInt8): UFix64
    /// Converts a UFix64 to a UInt256
    access(all) view fun ufix64ToUInt256(value: UFix64, decimals: UInt8): UInt256
    /// Returns the value as a UInt64 if it fits, otherwise panics
    access(all) view fun uint256ToUInt64(value: UInt256): UInt64

    /* Type-identifier Utils */
    //
    /// Returns the a type's defining contract address
    access(all) view fun getContractAddress(fromType: Type): Address?
    /// Returns the a type's defining contract name
    access(all) fun getContractName(fromType: Type): String?
    /// Returns the object's name from the given Type's identifier
    access(all) view fun getObjectName(fromType: Type): String?
    /// Splits a standard type identifier of format A.<CONTRACT_ADDRESS>.<CONTRACT_NAME>.<RESOURCE_NAME>
    access(all) view fun splitObjectIdentifier(identifier: String): [String]?
    // Builds a composite type from the given identifier parts
    access(all)
    view fun buildCompositeType(address: Address, contractName: String, resourceName: String): Type?
    
    /* Shared Bridge Helpers */
    //
    /// Deposits fees to the bridge account's FlowToken Vault - helps fund asset storage
    access(account) fun depositTollFee(_ tollFee: @FlowToken.Vault)
    /// Enables other bridge contracts to orchestrate bridge operations from contract-owned COA
    access(account) fun borrowCOA(): &EVM.BridgedAccount
    /// Shared helper simplifying calls using the bridge account's COA
    access(account) fun call(
        signature: String,
        targetEVMAddress: EVM.EVMAddress,
        args: [AnyStruct],
        gasLimit: UInt64,
        value: UFix64
    ): EVM.Result
}
```
</details>

</details>

<details>
<summary>FlowEVMBridgeTemplates.cdc</summary>

```cadence
/// This contract serves Cadence code from chunked templates, replacing the contract name with the name derived from
/// given arguments - either Cadence Type or EVM contract address.
access(all) contract FlowEVMBridgeTemplates {
    /// Canonical path for the Admin resource
    access(all) let AdminStoragePath: StoragePath
    /// Chunked Hex-encoded Cadence contract code, to be joined on derived contract name
    access(self) let templateCodeChunks: {String: [[UInt8]]}

    /// Emitted whenever there is a change to templated code
    access(all) event Updated(name: String, isNew: Bool?)

    access(all) fun getBridgedAssetContractCode(evmContractAddress: EVM.EVMAddress, isERC721: Bool): [UInt8]?
    
    /* Internal */
    //
    access(self) fun getBridgedNFTContractCode(contractName: String): [UInt8]?
    access(self) fun joinChunks(_ chunks: [[UInt8]], with name: String): [UInt8]

    access(self) fun getNFTLockerContractCode(forType: Type): [UInt8]?
    access(self) fun getFTLockerContractCode(forType: Type): [UInt8]?

    /// Resource enabling updates to the contract template code
    access(all) resource Admin {
        access(all) fun addNewContractCodeChunks(newTemplate: String, chunks: [String]) {
            pre {
                FlowEVMBridgeTemplates.templateCodeChunks[newTemplate] == nil: "Code already exists for template"
            }
        }
        access(all) fun upsertContractCodeChunks(forTemplate: String, chunks: [String])
        access(all) fun removeTemplate(name: String): Bool
    }
}
```
</details>

<details>
<summary>ICrossVM.cdc</summary>

```cadence
/// Contract interface denoting a cross-VM implementation, exposing methods to query EVM-associated addresses
access(all) contract interface ICrossVM {
    /// Retrieves the corresponding EVM contract address, assuming a 1:1 relationship between VM implementations
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress
}
```
</details>

<details>
<summary>IEVMBridgeNFTMinter</summary>

```cadence

/// Contract interface enabling FlowEVMBridge to mint NFTs
access(all) contract interface IEVMBridgeNFTMinter {
    /// Account-only method to mint an NFT
    access(account) fun mintNFT(id: UInt256, tokenURI: String): @{NonFungibleToken.NFT}
    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    access(account) fun updateTokenURI(evmID: UInt256, newURI: String)
}
```
</details>

<details>
<summary>IEVMBridgeFTMinter</summary>

```cadence
/// Contract interface enabling FlowEVMBridge to mint NFTs
access(all) contract interface IEVMBridgeFTMinter {
    /// Account-only method to mint an NFT
    access(account) fun mintFT(amount: UFix64): @{FungibleToken.Vault}
}
```
</details>

<details>
<summary>CrossVMNFT.cdc</summary>

```cadence
/// Contract defining cross-VM NFT & Collection interfaces
access(all) contract CrossVMNFT {
    
    /* Supporting Views - see https://github.com/onflow/flow-nft/pull/203 for feedback on inclusion to MetadataViews */
    //
    /// A struct to represent a general case URI, used to represent the URI of the NFT where the type of URI is not
    /// able to be determined (i.e. HTTP, IPFS, etc.)
    access(all) struct URI : MetadataViews.File {
        /// The base URI prefix, if any. Not needed for all URIs, but helpful for some use cases
        /// For example, updating a whole NFT collection's image host easily
        access(all) let baseURI: String?
        /// The URI value
        /// NOTE: this is set on init as a concatenation of the baseURI and the value if baseURI != nil
        access(self) let value: String

        access(all) view fun uri(): String {
            return self.value
        }
    }

    /// Proof of concept metadata to represent the ERC721 values of the NFT
    access(all) struct EVMBridgedMetadata {
        /// The name of the NFT
        access(all) let name: String
        /// The symbol of the NFT
        access(all) let symbol: String
        /// The URI of the NFT - this can either be contract-level or token-level URI depending on where the metadata
        /// is requested. See the ViewResolver contract interface to discover how contract & resource-level metadata
        /// requests are handled.
        access(all) let uri: {MetadataViews.File}
    }

    /// A simple interface for an NFT that is bridged from EVM. This may be necessary in some cases as there is
    /// discrepancy between Flow NFT standard IDs (UInt64) and EVM NFT standard IDs (UInt256). Discrepancies on IDs
    /// gone unaccounted for have the potential to induce loss of ownership bridging between VMs, so it's critical to
    /// retain identifying token information on bridging.
    ///
    /// See discussion https://github.com/onflow/flow-nft/pull/126#discussion_r1462612559 where @austinkline raised
    /// differentiating IDs in a minimal interface incorporated into the one below
    access(all) resource interface EVMNFT : NonFungibleToken.NFT {
        access(all) let evmID: UInt256
        access(all) let name: String
        access(all) let symbol: String
        access(all) view fun tokenURI(): String
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress
    }

    /// A simple interface for a collection of EVMNFTs
    access(all) resource interface EVMNFTCollection {
        access(all) view fun getEVMIDs(): [UInt256]
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64?
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256?
        access(all) view fun contractURI(): String?
    }

    /// Retrieves the EVM ID of an NFT if it implements the EVMNFT interface, returning nil if not
    access(all) view fun getEVMID(from token: &{NonFungibleToken.NFT}): UInt256?
}
```
</details>

<details>
<summary>CrossVMFungibleToken.cdc</summary>

```cadence
/// Contract defining cross-VM NFT & Collection interfaces
access(all) contract CrossVMFungibleToken {
    /// A simple interface for a Vault to retain identifying information from its EVM definition.
    access(all) resource interface EVMVault : FungibleToken.Vault {
        access(all) let name: String
        access(all) let symbol: String
        access(all) let decimals: UInt8
        access(all) view fun contractURI(): String?
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress
    }
}
```
</details>

<details>
<summary>FlowEVMBridgeNFTEscrow.cdc</summary>

```cadence
/// This escrow contract handles the locking of assets that are bridged from Flow to EVM and retrieval of locked
/// assets in escrow when they are bridged back to Flow.
///
access(all) contract FlowEVMBridgeNFTEscrow {

    /* Getters */
    //
    /// Returns whether the Locker has been initialized for the given NFT type
    access(all) view fun isInitialized(forType: Type): Bool
    /// Returns whether an NFT with the given ID is locked
    access(all) view fun isLocked(type: Type, id: UInt64): Bool
    /// Retrieves the locked NFT's Cadence ID as defined in the NFT standard's NFT.id value if it is locked
    access(all) view fun getLockedCadenceID(type: Type, evmID: UInt256): UInt64?
    /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value
    /// corresponding to the Cadence NFT.
    /// As far as the bridge is concerned, a bridge-deployed ERC721 assigns IDs based on NFT.id value at the time of
    /// bridging unless it implements the CrossVMNFT.EVMNFT in such case .evmID is used.
    /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID,
    /// otherwise the NFT's ID is returned as a UInt256 as this is how the bridge would handle minting in the
    /// corresponding ERC721 contract.
    access(all) view fun getLockedEVMID(type: Type, cadenceID: UInt64): UInt256?
    /// Returns the views supported by the defined NFT type and ID
    access(all) view fun getViews(nftType: Type, id: UInt256): [Type]
    /// Resolves the requested view type for the given NFT type if it is locked and supports the requested view type
    access(all) fun resolveLockedNFTView(nftType: Type, id: UInt256, viewType: Type): AnyStruct?

    /* Bridge Methods */
    //
    /// Initializes the Locker for the given NFT type if it hasn't been initialized yet
    access(account) fun initializeEscrow(forType: Type, erc721Address: EVM.EVMAddress)
    /// Locks the NFT in escrow, returning the amount of storage used by the locker after storing
    access(account) fun lockNFT(_ nft: @{NonFungibleToken.NFT}): UInt64
    /// Unlocks the NFT of the given type and ID, reverting if it isn't in escrow
    access(account) fun unlockNFT(type: Type, id: UInt64): @{NonFungibleToken.NFT}
    /// Retrieves a reference to the NFT of the given type and ID if it is locked, otherwise returns nil
    access(account) view fun borrowLockedNFT(type: Type, id: UInt64): &{NonFungibleToken.NFT}?

    /* Locker */
    //
    /// The resource managing the locking & unlocking of NFTs via this contract's interface
    ///
    access(all) resource Locker : CrossVMNFT.EVMNFTCollection, NonFungibleToken.Collection {
        /// The type of NFTs this Locker escrows
        access(all) let lockedType: Type
        /// Corresponding ERC721 address for the locked NFTs
        access(all) let erc721Address: EVM.EVMAddress
        /// Count of locked NFTs as lockedNFTs.length may exceed computation limits
        access(self) var lockedNFTCount: Int
        /// Indexed on NFT UUID to prevent collisions
        access(self) let lockedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Maps EVM NFT ID to Flow NFT ID, covering cross-VM project NFTs
        access(self) let evmIDToFlowID: {UInt256: UInt64}

        /* CrossVMNFT.EVMNFTCollection conformance */
        //
        /// Returns all the EVM IDs of the locked NFTs if the locked token implements CrossVMNFT.EVMNFT
        access(all) view fun getEVMIDs(): [UInt256]
        /// Returns the Flow NFT ID associated with the EVM NFT ID if the locked token implements CrossVMNFT.EVMNFT
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64?
        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256?
        access(all) view fun contractURI(): String?

        /* NFT.Collection conformance */
        //
        /// Returns the number of locked NFTs
        access(all) view fun getLength(): Int
        /// Depending on the number of locked NFTs, this may fail.
        access(all) view fun getIDs(): [UInt64]
        /// Returns a reference to the NFT if it is locked
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}?
        /// Returns a map of supported NFT types - at the moment Lockers only support the lockedNFTType defined by
        /// their contract
        access(all) view fun getSupportedNFTTypes(): {Type: Bool}
        /// Returns true if the NFT type is supported
        access(all) view fun isSupportedNFTType(type: Type): Bool
        /// Returns the NFT as a Resolver if it is locked
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}?
        /// Deposits the NFT into this locker, noting its EVM ID if it implements CrossVMNFT.EVMNFT
        access(all) fun deposit(token: @{NonFungibleToken.NFT})
        /// Withdraws the NFT from this locker, removing it from the collection and returning it
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT}
        /// Creates an empty Collection - added here for NFT.Collection conformance
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection}
    }
}

```
</details>

<details>
<summary>FlowEVMBridgeFTEscrow.cdc</summary>

```cadence
/// This escrow contract handles the locking of assets that are bridged from Flow to EVM and retrieval of locked
/// assets in escrow when they are bridged back to Flow.
access(all) contract interface FlowEVMBridgeFTEscrow {

    /* Getters */
    //
    access(all) view fun getLockedBalance(forVault: Type): UFix64
    access(all) view fun getViews(forVault: Type): [Type]
    access(all) fun resolveView(forVault: Type, viewType: Type): AnyStruct?

    /* Bridge Methods */
    //
    /// Initializes the Locker for the given Vault type if it hasn't been initialized yet
    access(account) fun initializeEscrow(forType: Type, erc20Address: EVM.EVMAddress)
    /// Locks the tokens in escrow, returning the amount of storage used by the locker after storing
    access(account) fun lockVault(_ vault: @{FungibleToken.Vault}): UInt64
    /// Unlocks the NFT of the given type and ID, reverting if it isn't in escrow
    access(account) fun unlockTokens(type: Type, amount: UFix64): @{FungibleToken.Vault}

    /* Locker */
    //
    /// The resource managing the locking & unlocking of FTs via this contract's interface
    ///
    access(all) resource Locker : CrossVMFT.EVMFT, FungibleToken.Vault {
        /// The type of FT this Locker escrows
        access(all) let lockedType: Type
        /// Corresponding ERC721 address for the locked NFTs
        access(all) let erc20Address: EVM.EVMAddress
        // Vault to hold all relevant locked FTs
        access(self) let lockedVault: @{FungibleToken.Vault}
        /// Field that tracks the balance of a vault
        access(all) var balance: UFix64

        // Returns the relevant fungible token contract
        access(all) view fun borrowContract(): &FungibleToken
        /// Returns the number of locked tokens in this locker
        access(all) view fun getBalance(): UFix64
        /// Returns a map of supported FT types - at the moment Lockers only support the lockedNFTType defined by
        /// their contract
        ///
        access(all) view fun getSupportedFTTypes(): {Type: Bool}
        /// Returns true if the NFT type is supported
        access(all) view fun isSupportedFTType(type: Type): Bool
        /// Deposits the given FT vault into this locker
        access(all) fun deposit(from: @{FungibleToken.Vault})
        access(all) view fun getSupportedVaultTypes(): {Type: Bool}
        /// Withdraws an amount of FT from this locker, removing it from the vault and returning it
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault}
        /// createEmptyVault allows any user to create a new Vault that has a zero balance
        access(all) fun createEmptyVault(): @{Vault}
        access(all) view fun getViews(): [Type]
        access(all) fun resolveView(_ view: Type): AnyStruct?
    }
}
```
</details>

<details>
<summary>BridgePermissions</summary>

```cadence
/// This contract defines a simple interface which can be implemented by any resource to prevent it from being
/// onboarded to the Flow-EVM bridge
///
/// NOTE: This is suggested only for cases where your asset (NFT/FT) incorporates non-standard logic that would
///      break your project if not handles properly
///      e.g. assets are reclaimed after a certain period of time, NFTs share IDs, etc.
///
access(all) contract interface BridgePermissions {
    /// Contract-level method enabling implementing contracts to identify whether they allow bridging for their
    /// project's assets. Implementers may consider adding a hook which would later enable an update to this value
    /// should either the project be updated or the bridge be updated to handle the asset's non-standard logic which 
    /// would otherwise prevent them from supporting VM bridging at the outset.
    access(all) view fun allowsBridging(): Bool
}

```
</details>

<details>
<summary>FlowEVMBridgeFactory.sol</summary>

```solidity
// Factory contract enabling contract deployment, Cadence to EVM associations, and EVM inspection
contract FlowBridgeFactory is Ownable {
    // Address of the deployment registry where deployed contract associations are registered. Note that this is a
    // registry for EVM contracts deployed by the bridge factory and does not include those EVM-native contracts that
    // have been onboarded to the bridge via Cadence contracts. The global source of truth is found in the Cadence
    // side of the bridge, however this registry and publicly accessible methods can serve as a source of truth
    // within EVM. Given some EVM contract, its bridge-supported Cadence type association can be found (and vice-versa)
    // by querying this contract, thus preventing impersonation attacks.
    address private deploymentRegistry;
    // Mapping of deployer tags to their implementation addresses
    mapping(string => address) private deployers;

    // Emitted when a deployer is added to the factory
     */
    event DeployerAdded(string tag, address deployerAddress);
    // Emitted when a deployer is updated in the factory
     */
    event DeployerUpdated(string tag, address oldAddress, address newAddress);
    // Emitted when a deployer is removed from the factory
     */
    event DeployerRemoved(string tag, address oldAddress);
    // Emitted when the deployment registry is updated
     */
    event DeploymentRegistryUpdated(address oldAddress, address newAddress);

    constructor() Ownable(msg.sender) {}

    // Deploys a new asset contract via a registered deployer
    function deploy(
        string memory deployerTag,
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) public onlyOwner returns (address)
    // Retrieves the Cadence type identifier associated with the bridge-deployed contract
    function getCadenceIdentifier(address contractAddr) public view returns (string memory)
    // Retrieves the address of a bridge-deployed contract by its associated Cadence type identifier
    function getContractAddress(string memory cadenceIdentifier) public view returns (address)
    // Checks if a contract address is associated with a registered deployment
    function isBridgeDeployed(address contractAddr) public view returns (bool)
    // Makes a best guess if the contract address is an ERC20 token by calling the publicly accessible ERC20
    function isERC20(address contractAddr) public view returns (bool)
    // Determines if a contract is an ERC721 token by checking if it implements the ERC721 interface via ERC165
    function isERC721(address contractAddr) public view returns (bool)
    // Determines if a contract is a valid asset by checking if it is either an ERC20 or ERC721 implementation
    function isValidAsset(address contractAddr) public view returns (bool)
    // Retrieves the address of the deployment registry
    function getRegistry() public view returns (address)
    // Retrieves the address of a deployer by its tag
    function getDeployer(string memory tag) public view returns (address)
    // Sets the address of the deployment registry
    function setDeploymentRegistry(address _deploymentRegistry) public onlyOwner
    // Adds a new deployer to the factory
    function addDeployer(string memory tag, address deployerAddress) public onlyOwner
    // Adds a deployer to the factory, or updates the address of an existing deployer
    function upsertDeployer(string memory tag, address deployerAddress) public onlyOwner
    // Removes a deployer from the factory
    function removeDeployer(string memory tag) public onlyOwner
    // Registers a new deployment in the deployment registry
    function _registerDeployment(string memory cadenceIdentifier, address contractAddr) internal
    // Asserts that the registry address is non-zero and implements the IFlowEVMDeploymentRegistry interface
    function _requireIsValidRegistry(address registryAddr) internal view
    // Asserts that the contract address is non-zero and implements the IFlowEVMBridgeDeployer interface
    function _requireIsValidDeployer(address contractAddr) internal view
    // Checks if a contract implements a specific interface
    function _implementsInterface(address contractAddr, bytes4 interfaceId) internal view returns (bool)
    // Asserts that the address is non-zero
    function _requireNotZeroAddress(address addr) internal pure
}
```
</details>


<details>
<summary>FlowBridgeDeploymentRegistry.sol</summary>

```solidity
// Store associations between bridged Flow EVM contracts and a corresponding Cadence resource type.
contract FlowBridgeDeploymentRegistry is FlowEVMDeploymentRegistry, Ownable {
    constructor() Ownable(msg.sender)

    // The address of the registrar who can register new deployments
    address public registrar;
    // Association between Cadence type identifiers and deployed contract addresses
    mapping(string => address) private cadenceIdentifierToContract;
    // Reverse association between deployed contract addresses and Cadence type identifiers
    mapping(address => string) private contractToCadenceIdentifier;

    modifier onlyRegistrar()

    // ERC165 introspection
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool)
    // Set the registrar address as the entity that can register new deployments. Only the owner can call this
    function setRegistrar(address _registrar) external onlyOwner
    // Get the Cadence type identifier associated with a contract address
    function getCadenceIdentifier(address contractAddr) external view returns (string memory)
    // Get the contract address associated with a Cadence type identifier
    function getContractAddress(string memory cadenceIdentifier) external view returns (address)
    // Check if a contract address is a registered deployment
    function isRegisteredDeployment(string memory cadenceIdentifier) external view returns (bool)
    // Check if a Cadence type identifier is associated with a registered deployment
    function isRegisteredDeployment(address contractAddr) external view returns (bool)
    // Register a new deployment address with the given Cadence type identifier. Can only be called by the
    function registerDeployment(string memory cadenceIdentifier, address contractAddr) external onlyRegistrar
    // Internal function to register a new deployment address with the given Cadence type identifier
    function _registerDeployment(string memory cadenceIdentifier, address contractAddr) internal
}

```
</details>


<details>

<summary>FlowBridgeERC20Deployer.sol</summary>

```solidity
// Deploys FlowEVMBridgedERC20 contracts with named associations to Cadence resources types. Only the
// delegated deployer can deploy new contracts. This contract is used by the Flow EVM bridge to deploy and define
// bridged ERC20 tokens which are defined natively in Cadence.
contract FlowEVMBridgedERC20Deployer is IFlowEVMBridgeDeployer, ERC165, Ownable {
    // The address of the delegated deployer who can deploy new contracts
    address public delegatedDeployer;

    event ERC20Deployed(
        address contractAddress, string name, string symbol, string cadenceTokenAddress, string cadenceVaultIdentifier
    );

    constructor() Ownable(msg.sender) {}

    modifier onlyDelegatedDeployer()

    // ERC165 introspection
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool)
    // Deploy a new FlowEVMBridgedERC20 contract with the given name, symbol, and association to a Cadence
    function deploy(
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) external onlyDelegatedDeployer returns (address)
    // Set the delegated deployer address as the entity that can deploy new contracts. Only the owner can call this
    function setDelegatedDeployer(address _delegatedDeployer) external onlyOwner
}
```
</details>

<summary>FlowBridgeERC721Deployer.sol</summary>

```solidity
// Deploys FlowEVMBridgedERC721 contracts with named associations to Cadence resources types. Only the
// delegated deployer can deploy new contracts. This contract is used by the Flow EVM bridge to deploy and define
// bridged ERC721 tokens which are defined natively in Cadence.
contract FlowEVMBridgedERC721Deployer is IFlowEVMBridgeDeployer, ERC165, Ownable {
    // The address of the delegated deployer who can deploy new contracts
    address public delegatedDeployer;

    event ERC721Deployed(
        address contractAddress, string name, string symbol, string cadenceTokenAddress, string cadenceVaultIdentifier
    );

    constructor() Ownable(msg.sender) {}

    modifier onlyDelegatedDeployer()

    // ERC165 introspection
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool)
    // Deploy a new FlowEVMBridgedERC721 contract with the given name, symbol, and association to a Cadence
    function deploy(
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) external onlyDelegatedDeployer returns (address)
    // Set the delegated deployer address as the entity that can deploy new contracts. Only the owner can call this
    function setDelegatedDeployer(address _delegatedDeployer) external onlyOwner
}
```
</details>

<details>
<summary>FlowEVMBridgedERC721.sol</summary>

```solidity
contract FlowBridgedERC721 is ERC721, ERC721URIStorage, ERC721Burnable, ERC721Enumerable, Ownable {
    string public flowNFTAddress;
    string public flowNFTIdentifier;

    constructor(
        address owner,
        string memory name,
        string memory symbol,
        string memory _flowNFTAddress,
        string memory _flowNFTIdentifier
    ) ERC721(name, symbol) Ownable(owner)

    // Enables minting of of Flow-native NFTs
    function safeMint(address to, uint256 tokenId, string memory uri) public onlyOwner
    // Retrieves the URI for the given NFT
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory)
    // ERC165 conformance & pass-through
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable, ERC721URIStorage) returns (bool)
    // Returns the Flow type identifier associated with this bridge-deployed contract
    function getFlowNFTAddress() public view returns (string memory)
    // Returns the Flow type identifier associated with this bridge-deployed contract
    function getFlowNFTIdentifier() public view returns (string memory)
    // Returns whether the given ID exists or not - deprecated by OZ, so added here for bridge validation
    function exists(uint256 tokenId) public view returns (bool)
    // Updates the URI for the given NFT which is done on bridging metadata from Cadence to EVM
    function updateTokenURI(uint256 tokenId, string memory uri) public onlyOwner
    // Getter for the contract's URI metadata
    function contractURI() public view returns (string memory)
}
```
</details>

<details>
<summary>FlowEVMBridgedERC20.sol</summary>

```solidity
contract FlowEVMBridgedERC20 is ERC20, ERC20Burnable, Ownable, ERC20Permit {
    string public flowTokenAddress;
    string public flowTokenIdentifier;
    string public contractMetadata;

    constructor(
        address owner,
        string memory name,
        string memory symbol,
        string memory _flowTokenAddress,
        string memory _flowTokenIdentifier,
        string memory _contractMetadata
    ) ERC20(name, symbol) Ownable(owner) ERC20Permit(name)

    // Enables the bridge to mint new tokens
    function mint(address to, uint256 amount) public onlyOwner
    // Returns the Flow type identifier associated with this bridge-deployed contract
    function getFlowTokenAddress() public view returns (string memory)
    // Returns the Flow type identifier associated with this bridge-deployed contract
    function getFlowTokenIdentifier() public view returns (string memory)
    // Returns the contract's metadata URI
    function contractURI() public view returns (string memory)
}
```
</details>

<details>

<summary>BridgePermissions.sol</summary>

```solidity
// Contract for which implementation is checked by the Flow VM bridge as an opt-out mechanism
// for non-standard asset contracts that wish to opt-out of bridging between Cadence & EVM. By
// default, the VM bridge operates on a permissionless basis, meaning anyone can request an asset
// be onboarded. However, some small subset of non-standard projects may wish to opt-out of this
// and this contract provides a way to do so while also enabling future opt-in.
//
// Note: The Flow VM bridge checks for permissions at asset onboarding. If your asset has already
// been onboarded, setting `permissions` to `false` will not affect movement between VMs.
//
abstract contract BridgePermissions is ERC165, IBridgePermissions {
    // The permissions for the contract to allow or disallow bridging of its assets.
    bool private _permissions;

    constructor() { _permissions = false; }

    // See {IERC165-supportsInterface}.
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool)
    // Returns true if the contract allows bridging of its assets. Checked by the Flow VM
    // bridge at asset onboarding to enable non-standard asset contracts to opt-out of bridging
    // between Cadence & EVM. Implementing this contract opts out by default but can be
    // overridden to opt-in or used in conjunction with a switch to enable opting in.
    function allowsBridging() external view virtual returns (bool)
    // Set the permissions for the contract to allow or disallow bridging of its assets.
    function _setPermissions(bool permissions) internal
}

```
</details>

### Special Cases

There are certain types of assets which may require special cased handling according to business demands or because the
asset itself, while implemented according to common standards, plays a non-standard role in either ecosystem. One such
asset falling into this category is `FlowToken`, though there may be others in the future. Here, we’ll discuss how these
two cases are handled by the bridge.

#### FlowToken

**Context**

Since $FLOW is the native token in both VMs, moving $FLOW between Cadence and EVM is integrated directly into the COA
resource and can be done without dependency on the VM bridge.

Bridging the token between VMs can be done easily via the EVM Cadence contract interface and its constructs. Depositing
\$FLOW is integrated directly into the `EVMAddress` object and can be deposited directly to any address in EVM without
the need to involve a COA resource at all. Bridging $FLOW from EVM can be done via any COA, resulting in a vault that
can be handled like any other Cadence Vault resource.

**Bridge Configuration**

Given the protocol-native integration of \$FLOW, the bridge will then special case on receipt of a request to bridge
\$FLOW to/from either VM and handle each direction accordingly. This can be done simply by filtering on the `Type` of
the requested asset.

On observing a request to bridge $FLOW to EVM, the bridge will simply leverage the existing `EVMAddress.deposit`
interface to deposit the provided Vault to the named recipient. However, since bridging $FLOW from EVM is built into the
COA resource and must be called from the owning COA - a call which is fundamentally different than that required to
transfer ERC20 to escrow - the same passthrough functionality cannot be leveraged. Due to these factors, requests to
bridge $FLOW from EVM will be filtered and reverted.

#### Generalized Cases

> :information_source: **TL;DR:** Requests to bridge special cased assets in either direction will be filtered,
> identified, and passed through to a custom handler. This handler will be initialized to disable bridging until
> explicitly enabled, at which point an association between the defining Cadence & EVM contracts will be simultaneously
> established. Once active, this handler will be routed related bridge requests, performing case-specific logic as
> needed to fulfill requests via the typical bridge entrypoints.

Building in special-cased functionality will aid code extensibility as the resources handling these requests can define
logic as needed on a case-by-case basis while maintaining a unified entry point for all bridge requests. As a
generalized solution for handling special cases, the bridge will leverage a `Handler` resource interface and maintain a
mapping of Cadence Types to Handler resource implementations.

<details>
<summary>Handler interface</summary>

```cadence
/// Handler for bridging Cadence native fungible tokens to EVM. In the event a Cadence project migrates native
/// support to EVM, this Hander can be configured to facilitate bridging the Cadence tokens to EVM. This Handler
/// then effectively allows the bridge to treat such tokens as bridge-defined on the Cadence side and EVM-native on
/// the EVM side minting/burning in Cadence and escrowing in EVM.
/// In order for this to occur, neither the Cadence token nor the EVM contract can be onboarded to the bridge - in
/// essence, neither side of the asset can be onboarded to the bridge.
/// The Handler must be configured in the bridge via the HandlerConfigurator. Once added, the bridge will filter
/// requests to bridge the token Vault to EVM through this Handler which cannot be enabled until a target EVM
/// address is set. Once the corresponding EVM contract address is known, it can be set and the Handler. It's also
/// suggested that the Handler only be enabled once sufficient liquidity has been arranged in bridge escrow on the
/// EVM side.
access(all) resource CadenceNativeTokenHandler : FlowEVMBridgeHandlerInterfaces.TokenHandler {
    /// Flag determining if request handling is enabled
    access(self) var enabled: Bool
    /// The Cadence Type this handler fulfills requests for
    access(self) var targetType: Type
    /// The EVM contract address this handler fulfills requests for. This field is optional in the event the EVM
    /// contract address is not yet known but the Cadence type must still be filtered via Handler to prevent the
    /// type from being onboarded otherwise.
    access(self) var targetEVMAddress: EVM.EVMAddress?
    /// The expected minter type for minting tokens on fulfillment
    access(self) let expectedMinterType: Type
    /// The Minter enabling minting of Cadence tokens on fulfillment from EVM
    access(self) var minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}?

    /* --- HandlerInfo --- */

    /// Returns the enabled status of the handler
    access(all) view fun isEnabled(): Bool
    /// Returns the type of the asset the handler is configured to handle
    access(all) view fun getTargetType(): Type?
    /// Returns the EVM contract address the handler is configured to handle
    access(all) view fun getTargetEVMAddress(): EVM.EVMAddress?
    /// Returns the expected minter type for the handler
    access(all) view fun getExpectedMinterType(): Type?

    /* --- TokenHandler --- */

    /// Fulfill a request to bridge tokens from Cadence to EVM, burning the provided Vault and transferring from
    /// EVM escrow to the named recipient. Assumes any fees are handled by the caller within the bridge contracts
    ///
    /// @param tokens: The Vault containing the tokens to bridge
    /// @param to: The EVM address to transfer the tokens to
    ///
    access(account)
    fun fulfillTokensToEVM(
        tokens: @{FungibleToken.Vault},
        to: EVM.EVMAddress
    ) {
        pre {
            self.isEnabled(): "Handler is not yet enabled"
            tokens.getType() == self.getTargetType(): "Invalid Vault type"
        }
    }
    /// Fulfill a request to bridge tokens from EVM to Cadence, minting the provided amount of tokens in Cadence
    /// and transferring from the named owner to bridge escrow in EVM.
    ///
    /// @param owner: The EVM address of the owner of the tokens. Should also be the caller executing the protected
    ///              transfer call.
    /// @param type: The type of the asset being bridged
    /// @param amount: The amount of tokens to bridge
    ///
    /// @return The minted Vault containing the the requested amount of Cadence tokens
    ///
    access(account)
    fun fulfillTokensFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        amount: UInt256,
        protectedTransferCall: fun (): EVM.Result
    ): @{FungibleToken.Vault} {
        pre {
            self.isEnabled(): "Handler is not yet enabled"
        }
        post {
            result.getType() == self.getTargetType(): "Invalid Vault type returned"
        }
    }

    /* --- Admin --- */

    /// Sets the target type for the handler
    access(FlowEVMBridgeHandlerInterfaces.Admin)
    fun setTargetType(_ type: Type) {
        pre {
            self.getTargetType() == nil: "Target Type has already been set"
        }
        post {
            self.getTargetType()! == type: "Problem setting target type"
        }
    }
    /// Sets the target EVM address for the handler
    access(FlowEVMBridgeHandlerInterfaces.Admin)
    fun setTargetEVMAddress(_ address: EVM.EVMAddress) {
        pre {
            self.getTargetEVMAddress() == nil: "Target EVM address has already been set"
        }
        post {
            self.getTargetEVMAddress()!.bytes == address!.bytes: "Problem setting target EVM address"
        }
    }
    /// Sets the target type for the handler
    access(FlowEVMBridgeHandlerInterfaces.Admin)
    fun setMinter(_ minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}) {
        pre {
            self.getExpectedMinterType() == minter.getType(): "Minter is not of the expected type"
            self.minter == nil: "Minter has already been set"
        }
    }
    /// Enables the handler for request handling. The
    access(FlowEVMBridgeHandlerInterfaces.Admin)
    fun enableBridging() {
        pre {
            self.minter != nil: "Cannot enable handler without a minter"
            self.getTargetType() != nil && self.getTargetEVMAddress() != nil:
                "Cannot enable before setting bridge targets"
            !self.isEnabled(): "Handler already enabled"
        }
        post {
            self.isEnabled(): "Problem enabling Handler"
            emit HandlerEnabled(
                handlerType: self.getType(),
                targetType: self.getTargetType()!,
                targetEVMAddress: self.getTargetEVMAddress()!
            )
        }
    }

    /* --- Internal --- */

    /// Returns an entitled reference to the encapsulated minter resource
    access(self)
    view fun borrowMinter(): auth(FlowEVMBridgeHandlerInterfaces.Mint) &{FlowEVMBridgeHandlerInterfaces.TokenMinter}?
}
```
</details>

Any use-case specific `Handler` will then be added to the bridge's `handlers` mapping indexed on the relevant asset
Cadence Type. Once the target EVM address is known, it can be associated with the `Handler`'s type which will prevent
the EVM contract from being onboarded as a bridged Cadence asset.

Once the `Handler` is enabled and the type -> EVM contract address association is established, the bridge will route
requests associated with the special-cased type through the `Handler` for fulfillment.

As you might imagine, this approach requires coordination between bridge maintainers and special-cased asset developers
and it is unlikely that many assets will require such treatment; however, it will be helpful to at least a couple
currently Cadence-native assets to have the option to support non-standard bridge configurations available.

### Considerations

#### NFT Metadata

##### Problem

Platform expectations between EVM & Flow NFT metadata storage differ. Whereas Flow projects generally prioritize onchain
metadata (with the exception of image data), EVM projects typically store NFT metadata in offchain systems - typically
in json blobs found in IPFS, though other patterns are also commonly used.

Since the bridge is public infrastructure, there is a need to generalize the breadth of migrated metadata. Minimizing
metadata would mean:

- Looking solely at the Solidity contract, bridged Flow-native NFTs would have very little identifying information per
  the ERC721 standard - ID & perhaps an image pointer.
- Looking solely at the Cadence contract, bridged EVM-native NFTs would have very little available onchain metadata - ID
  & perhaps an IPFS URI.

For typical bridge infrastructure connecting separate zones of sovereignty, metadata migration could be handled by their
offchain system components. However, the requirement for atomic asset migration between VMs prevents the inclusion of
such offchain systems as they would break atomicity and introduce the need for undesirable trust assumptions. For
example, upon bridging an NFT from Flow to EVM, an offchain listener would need to recognize a request to post metadata
to IPFS, post the metadata, and commit that URI to the defining EVM contract for the relevant NFT. We must trust that a/
the request is served, b/ metadata committed to IPFS, c/ commitment to the EVM contract succeeds and d/ that URI is
correct and contains correct metadata. Then there is the issue of IPFS storage funding.

##### Potential Solutions
___
ℹ️ **Update:** Since the original writing of this FLIP, another solution was proposed and implemented (currently in review
[here](https://github.com/onflow/flow-evm-bridge/pull/20)). While ideating in conversation with
[@austinkline](https://github.com/austinkline), he pointed out that data URLs are a common method for formatting and
inscribing ERC721 token URIs and mentioned he had an initial implementation of serialization in Cadence. This format
opened the door for on-the-fly serialization during the bridging flow, enabling the bridge to take a given NFT and
serialize it according to JSON schemas most commonly recognized in EVM and commit the serialized value as a data URL for
the token's URI.

Since serialization and URI data is all onchain, this URI can be updated as the Cadence NFT's metadata
changes as is the case for NFTs with sub-NFTs for instance. The format targeted for this initial implementation happens
to be OpenSea's metadata standards ([reference docs](https://docs.opensea.io/docs/metadata-standards)). A Mainnet
compatible script can be run here against any account and NFT for easy use and feedback.

Also note that a metadata view serving URI values is leveraged and defaulted to in the event projects wish to define
their bridged asset's metadata themselves. This was introduced as `EVMBridgedMetadata`, but as a standard view in
`MetadataViews` in [this PR](https://github.com/onflow/flow-nft/pull/203). This view can be used to resolve contract-
and token-level metadata as well as enables NFT projects to specify their collection's symbol - a value unsupported by
other views.
___

Alternatively, if Flow projects want their metadata to be served well across VMs, they may take it on themselves to add
offchain IPFS metadata. This would allow the ecosystem to both maintain onchain metadata advantages as well as reach
parity with EVM platform expectations. We may then want to consider a Cadence metadata view specifically for IPFS-stored
metadata to support this use case.

Yet another alternative, it may be possible to expose an API matching that of IPFS gateways so that bridge-stored NFTs
metadata could be served to IPFS clients as they would request URI material from any other provider. Imagine some IPFS
HTTP gateway say `https://ipfs.flow.com/ipfs/CID` where CID is some content-based addressing of the NFT. Requests to the
gateway could be served by access/observer or other data-availability node which, upon receiving a request, would derive
the information about where to locate the NFT from the CID, query for the NFT metadata and serialize it into a JSON blob
conforming to ERC721 metadata standards before returning the blob. On bridging a Flow-native NFT to Flow EVM, the IPFS
URI would be derived and committed to the minted NFT in the EVM side.

This construction would mean that NFT metadata never has to leave the Cadence runtime environment, but can be served on
request as if it was being retrieved from any other IPFS gateway. Of course, the engineering effort is then displaced to
Cadence serialization APIs, the mechanism to construct a CID from the provided NFT content, and an IPFS-like API bolted
on to some DA client-serving node.

Lastly, and likely more appropriately, there is also the option of creating an API similar to OpenSea's metadata API,
which would allow for querying of bridged NFT metadata from a centralized source. This service could in theory be run by
anyone - Flow Foundation or otherwise. While an offchain API would be a centralized solution, it would enable a
secondary source of truth platforms could leverage to serve metadata to their users and is in keeping with expectations
in the EVM ecosystem.

This problem and potential solutions are presented as a point of discussion and are not necessarily in scope for the
bridge's contract design. In the meantime, generalized scripts will be made available so that metadata can be retrieved
from locked NFTs using information solely available on ERC721 contracts defining bridged Flow-native NFTs (see
[@onflow/flow-evm-bridge#7](https://github.com/onflow/flow-evm-bridge/issues/7)).

#### NFT IDs
___
ℹ️ **Update:** While the id values on Cadence NFTs remains, the path forward on this problem was to introduce a simple
NFT interface (`CrossVMNFT.EVMNFT`) containing all ERC721 relevant values including name, symbol, EVM ID, token URI and
defining EVM contract address. Thanks again to [@austinkline](https://github.com/austinkline) for raising this idea in a
[GitHub comment](https://github.com/onflow/flow-nft/pull/126/files#r1463811764).
___

NFT ID values are some of the most critical token metadata, identifying each token as unique. While Flow NFTs define
IDs as `UInt64`, ERC721 IDs are `uint256`. It remains an open question as to how this reduction from `UInt256` to
`UInt64` would affect the uniqueness of NFTs bridged from EVM to Flow and how the bridge should handle such conversions
while safeguarding ownership guarantees upon bridging back.

### Drawbacks

- All contracts deployed by the bridge have the same minimized functionality restricted to their respective ecosystem
  standards
- Centralized storage of all bridged assets and their definitions presents a single, high-value target for potential
  hacks.
  - This vector is minimized by the fact that the bridge exists solely at the protocol and contract levels. Taking
    protocol security for granted, contract logic and key management are the primary considerations for compromise. This
    bridge benefits from the contained state space afforded by virtualizing the EVM environment in that offchain systems
    are not required for its function between VMs.

### Considered Alternatives

Motivated by the aforementioned drawback of centralized storage, previous iterations involved a network of distributed
accounts around a primary bridge account and contract. This primary contract served as the entrypoint for bridging
between VMs, deploying templated locking & asset-defining auxiliary contracts to distinct, contract-generated accounts.
The primary contract would conditionally deploy these auxiliary contracts on a per-asset basis as needed, maintaining a
registry for where each asset is locked/defined and routing bridge requests to their appropriate contracts.

The current approach was largely adapted from this design, but with auxiliary (locking & defining) contracts deployed to
the central bridge contract. Due to Cadence's contract namespace, it was also decided to dynamically name these
contracts using contract names derived from the relevant asset type. 

This design optimized for distributed asset storage and contract-mediated access. However, it also introduced additional
complexity and secondarily obscurity for what should be a highly transparent system. Additionally, since multisig access
is planned for the bridge and auxiliary accounts, centralization is ultimately no further improved by this design, at
least while custody is maintained on these accounts.

### Performance Implications

#### Migrations & Storage Usage

Previous network migrations have been complicated by single accounts using large amounts of storage. With a centralized
storage design, it's likely that (over time) the bridge account will consume a large amount of storage and that, given
the need to store bridged Flow-native assets indefinitely, that storage will likely only ever increase. Even if this
assumption is not true, it's to our benefit to consider and plan as if it is if account storage usage is a network-wide
issue.

Informed by initial conversations, saving state to a single account shouldn't be problematic until storage usage reaches
\>10GB of data which should give the team some time to figure out how to handle this edge case during migrations before
the problem is
encountered.

### Examples

At the current design stage, no working examples exist. However, examples will be a fast-follow as work on a proof of
concept continues. With that said, below are example transactions demonstrating the bridging of an NFT to and then from
EVM using the interface defined above.

<details>

<summary>Bridge NFT to EVM</summary>

```cadence
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges an NFT from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftContractAddress: The Flow account address hosting the NFT-defining Cadence contract
/// @param nftContractName: The name of the NFT-defining Cadence contract
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftContractAddress: Address, nftContractName: String, id: UInt64) {
    
    let nft: @{NonFungibleToken.NFT}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        let currentStorageUsage = signer.storage.used
        self.nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: currentStorageUsage - withdrawnStorageUsage
            ) * 1.10
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge
        self.coa.depositNFT(
            nft: <-self.nft,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```
</details>

<details>

<summary>Bridge NFT from EVM</summary>

```cadence
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftContractAddress: The Flow account address hosting the NFT-defining Cadence contract
/// @param nftContractName: The name of the NFT-defining Cadence contract
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftContractAddress: Address, nftContractName: String, id: UInt256) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        // Get the ERC721 contract address for the given NFT type
        self.nftType = FlowEVMBridgeUtils.buildCompositeType(
                address: nftContractAddress,
                contractName: nftContractName,
                resourceName: "NFT"
            ) ?? panic("Could not construct NFT type")

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow collection from storage path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 0)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Deposit the bridged NFT into the signer's collection
        self.collection.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```
</details>

### Compatibility

This bridge design will support bridging fungible and non-fungible token assets between VMs, and explicitly reverts on
mixed tokens - i.e. semi-fungible tokens or multi-token contracts.

Also note that the existence of this VM bridge does not preclude anyone else from building another one. The design
of this bridge and its integration with the COA resource may mean that self-rolled or project-specific bridges - while
increasing cross-VM flexibility and customization - may create infrastructure fragmentation. If this becomes a more
widespread issue, it may be worth considering a standardization of bridge interfaces and/or the addition of a routing
layer to consolidate such fragmentation.

## Prior Art

While the work is happening concurrently, there may be some cross-pollination between this project and the [Axelar
Interchain Token Service](https://github.com/AnChainAI/anchain-axelar-dapper-flowbridge).

## Source Code

The implementation against this design can be found at
[onflow/flow-evm-bridge](https://github.com/onflow/flow-evm-bridge/tree/main)




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/is_owner.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Returns whether the given owner (hex-encoded EVM address) is the owner of the given ERC721 NFT
/// defined at the hex-encoded EVM contract address
///
/// @param ofNFT: The ERC721 ID of the NFT
/// @param owner: The hex-encoded EVM address of the owner
/// @param evmContractAddress: The hex-encoded EVM contract address of the ERC721 contract
///
/// @return Whether the given owner is the owner of the given ERC721 NFT. Reverts on call failure.
///
access(all) fun main(ofNFT: UInt256, owner: String, evmContractAddress: String): Bool {
    return FlowEVMBridgeUtils.isOwner(
        ofNFT: ofNFT,
        owner: EVM.addressFromString(owner),
        evmContractAddress: EVM.addressFromString(evmContractAddress),
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/get_token_decimals.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

access(all)
fun main(erc20ContractAddressHex: String): UInt8 {
    return FlowEVMBridgeUtils.getTokenDecimals(
        evmContractAddress: EVM.addressFromString(erc20ContractAddressHex)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/transactions/destroy_coa.cdc

```
import "EVM"

transaction {
    prepare(signer: auth(UnpublishCapability, GetStorageCapabilityController, LoadValue) &Account)  {
        signer.capabilities.unpublish(/public/evm)
        let controllers = signer.capabilities.storage.getControllers(forPath: /storage/evm)
        for con in controllers {
            con.delete()
        }
        destroy signer.storage.load<@EVM.CadenceOwnedAccount>(from: /storage/evm)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/IFlowEVMBridgeDeployer.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

/**
 * @title IFlowEVMBridgeDeployer
 * @dev Interface contracts on FlowEVM which deploys EVM contracts with named associations to Cadence contracts.
 */
interface IFlowEVMBridgeDeployer is IERC165 {
    /**
     * @dev Event emitted when a new contract is deployed via this deployer
     */
    event Deployed(
        address indexed contractAddress, string name, string symbol, string cadenceAddress, string cadenceIdentifier
    );

    /**
     * @dev Event emitted when a new deployer is authorized
     */
    event DeployerAuthorized(address indexed deployer);

    /**
     * @dev Deploy a new EVM contract with the given name, symbol, and association to a Cadence contract.
     *
     * @param name The name of the EVM asset
     * @param symbol The symbol of the EVM asset
     * @param cadenceAddress The address of the associated Cadence contract
     * @param cadenceIdentifier The identifier of the associated Cadence asset type
     * @param contractURI The URI of the contract metadata
     *
     * @return The address of the deployed EVM contract
     */
    function deploy(
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) external returns (address);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/get_associated_type.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns the Cadence Type associated with the given EVM address (as its hex String)
///
/// @param evmAddressHex: The hex-encoded address of the EVM contract as a String
///
/// @return The Cadence Type associated with the EVM address or nil if the address is not onboarded. `nil` may also be
///        returned if the address is not a valid EVM address.
///
access(all)
fun main(addressHex: String): Type? {
    let address = EVM.addressFromString(addressHex)
    return FlowEVMBridgeConfig.getTypeAssociated(with: address)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/metadata/set_bridged_ft_display_view.cdc

```
import "MetadataViews"
import "FungibleTokenMetadataViews"

import "FlowEVMBridgeResolver"

/// This transaction sets the bridged FTDisplay view for all fungible tokens bridged from Flow EVM
///
transaction(
    externalURL: String,
    logoURI: String,
    logoFileTypeIdentifier: String,
    logoIPFSFilePath: String?,
    logoMediaType: String,
    socialsDict: {String: String}
) {

    let ftDisplay: FungibleTokenMetadataViews.FTDisplay
    let admin: auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // Determine the inteded File type based on the provided file type identifier
        let fileType = CompositeType(logoFileTypeIdentifier)
            ?? panic("Invalid file type identifier=".concat(logoFileTypeIdentifier))
        let file = FlowEVMBridgeResolver.buildFile(
                uri: logoURI,
                fileType: fileType,
                ipfsFilePath: logoIPFSFilePath
            ) ?? panic("Failed to build file")
        let logo = MetadataViews.Media(
                file: file,
                mediaType: logoMediaType
            )
        let logos = MetadataViews.Medias([logo])
        let socials = FlowEVMBridgeResolver.buildExternalURLMapping(fromDict: socialsDict)
        self.ftDisplay = FungibleTokenMetadataViews.FTDisplay(
                name: "This name is replaced by a bridged token's name",
                symbol: "This symbol is replaced by a bridged token's symbol",
                description: "This description is replaced by a bridged token's description",
                externalURL: MetadataViews.ExternalURL(externalURL),
                logos: logos,
                socials: socials
            )

        self.admin = signer.storage.borrow<auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin>(
                from: FlowEVMBridgeResolver.AdminStoragePath
            ) ?? panic("Missing or mis-typed Admin resource")
    }

    execute {
        self.admin.setView(self.ftDisplay)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/mint_erc20.cdc

```
import "EVM"

transaction(
    recipientHexAddress: String,
    amount: UInt256,
    erc20HexAddress: String,
    gasLimit: UInt64
) {
    
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Signer does not have a COA in storage")
    }

    execute {
        let recipientAddress = EVM.addressFromString(recipientHexAddress)
        let erc20Address = EVM.addressFromString(erc20HexAddress)
        let calldata = EVM.encodeABIWithSignature(
            "mint(address,uint256)",
            [recipientAddress, amount]
        )
        let callResult = self.coa.call(
            to: erc20Address,
            data: calldata,
            gasLimit: gasLimit,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "ERC20 mint failed with code: ".concat(callResult.errorCode.toString()))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/serialize_tests.cdc

```
import Test
import BlockchainHelpers

import "Serialize"

access(all) let admin = Test.getAccount(0x0000000000000007)
access(all) let alice = Test.createAccount()

access(all) struct NonSerializable {
    access(all) let foo: String
    init() {
        self.foo = "foo"
    }
}

access(all)
fun setup() {
    var err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
}

access(all)
fun testIntsTryToJSONStringSucceeds() {
    let i: Int = 127
    let i8: Int8 = 127
    let i16: Int16 = 127
    let i32: Int32 = 127
    let i64: Int64 = 127
    let i128: Int128 = 127
    let i256: Int256 = 127

    let expected = "\"127\""

    var actual = Serialize.tryToJSONString(i)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(i8)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(i16)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(i32)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(i64)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(i128)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(i256)
    Test.assertEqual(expected, actual!)
}

access(all)
fun testUIntsTryToJSONStringSucceeds() {
    let ui: UInt = 255
    let ui8: UInt8 = 255
    let ui16: UInt16 = 255
    let ui32: UInt32 = 255
    let ui64: UInt64 = 255
    let ui128: UInt128 = 255
    let ui256: UInt256 = 255

    let expected = "\"255\""
    
    var actual = Serialize.tryToJSONString(ui)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(ui8)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(ui16)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(ui32)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(ui64)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(ui128)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(ui256)
    Test.assertEqual(expected, actual!)
}

access(all)
fun testWordsTryToJSONStringSucceeds() {
    let word8: Word8 = 255
    let word16: Word16 = 255
    let word32: Word32 = 255
    let word64: Word64 = 255
    let word128: Word128 = 255
    let word256: Word256 = 255

    let expected = "\"255\""
    
    var actual = Serialize.tryToJSONString(word8)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(word16)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(word32)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(word64)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(word128)
    Test.assertEqual(expected, actual!)

    actual = Serialize.tryToJSONString(word256)
    Test.assertEqual(expected, actual!)
}

access(all)
fun testAddressTryToJSONStringSucceeds() {
    let address: Address = 0x0000000000000007
    let addressOpt: Address? = nil

    let expected = "\"0x0000000000000007\""
    let expectedOpt = "\"nil\""
    
    var actual = Serialize.tryToJSONString(address)
    Test.assertEqual(expected, actual!)
    
    var actualOpt = Serialize.tryToJSONString(addressOpt)
    Test.assertEqual(expectedOpt, actualOpt!)
}

access(all)
fun testStringTryToJSONStringSucceeds() {
    let str: String = "Hello, World!"
    let strOpt: String? = nil

    let expected = "\"Hello, World!\""
    let expectedOpt = "\"nil\""
    
    var actual = Serialize.tryToJSONString(str)
    Test.assertEqual(expected, actual!)
    
    var actualOpt = Serialize.tryToJSONString(strOpt)
    Test.assertEqual(expectedOpt, actualOpt!)
}

access(all)
fun testCharacterTryToJSONStringSucceeds() {
    let char: Character = "c"
    let charOpt: Character? = nil

    let expected = "\"c\""
    let expectedOpt = "\"nil\""
    
    var actual = Serialize.tryToJSONString(char)
    Test.assertEqual(expected, actual!)
    
    var actualOpt = Serialize.tryToJSONString(charOpt)
    Test.assertEqual(expectedOpt, actualOpt!)
}

access(all)
fun testUFix64TryToJSONStringSucceeds() {
    let uf64: UFix64 = UFix64.max

    let expected = "\"184467440737.09551615\""
    
    var actual = Serialize.tryToJSONString(uf64)
    Test.assertEqual(expected, actual!)
}

access(all)
fun testBoolTryToJSONStringSucceeds() {
    let t: Bool = true
    let f: Bool = false

    let expectedTrue = "\"true\""
    let expectedFalse = "\"false\""
    
    var actualTrue = Serialize.tryToJSONString(t)
    var actualFalse = Serialize.tryToJSONString(f)
    
    Test.assertEqual(expectedTrue, actualTrue!)
    Test.assertEqual(expectedFalse, actualFalse!)
}

access(all)
fun testArrayToJSONStringSucceeds() {
    let arr: [AnyStruct] = [
            NonSerializable(),
            127,
            255,
            "Hello, World!",
            "c",
            Address(0x0000000000000007),
            NonSerializable(),
            UFix64.max,
            true,
            NonSerializable(),
            NonSerializable()
        ]

    let expected = "[\"127\", \"255\", \"Hello, World!\", \"c\", \"0x0000000000000007\", \"184467440737.09551615\", \"true\"]"
    
    var actual = Serialize.arrayToJSONString(arr)

    Test.assertEqual(expected, actual!)
}

access(all)
fun testEmptyArrayToJSONStringSucceeds() {
    let arr: [AnyStruct] = []

    let expected = "[]"
    
    var actual = Serialize.arrayToJSONString(arr)

    Test.assertEqual(expected, actual!)
}

access(all)
fun testDictToJSONStringSucceeds() {
    let dict: {String: AnyStruct} = {
            "bar": NonSerializable(),
            "bool": true,
            "arr": [ 127, "Hello, World!" ],
            "foo": NonSerializable()
        }

    // Mapping values can be indexed in arbitrary order, so we need to check for all possible outputs
    var expectedOne: String = "{\"bool\": \"true\", \"arr\": [\"127\", \"Hello, World!\"]}"
    var expectedTwo: String = "{\"arr\": [\"127\", \"Hello, World!\"], \"bool\": \"true\"}"
    
    var actual: String? = Serialize.dictToJSONString(dict: dict, excludedNames: nil)
    Test.assertEqual(true, expectedOne == actual! || expectedTwo == actual!)
    
    actual = Serialize.tryToJSONString(dict)
    Test.assertEqual(true, expectedOne == actual! || expectedTwo == actual!)

    actual = Serialize.dictToJSONString(dict: dict, excludedNames: ["bool"])
    expectedOne = "{\"arr\": [\"127\", \"Hello, World!\"]}"
    Test.assertEqual(true, expectedOne == actual!)
}

access(all)
fun testEmptyDictToJSONStringSucceeds() {
    let dict: {String: AnyStruct} = {}

    // Mapping values can be indexed in arbitrary order, so we need to check for all possible outputs
    var expected: String = "{}"
    
    var actual: String? = Serialize.dictToJSONString(dict: dict, excludedNames: nil)
    Test.assertEqual(expected, actual!)
    
    actual = Serialize.tryToJSONString(dict)
    Test.assertEqual(expected, actual!)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm/upsert_deployer.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// This transaction adds the given EVM address as a deployer in the bridge factory contract, indexed on the
/// provided tag.
///
/// @param deployerTag: The tag to index the deployer with - e.g. ERC20, ERC721, etc.
/// @param deployerEVMAddressHex: The EVM address of the deployer contract as a hex string
///
transaction(deployerTag: String, deployerEVMAddressHex: String) {

    let targetDeployerEVMAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postDeployer: EVM.EVMAddress?

    prepare(signer: auth(BorrowValue) &Account) {
        self.targetDeployerEVMAddress = EVM.addressFromString(deployerEVMAddressHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        self.postDeployer = nil
    }

    execute {
        // Execute the call
        let callResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature(
                "upsertDeployer(string,address)",
                [deployerTag, self.targetDeployerEVMAddress]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Failed to add deployer")

        // Confirm the deployer was added under the tag
        let postDeployerResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature(
                "getDeployer(string)",
                [deployerTag]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(postDeployerResult.status == EVM.Status.successful, message: "Failed to get deployer")

        let decodedResult = EVM.decodeABI(
                types: [Type<EVM.EVMAddress>()],
                data: postDeployerResult.data
            )
        assert(decodedResult.length == 1, message: "Invalid response from getDeployer call")
        self.postDeployer = decodedResult[0] as! EVM.EVMAddress
    }

    post {
        self.postDeployer!.equals(self.targetDeployerEVMAddress): "Deployer was not properly configured"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/tokens/bridge_tokens_to_any_cadence_address.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges fungible tokens from EVM to Cadence assuming it has already been onboarded to the
/// FlowEVMBridge. The full amount to be transferred is sourced from EVM, so it's assumed the signer has sufficient
/// balance of the ERC20 to bridging into Cadence. Also know that the recipient Flow account must have a Receiver
/// capable of receiving the bridged tokens accessible via published Capability at the token's standard path.
///
/// NOTE: The ERC20 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM and transfer to the recipient
/// @param recipient: The Flow account address to receive the bridged tokens
///
transaction(vaultIdentifier: String, amount: UInt256, recipient: Address) {

    let vaultType: Type
    let receiver: &{FungibleToken.Receiver}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        self.vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: self.vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Reference the signer's Vault --- */
        //
        // Borrow a reference to the FungibleToken Vault, configuring if necessary
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract with name"
                .concat(tokenContractName).concat(" and address ")
                .concat(tokenContractAddress.toString()))
        let vaultData = viewResolver.resolveContractView(
                resourceType: self.vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view for Vault type ".concat(self.vaultType.identifier))
        // If the vault does not exist, create it and publish according to the contract's defined configuration
        if signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath) == nil {
            signer.storage.save(<-vaultData.createEmptyVault(), to: vaultData.storagePath)

            signer.capabilities.unpublish(vaultData.receiverPath)
            signer.capabilities.unpublish(vaultData.metadataPath)

            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)
            let metadataCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)

            signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
            signer.capabilities.publish(metadataCap, at: vaultData.metadataPath)
        }
        self.receiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow FungibleToken Vault from storage path ".concat(vaultData.storagePath.toString()))

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge request
        let vault: @{FungibleToken.Vault} <- self.coa.withdrawTokens(
            type: self.vaultType,
            amount: amount,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged vault is the correct type
        assert(
            vault.getType() == self.vaultType,
            message: "Bridged vault type mismatch - requested: ".concat(self.vaultType.identifier)
                .concat(", received: ").concat(vault.getType().identifier)
        )
        // Deposit the bridged token into the signer's vault
        self.receiver.deposit(from: <-vault)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc

```
import "FlowEVMBridgeTemplates"

/// Upserts the provided contract template stored in FlowEVMBridgeTemplates
///
/// @param forTemplate: The name of the template to upsert
/// @param newChunks: The new code chunks to upsert, chunked on the Cadence contract code separated on the contract
///     name. The included chunks should be hex-encoded bytecode values of the contract code which are then decoded
///     and stored in the FlowEVMBridgeTemplates contract under the `forTemplate` key.
///
transaction(forTemplate: String, newChunks: [String]) {
    prepare(signer: auth(BorrowValue) &Account) {
        signer.storage.borrow<&FlowEVMBridgeTemplates.Admin>(from: FlowEVMBridgeTemplates.AdminStoragePath)
            ?.upsertContractCodeChunks(forTemplate: forTemplate, chunks: newChunks)
            ?? panic("Could not borrow FlowEVMBridgeTemplates Admin reference")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/ICrossVM.cdc

```
import "EVM"

/// Contract interface denoting a cross-VM implementation, exposing methods to query EVM-associated addresses
///
access(all)
contract interface ICrossVM {

    /// Retrieves the corresponding EVM contract address, assuming a 1:1 relationship between VM implementations
    ///
    access(all)
    view fun getEVMContractAddress(): EVM.EVMAddress
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/get_registry_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

access(all)
fun main(coaHost: Address): String {
    let coa = getAuthAccount<auth(BorrowValue) &Account>(coaHost)
        .storage
        .borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
        ?? panic("Could not borrow CadenceOwnedAccount from host=".concat(coaHost.toString()))
    let res = coa.call(
        to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
        data: EVM.encodeABIWithSignature("getRegistry()", []),
        gasLimit: FlowEVMBridgeConfig.gasLimit,
        value: EVM.Balance(attoflow: UInt(0))
    )

    assert(
        res.status == EVM.Status.successful,
        message: "getRegistry call to FlowEVMBridgeFactory failed"
    )

    let decodedRes = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data) 

    assert(decodedRes.length == 1, message: "Invalid response length")

    return (decodedRes[0] as! EVM.EVMAddress).toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/test_helpers.cdc

```
import Test

import "FungibleToken"
import "NonFungibleToken"
import "ExampleNFT"
import "ExampleToken"
import "FlowStorageFees"
import "EVM"

/// This file contains constants for contract code which is used for bridge suite configuration.
/// See the python util `get_code_hex.py` to retrieve the hex-encoded Cadence either with or
/// without a separator (`{{CONTRACT_NAME}}` used in templates to 'chunk' template code).

access(all) let compiledFactoryBytecode = "608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6114b9806100a56000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c8063aff51c3e11610097578063daa09e5411610066578063daa09e5414610216578063db6d56cd14610229578063dfe1ac361461023c578063f2fde38b1461024f57600080fd5b8063aff51c3e146101bd578063b3d5dbdc146101d0578063cc435bf3146101f0578063d974d2381461020357600080fd5b806366cd5014116100d357806366cd50141461017e578063715018a61461019157806383843c9e146101995780638da5cb5b146101ac57600080fd5b806304433bbc1461010557806314902ad314610135578063263e0c1b1461014a5780635ab1bd531461016d575b600080fd5b610118610113366004611101565b610262565b6040516001600160a01b0390911681526020015b60405180910390f35b610148610143366004611153565b6102da565b005b61015d610158366004611153565b610347565b604051901515815260200161012c565b6001546001600160a01b0316610118565b61011861018c366004611101565b610737565b610148610768565b6101486101a7366004611101565b6107d6565b6000546001600160a01b0316610118565b6101486101cb366004611170565b6108eb565b6101e36101de366004611153565b610a20565b60405161012c9190611212565b61015d6101fe366004611153565b610a93565b610148610211366004611170565b610ab3565b61015d610224366004611153565b610ba0565b610118610237366004611225565b610c16565b61015d61024a366004611153565b610ceb565b61014861025d366004611153565b610d5a565b600154604051630110ceef60e21b81526000916001600160a01b0316906304433bbc90610293908590600401611212565b602060405180830381865afa1580156102b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d4919061131a565b92915050565b6102e2610d98565b6102eb81610dc7565b6001546040516001600160a01b038084169216907f61dad6e94cd5c0b65c9265246706a09bd0d11d5330f3e6b659d328151a664e8c90600090a3600180546001600160a01b0319166001600160a01b0392909216919091179055565b60408051600481526024810182526020810180516001600160e01b03166318160ddd60e01b1790529051600091829182916001600160a01b0386169161038d9190611337565b600060405180830381855afa9150503d80600081146103c8576040519150601f19603f3d011682016040523d82523d6000602084013e6103cd565b606091505b50915091508115806103de57508051155b156103ed575060009392505050565b604051600060248201526001600160a01b0385169060440160408051601f198184030181529181526020820180516001600160e01b03166370a0823160e01b1790525161043a9190611337565b600060405180830381855afa9150503d8060008114610475576040519150601f19603f3d011682016040523d82523d6000602084013e61047a565b606091505b50909250905081158061048c57508051155b1561049b575060009392505050565b60405160006024820181905260448201526001600160a01b0385169060640160408051601f198184030181529181526020820180516001600160e01b0316636eb1769f60e11b179052516104ef9190611337565b600060405180830381855afa9150503d806000811461052a576040519150601f19603f3d011682016040523d82523d6000602084013e61052f565b606091505b50909250905081158061054157508051155b15610550575060009392505050565b60408051600481526024810182526020810180516001600160e01b03166306fdde0360e01b17905290516001600160a01b0386169161058e91611337565b600060405180830381855afa9150503d80600081146105c9576040519150601f19603f3d011682016040523d82523d6000602084013e6105ce565b606091505b5090925090508115806105e057508051155b156105ef575060009392505050565b60408051600481526024810182526020810180516001600160e01b03166395d89b4160e01b17905290516001600160a01b0386169161062d91611337565b600060405180830381855afa9150503d8060008114610668576040519150601f19603f3d011682016040523d82523d6000602084013e61066d565b606091505b50909250905081158061067f57508051155b1561068e575060009392505050565b60408051600481526024810182526020810180516001600160e01b031663313ce56760e01b17905290516001600160a01b038616916106cc91611337565b600060405180830381855afa9150503d8060008114610707576040519150601f19603f3d011682016040523d82523d6000602084013e61070c565b606091505b50909250905081158061071e57508051155b1561072d575060009392505050565b5060019392505050565b60006002826040516107499190611337565b908152604051908190036020019020546001600160a01b031692915050565b610770610d98565b60405162461bcd60e51b815260206004820152603060248201527f466c6f77427269646765466163746f72793a204f776e6572736869702063616e60448201526f1b9bdd081899481c995b9bdd5b98d95960821b60648201526084015b60405180910390fd5b6107de610d98565b60006002826040516107f09190611337565b908152604051908190036020019020546001600160a01b031690508061086b5760405162461bcd60e51b815260206004820152602a60248201527f466c6f77427269646765466163746f72793a204465706c6f796572206e6f74206044820152691c9959da5cdd195c995960b21b60648201526084016107cd565b60028260405161087b9190611337565b90815260405190819003602001812080546001600160a01b03191690556108a3908390611337565b6040519081900381206001600160a01b0383168252907f03c7566b5f4959b890c1a6d38f39df053c6737c9965d9c0ddf612c86100a838b906020015b60405180910390a25050565b6108f3610d98565b6108fc81610e39565b60006001600160a01b03166002836040516109179190611337565b908152604051908190036020019020546001600160a01b0316146109945760405162461bcd60e51b815260206004820152602e60248201527f466c6f77427269646765466163746f72793a204465706c6f79657220616c726560448201526d18591e481c9959da5cdd195c995960921b60648201526084016107cd565b806002836040516109a59190611337565b90815260405190819003602001812080546001600160a01b03939093166001600160a01b0319909316929092179091556109e0908390611337565b6040519081900381206001600160a01b0383168252907fc0c30f085f0b1397c8bf23f8b851b63b33e13d11832b8320a37fca1c07dcb40f906020016108df565b600154604051632cf576f760e21b81526001600160a01b038381166004830152606092169063b3d5dbdc90602401600060405180830381865afa158015610a6b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526102d49190810190611353565b6000610a9e82610ba0565b1515610aa983610347565b1515141592915050565b610abb610d98565b610ac481610e39565b6000600283604051610ad69190611337565b908152604051908190036020019020546001600160a01b0316905080610b0557610b0083836108eb565b505050565b81600284604051610b169190611337565b90815260405190819003602001812080546001600160a01b03939093166001600160a01b031990931692909217909155610b51908490611337565b604080519182900382206001600160a01b03808516845285166020840152917f848576f8a081c5af60d89f0215c8af528186670eefd6349c05014d5b22688646910160405180910390a2505050565b6040516301ffc9a760e01b81526380ac58cd60e01b60048201526000906001600160a01b038316906301ffc9a790602401602060405180830381865afa925050508015610c0a575060408051601f3d908101601f19168201909252610c07918101906113ca565b60015b6102d457506000919050565b6000610c20610d98565b6000600288604051610c329190611337565b908152604051908190036020019020546001600160a01b03169050610c5681610e39565b60405163476d399760e01b815281906000906001600160a01b0383169063476d399790610c8f908c908c908c908c908c906004016113ec565b6020604051808303816000875af1158015610cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd2919061131a565b9050610cde8682610eab565b9998505050505050505050565b60015460405163a6de610560e01b81526001600160a01b038381166004830152600092169063a6de610590602401602060405180830381865afa158015610d36573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d491906113ca565b610d62610d98565b6001600160a01b038116610d8c57604051631e4fbdf760e01b8152600060048201526024016107cd565b610d9581610f16565b50565b6000546001600160a01b03163314610dc55760405163118cdaa760e01b81523360048201526024016107cd565b565b610dd081610f66565b610de18163976998cb60e01b610fbc565b610d955760405162461bcd60e51b815260206004820152602360248201527f466c6f77427269646765466163746f72793a20496e76616c696420726567697360448201526274727960e81b60648201526084016107cd565b610e4281610f66565b610e538163476d399760e01b610fbc565b610d955760405162461bcd60e51b815260206004820152602360248201527f466c6f77427269646765466163746f72793a20496e76616c6964206465706c6f6044820152623cb2b960e91b60648201526084016107cd565b60015460405163522791d160e01b81526001600160a01b0390911690819063522791d190610edf9086908690600401611459565b600060405180830381600087803b158015610ef957600080fd5b505af1158015610f0d573d6000803e3d6000fd5b50505050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b038116610d955760405162461bcd60e51b815260206004820152601f60248201527f466c6f77427269646765466163746f72793a205a65726f20616464726573730060448201526064016107cd565b6040516301ffc9a760e01b81526001600160e01b0319821660048201526000906001600160a01b038416906301ffc9a790602401602060405180830381865afa925050508015611029575060408051601f3d908101601f19168201909252611026918101906113ca565b60015b611035575060006102d4565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561107b5761107b61103c565b604052919050565b600067ffffffffffffffff82111561109d5761109d61103c565b50601f01601f191660200190565b600082601f8301126110bc57600080fd5b81356110cf6110ca82611083565b611052565b8181528460208386010111156110e457600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561111357600080fd5b813567ffffffffffffffff81111561112a57600080fd5b611136848285016110ab565b949350505050565b6001600160a01b0381168114610d9557600080fd5b60006020828403121561116557600080fd5b81356110358161113e565b6000806040838503121561118357600080fd5b823567ffffffffffffffff81111561119a57600080fd5b6111a6858286016110ab565b92505060208301356111b78161113e565b809150509250929050565b60005b838110156111dd5781810151838201526020016111c5565b50506000910152565b600081518084526111fe8160208601602086016111c2565b601f01601f19169290920160200192915050565b60208152600061103560208301846111e6565b60008060008060008060c0878903121561123e57600080fd5b863567ffffffffffffffff8082111561125657600080fd5b6112628a838b016110ab565b9750602089013591508082111561127857600080fd5b6112848a838b016110ab565b9650604089013591508082111561129a57600080fd5b6112a68a838b016110ab565b955060608901359150808211156112bc57600080fd5b6112c88a838b016110ab565b945060808901359150808211156112de57600080fd5b6112ea8a838b016110ab565b935060a089013591508082111561130057600080fd5b5061130d89828a016110ab565b9150509295509295509295565b60006020828403121561132c57600080fd5b81516110358161113e565b600082516113498184602087016111c2565b9190910192915050565b60006020828403121561136557600080fd5b815167ffffffffffffffff81111561137c57600080fd5b8201601f8101841361138d57600080fd5b805161139b6110ca82611083565b8181528560208385010111156113b057600080fd5b6113c18260208301602086016111c2565b95945050505050565b6000602082840312156113dc57600080fd5b8151801515811461103557600080fd5b60a0815260006113ff60a08301886111e6565b828103602084015261141181886111e6565b9050828103604084015261142581876111e6565b9050828103606084015261143981866111e6565b9050828103608084015261144d81856111e6565b98975050505050505050565b60408152600061146c60408301856111e6565b905060018060a01b0383166020830152939250505056fea26469706673582212200af9d80b662861a856536a56fb3a4afaa201b1b9be2839aa487140e647786f8f64736f6c63430008180033"

access(all) let erc20DeployerBytecode = "608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61243d806100a56000396000f3fe60806040523480156200001157600080fd5b5060043610620000875760003560e01c8063715018a61162000062578063715018a614620000fc5780638da5cb5b1462000108578063ee2d8496146200011a578063f2fde38b146200013157600080fd5b806301ffc9a7146200008c578063476d399714620000b85780636418e6de14620000e8575b600080fd5b620000a36200009d36600462000484565b62000148565b60405190151581526020015b60405180910390f35b620000cf620000c936600462000562565b6200019c565b6040516001600160a01b039091168152602001620000af565b600154620000cf906001600160a01b031681565b62000106620002c9565b005b6000546001600160a01b0316620000cf565b620001066200012b36600462000644565b620002e1565b620001066200014236600462000644565b620003b3565b60006001600160e01b0319821663476d399760e01b14806200017a57506001600160e01b03198216630704183b60e11b145b806200019657506301ffc9a760e01b6001600160e01b03198316145b92915050565b6001546000906001600160a01b03163314620002255760405162461bcd60e51b815260206004820152603f60248201527f466c6f7745564d4272696467656445524332304465706c6f7965723a204f6e6c60448201527f792064656c656761746564206465706c6f7965722063616e206465706c6f790060648201526084015b60405180910390fd5b600080546001600160a01b03168787878787604051620002459062000476565b6200025696959493929190620006b7565b604051809103906000f08015801562000273573d6000803e3d6000fd5b509050806001600160a01b03167fac166d2e64b2aaf94e9dfc7205dc17bc2a537b28fab78dfb70d79325657a8d3f88888888604051620002b7949392919062000740565b60405180910390a29695505050505050565b620002d3620003f7565b620002df600062000426565b565b620002eb620003f7565b6001600160a01b038116620003695760405162461bcd60e51b815260206004820152603f60248201527f466c6f7745564d4272696467656445524332304465706c6f7965723a20496e7660448201527f616c69642064656c656761746564206465706c6f79657220616464726573730060648201526084016200021c565b600180546001600160a01b0319166001600160a01b0383169081179091556040517fc553df5d2803898b31fac480ec2b45d67b73294d4c94a93f069f47400f76bdbb90600090a250565b620003bd620003f7565b6001600160a01b038116620003e957604051631e4fbdf760e01b8152600060048201526024016200021c565b620003f48162000426565b50565b6000546001600160a01b03163314620002df5760405163118cdaa760e01b81523360048201526024016200021c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611c6780620007a183390190565b6000602082840312156200049757600080fd5b81356001600160e01b031981168114620004b057600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112620004df57600080fd5b813567ffffffffffffffff80821115620004fd57620004fd620004b7565b604051601f8301601f19908116603f01168101908282118183101715620005285762000528620004b7565b816040528381528660208588010111156200054257600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a086880312156200057b57600080fd5b853567ffffffffffffffff808211156200059457600080fd5b620005a289838a01620004cd565b96506020880135915080821115620005b957600080fd5b620005c789838a01620004cd565b95506040880135915080821115620005de57600080fd5b620005ec89838a01620004cd565b945060608801359150808211156200060357600080fd5b6200061189838a01620004cd565b935060808801359150808211156200062857600080fd5b506200063788828901620004cd565b9150509295509295909350565b6000602082840312156200065757600080fd5b81356001600160a01b0381168114620004b057600080fd5b6000815180845260005b81811015620006975760208185018101518683018201520162000679565b506000602082860101526020601f19601f83011685010191505092915050565b6001600160a01b038716815260c060208201819052600090620006dd908301886200066f565b8281036040840152620006f181886200066f565b905082810360608401526200070781876200066f565b905082810360808401526200071d81866200066f565b905082810360a08401526200073381856200066f565b9998505050505050505050565b6080815260006200075560808301876200066f565b82810360208401526200076981876200066f565b905082810360408401526200077f81866200066f565b905082810360608401526200079581856200066f565b97965050505050505056fe6101606040523480156200001257600080fd5b5060405162001c6738038062001c6783398101604081905262000035916200036b565b858580604051806040016040528060018152602001603160f81b81525088888160039081620000659190620004ef565b506004620000748282620004ef565b506200008691508390506005620001b3565b6101205262000097816006620001b3565b61014052815160208084019190912060e052815190820120610100524660a0526200012560e05161010051604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201529081019290925260608201524660808201523060a082015260009060c00160405160208183030381529060405280519060200120905090565b60805250503060c052506001600160a01b0381166200015f57604051631e4fbdf760e01b8152600060048201526024015b60405180910390fd5b6200016a81620001ec565b50600c620001798582620004ef565b506009620001888482620004ef565b50600a620001978382620004ef565b50600b620001a68282620004ef565b5050505050505062000615565b6000602083511015620001d357620001cb836200023e565b9050620001e6565b81620001e08482620004ef565b5060ff90505b92915050565b600880546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600080829050601f815111156200026c578260405163305a27a960e01b8152600401620001569190620005bb565b80516200027982620005f0565b179392505050565b80516001600160a01b03811681146200029957600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620002d1578181015183820152602001620002b7565b50506000910152565b600082601f830112620002ec57600080fd5b81516001600160401b03808211156200030957620003096200029e565b604051601f8301601f19908116603f011681019082821181831017156200033457620003346200029e565b816040528381528660208588010111156200034e57600080fd5b62000361846020830160208901620002b4565b9695505050505050565b60008060008060008060c087890312156200038557600080fd5b620003908762000281565b60208801519096506001600160401b0380821115620003ae57600080fd5b620003bc8a838b01620002da565b96506040890151915080821115620003d357600080fd5b620003e18a838b01620002da565b95506060890151915080821115620003f857600080fd5b620004068a838b01620002da565b945060808901519150808211156200041d57600080fd5b6200042b8a838b01620002da565b935060a08901519150808211156200044257600080fd5b506200045189828a01620002da565b9150509295509295509295565b600181811c908216806200047357607f821691505b6020821081036200049457634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620004ea576000816000526020600020601f850160051c81016020861015620004c55750805b601f850160051c820191505b81811015620004e657828155600101620004d1565b5050505b505050565b81516001600160401b038111156200050b576200050b6200029e565b62000523816200051c84546200045e565b846200049a565b602080601f8311600181146200055b5760008415620005425750858301515b600019600386901b1c1916600185901b178555620004e6565b600085815260208120601f198616915b828110156200058c578886015182559484019460019091019084016200056b565b5085821015620005ab5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6020815260008251806020840152620005dc816040850160208701620002b4565b601f01601f19169190910160400192915050565b80516020808301519190811015620004945760001960209190910360031b1b16919050565b60805160a05160c05160e0516101005161012051610140516115f7620006706000396000610bd401526000610ba701526000610a6401526000610a3c01526000610997015260006109c1015260006109eb01526115f76000f3fe608060405234801561001057600080fd5b50600436106101c45760003560e01c806379cc6790116100f9578063a76b4d5611610097578063d505accf11610071578063d505accf14610373578063dd62ed3e14610386578063e8a3d485146103bf578063f2fde38b146103c757600080fd5b8063a76b4d5614610345578063a9059cbb1461034d578063b84c82461461036057600080fd5b80638da5cb5b116100d35780638da5cb5b14610307578063938e3d7b1461032257806395d89b411461033557806397d9a1591461033d57600080fd5b806379cc6790146102c65780637ecebe00146102d957806384b0196e146102ec57600080fd5b80633644e5151161016657806342966c681161014057806342966c681461027a57806370a082311461028d578063715018a6146102b657806378c13082146102be57600080fd5b80633644e5151461025557806338e5d7b31461025d57806340c10f191461026557600080fd5b806318160ddd116101a257806318160ddd146102195780631a6228961461022b57806323b872dd14610233578063313ce5671461024657600080fd5b806301ffc9a7146101c957806306fdde03146101f1578063095ea7b314610206575b600080fd5b6101dc6101d73660046110fa565b6103da565b60405190151581526020015b60405180910390f35b6101f961047d565b6040516101e89190611171565b6101dc6102143660046111a0565b61050f565b6002545b6040519081526020016101e8565b6101f9610527565b6101dc6102413660046111ca565b610536565b604051601281526020016101e8565b61021d61055a565b6101f9610569565b6102786102733660046111a0565b6105f7565b005b610278610288366004611206565b61060d565b61021d61029b36600461121f565b6001600160a01b031660009081526020819052604090205490565b61027861061a565b6101f961062e565b6102786102d43660046111a0565b61063b565b61021d6102e736600461121f565b610650565b6102f461066e565b6040516101e8979695949392919061123a565b6008546040516001600160a01b0390911681526020016101e8565b6102786103303660046112e9565b6106b4565b6101f96106c8565b6101f96106d7565b6101f96106e6565b6101dc61035b3660046111a0565b6106f3565b61027861036e3660046112e9565b610701565b61027861038136600461139a565b610712565b61021d61039436600461140d565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6101f9610851565b6102786103d536600461121f565b610860565b60006001600160e01b031982166336372b0760e01b148061040b57506001600160e01b0319821663076b417f60e31b145b8061042657506001600160e01b03198216630704183b60e11b145b8061044157506001600160e01b03198216634ec7fbed60e11b145b8061045c57506001600160e01b03198216638dbb89cf60e01b145b8061047757506301ffc9a760e01b6001600160e01b03198316145b92915050565b60606003805461048c90611440565b80601f01602080910402602001604051908101604052809291908181526020018280546104b890611440565b80156105055780601f106104da57610100808354040283529160200191610505565b820191906000526020600020905b8154815290600101906020018083116104e857829003601f168201915b5050505050905090565b60003361051d81858561089b565b5060019392505050565b60606009805461048c90611440565b6000336105448582856108ad565b61054f85858561092b565b506001949350505050565b600061056461098a565b905090565b6009805461057690611440565b80601f01602080910402602001604051908101604052809291908181526020018280546105a290611440565b80156105ef5780601f106105c4576101008083540402835291602001916105ef565b820191906000526020600020905b8154815290600101906020018083116105d257829003601f168201915b505050505081565b6105ff610ab5565b6106098282610ae2565b5050565b6106173382610b18565b50565b610622610ab5565b61062c6000610b4e565b565b600a805461057690611440565b6106468233836108ad565b6106098282610b18565b6001600160a01b038116600090815260076020526040812054610477565b600060608060008060006060610682610ba0565b61068a610bcd565b60408051600080825260208201909252600f60f81b9b939a50919850469750309650945092509050565b6106bc610ab5565b600b61060982826114ca565b6060600c805461048c90611440565b6060600a805461048c90611440565b600b805461057690611440565b60003361051d81858561092b565b610709610ab5565b61061781610bfa565b8342111561073b5760405163313c898160e11b8152600481018590526024015b60405180910390fd5b60007f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98888886107888c6001600160a01b0316600090815260076020526040902080546001810190915590565b6040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810186905260e00160405160208183030381529060405280519060200120905060006107e382610c06565b905060006107f382878787610c33565b9050896001600160a01b0316816001600160a01b03161461083a576040516325c0072360e11b81526001600160a01b0380831660048301528b166024820152604401610732565b6108458a8a8a61089b565b50505050505050505050565b6060600b805461048c90611440565b610868610ab5565b6001600160a01b03811661089257604051631e4fbdf760e01b815260006004820152602401610732565b61061781610b4e565b6108a88383836001610c61565b505050565b6001600160a01b038381166000908152600160209081526040808320938616835292905220546000198114610925578181101561091657604051637dc7a0d960e11b81526001600160a01b03841660048201526024810182905260448101839052606401610732565b61092584848484036000610c61565b50505050565b6001600160a01b03831661095557604051634b637e8f60e11b815260006004820152602401610732565b6001600160a01b03821661097f5760405163ec442f0560e01b815260006004820152602401610732565b6108a8838383610d36565b6000306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480156109e357507f000000000000000000000000000000000000000000000000000000000000000046145b15610a0d57507f000000000000000000000000000000000000000000000000000000000000000090565b610564604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201527f0000000000000000000000000000000000000000000000000000000000000000918101919091527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260009060c00160405160208183030381529060405280519060200120905090565b6008546001600160a01b0316331461062c5760405163118cdaa760e01b8152336004820152602401610732565b6001600160a01b038216610b0c5760405163ec442f0560e01b815260006004820152602401610732565b61060960008383610d36565b6001600160a01b038216610b4257604051634b637e8f60e11b815260006004820152602401610732565b61060982600083610d36565b600880546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60606105647f00000000000000000000000000000000000000000000000000000000000000006005610e60565b60606105647f00000000000000000000000000000000000000000000000000000000000000006006610e60565b600c61060982826114ca565b6000610477610c1361098a565b8360405161190160f01b8152600281019290925260228201526042902090565b600080600080610c4588888888610f0b565b925092509250610c558282610fda565b50909695505050505050565b6001600160a01b038416610c8b5760405163e602df0560e01b815260006004820152602401610732565b6001600160a01b038316610cb557604051634a1406b160e11b815260006004820152602401610732565b6001600160a01b038085166000908152600160209081526040808320938716835292905220829055801561092557826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610d2891815260200190565b60405180910390a350505050565b6001600160a01b038316610d61578060026000828254610d56919061158a565b90915550610dd39050565b6001600160a01b03831660009081526020819052604090205481811015610db45760405163391434e360e21b81526001600160a01b03851660048201526024810182905260448101839052606401610732565b6001600160a01b03841660009081526020819052604090209082900390555b6001600160a01b038216610def57600280548290039055610e0e565b6001600160a01b03821660009081526020819052604090208054820190555b816001600160a01b0316836001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610e5391815260200190565b60405180910390a3505050565b606060ff8314610e7a57610e7383611093565b9050610477565b818054610e8690611440565b80601f0160208091040260200160405190810160405280929190818152602001828054610eb290611440565b8015610eff5780601f10610ed457610100808354040283529160200191610eff565b820191906000526020600020905b815481529060010190602001808311610ee257829003601f168201915b50505050509050610477565b600080807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0841115610f465750600091506003905082610fd0565b604080516000808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa158015610f9a573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610fc657506000925060019150829050610fd0565b9250600091508190505b9450945094915050565b6000826003811115610fee57610fee6115ab565b03610ff7575050565b600182600381111561100b5761100b6115ab565b036110295760405163f645eedf60e01b815260040160405180910390fd5b600282600381111561103d5761103d6115ab565b0361105e5760405163fce698f760e01b815260048101829052602401610732565b6003826003811115611072576110726115ab565b03610609576040516335e2f38360e21b815260048101829052602401610732565b606060006110a0836110d2565b604080516020808252818301909252919250600091906020820181803683375050509182525060208101929092525090565b600060ff8216601f81111561047757604051632cd44ac360e21b815260040160405180910390fd5b60006020828403121561110c57600080fd5b81356001600160e01b03198116811461112457600080fd5b9392505050565b6000815180845260005b8181101561115157602081850181015186830182015201611135565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000611124602083018461112b565b80356001600160a01b038116811461119b57600080fd5b919050565b600080604083850312156111b357600080fd5b6111bc83611184565b946020939093013593505050565b6000806000606084860312156111df57600080fd5b6111e884611184565b92506111f660208501611184565b9150604084013590509250925092565b60006020828403121561121857600080fd5b5035919050565b60006020828403121561123157600080fd5b61112482611184565b60ff60f81b881681526000602060e0602084015261125b60e084018a61112b565b838103604085015261126d818a61112b565b606085018990526001600160a01b038816608086015260a0850187905284810360c08601528551808252602080880193509091019060005b818110156112c1578351835292840192918401916001016112a5565b50909c9b505050505050505050505050565b634e487b7160e01b600052604160045260246000fd5b6000602082840312156112fb57600080fd5b813567ffffffffffffffff8082111561131357600080fd5b818401915084601f83011261132757600080fd5b813581811115611339576113396112d3565b604051601f8201601f19908116603f01168101908382118183101715611361576113616112d3565b8160405282815287602084870101111561137a57600080fd5b826020860160208301376000928101602001929092525095945050505050565b600080600080600080600060e0888a0312156113b557600080fd5b6113be88611184565b96506113cc60208901611184565b95506040880135945060608801359350608088013560ff811681146113f057600080fd5b9699959850939692959460a0840135945060c09093013592915050565b6000806040838503121561142057600080fd5b61142983611184565b915061143760208401611184565b90509250929050565b600181811c9082168061145457607f821691505b60208210810361147457634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156108a8576000816000526020600020601f850160051c810160208610156114a35750805b601f850160051c820191505b818110156114c2578281556001016114af565b505050505050565b815167ffffffffffffffff8111156114e4576114e46112d3565b6114f8816114f28454611440565b8461147a565b602080601f83116001811461152d57600084156115155750858301515b600019600386901b1c1916600185901b1785556114c2565b600085815260208120601f198616915b8281101561155c5788860151825594840194600190910190840161153d565b508582101561157a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b8082018082111561047757634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052602160045260246000fdfea26469706673582212205925aa41f57e7f807e4f6f28f1a52085c0904a35c9a80771699e875e7c19ab3e64736f6c63430008180033a26469706673582212205b6b53df7c7e4ceae2b9ddb5724cebe40152e6f02e787328f765a5d78baec47764736f6c63430008180033"

access(all) let erc721DeployerBytecode = "608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6127b1806100a56000396000f3fe60806040523480156200001157600080fd5b5060043610620000875760003560e01c8063715018a61162000062578063715018a614620000fc5780638da5cb5b1462000108578063ee2d8496146200011a578063f2fde38b146200013157600080fd5b806301ffc9a7146200008c578063476d399714620000b85780636418e6de14620000e8575b600080fd5b620000a36200009d36600462000488565b62000148565b60405190151581526020015b60405180910390f35b620000cf620000c936600462000566565b6200019c565b6040516001600160a01b039091168152602001620000af565b600154620000cf906001600160a01b031681565b62000106620002cb565b005b6000546001600160a01b0316620000cf565b620001066200012b36600462000648565b620002e3565b620001066200014236600462000648565b620003b7565b60006001600160e01b0319821663476d399760e01b14806200017a57506001600160e01b03198216630704183b60e11b145b806200019657506301ffc9a760e01b6001600160e01b03198316145b92915050565b6001546000906001600160a01b0316331462000227576040805162461bcd60e51b81526020600482015260248101919091527f466c6f7745564d427269646765644552433732314465706c6f7965723a204f6e60448201527f6c792064656c656761746564206465706c6f7965722063616e206465706c6f7960648201526084015b60405180910390fd5b600080546001600160a01b0316878787878760405162000247906200047a565b6200025896959493929190620006bb565b604051809103906000f08015801562000275573d6000803e3d6000fd5b509050806001600160a01b03167fac166d2e64b2aaf94e9dfc7205dc17bc2a537b28fab78dfb70d79325657a8d3f88888888604051620002b9949392919062000744565b60405180910390a29695505050505050565b620002d5620003fb565b620002e160006200042a565b565b620002ed620003fb565b6001600160a01b0381166200036d576040805162461bcd60e51b81526020600482015260248101919091527f466c6f7745564d427269646765644552433732314465706c6f7965723a20496e60448201527f76616c69642064656c656761746564206465706c6f796572206164647265737360648201526084016200021e565b600180546001600160a01b0319166001600160a01b0383169081179091556040517fc553df5d2803898b31fac480ec2b45d67b73294d4c94a93f069f47400f76bdbb90600090a250565b620003c1620003fb565b6001600160a01b038116620003ed57604051631e4fbdf760e01b8152600060048201526024016200021e565b620003f8816200042a565b50565b6000546001600160a01b03163314620002e15760405163118cdaa760e01b81523360048201526024016200021e565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611fd780620007a583390190565b6000602082840312156200049b57600080fd5b81356001600160e01b031981168114620004b457600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112620004e357600080fd5b813567ffffffffffffffff80821115620005015762000501620004bb565b604051601f8301601f19908116603f011681019082821181831017156200052c576200052c620004bb565b816040528381528660208588010111156200054657600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a086880312156200057f57600080fd5b853567ffffffffffffffff808211156200059857600080fd5b620005a689838a01620004d1565b96506020880135915080821115620005bd57600080fd5b620005cb89838a01620004d1565b95506040880135915080821115620005e257600080fd5b620005f089838a01620004d1565b945060608801359150808211156200060757600080fd5b6200061589838a01620004d1565b935060808801359150808211156200062c57600080fd5b506200063b88828901620004d1565b9150509295509295909350565b6000602082840312156200065b57600080fd5b81356001600160a01b0381168114620004b457600080fd5b6000815180845260005b818110156200069b576020818501810151868301820152016200067d565b506000602082860101526020601f19601f83011685010191505092915050565b6001600160a01b038716815260c060208201819052600090620006e19083018862000673565b8281036040840152620006f5818862000673565b905082810360608401526200070b818762000673565b9050828103608084015262000721818662000673565b905082810360a084015262000737818562000673565b9998505050505050505050565b60808152600062000759608083018762000673565b82810360208401526200076d818762000673565b9050828103604084015262000783818662000673565b9050828103606084015262000799818562000673565b97965050505050505056fe60806040523480156200001157600080fd5b5060405162001fd738038062001fd7833981016040819052620000349162000211565b858585600062000045838262000395565b50600162000054828262000395565b5050506001600160a01b0381166200008657604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b6200009181620000da565b50600f620000a0858262000395565b50600c620000af848262000395565b50600d620000be838262000395565b50600e620000cd828262000395565b5050505050505062000461565b600b80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b80516001600160a01b03811681146200014457600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200017157600080fd5b81516001600160401b03808211156200018e576200018e62000149565b604051601f8301601f19908116603f01168101908282118183101715620001b957620001b962000149565b8160405283815260209250866020858801011115620001d757600080fd5b600091505b83821015620001fb5785820183015181830184015290820190620001dc565b6000602085830101528094505050505092915050565b60008060008060008060c087890312156200022b57600080fd5b62000236876200012c565b60208801519096506001600160401b03808211156200025457600080fd5b620002628a838b016200015f565b965060408901519150808211156200027957600080fd5b620002878a838b016200015f565b955060608901519150808211156200029e57600080fd5b620002ac8a838b016200015f565b94506080890151915080821115620002c357600080fd5b620002d18a838b016200015f565b935060a0890151915080821115620002e857600080fd5b50620002f789828a016200015f565b9150509295509295509295565b600181811c908216806200031957607f821691505b6020821081036200033a57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111562000390576000816000526020600020601f850160051c810160208610156200036b5750805b601f850160051c820191505b818110156200038c5782815560010162000377565b5050505b505050565b81516001600160401b03811115620003b157620003b162000149565b620003c981620003c2845462000304565b8462000340565b602080601f831160018114620004015760008415620003e85750858301515b600019600386901b1c1916600185901b1785556200038c565b600085815260208120601f198616915b82811015620004325788860151825594840194600190910190840162000411565b5085821015620004515787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b611b6680620004716000396000f3fe608060405234801561001057600080fd5b50600436106101da5760003560e01c806370a0823111610104578063b84c8246116100a2578063cd279c7c11610071578063cd279c7c146103c6578063e8a3d485146103d9578063e985e9c5146103e1578063f2fde38b146103f457600080fd5b8063b84c824614610385578063b88d4fde14610398578063bef43b9d146103ab578063c87b56dd146103b357600080fd5b806395d89b41116100de57806395d89b411461035a57806397d9a15914610362578063a22cb4651461036a578063a76b4d561461037d57600080fd5b806370a082311461032e578063715018a6146103415780638da5cb5b1461034957600080fd5b806323b872dd1161017c5780634f558e791161014b5780634f558e79146102d55780634f6ccce7146103005780636352211e1461031357806366bd8dc01461032657600080fd5b806323b872dd146102895780632f745c591461029c57806342842e0e146102af57806342966c68146102c257600080fd5b8063095ea7b3116101b8578063095ea7b31461024757806318160ddd1461025c57806318e97fd11461026e5780631a6228961461028157600080fd5b806301ffc9a7146101df57806306fdde0314610207578063081812fc1461021c575b600080fd5b6101f26101ed366004611570565b610407565b60405190151581526020015b60405180910390f35b61020f6104b9565b6040516101fe91906115dd565b61022f61022a3660046115f0565b61054b565b6040516001600160a01b0390911681526020016101fe565b61025a610255366004611625565b610574565b005b6009545b6040519081526020016101fe565b61025a61027c3660046116fb565b610583565b61020f610595565b61025a610297366004611742565b6105a4565b6102606102aa366004611625565b610634565b61025a6102bd366004611742565b610699565b61025a6102d03660046115f0565b6106b9565b6101f26102e33660046115f0565b6000908152600260205260409020546001600160a01b0316151590565b61026061030e3660046115f0565b6106c5565b61022f6103213660046115f0565b61071e565b61020f610729565b61026061033c36600461177e565b6107b7565b61025a6107ff565b600b546001600160a01b031661022f565b61020f610813565b61020f610822565b61025a610378366004611799565b610831565b61020f61083c565b61025a6103933660046117d5565b610849565b61025a6103a636600461180a565b61085d565b61020f610874565b61020f6103c13660046115f0565b610881565b61025a6103d4366004611886565b61088c565b61020f6108a8565b6101f26103ef3660046118dd565b6108b7565b61025a61040236600461177e565b6108e5565b60006001600160e01b031982166301ffc9a760e01b148061043857506001600160e01b03198216635b5e139f60e01b145b8061045357506001600160e01b0319821663780e9d6360e01b145b8061046e57506001600160e01b03198216630852cd8d60e31b145b8061048957506001600160e01b03198216630704183b60e11b145b806104a457506001600160e01b03198216638dbb89cf60e01b145b806104b357506104b382610920565b92915050565b6060600080546104c890611910565b80601f01602080910402602001604051908101604052809291908181526020018280546104f490611910565b80156105415780601f1061051657610100808354040283529160200191610541565b820191906000526020600020905b81548152906001019060200180831161052457829003601f168201915b5050505050905090565b600061055682610945565b506000828152600460205260409020546001600160a01b03166104b3565b61057f82823361097e565b5050565b61058b61098b565b61057f82826109b8565b6060600c80546104c890611910565b6001600160a01b0382166105d357604051633250574960e11b8152600060048201526024015b60405180910390fd5b60006105e0838333610a08565b9050836001600160a01b0316816001600160a01b03161461062e576040516364283d7b60e01b81526001600160a01b03808616600483015260248201849052821660448201526064016105ca565b50505050565b600061063f836107b7565b82106106705760405163295f44f760e21b81526001600160a01b0384166004820152602481018390526044016105ca565b506001600160a01b03919091166000908152600760209081526040808320938352929052205490565b6106b48383836040518060200160405280600081525061085d565b505050565b61057f60008233610a08565b60006106d060095490565b82106106f95760405163295f44f760e21b815260006004820152602481018390526044016105ca565b6009828154811061070c5761070c61194a565b90600052602060002001549050919050565b60006104b382610945565b600c805461073690611910565b80601f016020809104026020016040519081016040528092919081815260200182805461076290611910565b80156107af5780601f10610784576101008083540402835291602001916107af565b820191906000526020600020905b81548152906001019060200180831161079257829003601f168201915b505050505081565b60006001600160a01b0382166107e3576040516322718ad960e21b8152600060048201526024016105ca565b506001600160a01b031660009081526003602052604090205490565b61080761098b565b6108116000610a1d565b565b6060600f80546104c890611910565b6060600d80546104c890611910565b61057f338383610a6f565b600e805461073690611910565b61085161098b565b61085a81610b0e565b50565b6108688484846105a4565b61062e84848484610b1a565b600d805461073690611910565b60606104b382610c43565b61089461098b565b61089e8383610d4c565b6106b482826109b8565b6060600e80546104c890611910565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b6108ed61098b565b6001600160a01b03811661091757604051631e4fbdf760e01b8152600060048201526024016105ca565b61085a81610a1d565b60006001600160e01b0319821663780e9d6360e01b14806104b357506104b382610d66565b6000818152600260205260408120546001600160a01b0316806104b357604051637e27328960e01b8152600481018490526024016105ca565b6106b48383836001610d8b565b600b546001600160a01b031633146108115760405163118cdaa760e01b81523360048201526024016105ca565b60008281526006602052604090206109d082826119b0565b506040518281527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050565b6000610a15848484610e91565b949350505050565b600b80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b038216610aa157604051630b61174360e31b81526001600160a01b03831660048201526024016105ca565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b600f61057f82826119b0565b6001600160a01b0383163b1561062e57604051630a85bd0160e11b81526001600160a01b0384169063150b7a0290610b5c903390889087908790600401611a70565b6020604051808303816000875af1925050508015610b97575060408051601f3d908101601f19168201909252610b9491810190611aad565b60015b610c00573d808015610bc5576040519150601f19603f3d011682016040523d82523d6000602084013e610bca565b606091505b508051600003610bf857604051633250574960e11b81526001600160a01b03851660048201526024016105ca565b805181602001fd5b6001600160e01b03198116630a85bd0160e11b14610c3c57604051633250574960e11b81526001600160a01b03851660048201526024016105ca565b5050505050565b6060610c4e82610945565b5060008281526006602052604081208054610c6890611910565b80601f0160208091040260200160405190810160405280929190818152602001828054610c9490611910565b8015610ce15780601f10610cb657610100808354040283529160200191610ce1565b820191906000526020600020905b815481529060010190602001808311610cc457829003601f168201915b505050505090506000610cff60408051602081019091526000815290565b90508051600003610d11575092915050565b815115610d43578082604051602001610d2b929190611aca565b60405160208183030381529060405292505050919050565b610a1584610f5e565b61057f828260405180602001604052806000815250610fd3565b60006001600160e01b03198216632483248360e11b14806104b357506104b382610fea565b8080610d9f57506001600160a01b03821615155b15610e61576000610daf84610945565b90506001600160a01b03831615801590610ddb5750826001600160a01b0316816001600160a01b031614155b8015610dee5750610dec81846108b7565b155b15610e175760405163a9fbf51f60e01b81526001600160a01b03841660048201526024016105ca565b8115610e5f5783856001600160a01b0316826001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b5050600090815260046020526040902080546001600160a01b0319166001600160a01b0392909216919091179055565b600080610e9f85858561103a565b90506001600160a01b038116610efc57610ef784600980546000838152600a60205260408120829055600182018355919091527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0155565b610f1f565b846001600160a01b0316816001600160a01b031614610f1f57610f1f8185611133565b6001600160a01b038516610f3b57610f36846111c4565b610a15565b846001600160a01b0316816001600160a01b031614610a1557610a158585611273565b6060610f6982610945565b506000610f8160408051602081019091526000815290565b90506000815111610fa15760405180602001604052806000815250610fcc565b80610fab846112c3565b604051602001610fbc929190611aca565b6040516020818303038152906040525b9392505050565b610fdd8383611356565b6106b46000848484610b1a565b60006001600160e01b031982166380ac58cd60e01b148061101b57506001600160e01b03198216635b5e139f60e01b145b806104b357506301ffc9a760e01b6001600160e01b03198316146104b3565b6000828152600260205260408120546001600160a01b0390811690831615611067576110678184866113bb565b6001600160a01b038116156110a557611084600085600080610d8b565b6001600160a01b038116600090815260036020526040902080546000190190555b6001600160a01b038516156110d4576001600160a01b0385166000908152600360205260409020805460010190555b60008481526002602052604080822080546001600160a01b0319166001600160a01b0389811691821790925591518793918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4949350505050565b600061113e836107b7565b600083815260086020526040902054909150808214611191576001600160a01b03841660009081526007602090815260408083208584528252808320548484528184208190558352600890915290208190555b5060009182526008602090815260408084208490556001600160a01b039094168352600781528383209183525290812055565b6009546000906111d690600190611af9565b6000838152600a6020526040812054600980549394509092849081106111fe576111fe61194a565b90600052602060002001549050806009838154811061121f5761121f61194a565b6000918252602080832090910192909255828152600a9091526040808220849055858252812055600980548061125757611257611b1a565b6001900381819060005260206000200160009055905550505050565b60006001611280846107b7565b61128a9190611af9565b6001600160a01b039093166000908152600760209081526040808320868452825280832085905593825260089052919091209190915550565b606060006112d08361141f565b600101905060008167ffffffffffffffff8111156112f0576112f061164f565b6040519080825280601f01601f19166020018201604052801561131a576020820181803683370190505b5090508181016020015b600019016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a850494508461132457509392505050565b6001600160a01b03821661138057604051633250574960e11b8152600060048201526024016105ca565b600061138e83836000610a08565b90506001600160a01b038116156106b4576040516339e3563760e11b8152600060048201526024016105ca565b6113c68383836114f7565b6106b4576001600160a01b0383166113f457604051637e27328960e01b8152600481018290526024016105ca565b60405163177e802f60e01b81526001600160a01b0383166004820152602481018290526044016105ca565b60008072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b831061145e5772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef8100000000831061148a576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106114a857662386f26fc10000830492506010015b6305f5e10083106114c0576305f5e100830492506008015b61271083106114d457612710830492506004015b606483106114e6576064830492506002015b600a83106104b35760010192915050565b60006001600160a01b03831615801590610a155750826001600160a01b0316846001600160a01b03161480611531575061153184846108b7565b80610a155750506000908152600460205260409020546001600160a01b03908116911614919050565b6001600160e01b03198116811461085a57600080fd5b60006020828403121561158257600080fd5b8135610fcc8161155a565b60005b838110156115a8578181015183820152602001611590565b50506000910152565b600081518084526115c981602086016020860161158d565b601f01601f19169290920160200192915050565b602081526000610fcc60208301846115b1565b60006020828403121561160257600080fd5b5035919050565b80356001600160a01b038116811461162057600080fd5b919050565b6000806040838503121561163857600080fd5b61164183611609565b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b600067ffffffffffffffff808411156116805761168061164f565b604051601f8501601f19908116603f011681019082821181831017156116a8576116a861164f565b816040528093508581528686860111156116c157600080fd5b858560208301376000602087830101525050509392505050565b600082601f8301126116ec57600080fd5b610fcc83833560208501611665565b6000806040838503121561170e57600080fd5b82359150602083013567ffffffffffffffff81111561172c57600080fd5b611738858286016116db565b9150509250929050565b60008060006060848603121561175757600080fd5b61176084611609565b925061176e60208501611609565b9150604084013590509250925092565b60006020828403121561179057600080fd5b610fcc82611609565b600080604083850312156117ac57600080fd5b6117b583611609565b9150602083013580151581146117ca57600080fd5b809150509250929050565b6000602082840312156117e757600080fd5b813567ffffffffffffffff8111156117fe57600080fd5b610a15848285016116db565b6000806000806080858703121561182057600080fd5b61182985611609565b935061183760208601611609565b925060408501359150606085013567ffffffffffffffff81111561185a57600080fd5b8501601f8101871361186b57600080fd5b61187a87823560208401611665565b91505092959194509250565b60008060006060848603121561189b57600080fd5b6118a484611609565b925060208401359150604084013567ffffffffffffffff8111156118c757600080fd5b6118d3868287016116db565b9150509250925092565b600080604083850312156118f057600080fd5b6118f983611609565b915061190760208401611609565b90509250929050565b600181811c9082168061192457607f821691505b60208210810361194457634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b601f8211156106b4576000816000526020600020601f850160051c810160208610156119895750805b601f850160051c820191505b818110156119a857828155600101611995565b505050505050565b815167ffffffffffffffff8111156119ca576119ca61164f565b6119de816119d88454611910565b84611960565b602080601f831160018114611a1357600084156119fb5750858301515b600019600386901b1c1916600185901b1785556119a8565b600085815260208120601f198616915b82811015611a4257888601518255948401946001909101908401611a23565b5085821015611a605787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6001600160a01b0385811682528416602082015260408101839052608060608201819052600090611aa3908301846115b1565b9695505050505050565b600060208284031215611abf57600080fd5b8151610fcc8161155a565b60008351611adc81846020880161158d565b835190830190611af081836020880161158d565b01949350505050565b818103818111156104b357634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603160045260246000fdfea2646970667358221220e708ad8174a5df5c602c7a68f8ef19d0343c901a0800a36618542be68d6a333264736f6c63430008180033a264697066735822122073f5f1bfe1177c16816d43f4e0bbf2615d36fb452254b7ac865fb27f1e426de364736f6c63430008180033"

access(all) let registryBytecode = "608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610058565b50600080546001600160a01b031916331790556100aa565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b610bbd806100b96000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c8063862119ae11610071578063862119ae146101315780638da5cb5b14610144578063a6de610514610155578063b3d5dbdc14610168578063f2fde38b14610188578063faab9d391461019b57600080fd5b806301ffc9a7146100ae57806304433bbc146100d65780632b20e39714610101578063522791d114610114578063715018a614610129575b600080fd5b6100c16100bc366004610833565b6101ae565b60405190151581526020015b60405180910390f35b6100e96100e4366004610907565b6101e5565b6040516001600160a01b0390911681526020016100cd565b6000546100e9906001600160a01b031681565b610127610122366004610960565b610216565b005b6101276102b7565b6100c161013f366004610907565b6102cb565b6003546001600160a01b03166100e9565b6100c16101633660046109ae565b610308565b61017b6101763660046109ae565b610334565b6040516100cd91906109ed565b6101276101963660046109ae565b6103e0565b6101276101a93660046109ae565b61041e565b60006001600160e01b0319821663976998cb60e01b14806101df57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60006001826040516101f79190610a20565b908152604051908190036020019020546001600160a01b031692915050565b6000546001600160a01b031633146102a95760405162461bcd60e51b815260206004820152604560248201527f466c6f774272696467654465706c6f796d656e7452656769737472793a204f6e60448201527f6c79207265676973747261722063616e207265676973746572206173736f636960648201526430ba34b7b760d91b608482015260a4015b60405180910390fd5b6102b3828261042f565b5050565b6102bf6106fd565b6102c9600061072a565b565b6000806001600160a01b03166001836040516102e79190610a20565b908152604051908190036020019020546001600160a01b0316141592915050565b6001600160a01b0381166000908152600260205260408120805461032b90610a3c565b15159392505050565b6001600160a01b038116600090815260026020526040902080546060919061035b90610a3c565b80601f016020809104026020016040519081016040528092919081815260200182805461038790610a3c565b80156103d45780601f106103a9576101008083540402835291602001916103d4565b820191906000526020600020905b8154815290600101906020018083116103b757829003601f168201915b50505050509050919050565b6103e86106fd565b6001600160a01b03811661041257604051631e4fbdf760e01b8152600060048201526024016102a0565b61041b8161072a565b50565b6104266106fd565b61041b8161077c565b6001600160a01b0381166104ab5760405162461bcd60e51b815260206004820152603760248201527f466c6f7745564d4465706c6f796d656e7452656769737472793a20436f6e747260448201527f61637420616464726573732063616e6e6f74206265203000000000000000000060648201526084016102a0565b81516000036105225760405162461bcd60e51b815260206004820152603d60248201527f466c6f7745564d4465706c6f796d656e7452656769737472793a20436164656e60448201527f6365206964656e7469666965722063616e6e6f7420626520656d70747900000060648201526084016102a0565b60006001600160a01b031660018360405161053d9190610a20565b908152604051908190036020019020546001600160a01b0316146105cb576040805162461bcd60e51b81526020600482015260248101919091527f466c6f7745564d4465706c6f796d656e7452656769737472793a20436164656e60448201527f6365206964656e74696669657220616c7265616479207265676973746572656460648201526084016102a0565b6001600160a01b038116600090815260026020526040902080546105ee90610a3c565b1590506106635760405162461bcd60e51b815260206004820152603e60248201527f466c6f7745564d4465706c6f796d656e7452656769737472793a20436f6e747260448201527f616374206164647265737320616c72656164792072656769737465726564000060648201526084016102a0565b806001836040516106749190610a20565b908152604080516020928190038301902080546001600160a01b0319166001600160a01b0394851617905591831660009081526002909152206106b78382610ac7565b50806001600160a01b03167f25d7ffc1de7be1c9b0762be63022756c4773f73211c044d668da6bbcba3e7f14836040516106f191906109ed565b60405180910390a25050565b6003546001600160a01b031633146102c95760405163118cdaa760e01b81523360048201526024016102a0565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b0381166107eb5760405162461bcd60e51b815260206004820152603060248201527f466c6f7745564d4465706c6f796d656e7452656769737472793a20526567697360448201526f0747261722063616e6e6f7420626520360841b60648201526084016102a0565b600080546001600160a01b0319166001600160a01b038316908117825560405190917ff90b3304151c89847ba28c08c86e9391dd12ef3a402cba7d3728776a36f29d1191a250565b60006020828403121561084557600080fd5b81356001600160e01b03198116811461085d57600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261088b57600080fd5b813567ffffffffffffffff808211156108a6576108a6610864565b604051601f8301601f19908116603f011681019082821181831017156108ce576108ce610864565b816040528381528660208588010111156108e757600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561091957600080fd5b813567ffffffffffffffff81111561093057600080fd5b61093c8482850161087a565b949350505050565b80356001600160a01b038116811461095b57600080fd5b919050565b6000806040838503121561097357600080fd5b823567ffffffffffffffff81111561098a57600080fd5b6109968582860161087a565b9250506109a560208401610944565b90509250929050565b6000602082840312156109c057600080fd5b61085d82610944565b60005b838110156109e45781810151838201526020016109cc565b50506000910152565b6020815260008251806020840152610a0c8160408501602087016109c9565b601f01601f19169190910160400192915050565b60008251610a328184602087016109c9565b9190910192915050565b600181811c90821680610a5057607f821691505b602082108103610a7057634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115610ac2576000816000526020600020601f850160051c81016020861015610a9f5750805b601f850160051c820191505b81811015610abe57828155600101610aab565b5050505b505050565b815167ffffffffffffffff811115610ae157610ae1610864565b610af581610aef8454610a3c565b84610a76565b602080601f831160018114610b2a5760008415610b125750858301515b600019600386901b1c1916600185901b178555610abe565b600085815260208120601f198616915b82811015610b5957888601518255948401946001909101908401610b3a565b5085821015610b775787850151600019600388901b60f8161c191681555b5050505050600190811b0190555056fea26469706673582212207bc4fe07fbc245f342675c43729c0cf0da0a7b16d24fef9f2aac1a401e334c8964736f6c63430008180033"

access(all) let compiledERC721Bytecode = "60806040523480156200001157600080fd5b5033604051806040016040528060048152602001634e414d4560e01b8152506040518060400160405280600681526020016514d6535093d360d21b8152508160009081620000609190620001ac565b5060016200006f8282620001ac565b5050506001600160a01b038116620000a157604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b620000ac81620000b3565b5062000278565b600780546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200013057607f821691505b6020821081036200015157634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620001a7576000816000526020600020601f850160051c81016020861015620001825750805b601f850160051c820191505b81811015620001a3578281556001016200018e565b5050505b505050565b81516001600160401b03811115620001c857620001c862000105565b620001e081620001d984546200011b565b8462000157565b602080601f831160018114620002185760008415620001ff5750858301515b600019600386901b1c1916600185901b178555620001a3565b600085815260208120601f198616915b82811015620002495788860151825594840194600190910190840162000228565b5085821015620002685787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b61143080620002886000396000f3fe608060405234801561001057600080fd5b50600436106101165760003560e01c8063715018a6116100a2578063b88d4fde11610071578063b88d4fde14610239578063c87b56dd1461024c578063cd279c7c1461025f578063e985e9c514610272578063f2fde38b1461028557600080fd5b8063715018a6146102055780638da5cb5b1461020d57806395d89b411461021e578063a22cb4651461022657600080fd5b806323b872dd116100e957806323b872dd1461019857806342842e0e146101ab57806342966c68146101be5780636352211e146101d157806370a08231146101e457600080fd5b806301ffc9a71461011b57806306fdde0314610143578063081812fc14610158578063095ea7b314610183575b600080fd5b61012e610129366004610f0f565b610298565b60405190151581526020015b60405180910390f35b61014b6102a9565b60405161013a9190610f7c565b61016b610166366004610f8f565b61033b565b6040516001600160a01b03909116815260200161013a565b610196610191366004610fc4565b610364565b005b6101966101a6366004610fee565b610373565b6101966101b9366004610fee565b610403565b6101966101cc366004610f8f565b610423565b61016b6101df366004610f8f565b61042f565b6101f76101f236600461102a565b61043a565b60405190815260200161013a565b610196610482565b6007546001600160a01b031661016b565b61014b610496565b610196610234366004611045565b6104a5565b61019661024736600461110d565b6104b0565b61014b61025a366004610f8f565b6104c7565b61019661026d366004611189565b6104d2565b61012e6102803660046111f4565b6104ee565b61019661029336600461102a565b61051c565b60006102a38261055a565b92915050565b6060600080546102b890611227565b80601f01602080910402602001604051908101604052809291908181526020018280546102e490611227565b80156103315780601f1061030657610100808354040283529160200191610331565b820191906000526020600020905b81548152906001019060200180831161031457829003601f168201915b5050505050905090565b60006103468261057f565b506000828152600460205260409020546001600160a01b03166102a3565b61036f8282336105b8565b5050565b6001600160a01b0382166103a257604051633250574960e11b8152600060048201526024015b60405180910390fd5b60006103af8383336105c5565b9050836001600160a01b0316816001600160a01b0316146103fd576040516364283d7b60e01b81526001600160a01b0380861660048301526024820184905282166044820152606401610399565b50505050565b61041e838383604051806020016040528060008152506104b0565b505050565b61036f600082336105c5565b60006102a38261057f565b60006001600160a01b038216610466576040516322718ad960e21b815260006004820152602401610399565b506001600160a01b031660009081526003602052604090205490565b61048a6106be565b61049460006106eb565b565b6060600180546102b890611227565b61036f33838361073d565b6104bb848484610373565b6103fd848484846107dc565b60606102a382610905565b6104da6106be565b6104e48383610a16565b61041e8282610a30565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b6105246106be565b6001600160a01b03811661054e57604051631e4fbdf760e01b815260006004820152602401610399565b610557816106eb565b50565b60006001600160e01b03198216632483248360e11b14806102a357506102a382610a80565b6000818152600260205260408120546001600160a01b0316806102a357604051637e27328960e01b815260048101849052602401610399565b61041e8383836001610ad0565b6000828152600260205260408120546001600160a01b03908116908316156105f2576105f2818486610bd6565b6001600160a01b038116156106305761060f600085600080610ad0565b6001600160a01b038116600090815260036020526040902080546000190190555b6001600160a01b0385161561065f576001600160a01b0385166000908152600360205260409020805460010190555b60008481526002602052604080822080546001600160a01b0319166001600160a01b0389811691821790925591518793918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4949350505050565b6007546001600160a01b031633146104945760405163118cdaa760e01b8152336004820152602401610399565b600780546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03821661076f57604051630b61174360e31b81526001600160a01b0383166004820152602401610399565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6001600160a01b0383163b156103fd57604051630a85bd0160e11b81526001600160a01b0384169063150b7a029061081e903390889087908790600401611261565b6020604051808303816000875af1925050508015610859575060408051601f3d908101601f191682019092526108569181019061129e565b60015b6108c2573d808015610887576040519150601f19603f3d011682016040523d82523d6000602084013e61088c565b606091505b5080516000036108ba57604051633250574960e11b81526001600160a01b0385166004820152602401610399565b805181602001fd5b6001600160e01b03198116630a85bd0160e11b146108fe57604051633250574960e11b81526001600160a01b0385166004820152602401610399565b5050505050565b60606109108261057f565b506000828152600660205260408120805461092a90611227565b80601f016020809104026020016040519081016040528092919081815260200182805461095690611227565b80156109a35780601f10610978576101008083540402835291602001916109a3565b820191906000526020600020905b81548152906001019060200180831161098657829003601f168201915b5050505050905060006109c160408051602081019091526000815290565b905080516000036109d3575092915050565b815115610a055780826040516020016109ed9291906112bb565b60405160208183030381529060405292505050919050565b610a0e84610c3a565b949350505050565b61036f828260405180602001604052806000815250610caf565b6000828152600660205260409020610a48828261133a565b506040518281527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050565b60006001600160e01b031982166380ac58cd60e01b1480610ab157506001600160e01b03198216635b5e139f60e01b145b806102a357506301ffc9a760e01b6001600160e01b03198316146102a3565b8080610ae457506001600160a01b03821615155b15610ba6576000610af48461057f565b90506001600160a01b03831615801590610b205750826001600160a01b0316816001600160a01b031614155b8015610b335750610b3181846104ee565b155b15610b5c5760405163a9fbf51f60e01b81526001600160a01b0384166004820152602401610399565b8115610ba45783856001600160a01b0316826001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b5050600090815260046020526040902080546001600160a01b0319166001600160a01b0392909216919091179055565b610be1838383610cc6565b61041e576001600160a01b038316610c0f57604051637e27328960e01b815260048101829052602401610399565b60405163177e802f60e01b81526001600160a01b038316600482015260248101829052604401610399565b6060610c458261057f565b506000610c5d60408051602081019091526000815290565b90506000815111610c7d5760405180602001604052806000815250610ca8565b80610c8784610d29565b604051602001610c989291906112bb565b6040516020818303038152906040525b9392505050565b610cb98383610dbc565b61041e60008484846107dc565b60006001600160a01b03831615801590610a0e5750826001600160a01b0316846001600160a01b03161480610d005750610d0084846104ee565b80610a0e5750506000908152600460205260409020546001600160a01b03908116911614919050565b60606000610d3683610e21565b600101905060008167ffffffffffffffff811115610d5657610d56611081565b6040519080825280601f01601f191660200182016040528015610d80576020820181803683370190505b5090508181016020015b600019016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084610d8a57509392505050565b6001600160a01b038216610de657604051633250574960e11b815260006004820152602401610399565b6000610df4838360006105c5565b90506001600160a01b0381161561041e576040516339e3563760e11b815260006004820152602401610399565b60008072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b8310610e605772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef81000000008310610e8c576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310610eaa57662386f26fc10000830492506010015b6305f5e1008310610ec2576305f5e100830492506008015b6127108310610ed657612710830492506004015b60648310610ee8576064830492506002015b600a83106102a35760010192915050565b6001600160e01b03198116811461055757600080fd5b600060208284031215610f2157600080fd5b8135610ca881610ef9565b60005b83811015610f47578181015183820152602001610f2f565b50506000910152565b60008151808452610f68816020860160208601610f2c565b601f01601f19169290920160200192915050565b602081526000610ca86020830184610f50565b600060208284031215610fa157600080fd5b5035919050565b80356001600160a01b0381168114610fbf57600080fd5b919050565b60008060408385031215610fd757600080fd5b610fe083610fa8565b946020939093013593505050565b60008060006060848603121561100357600080fd5b61100c84610fa8565b925061101a60208501610fa8565b9150604084013590509250925092565b60006020828403121561103c57600080fd5b610ca882610fa8565b6000806040838503121561105857600080fd5b61106183610fa8565b91506020830135801515811461107657600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b600067ffffffffffffffff808411156110b2576110b2611081565b604051601f8501601f19908116603f011681019082821181831017156110da576110da611081565b816040528093508581528686860111156110f357600080fd5b858560208301376000602087830101525050509392505050565b6000806000806080858703121561112357600080fd5b61112c85610fa8565b935061113a60208601610fa8565b925060408501359150606085013567ffffffffffffffff81111561115d57600080fd5b8501601f8101871361116e57600080fd5b61117d87823560208401611097565b91505092959194509250565b60008060006060848603121561119e57600080fd5b6111a784610fa8565b925060208401359150604084013567ffffffffffffffff8111156111ca57600080fd5b8401601f810186136111db57600080fd5b6111ea86823560208401611097565b9150509250925092565b6000806040838503121561120757600080fd5b61121083610fa8565b915061121e60208401610fa8565b90509250929050565b600181811c9082168061123b57607f821691505b60208210810361125b57634e487b7160e01b600052602260045260246000fd5b50919050565b6001600160a01b038581168252841660208201526040810183905260806060820181905260009061129490830184610f50565b9695505050505050565b6000602082840312156112b057600080fd5b8151610ca881610ef9565b600083516112cd818460208801610f2c565b8351908301906112e1818360208801610f2c565b01949350505050565b601f82111561041e576000816000526020600020601f850160051c810160208610156113135750805b601f850160051c820191505b818110156113325782815560010161131f565b505050505050565b815167ffffffffffffffff81111561135457611354611081565b611368816113628454611227565b846112ea565b602080601f83116001811461139d57600084156113855750858301515b600019600386901b1c1916600185901b178555611332565b600085815260208120601f198616915b828110156113cc578886015182559484019460019091019084016113ad565b50858210156113ea5787850151600019600388901b60f8161c191681555b5050505050600190811b0190555056fea264697066735822122046da1d9cfc7c225e4655204f464e2ecbb316a6284c51c9c338433a1abb5919f864736f6c63430008170033"

access(all) let compiledERC20Bytecode = "6101606040523480156200001257600080fd5b50604051806040016040528060048152602001634e414d4560e01b81525080604051806040016040528060018152602001603160f81b81525033604051806040016040528060048152602001634e414d4560e01b8152506040518060400160405280600681526020016514d6535093d360d21b815250816003908162000099919062000318565b506004620000a8828262000318565b5050506001600160a01b038116620000db57604051631e4fbdf760e01b8152600060048201526024015b60405180910390fd5b620000e681620001a3565b50620000f4826006620001f5565b6101205262000105816007620001f5565b61014052815160208084019190912060e052815190820120610100524660a0526200019360e05161010051604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201529081019290925260608201524660808201523060a082015260009060c00160405160208183030381529060405280519060200120905090565b60805250503060c052506200045a565b600580546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060208351101562000215576200020d836200022e565b905062000228565b8162000222848262000318565b5060ff90505b92915050565b600080829050601f815111156200025c578260405163305a27a960e01b8152600401620000d29190620003e4565b8051620002698262000435565b179392505050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200029c57607f821691505b602082108103620002bd57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111562000313576000816000526020600020601f850160051c81016020861015620002ee5750805b601f850160051c820191505b818110156200030f57828155600101620002fa565b5050505b505050565b81516001600160401b0381111562000334576200033462000271565b6200034c8162000345845462000287565b84620002c3565b602080601f8311600181146200038457600084156200036b5750858301515b600019600386901b1c1916600185901b1785556200030f565b600085815260208120601f198616915b82811015620003b55788860151825594840194600190910190840162000394565b5085821015620003d45787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006020808352835180602085015260005b818110156200041457858101830151858201604001528201620003f6565b506000604082860101526040601f19601f8301168501019250505092915050565b80516020808301519190811015620002bd5760001960209190910360031b1b16919050565b60805160a05160c05160e051610100516101205161014051611147620004b5600039600061093101526000610904015260006107c101526000610799015260006106f40152600061071e0152600061074801526111476000f3fe608060405234801561001057600080fd5b50600436106101215760003560e01c8063715018a6116100ad57806395d89b411161007157806395d89b4114610258578063a9059cbb14610260578063d505accf14610273578063dd62ed3e14610286578063f2fde38b146102bf57600080fd5b8063715018a6146101f457806379cc6790146101fc5780637ecebe001461020f57806384b0196e146102225780638da5cb5b1461023d57600080fd5b8063313ce567116100f4578063313ce5671461018c5780633644e5151461019b57806340c10f19146101a357806342966c68146101b857806370a08231146101cb57600080fd5b806306fdde0314610126578063095ea7b31461014457806318160ddd1461016757806323b872dd14610179575b600080fd5b61012e6102d2565b60405161013b9190610e91565b60405180910390f35b610157610152366004610ec7565b610364565b604051901515815260200161013b565b6002545b60405190815260200161013b565b610157610187366004610ef1565b61037e565b6040516012815260200161013b565b61016b6103a2565b6101b66101b1366004610ec7565b6103b1565b005b6101b66101c6366004610f2d565b6103c7565b61016b6101d9366004610f46565b6001600160a01b031660009081526020819052604090205490565b6101b66103d4565b6101b661020a366004610ec7565b6103e8565b61016b61021d366004610f46565b6103fd565b61022a61041b565b60405161013b9796959493929190610f61565b6005546040516001600160a01b03909116815260200161013b565b61012e610461565b61015761026e366004610ec7565b610470565b6101b6610281366004610ffa565b61047e565b61016b61029436600461106d565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6101b66102cd366004610f46565b6105bd565b6060600380546102e1906110a0565b80601f016020809104026020016040519081016040528092919081815260200182805461030d906110a0565b801561035a5780601f1061032f5761010080835404028352916020019161035a565b820191906000526020600020905b81548152906001019060200180831161033d57829003601f168201915b5050505050905090565b6000336103728185856105f8565b60019150505b92915050565b60003361038c85828561060a565b610397858585610688565b506001949350505050565b60006103ac6106e7565b905090565b6103b9610812565b6103c3828261083f565b5050565b6103d13382610875565b50565b6103dc610812565b6103e660006108ab565b565b6103f382338361060a565b6103c38282610875565b6001600160a01b038116600090815260086020526040812054610378565b60006060806000806000606061042f6108fd565b61043761092a565b60408051600080825260208201909252600f60f81b9b939a50919850469750309650945092509050565b6060600480546102e1906110a0565b600033610372818585610688565b834211156104a75760405163313c898160e11b8152600481018590526024015b60405180910390fd5b60007f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98888886104f48c6001600160a01b0316600090815260086020526040902080546001810190915590565b6040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810186905260e001604051602081830303815290604052805190602001209050600061054f82610957565b9050600061055f82878787610984565b9050896001600160a01b0316816001600160a01b0316146105a6576040516325c0072360e11b81526001600160a01b0380831660048301528b16602482015260440161049e565b6105b18a8a8a6105f8565b50505050505050505050565b6105c5610812565b6001600160a01b0381166105ef57604051631e4fbdf760e01b81526000600482015260240161049e565b6103d1816108ab565b61060583838360016109b2565b505050565b6001600160a01b038381166000908152600160209081526040808320938616835292905220546000198114610682578181101561067357604051637dc7a0d960e11b81526001600160a01b0384166004820152602481018290526044810183905260640161049e565b610682848484840360006109b2565b50505050565b6001600160a01b0383166106b257604051634b637e8f60e11b81526000600482015260240161049e565b6001600160a01b0382166106dc5760405163ec442f0560e01b81526000600482015260240161049e565b610605838383610a87565b6000306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614801561074057507f000000000000000000000000000000000000000000000000000000000000000046145b1561076a57507f000000000000000000000000000000000000000000000000000000000000000090565b6103ac604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201527f0000000000000000000000000000000000000000000000000000000000000000918101919091527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260009060c00160405160208183030381529060405280519060200120905090565b6005546001600160a01b031633146103e65760405163118cdaa760e01b815233600482015260240161049e565b6001600160a01b0382166108695760405163ec442f0560e01b81526000600482015260240161049e565b6103c360008383610a87565b6001600160a01b03821661089f57604051634b637e8f60e11b81526000600482015260240161049e565b6103c382600083610a87565b600580546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60606103ac7f00000000000000000000000000000000000000000000000000000000000000006006610bb1565b60606103ac7f00000000000000000000000000000000000000000000000000000000000000006007610bb1565b60006103786109646106e7565b8360405161190160f01b8152600281019290925260228201526042902090565b60008060008061099688888888610c5c565b9250925092506109a68282610d2b565b50909695505050505050565b6001600160a01b0384166109dc5760405163e602df0560e01b81526000600482015260240161049e565b6001600160a01b038316610a0657604051634a1406b160e11b81526000600482015260240161049e565b6001600160a01b038085166000908152600160209081526040808320938716835292905220829055801561068257826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610a7991815260200190565b60405180910390a350505050565b6001600160a01b038316610ab2578060026000828254610aa791906110da565b90915550610b249050565b6001600160a01b03831660009081526020819052604090205481811015610b055760405163391434e360e21b81526001600160a01b0385166004820152602481018290526044810183905260640161049e565b6001600160a01b03841660009081526020819052604090209082900390555b6001600160a01b038216610b4057600280548290039055610b5f565b6001600160a01b03821660009081526020819052604090208054820190555b816001600160a01b0316836001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610ba491815260200190565b60405180910390a3505050565b606060ff8314610bcb57610bc483610de4565b9050610378565b818054610bd7906110a0565b80601f0160208091040260200160405190810160405280929190818152602001828054610c03906110a0565b8015610c505780601f10610c2557610100808354040283529160200191610c50565b820191906000526020600020905b815481529060010190602001808311610c3357829003601f168201915b50505050509050610378565b600080807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0841115610c975750600091506003905082610d21565b604080516000808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa158015610ceb573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610d1757506000925060019150829050610d21565b9250600091508190505b9450945094915050565b6000826003811115610d3f57610d3f6110fb565b03610d48575050565b6001826003811115610d5c57610d5c6110fb565b03610d7a5760405163f645eedf60e01b815260040160405180910390fd5b6002826003811115610d8e57610d8e6110fb565b03610daf5760405163fce698f760e01b81526004810182905260240161049e565b6003826003811115610dc357610dc36110fb565b036103c3576040516335e2f38360e21b81526004810182905260240161049e565b60606000610df183610e23565b604080516020808252818301909252919250600091906020820181803683375050509182525060208101929092525090565b600060ff8216601f81111561037857604051632cd44ac360e21b815260040160405180910390fd5b6000815180845260005b81811015610e7157602081850181015186830182015201610e55565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000610ea46020830184610e4b565b9392505050565b80356001600160a01b0381168114610ec257600080fd5b919050565b60008060408385031215610eda57600080fd5b610ee383610eab565b946020939093013593505050565b600080600060608486031215610f0657600080fd5b610f0f84610eab565b9250610f1d60208501610eab565b9150604084013590509250925092565b600060208284031215610f3f57600080fd5b5035919050565b600060208284031215610f5857600080fd5b610ea482610eab565b60ff60f81b881681526000602060e06020840152610f8260e084018a610e4b565b8381036040850152610f94818a610e4b565b606085018990526001600160a01b038816608086015260a0850187905284810360c08601528551808252602080880193509091019060005b81811015610fe857835183529284019291840191600101610fcc565b50909c9b505050505050505050505050565b600080600080600080600060e0888a03121561101557600080fd5b61101e88610eab565b965061102c60208901610eab565b95506040880135945060608801359350608088013560ff8116811461105057600080fd5b9699959850939692959460a0840135945060c09093013592915050565b6000806040838503121561108057600080fd5b61108983610eab565b915061109760208401610eab565b90509250929050565b600181811c908216806110b457607f821691505b6020821081036110d457634e487b7160e01b600052602260045260246000fd5b50919050565b8082018082111561037857634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052602160045260246000fdfea2646970667358221220f1e9d08ff3a77a5dedf27b973e8f3f8da74683e415389a21794cdc5ebb196f9164736f6c63430008170033"

access(all) let compiledWFLOWBytecode = "60c0604052600c60808190526b5772617070656420466c6f7760a01b60a090815261002d916000919061007a565b506040805180820190915260058082526457464c4f5760d81b602090920191825261005a9160019161007a565b506002805460ff1916601217905534801561007457600080fd5b50610115565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100bb57805160ff19168380011785556100e8565b828001600101855582156100e8579182015b828111156100e85782518255916020019190600101906100cd565b506100f49291506100f8565b5090565b61011291905b808211156100f457600081556001016100fe565b90565b6106e3806101246000396000f3fe60806040526004361061009c5760003560e01c8063313ce56711610064578063313ce5671461021157806370a082311461023c57806395d89b411461026f578063a9059cbb14610284578063d0e30db01461009c578063dd62ed3e146102bd5761009c565b806306fdde03146100a6578063095ea7b31461013057806318160ddd1461017d57806323b872dd146101a45780632e1a7d4d146101e7575b6100a46102f8565b005b3480156100b257600080fd5b506100bb610347565b6040805160208082528351818301528351919283929083019185019080838360005b838110156100f55781810151838201526020016100dd565b50505050905090810190601f1680156101225780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561013c57600080fd5b506101696004803603604081101561015357600080fd5b506001600160a01b0381351690602001356103d5565b604080519115158252519081900360200190f35b34801561018957600080fd5b5061019261043b565b60408051918252519081900360200190f35b3480156101b057600080fd5b50610169600480360360608110156101c757600080fd5b506001600160a01b0381358116916020810135909116906040013561043f565b3480156101f357600080fd5b506100a46004803603602081101561020a57600080fd5b5035610573565b34801561021d57600080fd5b50610226610608565b6040805160ff9092168252519081900360200190f35b34801561024857600080fd5b506101926004803603602081101561025f57600080fd5b50356001600160a01b0316610611565b34801561027b57600080fd5b506100bb610623565b34801561029057600080fd5b50610169600480360360408110156102a757600080fd5b506001600160a01b03813516906020013561067d565b3480156102c957600080fd5b50610192600480360360408110156102e057600080fd5b506001600160a01b0381358116916020013516610691565b33600081815260036020908152604091829020805434908101909155825190815291517fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c9281900390910190a2565b6000805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156103cd5780601f106103a2576101008083540402835291602001916103cd565b820191906000526020600020905b8154815290600101906020018083116103b057829003601f168201915b505050505081565b3360008181526004602090815260408083206001600160a01b038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b4790565b6001600160a01b03831660009081526003602052604081205482111561046457600080fd5b6001600160a01b03841633148015906104a257506001600160a01b038416600090815260046020908152604080832033845290915290205460001914155b15610502576001600160a01b03841660009081526004602090815260408083203384529091529020548211156104d757600080fd5b6001600160a01b03841660009081526004602090815260408083203384529091529020805483900390555b6001600160a01b03808516600081815260036020908152604080832080548890039055938716808352918490208054870190558351868152935191937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929081900390910190a35060019392505050565b3360009081526003602052604090205481111561058f57600080fd5b33600081815260036020526040808220805485900390555183156108fc0291849190818181858888f193505050501580156105ce573d6000803e3d6000fd5b5060408051828152905133917f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65919081900360200190a250565b60025460ff1681565b60036020526000908152604090205481565b60018054604080516020600284861615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156103cd5780601f106103a2576101008083540402835291602001916103cd565b600061068a33848461043f565b9392505050565b60046020908152600092835260408084209091529082529020548156fea265627a7a7231582070f4b62cd9290b18cc1aa556d5b98fd34e7976b42cbe1a04c5553cc18b2b915c64736f6c63430005110032"

access(all) let bridgedNFTCodeChunks = [
    "696d706f7274204e6f6e46756e6769626c65546f6b656e2066726f6d203078303030303030303030303030303030310a696d706f7274204d6574616461746156696577732066726f6d203078303030303030303030303030303030310a696d706f727420566965775265736f6c7665722066726f6d203078303030303030303030303030303030310a696d706f72742046756e6769626c65546f6b656e2066726f6d203078303030303030303030303030303030320a696d706f727420466c6f77546f6b656e2066726f6d203078303030303030303030303030303030330a0a696d706f72742045564d2066726f6d203078303030303030303030303030303030310a0a696d706f7274204943726f7373564d2066726f6d203078303030303030303030303030303030370a696d706f7274204943726f7373564d41737365742066726f6d203078303030303030303030303030303030370a696d706f7274204945564d4272696467654e46544d696e7465722066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467654e4654457363726f772066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d427269646765436f6e6669672066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467655574696c732066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467652066726f6d203078303030303030303030303030303030370a696d706f72742043726f7373564d4e46542066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467655265736f6c7665722066726f6d203078303030303030303030303030303030370a0a2f2f2f205468697320636f6e747261637420697320612074656d706c617465207573656420627920466c6f7745564d42726964676520746f20646566696e652045564d2d6e6174697665204e46547320627269646765642066726f6d20466c6f772045564d20746f20466c6f772e0a2f2f2f2055706f6e206465706c6f796d656e74206f66207468697320636f6e74726163742c2074686520636f6e7472616374206e616d65206973206465726976656420617320612066756e6374696f6e206f6620746865206173736574207479706520286865726520616e2045524337323120616b610a2f2f2f20616e204e46542920616e642074686520636f6e747261637427732045564d20616464726573732e20546865206465726976656420636f6e7472616374206e616d65206973207468656e206a6f696e65642077697468207468697320636f6e7472616374277320636f64652c0a2f2f2f207072657061726564206173206368756e6b7320696e20466c6f7745564d42726964676554656d706c61746573206265666f7265206265696e67206465706c6f79656420746f2074686520466c6f772045564d20427269646765206163636f756e742e0a2f2f2f0a2f2f2f204f6e206272696467696e672c2074686520455243373231206973207472616e7366657272656420746f2074686520627269646765277320436164656e63654f776e65644163636f756e742045564d206164647265737320616e642061206e6577204e4654206973206d696e7465642066726f6d0a2f2f2f207468697320636f6e747261637420746f20746865206272696467696e672063616c6c65722e204f6e2072657475726e20746f20466c6f772045564d2c2074686520726576657273652070726f6365737320697320666f6c6c6f776564202d2074686520746f6b656e206973206c6f636b65640a2f2f2f20696e204e465420657363726f7720616e642074686520455243373231206973207472616e7366657272656420746f2074686520646566696e656420726563697069656e742e20496e2074686973207761792c2074686520436164656e636520746f6b656e206163747320617320610a2f2f2f20726570726573656e746174696f6e206f6620626f7468207468652045564d204e465420616e642074687573206f776e6572736869702072696768747320746f2069742075706f6e206272696467696e67206261636b20746f20466c6f772045564d2e0a2f2f2f0a2f2f2f20546f20627269646765206265747765656e20564d732c20612063616c6c65722063616e20656974686572207573652074686520696e74657266616365206578706f736564206f6e20436164656e63654f776e65644163636f756e74206f722075736520466c6f7745564d4272696467650a2f2f2f207075626c696320636f6e7472616374206d6574686f64732e0a2f2f2f0a61636365737328616c6c2920636f6e747261637420",
    "203a204943726f7373564d2c204943726f7373564d41737365742c204945564d4272696467654e46544d696e7465722c204e6f6e46756e6769626c65546f6b656e207b0a0a202020202f2f2f20506f696e74657220746f2074686520466163746f7279206465706c6f79656420536f6c696469747920636f6e7472616374206164647265737320646566696e696e672074686520627269646765642061737365740a2020202061636365737328616c6c29206c65742065766d4e4654436f6e7472616374416464726573733a2045564d2e45564d416464726573730a202020202f2f2f204e616d65206f6620746865204e465420636f6c6c656374696f6e20646566696e656420696e2074686520636f72726573706f6e64696e672045524337323120636f6e74726163740a2020202061636365737328616c6c29206c6574206e616d653a20537472696e670a202020202f2f2f2053796d626f6c206f6620746865204e465420636f6c6c656374696f6e20646566696e656420696e2074686520636f72726573706f6e64696e672045524337323120636f6e74726163740a2020202061636365737328616c6c29206c65742073796d626f6c3a20537472696e670a202020202f2f2f20555249206f662074686520636f6e74726163742c20696620617661696c61626c6520617320612076617220696e2063617365207468652062726964676520656e61626c65732063726f73732d564d204d657461646174612073796e63696e6720696e20746865206675747572650a2020202061636365737328616c6c292076617220636f6e74726163745552493a20537472696e673f0a202020202f2f2f2052657461696e206120436f6c6c656374696f6e20746f207265666572656e6365207768656e207265736f6c76696e6720436f6c6c656374696f6e204d657461646174610a202020206163636573732873656c6629206c657420636f6c6c656374696f6e3a2040436f6c6c656374696f6e0a202020202f2f2f204d617070696e67206f6620746f6b656e205552497320696e6465786564206f6e207468656972204552433732312049442e205468697320776f756c64206e6f74206e6f726d616c6c792062652072657461696e65642077697468696e206120436164656e6365204e46540a202020202f2f2f20636f6e74726163742c206275742073696e6365204e4654206d65746164617461206d6179206265207570646174656420696e2045564d2c20697427732072657461696e6564206865726520736f207468617420746865206272696467652063616e207570646174650a202020202f2f2f20697420616761696e73742074686520736f757263652045524337323120636f6e7472616374207768696368206973207472656174656420617320746865204e4654277320736f75726365206f662074727574682e0a2020202061636365737328616c6c29206c657420746f6b656e555249733a207b55496e743235363a20537472696e677d0a0a202020202f2f2f20546865204e4654207265736f7572636520726570726573656e74696e672074686520627269646765642045524337323120746f6b656e0a202020202f2f2f0a2020202061636365737328616c6c29207265736f75726365204e4654203a204943726f7373564d41737365742e4173736574496e666f2c2043726f7373564d4e46542e45564d4e4654207b0a20202020202020202f2f2f2054686520436164656e6365204944206f6620746865204e46540a202020202020202061636365737328616c6c29206c65742069643a2055496e7436340a20202020202020202f2f2f2054686520455243373231204944206f6620746865204e46540a202020202020202061636365737328616c6c29206c65742065766d49443a2055496e743235360a20202020202020202f2f2f204164646974696f6e616c206f6e636861696e206d657461646174610a202020202020202061636365737328616c6c29206c6574206d657461646174613a207b537472696e673a20416e795374727563747d0a0a2020202020202020696e6974280a20202020202020202020202065766d49443a2055496e743235362c0a2020202020202020202020206d657461646174613a207b537472696e673a20416e795374727563747d0a202020202020202029207b0a20202020202020202020202073656c662e6964203d2073656c662e757569640a20202020202020202020202073656c662e65766d4944203d2065766d49440a20202020202020202020202073656c662e6d65746164617461203d206d657461646174610a20202020202020207d0a0a20202020202020202f2f2f2052657475726e7320746865206d65746164617461207669657720747970657320737570706f727465642062792074686973204e46540a202020202020202061636365737328616c6c2920766965772066756e20676574566965777328293a205b547970655d207b0a20202020202020202020202072657475726e205b0a20202020202020202020202020202020547970653c4d6574616461746156696577732e446973706c61793e28292c0a20202020202020202020202020202020547970653c4d6574616461746156696577732e53657269616c3e28292c0a20202020202020202020202020202020547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28292c0a20202020202020202020202020202020547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e28292c0a20202020202020202020202020202020547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28290a2020202020202020202020205d0a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e206765744e616d6528293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e6e616d650a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e2067657453796d626f6c28293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e73796d626f6c0a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e20746f6b656e55524928293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e746f6b656e555249735b73656c662e65766d49445d203f3f2022220a20202020202020207d0a0a20202020202020202f2f2f205265736f6c7665732061206d65746164617461207669657720666f722074686973204e46540a202020202020202061636365737328616c6c292066756e207265736f6c766556696577285f20766965773a2054797065293a20416e795374727563743f207b0a2020202020202020202020207377697463682076696577207b0a202020202020202020202020202020206361736520547970653c4d6574616461746156696577732e446973706c61793e28293a0a20202020202020202020202020202020202020206c657420636f6e7472616374526566203d20",
    "2e626f72726f7754686973436f6e747261637428290a202020202020202020202020202020202020202072657475726e20466c6f7745564d4272696467655265736f6c7665722e7265736f6c766542726964676564566965772862726964676564436f6e74726163743a20636f6e74726163745265662c20766965773a20547970653c4d6574616461746156696577732e446973706c61793e2829290a202020202020202020202020202020206361736520547970653c4d6574616461746156696577732e53657269616c3e28293a0a202020202020202020202020202020202020202072657475726e204d6574616461746156696577732e53657269616c280a20202020202020202020202020202020202020202020202073656c662e69640a2020202020202020202020202020202020202020290a202020202020202020202020202020206361736520547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28293a0a202020202020202020202020202020202020202072657475726e20",
    "2e7265736f6c7665436f6e747261637456696577280a2020202020202020202020202020202020202020202020207265736f75726365547970653a2073656c662e6765745479706528292c0a20202020202020202020202020202020202020202020202076696577547970653a20547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28290a2020202020202020202020202020202020202020290a202020202020202020202020202020206361736520547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e28293a0a202020202020202020202020202020202020202072657475726e20",
    "2e7265736f6c7665436f6e747261637456696577280a2020202020202020202020202020202020202020202020207265736f75726365547970653a2073656c662e6765745479706528292c0a20202020202020202020202020202020202020202020202076696577547970653a20547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e28290a2020202020202020202020202020202020202020290a202020202020202020202020202020206361736520547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28293a0a202020202020202020202020202020202020202072657475726e204d6574616461746156696577732e45564d427269646765644d65746164617461280a2020202020202020202020202020202020202020202020206e616d653a2073656c662e6765744e616d6528292c0a20202020202020202020202020202020202020202020202073796d626f6c3a2073656c662e67657453796d626f6c28292c0a2020202020202020202020202020202020202020202020207572693a204d6574616461746156696577732e55524928626173655552493a206e696c2c2076616c75653a2073656c662e746f6b656e5552492829290a2020202020202020202020202020202020202020290a2020202020202020202020207d0a20202020202020202020202072657475726e206e696c0a20202020202020207d0a0a20202020202020202f2f2f207075626c69632066756e6374696f6e207468617420616e796f6e652063616e2063616c6c20746f206372656174652061206e657720656d70747920636f6c6c656374696f6e0a202020202020202061636365737328616c6c292066756e20637265617465456d707479436f6c6c656374696f6e28293a20407b4e6f6e46756e6769626c65546f6b656e2e436f6c6c656374696f6e7d207b0a20202020202020202020202072657475726e203c2d20",
    "2e637265617465456d707479436f6c6c656374696f6e286e6674547970653a2073656c662e676574547970652829290a20202020202020207d0a0a20202020202020202f2a202d2d2d2043726f7373564d4e465420636f6e666f726d616e6365202d2d2d202a2f0a20202020202020202f2f0a20202020202020202f2f2f2052657475726e73207468652045564d20636f6e74726163742061646472657373206f6620746865204e46540a202020202020202061636365737328616c6c2920766965772066756e2067657445564d436f6e74726163744164647265737328293a2045564d2e45564d41646472657373207b0a20202020202020202020202072657475726e20",
    "2e67657445564d436f6e74726163744164647265737328290a20202020202020207d0a202020207d0a0a202020202f2f2f2054686973207265736f7572636520686f6c6473206173736f636961746564204e4654732c20616e642073657276657320717565726965732061626f75742073746f726564204e4654730a2020202061636365737328616c6c29207265736f7572636520436f6c6c656374696f6e203a2043726f7373564d4e46542e45564d4e4654436f6c6c656374696f6e207b0a20202020202020202f2f2f2064696374696f6e617279206f66204e465420636f6e666f726d696e6720746f6b656e7320696e6465786564206f6e2074686569722049440a202020202020202061636365737328616c6c2920766172206f776e65644e4654733a20407b55496e7436343a207b4e6f6e46756e6769626c65546f6b656e2e4e46547d7d0a20202020202020202f2f2f204d617070696e67206f662045564d2049447320746f20466c6f77204e4654204944730a202020202020202061636365737328636f6e747261637429206c65742065766d4944546f466c6f7749443a207b55496e743235363a2055496e7436347d0a0a202020202020202061636365737328616c6c29207661722073746f72616765506174683a2053746f72616765506174680a202020202020202061636365737328616c6c2920766172207075626c6963506174683a205075626c6963506174680a0a2020202020202020696e6974202829207b0a20202020202020202020202073656c662e6f776e65644e465473203c2d207b7d0a20202020202020202020202073656c662e65766d4944546f466c6f774944203d207b7d0a2020202020202020202020206c657420636f6c6c656374696f6e44617461203d20",
    "2e7265736f6c7665436f6e747261637456696577280a20202020202020202020202020202020202020207265736f75726365547970653a20547970653c40",
    "2e4e46543e28292c0a202020202020202020202020202020202020202076696577547970653a20547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28290a202020202020202020202020202020202920617321204d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613f0a202020202020202020202020202020203f3f2070616e69632822436f756c64206e6f74207265736f6c76652074686520636f6c6c656374696f6e2064617461207669657720666f7220746865204e465420636f6c6c656374696f6e22290a20202020202020202020202073656c662e73746f7261676550617468203d20636f6c6c656374696f6e446174612e73746f72616765506174680a20202020202020202020202073656c662e7075626c696350617468203d20636f6c6c656374696f6e446174612e7075626c6963506174680a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e206765744e616d6528293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e6e616d650a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e2067657453796d626f6c28293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e73796d626f6c0a20202020202020207d0a0a20202020202020202f2f2f2052657475726e732061206c697374206f66204e46542074797065732074686174207468697320726563656976657220616363657074730a202020202020202061636365737328616c6c2920766965772066756e20676574537570706f727465644e4654547970657328293a207b547970653a20426f6f6c7d207b0a20202020202020202020202072657475726e207b20547970653c40",
    "2e4e46543e28293a2074727565207d0a20202020202020207d0a0a20202020202020202f2f2f2052657475726e732077686574686572206f72206e6f742074686520676976656e20747970652069732061636365707465642062792074686520636f6c6c656374696f6e0a20202020202020202f2f2f204120636f6c6c656374696f6e20746861742063616e2061636365707420616e7920747970652073686f756c64206a7573742072657475726e20747275652062792064656661756c740a202020202020202061636365737328616c6c2920766965772066756e206973537570706f727465644e46545479706528747970653a2054797065293a20426f6f6c207b0a202020202020202020202072657475726e2074797065203d3d20547970653c40",
    "2e4e46543e28290a20202020202020207d0a0a20202020202020202f2f2f2052656d6f76657320616e204e46542066726f6d2074686520636f6c6c656374696f6e20616e64206d6f76657320697420746f207468652063616c6c65720a2020202020202020616363657373284e6f6e46756e6769626c65546f6b656e2e5769746864726177292066756e20776974686472617728776974686472617749443a2055496e743634293a20407b4e6f6e46756e6769626c65546f6b656e2e4e46547d207b0a2020202020202020202020206c657420746f6b656e203c2d2073656c662e6f776e65644e4654732e72656d6f7665286b65793a2077697468647261774944290a202020202020202020202020202020203f3f2070616e69632822436f756c64206e6f7420776974686472617720616e204e46542077697468207468652070726f76696465642049442066726f6d2074686520636f6c6c656374696f6e22290a0a20202020202020202020202072657475726e203c2d746f6b656e0a20202020202020207d0a0a20202020202020202f2f2f2057697468647261777320616e204e46542066726f6d2074686520636f6c6c656374696f6e206279206974732045564d2049440a2020202020202020616363657373284e6f6e46756e6769626c65546f6b656e2e5769746864726177292066756e207769746864726177427945564d4944285f2069643a2055496e74323536293a20407b4e6f6e46756e6769626c65546f6b656e2e4e46547d207b0a20202020202020202020202072657475726e203c2d2073656c662e776974686472617728776974686472617749443a200a2020202020202020202020202020202073656c662e676574436164656e636549442866726f6d3a20696429203f3f2070616e69632822436f756c64206e6f7420776974686472617720616e204e46542077697468207468652070726f76696465642045564d2049442066726f6d2074686520636f6c6c656374696f6e22290a202020202020202020202020290a20202020202020207d0a0a20202020202020202f2f2f205474616b65732061204e465420616e64206164647320697420746f2074686520636f6c6c656374696f6e732064696374696f6e61727920616e6420616464732074686520494420746f207468652065766d4944546f466c6f774944206d617070696e670a202020202020202061636365737328616c6c292066756e206465706f73697428746f6b656e3a20407b4e6f6e46756e6769626c65546f6b656e2e4e46547d29207b0a2020202020202020202020206c657420746f6b656e203c2d20746f6b656e206173212040",
    "2e4e46540a0a2020202020202020202020202f2f2061646420746865206e657720746f6b656e20746f207468652064696374696f6e6172792077686963682072656d6f76657320746865206f6c64206f6e650a20202020202020202020202073656c662e65766d4944546f466c6f7749445b746f6b656e2e65766d49445d203d20746f6b656e2e69640a2020202020202020202020206c6574206f6c64546f6b656e203c2d2073656c662e6f776e65644e4654735b746f6b656e2e69645d203c2d20746f6b656e0a0a20202020202020202020202064657374726f79206f6c64546f6b656e0a20202020202020207d0a0a20202020202020202f2f2f2052657475726e7320616e206172726179206f66207468652049447320746861742061726520696e2074686520636f6c6c656374696f6e0a202020202020202061636365737328616c6c2920766965772066756e2067657449447328293a205b55496e7436345d207b0a20202020202020202020202072657475726e2073656c662e6f776e65644e4654732e6b6579730a20202020202020207d0a0a20202020202020202f2f2f2052657475726e7320616e206172726179206f66207468652045564d2049447320746861742061726520696e2074686520636f6c6c656374696f6e0a202020202020202061636365737328616c6c2920766965772066756e2067657445564d49447328293a205b55496e743235365d207b0a20202020202020202020202072657475726e2073656c662e65766d4944546f466c6f7749442e6b6579730a20202020202020207d0a0a20202020202020202f2f2f2052657475726e732074686520436164656e6365204e46542e696420666f722074686520676976656e2045564d204e46542049442069662069742065786973747320696e2074686520636f6c6c656374696f6e0a202020202020202061636365737328616c6c2920766965772066756e20676574436164656e636549442866726f6d2065766d49443a2055496e74323536293a2055496e7436343f207b0a20202020202020202020202069662073656c662e65766d4944546f466c6f7749445b65766d49445d20213d206e696c207b0a2020202020202020202020202020202072657475726e2073656c662e65766d4944546f466c6f7749445b65766d49445d0a2020202020202020202020207d20656c73652069662065766d4944203c2055496e743235362855496e7436342e6d6178292026262073656c662e626f72726f774e46542855496e7436342865766d4944292920213d206e696c207b0a2020202020202020202020202020202072657475726e2055496e7436342865766d4944290a2020202020202020202020207d20656c7365207b0a2020202020202020202020202020202072657475726e206e696c0a2020202020202020202020207d0a20202020202020207d0a0a20202020202020202f2f2f2052657475726e73207468652045564d204e4654204944206173736f63696174656420776974682074686520436164656e6365204e46542049442e2054686520676f616c20697320746f20726574726965766520746865204552433732312049442076616c75652e0a20202020202020202f2f2f20417320666172206173207468652062726964676520697320636f6e6365726e65642c20616e2045524337323120646566696e6564206279207468652062726964676520697320746865204e46542773204944206174207468652074696d65206f66206272696467696e670a20202020202020202f2f2f206f72207468652076616c7565206f6620746865204e46542e65766d494420696620697420696d706c656d656e7473207468652043726f7373564d4e46542e45564d4e465420696e74657266616365207768656e20627269646765642e0a20202020202020202f2f2f20466f6c6c6f77696e672074686973207061747465726e2c206966206c6f636b65642c20746865204e465420697320636865636b656420666f722045564d4e465420636f6e666f726d616e63652072657475726e696e67202e65766d494420696620736f2c0a20202020202020202f2f2f206f746865727769736520746865204e465427732049442069732072657475726e656420617320612055496e743235362073696e63652074686174277320686f77207468652062726964676520776f756c642068616e646c65206d696e74696e6720696e207468650a20202020202020202f2f2f20636f72726573706f6e64696e672045524337323120636f6e74726163742e0a20202020202020202f2f2f0a202020202020202061636365737328616c6c2920766965772066756e2067657445564d49442866726f6d20636164656e636549443a2055496e743634293a2055496e743235363f207b0a2020202020202020202020206966206c6574206e6674203d2073656c662e626f72726f774e465428636164656e6365494429207b0a202020202020202020202020202020206966206c65742065766d4e4654203d2043726f7373564d4e46542e67657445564d49442866726f6d3a206e667429207b0a202020202020202020202020202020202020202072657475726e2065766d4e46540a202020202020202020202020202020207d0a2020202020202020202020202020202072657475726e2055496e74323536286e66742e6964290a2020202020202020202020207d0a20202020202020202020202072657475726e206e696c0a20202020202020207d0a0a20202020202020202f2f2f2052657475726e732074686520636f6e747261637455524920666f7220746865204e465420636f6c6c656374696f6e20617320646566696e656420696e2074686520736f757263652045524337323120636f6e74726163742e204966206e6f6e65207761730a20202020202020202f2f2f20646566696e6564206174207468652074696d65206f66206272696467696e672c20616e20656d70747920737472696e672069732072657475726e65642e0a202020202020202061636365737328616c6c2920766965772066756e20636f6e747261637455524928293a20537472696e673f207b0a20202020202020202020202072657475726e20",
    "2e636f6e74726163745552490a20202020202020207d0a0a20202020202020202f2f2f20476574732074686520616d6f756e74206f66204e4654732073746f72656420696e2074686520636f6c6c656374696f6e0a202020202020202061636365737328616c6c2920766965772066756e206765744c656e67746828293a20496e74207b0a20202020202020202020202072657475726e2073656c662e6f776e65644e4654732e6b6579732e6c656e6774680a20202020202020207d0a0a20202020202020202f2f2f205265747269657665732061207265666572656e636520746f20746865204e46542073746f72656420696e2074686520636f6c6c656374696f6e206279206974732049440a202020202020202061636365737328616c6c2920766965772066756e20626f72726f774e4654285f2069643a2055496e743634293a20267b4e6f6e46756e6769626c65546f6b656e2e4e46547d3f207b0a20202020202020202020202072657475726e202673656c662e6f776e65644e4654735b69645d0a20202020202020207d0a0a20202020202020202f2f2f20426f72726f77207468652076696577207265736f6c76657220666f722074686520737065636966696564204e46542049440a202020202020202061636365737328616c6c2920766965772066756e20626f72726f77566965775265736f6c7665722869643a2055496e743634293a20267b566965775265736f6c7665722e5265736f6c7665727d3f207b0a20202020202020202020202072657475726e202673656c662e6f776e65644e4654735b69645d20617320267b566965775265736f6c7665722e5265736f6c7665727d3f203f3f206e696c0a20202020202020207d0a0a20202020202020202f2f2f204372656174657320616e20656d70747920636f6c6c656374696f6e0a202020202020202061636365737328616c6c292066756e20637265617465456d707479436f6c6c656374696f6e28293a20407b4e6f6e46756e6769626c65546f6b656e2e436f6c6c656374696f6e7d20207b0a20202020202020202020202072657475726e203c2d",
    "2e637265617465456d707479436f6c6c656374696f6e286e6674547970653a20547970653c40",
    "2e4e46543e2829290a20202020202020207d0a202020207d0a0a202020202f2f2f20637265617465456d707479436f6c6c656374696f6e206372656174657320616e20656d70747920436f6c6c656374696f6e20666f722074686520737065636966696564204e465420747970650a202020202f2f2f20616e642072657475726e7320697420746f207468652063616c6c657220736f207468617420746865792063616e206f776e204e4654730a2020202061636365737328616c6c292066756e20637265617465456d707479436f6c6c656374696f6e286e6674547970653a2054797065293a20407b4e6f6e46756e6769626c65546f6b656e2e436f6c6c656374696f6e7d207b0a202020202020202072657475726e203c2d2063726561746520436f6c6c656374696f6e28290a202020207d0a0a202020202f2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a0a202020202020202020202020476574746572730a202020202a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2f0a0a202020202f2f2f2052657475726e7320746865206e616d65206f66207468652061737365740a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e206765744e616d6528293a20537472696e67207b0a202020202020202072657475726e2073656c662e6e616d650a202020207d0a0a202020202f2f2f2052657475726e73207468652073796d626f6c206f66207468652061737365740a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e2067657453796d626f6c28293a20537472696e67207b0a202020202020202072657475726e2073656c662e73796d626f6c0a202020207d0a0a202020202f2f2f2052657475726e73207468652045564d20636f6e74726163742061646472657373206f6620746865204e4654207468697320636f6e747261637420726570726573656e74730a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e2067657445564d436f6e74726163744164647265737328293a2045564d2e45564d41646472657373207b0a202020202020202072657475726e2073656c662e65766d4e4654436f6e7472616374416464726573730a202020207d0a0a202020202f2f2f2046756e6374696f6e20746861742072657475726e7320616c6c20746865204d6574616461746120566965777320696d706c656d656e7465642062792061204e6f6e2046756e6769626c6520546f6b656e0a202020202f2f2f0a202020202f2f2f204072657475726e20416e206172726179206f6620547970657320646566696e696e672074686520696d706c656d656e7465642076696577732e20546869732076616c75652077696c6c20626520757365642062790a202020202f2f2f202020202020202020646576656c6f7065727320746f206b6e6f7720776869636820706172616d6574657220746f207061737320746f20746865207265736f6c7665566965772829206d6574686f642e0a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e20676574436f6e74726163745669657773287265736f75726365547970653a20547970653f293a205b547970655d207b0a202020202020202072657475726e205b0a202020202020202020202020547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28292c0a202020202020202020202020547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e28292c0a202020202020202020202020547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28290a20202020202020205d0a202020207d0a0a202020202f2f2f2046756e6374696f6e2074686174207265736f6c7665732061206d65746164617461207669657720666f72207468697320636f6e74726163742e0a202020202f2f2f0a202020202f2f2f2040706172616d20766965773a205468652054797065206f6620746865206465736972656420766965772e0a202020202f2f2f204072657475726e20412073747275637475726520726570726573656e74696e67207468652072657175657374656420766965772e0a202020202f2f2f0a2020202061636365737328616c6c292066756e207265736f6c7665436f6e747261637456696577287265736f75726365547970653a20547970653f2c2076696577547970653a2054797065293a20416e795374727563743f207b0a2020202020202020737769746368207669657754797065207b0a2020202020202020202020206361736520547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446174613e28293a0a202020202020202020202020202020206c6574206964656e746966696572203d2022",
    "436f6c6c656374696f6e220a202020202020202020202020202020206c657420636f6c6c656374696f6e44617461203d204d6574616461746156696577732e4e4654436f6c6c656374696f6e44617461280a202020202020202020202020202020202020202073746f72616765506174683a2053746f7261676550617468286964656e7469666965723a206964656e74696669657229212c0a20202020202020202020202020202020202020207075626c6963506174683a205075626c696350617468286964656e7469666965723a206964656e74696669657229212c0a20202020202020202020202020202020202020207075626c6963436f6c6c656374696f6e3a20547970653c26",
    "2e436f6c6c656374696f6e3e28292c0a20202020202020202020202020202020202020207075626c69634c696e6b6564547970653a20547970653c26",
    "2e436f6c6c656374696f6e3e28292c0a2020202020202020202020202020202020202020637265617465456d707479436f6c6c656374696f6e46756e6374696f6e3a202866756e28293a20407b4e6f6e46756e6769626c65546f6b656e2e436f6c6c656374696f6e7d207b0a20202020202020202020202020202020202020202020202072657475726e203c2d",
    "2e637265617465456d707479436f6c6c656374696f6e286e6674547970653a20547970653c40",
    "2e4e46543e2829290a20202020202020202020202020202020202020207d290a20202020202020202020202020202020290a2020202020202020202020202020202072657475726e20636f6c6c656374696f6e446174610a2020202020202020202020206361736520547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e28293a0a202020202020202020202020202020206c65742073656c66526566203d2073656c662e626f72726f7754686973436f6e747261637428290a2020202020202020202020202020202072657475726e20466c6f7745564d4272696467655265736f6c7665722e7265736f6c766542726964676564566965772862726964676564436f6e74726163743a2073656c665265662c20766965773a20547970653c4d6574616461746156696577732e4e4654436f6c6c656374696f6e446973706c61793e2829290a2020202020202020202020206361736520547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28293a0a2020202020202020202020202020202072657475726e204d6574616461746156696577732e45564d427269646765644d65746164617461280a20202020202020202020202020202020202020206e616d653a2073656c662e6e616d652c0a202020202020202020202020202020202020202073796d626f6c3a2073656c662e73796d626f6c2c0a20202020202020202020202020202020202020207572693a2073656c662e636f6e747261637455524920213d206e696c203f204d6574616461746156696577732e55524928626173655552493a206e696c2c2076616c75653a2073656c662e636f6e74726163745552492129203a204d6574616461746156696577732e55524928626173655552493a206e696c2c2076616c75653a202222290a20202020202020202020202020202020290a20202020202020207d0a202020202020202072657475726e206e696c0a202020207d0a0a202020202f2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a0a2020202020202020496e7465726e616c204d6574686f64730a202020202a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2f0a0a202020202f2f2f20416c6c6f7773207468652062726964676520746f206d696e74204e4654732066726f6d206272696467652d646566696e6564204e465420636f6e7472616374730a202020202f2f2f0a20202020616363657373286163636f756e74290a2020202066756e206d696e744e46542869643a2055496e743235362c20746f6b656e5552493a20537472696e67293a20404e4654207b0a2020202020202020707265207b0a20202020202020202020202073656c662e746f6b656e555249735b69645d203d3d206e696c3a20224120746f6b656e20776974682074686520676976656e2045524337323120494420616c726561647920657869737473220a20202020202020207d0a202020202020202073656c662e746f6b656e555249735b69645d203d20746f6b656e5552490a202020202020202072657475726e203c2d637265617465204e4654280a20202020202020202020202065766d49443a2069642c0a2020202020202020202020206d657461646174613a207b0a20202020202020202020202020202020224272696467656420426c6f636b223a2067657443757272656e74426c6f636b28292e6865696768742c0a2020202020202020202020202020202022427269646765642054696d657374616d70223a2067657443757272656e74426c6f636b28292e74696d657374616d700a2020202020202020202020207d0a2020202020202020290a202020207d0a0a202020202f2f2f20416c6c6f7773207468652062726964676520746f207570646174652074686520555249206f662062726964676564204e4654732e205468697320617373756d65732074686174207468652045564d2d646566696e696e672070726f6a656374206d617920636f6e7461696e0a202020202f2f2f206c6f67696320286f6e636861696e206f72206f6666636861696e292077686963682075706461746573204e4654206d6574616461746120696e2074686520736f757263652045524337323120636f6e74726163742e204f6e206272696467696e672c20746865205552492063616e0a202020202f2f2f207468656e206265207570646174656420696e207468697320636f6e747261637420746f207265666c6563742074686520736f757263652045524337323120636f6e74726163742773206d657461646174612e0a202020202f2f2f0a20202020616363657373286163636f756e74290a2020202066756e20757064617465546f6b656e5552492865766d49443a2055496e743235362c206e65775552493a20537472696e6729207b0a2020202020202020707265207b0a20202020202020202020202073656c662e746f6b656e555249735b65766d49445d20213d206e696c3a20224e6f20746f6b656e20776974682074686520676976656e2045524337323120494420657869737473220a20202020202020207d0a202020202020202069662073656c662e746f6b656e555249735b65766d49445d20213d206e6577555249207b0a20202020202020202020202073656c662e746f6b656e555249735b65766d49445d203d206e65775552490a20202020202020207d0a202020207d0a0a202020202f2f2f2052657475726e732061207265666572656e636520746f207468697320636f6e747261637420617320616e204943726f7373564d417373657420636f6e74726163740a202020202f2f2f0a202020206163636573732873656c66290a2020202066756e20626f72726f7754686973436f6e747261637428293a20267b4943726f7373564d41737365747d207b0a20202020202020206c657420636f6e747261637441646472657373203d2073656c662e6163636f756e742e616464726573730a202020202020202072657475726e206765744163636f756e7428636f6e747261637441646472657373292e636f6e7472616374732e626f72726f773c267b4943726f7373564d41737365747d3e286e616d653a2022",
    "2229210a202020207d0a0a20202020696e6974286e616d653a20537472696e672c2073796d626f6c3a20537472696e672c2065766d436f6e7472616374416464726573733a2045564d2e45564d416464726573732c20636f6e74726163745552493a20537472696e673f29207b0a202020202020202073656c662e65766d4e4654436f6e747261637441646472657373203d2065766d436f6e7472616374416464726573730a202020202020202073656c662e6e616d65203d206e616d650a202020202020202073656c662e73796d626f6c203d2073796d626f6c0a202020202020202073656c662e636f6e7472616374555249203d20636f6e74726163745552490a202020202020202073656c662e746f6b656e55524973203d207b7d0a202020202020202073656c662e636f6c6c656374696f6e203c2d2063726561746520436f6c6c656374696f6e28290a0a2020202020202020466c6f7745564d427269646765436f6e6669672e6173736f63696174655479706528547970653c40",
    "2e4e46543e28292c20776974683a2073656c662e65766d4e4654436f6e747261637441646472657373290a2020202020202020466c6f7745564d4272696467654e4654457363726f772e696e697469616c697a65457363726f77280a202020202020202020202020666f72547970653a20547970653c40",
    "2e4e46543e28292c0a2020202020202020202020206e616d653a206e616d652c0a20202020202020202020202073796d626f6c3a2073796d626f6c2c0a202020202020202020202020657263373231416464726573733a2073656c662e65766d4e4654436f6e7472616374416464726573730a2020202020202020290a202020207d0a7d0a"
]

access(all) let bridgedTokenCodeChunks = [
    "696d706f7274204e6f6e46756e6769626c65546f6b656e2066726f6d203078303030303030303030303030303030310a696d706f7274204d6574616461746156696577732066726f6d203078303030303030303030303030303030310a696d706f72742046756e6769626c65546f6b656e4d6574616461746156696577732066726f6d203078303030303030303030303030303030320a696d706f727420566965775265736f6c7665722066726f6d203078303030303030303030303030303030310a696d706f72742046756e6769626c65546f6b656e2066726f6d203078303030303030303030303030303030320a696d706f727420466c6f77546f6b656e2066726f6d203078303030303030303030303030303030330a0a696d706f72742045564d2066726f6d203078303030303030303030303030303030310a0a696d706f7274204943726f7373564d2066726f6d203078303030303030303030303030303030370a696d706f7274204943726f7373564d41737365742066726f6d203078303030303030303030303030303030370a696d706f7274204945564d427269646765546f6b656e4d696e7465722066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d427269646765546f6b656e457363726f772066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d427269646765436f6e6669672066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467655574696c732066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467652066726f6d203078303030303030303030303030303030370a696d706f72742043726f7373564d546f6b656e2066726f6d203078303030303030303030303030303030370a696d706f727420466c6f7745564d4272696467655265736f6c7665722066726f6d203078303030303030303030303030303030370a0a2f2f2f205468697320636f6e747261637420697320612074656d706c617465207573656420627920466c6f7745564d42726964676520746f20646566696e652045564d2d6e61746976652066756e6769626c6520746f6b656e7320627269646765642066726f6d20466c6f772045564d20746f200a2f2f2f20436164656e63652e2055706f6e206465706c6f796d656e74206f66207468697320636f6e74726163742c2074686520636f6e7472616374206e616d65206973206465726976656420617320612066756e6374696f6e206f6620746865206173736574207479706520286865726520616e200a2f2f2f2045524332302920616e642074686520636f6e747261637427732045564d20616464726573732e20546865206465726976656420636f6e7472616374206e616d65206973207468656e206a6f696e65642077697468207468697320636f6e7472616374277320636f64652c0a2f2f2f207072657061726564206173206368756e6b7320696e20466c6f7745564d42726964676554656d706c61746573206265666f7265206265696e67206465706c6f79656420746f2074686520466c6f772045564d20427269646765206163636f756e742e0a2f2f2f0a2f2f2f204f6e206272696467696e672c20746865204552433230206973207472616e7366657272656420746f2074686520627269646765277320436164656e63654f776e65644163636f756e742045564d206164647265737320616e6420746f6b656e7320617265206d696e7465642066726f6d0a2f2f2f207468697320636f6e747261637420746f20746865206272696467696e672063616c6c65722e204f6e2072657475726e20746f20466c6f772045564d2c2074686520726576657273652070726f6365737320697320666f6c6c6f776564202d2074686520746f6b656e206973206275726e65640a2f2f2f20696e207468697320636f6e747261637420616e6420746865204552433230206973207472616e7366657272656420746f2074686520646566696e656420726563697069656e742e20496e2074686973207761792c2074686520436164656e6365205661756c74206163747320617320610a2f2f2f20726570726573656e746174696f6e206f6620626f7468207468652045564d20746f6b656e7320616e642074687573206f776e6572736869702072696768747320746f2069742075706f6e206272696467696e67206261636b20746f20466c6f772045564d2e0a2f2f2f0a2f2f2f20546f20627269646765206265747765656e20564d732c20612063616c6c65722063616e20656974686572207573652074686520696e74657266616365206578706f736564206f6e20436164656e63654f776e65644163636f756e74206f722075736520466c6f7745564d4272696467650a2f2f2f207075626c696320636f6e7472616374206d6574686f64732e0a2f2f2f0a61636365737328616c6c2920636f6e747261637420",
    "203a204943726f7373564d2c204943726f7373564d41737365742c204945564d427269646765546f6b656e4d696e7465722c2046756e6769626c65546f6b656e207b0a0a202020202f2f2f20506f696e74657220746f2074686520466163746f7279206465706c6f79656420536f6c696469747920636f6e7472616374206164647265737320646566696e696e672074686520627269646765642061737365740a2020202061636365737328616c6c29206c65742065766d546f6b656e436f6e7472616374416464726573733a2045564d2e45564d416464726573730a202020202f2f2f204e616d65206f66207468652066756e6769626c6520746f6b656e20646566696e656420696e2074686520636f72726573706f6e64696e6720455243323020636f6e74726163740a2020202061636365737328616c6c29206c6574206e616d653a20537472696e670a202020202f2f2f2053796d626f6c206f66207468652066756e6769626c6520746f6b656e20646566696e656420696e2074686520636f72726573706f6e64696e6720455243323020636f6e74726163740a2020202061636365737328616c6c29206c65742073796d626f6c3a20537472696e670a202020202f2f2f20446563696d616c20706c6163652076616c756520646566696e656420696e2074686520736f7572636520455243323020636f6e74726163740a2020202061636365737328616c6c29206c657420646563696d616c733a2055496e74380a202020202f2f2f20555249206f662074686520636f6e74726163742c20696620617661696c61626c6520617320612076617220696e2063617365207468652062726964676520656e61626c65732063726f73732d564d204d657461646174612073796e63696e6720696e20746865206675747572650a2020202061636365737328616c6c292076617220636f6e74726163745552493a20537472696e673f0a202020202f2f2f20546f74616c20737570706c79206f66207468697320436164656e636520746f6b656e20696e2063697263756c6174696f6e0a202020202f2f2f204e4f54453a205468697320646f6573206e6f74207265666c6563742074686520746f74616c20737570706c79206f662074686520736f7572636520455243323020696e2063697263756c6174696f6e2077697468696e2045564d0a2020202061636365737328616c6c292076617220746f74616c537570706c793a205546697836340a202020202f2f2f2052657461696e2061205661756c7420746f207265666572656e6365207768656e207265736f6c76696e67205661756c74204d657461646174610a202020206163636573732873656c6629206c6574207661756c743a20405661756c740a0a202020202f2f2f20546865205661756c74207265736f7572636520726570726573656e74696e6720746865206272696467656420455243323020746f6b656e0a202020202f2f2f0a2020202061636365737328616c6c29207265736f75726365205661756c74203a204943726f7373564d41737365742e4173736574496e666f2c2043726f7373564d546f6b656e2e45564d546f6b656e496e666f2c2046756e6769626c65546f6b656e2e5661756c74207b0a20202020202020202f2f2f2042616c616e6365206f662074686520746f6b656e7320696e206120676976656e205661756c740a202020202020202061636365737328616c6c29207661722062616c616e63653a205546697836340a0a2020202020202020696e69742862616c616e63653a2055466978363429207b0a20202020202020202020202073656c662e62616c616e6365203d2062616c616e63650a20202020202020207d0a0a20202020202020202f2a202d2d2d2043726f7373564d546f6b656e2e45564d46545661756c7420636f6e666f726d616e6365202d2d2d202a2f0a20202020202020202f2f0a20202020202020202f2f2f204765747320746865204552433230206e616d652076616c75650a202020202020202061636365737328616c6c2920766965772066756e206765744e616d6528293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e6e616d650a20202020202020207d0a20202020202020202f2f2f2047657473207468652045524332302073796d626f6c2076616c75650a202020202020202061636365737328616c6c2920766965772066756e2067657453796d626f6c28293a20537472696e67207b0a20202020202020202020202072657475726e20",
    "2e73796d626f6c0a20202020202020207d0a20202020202020202f2f2f20476574732074686520455243323020646563696d616c732076616c75650a202020202020202061636365737328616c6c2920766965772066756e20676574446563696d616c7328293a2055496e7438207b0a20202020202020202020202072657475726e20",
    "2e646563696d616c730a20202020202020207d0a20202020202020202f2f2f2052657475726e73207468652045564d20636f6e74726163742061646472657373206f66207468652066756e6769626c6520746f6b656e0a202020202020202061636365737328616c6c2920766965772066756e2067657445564d436f6e74726163744164647265737328293a2045564d2e45564d41646472657373207b0a20202020202020202020202072657475726e20",
    "2e67657445564d436f6e74726163744164647265737328290a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e20676574566965777328293a205b547970655d207b0a20202020202020202020202072657475726e20",
    "2e676574436f6e74726163745669657773287265736f75726365547970653a206e696c290a20202020202020207d0a0a202020202020202061636365737328616c6c292066756e207265736f6c766556696577285f20766965773a2054797065293a20416e795374727563743f207b0a20202020202020202020202072657475726e20",
    "2e7265736f6c7665436f6e747261637456696577287265736f75726365547970653a206e696c2c2076696577547970653a2076696577290a20202020202020207d0a0a20202020202020202f2f2f20676574537570706f727465645661756c745479706573206f7074696f6e616c6c792072657475726e732061206c697374206f66207661756c742074797065732074686174207468697320726563656976657220616363657074730a202020202020202061636365737328616c6c2920766965772066756e20676574537570706f727465645661756c74547970657328293a207b547970653a20426f6f6c7d207b0a20202020202020202020202072657475726e207b2073656c662e6765745479706528293a2074727565207d0a20202020202020207d0a0a202020202020202061636365737328616c6c2920766965772066756e206973537570706f727465645661756c745479706528747970653a2054797065293a20426f6f6c207b0a20202020202020202020202072657475726e2073656c662e676574537570706f727465645661756c74547970657328295b747970655d203f3f2066616c73650a20202020202020207d0a0a20202020202020202f2f2f2041736b732069662074686520616d6f756e742063616e2062652077697468647261776e2066726f6d2074686973207661756c740a202020202020202061636365737328616c6c2920766965772066756e206973417661696c61626c65546f576974686472617728616d6f756e743a20554669783634293a20426f6f6c207b0a20202020202020202020202072657475726e20616d6f756e74203c3d2073656c662e62616c616e63650a20202020202020207d0a0a20202020202020202f2f2f206465706f7369740a20202020202020202f2f2f0a20202020202020202f2f2f2046756e6374696f6e20746861742074616b65732061205661756c74206f626a65637420617320616e20617267756d656e7420616e6420616464730a20202020202020202f2f2f206974732062616c616e636520746f207468652062616c616e6365206f6620746865206f776e657273205661756c742e0a20202020202020202f2f2f0a20202020202020202f2f2f20497420697320616c6c6f77656420746f2064657374726f79207468652073656e74205661756c74206265636175736520746865205661756c740a20202020202020202f2f2f2077617320612074656d706f7261727920686f6c646572206f662074686520746f6b656e732e20546865205661756c7427732062616c616e6365206861730a20202020202020202f2f2f206265656e20636f6e73756d656420616e64207468657265666f72652063616e2062652064657374726f7965642e0a20202020202020202f2f2f0a202020202020202061636365737328616c6c292066756e206465706f7369742866726f6d3a20407b46756e6769626c65546f6b656e2e5661756c747d29207b0a2020202020202020202020206c6574207661756c74203c2d2066726f6d2061732120405661756c740a20202020202020202020202073656c662e62616c616e6365203d2073656c662e62616c616e6365202b207661756c742e62616c616e63650a2020202020202020202020207661756c742e62616c616e6365203d20302e300a20202020202020202020202064657374726f79207661756c740a20202020202020207d0a0a20202020202020202f2f2f20637265617465456d7074795661756c740a20202020202020202f2f2f0a20202020202020202f2f2f2046756e6374696f6e207468617420637265617465732061206e6577205661756c74207769746820612062616c616e6365206f66207a65726f0a20202020202020202f2f2f20616e642072657475726e7320697420746f207468652063616c6c696e6720636f6e746578742e20412075736572206d7573742063616c6c20746869732066756e6374696f6e0a20202020202020202f2f2f20616e642073746f7265207468652072657475726e6564205661756c7420696e2074686569722073746f7261676520696e206f7264657220746f20616c6c6f772074686569720a20202020202020202f2f2f206163636f756e7420746f2062652061626c6520746f2072656365697665206465706f73697473206f66207468697320746f6b656e20747970652e0a20202020202020202f2f2f0a202020202020202061636365737328616c6c292066756e20637265617465456d7074795661756c7428293a20405661756c74207b0a20202020202020202020202072657475726e203c2d637265617465205661756c742862616c616e63653a20302e30290a20202020202020207d0a0a20202020202020202f2f2f2077697468647261770a20202020202020202f2f2f0a20202020202020202f2f2f2046756e6374696f6e20746861742074616b657320616e20616d6f756e7420617320616e20617267756d656e740a20202020202020202f2f2f20616e6420776974686472617773207468617420616d6f756e742066726f6d20746865205661756c742e0a20202020202020202f2f2f0a20202020202020202f2f2f20497420637265617465732061206e65772074656d706f72617279205661756c742074686174206973207573656420746f20686f6c640a20202020202020202f2f2f2074686520746f6b656e73207468617420617265206265696e67207472616e736665727265642e2049742072657475726e7320746865206e65776c790a20202020202020202f2f2f2063726561746564205661756c7420746f2074686520636f6e7465787420746861742063616c6c656420736f2069742063616e206265206465706f73697465640a20202020202020202f2f2f20656c736577686572652e0a20202020202020202f2f2f0a20202020202020206163636573732846756e6769626c65546f6b656e2e5769746864726177292066756e20776974686472617728616d6f756e743a20554669783634293a20405661756c74207b0a20202020202020202020202073656c662e62616c616e6365203d2073656c662e62616c616e6365202d20616d6f756e740a20202020202020202020202072657475726e203c2d637265617465205661756c742862616c616e63653a20616d6f756e74290a20202020202020207d0a0a20202020202020202f2f2f2043616c6c6564207768656e20612066756e6769626c6520746f6b656e206973206275726e6564207669612074686520604275726e65722e6275726e282960206d6574686f640a202020202020202061636365737328636f6e7472616374292066756e206275726e43616c6c6261636b2829207b0a20202020202020202020202069662073656c662e62616c616e6365203e20302e30207b0a20202020202020202020202020202020",
    "2e746f74616c537570706c79203d20",
    "2e746f74616c537570706c79202d2073656c662e62616c616e63650a2020202020202020202020207d0a20202020202020202020202073656c662e62616c616e6365203d20302e300a20202020202020207d0a202020207d0a0a202020202f2f2f20637265617465456d7074795661756c740a202020202f2f2f0a202020202f2f2f2046756e6374696f6e207468617420637265617465732061206e6577205661756c74207769746820612062616c616e6365206f66207a65726f20616e642072657475726e7320697420746f207468652063616c6c696e6720636f6e746578742e20412075736572206d7573742063616c6c0a202020202f2f2f20746869732066756e6374696f6e20616e642073746f7265207468652072657475726e6564205661756c7420696e2074686569722073746f7261676520696e206f7264657220746f20616c6c6f77207468656972206163636f756e7420746f2062652061626c6520746f0a202020202f2f2f2072656365697665206465706f73697473206f66207468697320746f6b656e20747970652e0a202020202f2f2f0a2020202061636365737328616c6c292066756e20637265617465456d7074795661756c74287661756c74547970653a2054797065293a2040",
    "2e5661756c74207b0a202020202020202072657475726e203c2d20637265617465205661756c742862616c616e63653a20302e30290a202020207d0a0a202020202f2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a0a202020202020202020202020476574746572730a202020202a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2f0a0a202020202f2f2f2052657475726e7320746865206e616d65206f66207468652061737365740a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e206765744e616d6528293a20537472696e67207b0a202020202020202072657475726e2073656c662e6e616d650a202020207d0a0a202020202f2f2f2052657475726e73207468652073796d626f6c206f66207468652061737365740a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e2067657453796d626f6c28293a20537472696e67207b0a202020202020202072657475726e2073656c662e73796d626f6c0a202020207d0a0a202020202f2f2f2052657475726e73207468652045564d20636f6e74726163742061646472657373206f66207468652066756e6769626c6520746f6b656e207468697320636f6e747261637420726570726573656e74730a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e2067657445564d436f6e74726163744164647265737328293a2045564d2e45564d41646472657373207b0a202020202020202072657475726e2073656c662e65766d546f6b656e436f6e7472616374416464726573730a202020207d0a0a202020202f2f2f2046756e6374696f6e20746861742072657475726e7320616c6c20746865204d6574616461746120566965777320696d706c656d656e74656420627920746869732066756e6769626c6520746f6b656e20636f6e74726163742e0a202020202f2f2f0a202020202f2f2f204072657475726e20416e206172726179206f6620547970657320646566696e696e672074686520696d706c656d656e7465642076696577732e20546869732076616c75652077696c6c206265207573656420627920646576656c6f7065727320746f206b6e6f772077686963680a202020202f2f2f202020202020202020706172616d6574657220746f207061737320746f20746865207265736f6c7665436f6e7472616374566965772829206d6574686f642e0a202020202f2f2f0a2020202061636365737328616c6c2920766965772066756e20676574436f6e74726163745669657773287265736f75726365547970653a20547970653f293a205b547970655d207b0a202020202020202072657475726e205b0a202020202020202020202020547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654566965773e28292c0a202020202020202020202020547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654446973706c61793e28292c0a202020202020202020202020547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e46545661756c74446174613e28292c0a202020202020202020202020547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e546f74616c537570706c793e28292c0a202020202020202020202020547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28290a20202020202020205d0a202020207d0a0a202020202f2f2f2046756e6374696f6e2074686174207265736f6c7665732061206d65746164617461207669657720666f72207468697320636f6e74726163742e0a202020202f2f2f0a202020202f2f2f2040706172616d20766965773a205468652054797065206f6620746865206465736972656420766965772e0a202020202f2f2f0a202020202f2f2f204072657475726e20412073747275637475726520726570726573656e74696e67207468652072657175657374656420766965772e0a202020202f2f2f0a2020202061636365737328616c6c292066756e207265736f6c7665436f6e747261637456696577287265736f75726365547970653a20547970653f2c2076696577547970653a2054797065293a20416e795374727563743f207b0a2020202020202020737769746368207669657754797065207b0a2020202020202020202020206361736520547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654566965773e28293a0a2020202020202020202020202020202072657475726e2046756e6769626c65546f6b656e4d6574616461746156696577732e465456696577280a20202020202020202020202020202020202020206674446973706c61793a2073656c662e7265736f6c7665436f6e747261637456696577287265736f75726365547970653a206e696c2c2076696577547970653a20547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654446973706c61793e282929206173212046756e6769626c65546f6b656e4d6574616461746156696577732e4654446973706c61793f2c0a202020202020202020202020202020202020202066745661756c74446174613a2073656c662e7265736f6c7665436f6e747261637456696577287265736f75726365547970653a206e696c2c2076696577547970653a20547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e46545661756c74446174613e282929206173212046756e6769626c65546f6b656e4d6574616461746156696577732e46545661756c74446174613f0a20202020202020202020202020202020290a2020202020202020202020206361736520547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654446973706c61793e28293a0a202020202020202020202020202020206c657420636f6e7472616374526566203d2073656c662e626f72726f7754686973436f6e747261637428290a2020202020202020202020202020202072657475726e20466c6f7745564d4272696467655265736f6c7665722e7265736f6c766542726964676564566965772862726964676564436f6e74726163743a20636f6e74726163745265662c20766965773a20547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e4654446973706c61793e2829290a2020202020202020202020206361736520547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e46545661756c74446174613e28293a0a2020202020202020202020202020202072657475726e2046756e6769626c65546f6b656e4d6574616461746156696577732e46545661756c7444617461280a202020202020202020202020202020202020202073746f72616765506174683a202f73746f726167652f",
    "5661756c742c0a20202020202020202020202020202020202020207265636569766572506174683a202f7075626c69632f",
    "52656365697665722c0a20202020202020202020202020202020202020206d65746164617461506174683a202f7075626c69632f",
    "5661756c742c0a202020202020202020202020202020202020202072656365697665724c696e6b6564547970653a20547970653c26",
    "2e5661756c743e28292c0a20202020202020202020202020202020202020206d657461646174614c696e6b6564547970653a20547970653c26",
    "2e5661756c743e28292c0a2020202020202020202020202020202020202020637265617465456d7074795661756c7446756e6374696f6e3a202866756e28293a20407b46756e6769626c65546f6b656e2e5661756c747d207b0a20202020202020202020202020202020202020202020202072657475726e203c2d73656c662e637265617465456d7074795661756c74287661756c74547970653a20547970653c40",
    "2e5661756c743e2829290a20202020202020202020202020202020202020207d290a20202020202020202020202020202020290a2020202020202020202020206361736520547970653c46756e6769626c65546f6b656e4d6574616461746156696577732e546f74616c537570706c793e28293a0a2020202020202020202020202020202072657475726e2046756e6769626c65546f6b656e4d6574616461746156696577732e546f74616c537570706c79280a2020202020202020202020202020202020202020746f74616c537570706c793a2073656c662e746f74616c537570706c790a20202020202020202020202020202020290a2020202020202020202020206361736520547970653c4d6574616461746156696577732e45564d427269646765644d657461646174613e28293a0a2020202020202020202020202020202072657475726e204d6574616461746156696577732e45564d427269646765644d65746164617461280a20202020202020202020202020202020202020206e616d653a2073656c662e6e616d652c0a202020202020202020202020202020202020202073796d626f6c3a2073656c662e73796d626f6c2c0a20202020202020202020202020202020202020207572693a2073656c662e636f6e747261637455524920213d206e696c203f204d6574616461746156696577732e55524928626173655552493a206e696c2c2076616c75653a2073656c662e636f6e74726163745552492129203a204d6574616461746156696577732e55524928626173655552493a206e696c2c2076616c75653a202222290a20202020202020202020202020202020290a20202020202020207d0a202020202020202072657475726e206e696c0a202020207d0a0a202020202f2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a0a2020202020202020496e7465726e616c204d6574686f64730a202020202a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2f0a0a202020202f2f2f20416c6c6f7773207468652062726964676520746f206d696e7420746f6b656e732066726f6d206272696467652d646566696e65642066756e6769626c6520746f6b656e20636f6e7472616374730a202020202f2f2f0a20202020616363657373286163636f756e74292066756e206d696e74546f6b656e7328616d6f756e743a20554669783634293a20407b46756e6769626c65546f6b656e2e5661756c747d207b0a202020202020202073656c662e746f74616c537570706c79203d2073656c662e746f74616c537570706c79202b20616d6f756e740a202020202020202072657475726e203c2d20637265617465205661756c742862616c616e63653a20616d6f756e74290a202020207d0a0a202020202f2f2f2052657475726e732061207265666572656e636520746f207468697320636f6e747261637420617320616e204943726f7373564d417373657420636f6e74726163740a202020202f2f2f0a202020206163636573732873656c66290a2020202066756e20626f72726f7754686973436f6e747261637428293a20267b4943726f7373564d41737365747d207b0a20202020202020206c657420636f6e747261637441646472657373203d2073656c662e6163636f756e742e616464726573730a202020202020202072657475726e206765744163636f756e7428636f6e747261637441646472657373292e636f6e7472616374732e626f72726f773c267b4943726f7373564d41737365747d3e286e616d653a2022",
    "2229210a202020207d0a0a20202020696e6974286e616d653a20537472696e672c2073796d626f6c3a20537472696e672c20646563696d616c733a2055496e74382c2065766d436f6e7472616374416464726573733a2045564d2e45564d416464726573732c20636f6e74726163745552493a20537472696e673f29207b0a202020202020202073656c662e65766d546f6b656e436f6e747261637441646472657373203d2065766d436f6e7472616374416464726573730a202020202020202073656c662e6e616d65203d206e616d650a202020202020202073656c662e73796d626f6c203d2073796d626f6c0a202020202020202073656c662e646563696d616c73203d20646563696d616c730a202020202020202073656c662e636f6e7472616374555249203d20636f6e74726163745552490a202020202020202073656c662e746f74616c537570706c79203d20302e300a202020202020202073656c662e7661756c74203c2d20637265617465205661756c742862616c616e63653a20302e30290a0a2020202020202020466c6f7745564d427269646765436f6e6669672e6173736f63696174655479706528547970653c40",
    "2e5661756c743e28292c20776974683a2073656c662e65766d546f6b656e436f6e747261637441646472657373290a2020202020202020466c6f7745564d427269646765546f6b656e457363726f772e696e697469616c697a65457363726f77280a202020202020202020202020776974683a203c2d637265617465205661756c742862616c616e63653a20302e30292c0a2020202020202020202020206e616d653a206e616d652c0a20202020202020202020202073796d626f6c3a2073796d626f6c2c0a202020202020202020202020646563696d616c733a20646563696d616c732c0a20202020202020202020202065766d546f6b656e416464726573733a2073656c662e65766d546f6b656e436f6e7472616374416464726573730a2020202020202020290a202020207d0a7d0a"
]

/* --- Bytecode Getters --- */

access(all)
fun getCompiledFactoryBytecode(): String {
    return compiledFactoryBytecode
}

access(all)
fun getERC20DeployerBytecode(): String {
    return erc20DeployerBytecode
}

access(all)
fun getERC721DeployerBytecode(): String {
    return erc721DeployerBytecode
}

access(all)
fun getRegistryBytecode(): String {
    return registryBytecode
}

access(all)
fun getCompiledERC721Bytecode(): String {
    return compiledERC721Bytecode
}

access(all)
fun getCompiledERC20Bytecode(): String {
    return compiledERC20Bytecode
}

access(all)
fun getCompiledWFLOWBytecode(): String {
    return compiledWFLOWBytecode
}

access(all)
fun getBridgedNFTCodeChunks(): [String] {
    return bridgedNFTCodeChunks
}

access(all)
fun getBridgedTokenCodeChunks(): [String] {
    return bridgedTokenCodeChunks
}

/* --- Event Value Helpers --- */

access(all)
fun getEVMAddressHexFromEvents(_ evts: [AnyStruct], idx: Int): String {
    Test.assert(evts.length > idx, message: "Event index out of bounds")
    
    let evt = evts[idx] as? EVM.TransactionExecuted
        ?? panic("Event at index ".concat(idx.toString()).concat(" is not a TransactionExecuted event"))
    let emittedAddress = evt.contractAddress
    Test.assert(emittedAddress.length != 0, message: "Emitted .contractAddress value is empty")

    let hexAddress = emittedAddress.slice(from: 2, upTo: emittedAddress.length).toLower()
    Test.assertEqual(40, hexAddress.length)
    return hexAddress
}

/* --- Derivation Helpers --- */

access(all)
fun buildTypeIdentifier(address: Address, contractName: String, resourceName: String): String {
    return "A.".concat(address.toString().split(separator: "x")[1]).concat(".")
        .concat(contractName).concat(".")
        .concat(resourceName)
}

/* --- Script Helpers --- */

access(all)
fun _executeScript(_ path: String, _ args: [AnyStruct]): Test.ScriptResult {
    return Test.executeScript(Test.readFile(path), args)
}

access(all)
fun _executeTransaction(_ path: String, _ args: [AnyStruct], _ signer: Test.TestAccount): Test.TransactionResult {
    let txn = Test.Transaction(
        code: Test.readFile(path),
        authorizers: [signer.address],
        signers: [signer],
        arguments: args
    )    
    return Test.executeTransaction(txn)
}

access(all)
fun getCOAAddressHex(atFlowAddress: Address): String {
    let coaAddressResult = _executeScript(
        "../scripts/evm/get_evm_address_string.cdc",
        [atFlowAddress]
    )
    Test.expect(coaAddressResult, Test.beSucceeded())
    let coaAddressHex = coaAddressResult.returnValue as! String? ?? panic("Problem getting COA address as String")
    Test.assertEqual(40, coaAddressHex.length)
    return coaAddressHex
}

access(all)
fun getBridgeCOAAddressHex(): String {
    let coaAddressResult = _executeScript(
        "../scripts/bridge/get_bridge_coa_address.cdc",
        []
    )
    Test.expect(coaAddressResult, Test.beSucceeded())
    let addressHex = coaAddressResult.returnValue as! String? ?? panic("Problem getting COA address as String")
    Test.assertEqual(40, addressHex.length)
    return addressHex
}

access(all)
fun getAssociatedEVMAddressHex(with typeIdentifier: String): String {
    var associatedEVMAddressResult = _executeScript(
        "../scripts/bridge/get_associated_evm_address.cdc",
        [typeIdentifier]
    )
    Test.expect(associatedEVMAddressResult, Test.beSucceeded())
    return associatedEVMAddressResult.returnValue as! String? ?? panic("Problem getting EVM Address as String")
}

access(all)
fun getDeployedAddressFromDeployer(name: String): String {
    let erc721AddressResult = _executeScript(
        "./scripts/get_deployed_address_string_from_deployer.cdc",
        [name]
    )
    Test.expect(erc721AddressResult, Test.beSucceeded())
    let addressHex = erc721AddressResult.returnValue as! String? ?? panic("Problem getting COA address as String")
    Test.assertEqual(40, addressHex.length)
    return addressHex
}

access(all)
fun getIDs(ownerAddr: Address, storagePathIdentifier: String): [UInt64] {
    let idResult = _executeScript(
        "../scripts/nft/get_ids.cdc",
        [ownerAddr, storagePathIdentifier]
    )
    Test.expect(idResult, Test.beSucceeded())
    return idResult.returnValue as! [UInt64]? ?? panic("Problem getting NFT IDs")
}

access(all)
fun getBalance(ownerAddr: Address, storagePathIdentifier: String): UFix64? {
    let balanceResult = _executeScript(
        "../scripts/tokens/get_balance.cdc",
        [ownerAddr, storagePathIdentifier]
    )
    Test.expect(balanceResult, Test.beSucceeded())
    return balanceResult.returnValue as! UFix64?
}

access(all)
fun balanceOf(evmAddressHex: String, erc20AddressHex: String): UInt256 {
    let balanceOfResult = _executeScript(
        "../scripts/utils/balance_of.cdc",
        [evmAddressHex, erc20AddressHex]
    )
    Test.expect(balanceOfResult, Test.beSucceeded())
    return balanceOfResult.returnValue as! UInt256? ?? panic("Problem getting ERC20 balance")
}

access(all)
fun getEVMFlowBalance(of evmAddressHex: String): UFix64 {
    let balanceResult = _executeScript(
        "../scripts/evm/get_balance.cdc",
        [evmAddressHex]
    )
    Test.expect(balanceResult, Test.beSucceeded())
    return balanceResult.returnValue as! UFix64? ?? panic("Problem getting EVM balance")
}

access(all)
fun getTokenDecimals(erc20AddressHex: String): UInt8 {
    let decimalsResult = _executeScript(
        "../scripts/utils/get_token_decimals.cdc",
        [erc20AddressHex]
    )
    Test.expect(decimalsResult, Test.beSucceeded())
    return decimalsResult.returnValue as! UInt8? ?? panic("Problem getting ERC20 decimals")
}

access(all)
fun ufix64ToUInt256(_ value: UFix64, decimals: UInt8): UInt256 {
    let convertedResult = _executeScript(
        "../scripts/utils/ufix64_to_uint256.cdc",
        [value, decimals]
    )
    Test.expect(convertedResult, Test.beSucceeded())
    return convertedResult.returnValue as! UInt256? ?? panic("Problem converting UFix64 to UInt256")
}

access(all)
fun uint256ToUFix64(_ value: UInt256, decimals: UInt8): UFix64 {
    let convertedResult = _executeScript(
        "../scripts/utils/uint256_to_ufix64.cdc",
        [value, decimals]
    )
    Test.expect(convertedResult, Test.beSucceeded())
    return convertedResult.returnValue as! UFix64? ?? panic("Problem converting UInt256 to UFix64")
}

access(all)
fun isOwner(of: UInt256, ownerEVMAddrHex: String, erc721AddressHex: String): Bool {
    let isOwnerResult = _executeScript(
        "../scripts/utils/is_owner.cdc",
        [of, ownerEVMAddrHex, erc721AddressHex]
    )
    Test.expect(isOwnerResult, Test.beSucceeded())
    return isOwnerResult.returnValue as! Bool? ?? panic("Problem getting owner status")
}

access(all)
fun getCadenceTotalSupply(contractAddress: Address, contractName: String, vaultIdentifier: String): UFix64? {
    let exampleTokenTotalSupplyResult = _executeScript(
        "../scripts/tokens/total_supply.cdc",
        [contractAddress, "ExampleHandledToken", vaultIdentifier]
    )
    Test.expect(exampleTokenTotalSupplyResult, Test.beSucceeded())
    return exampleTokenTotalSupplyResult.returnValue as! UFix64?
}

access(all)
fun getEVMTotalSupply(erc20AddressHex: String): UInt256 {
    let totalSupplyResult = _executeScript(
        "../scripts/utils/total_supply.cdc",
        [erc20AddressHex]
    )
    Test.expect(totalSupplyResult, Test.beSucceeded())
    return totalSupplyResult.returnValue as! UInt256? ?? panic("Problem getting ERC20 total supply")
}

access(all)
fun deriveBridgedNFTContractName(evmAddressHex: String): String {
    let nameResult = _executeScript(
        "../scripts/utils/derive_bridged_nft_contract_name.cdc",
        [evmAddressHex]
    )
    Test.expect(nameResult, Test.beSucceeded())
    return nameResult.returnValue as! String? ?? panic("Problem getting derived contract name")
}

access(all)
fun deriveBridgedTokenContractName(evmAddressHex: String): String {
    let nameResult = _executeScript(
        "../scripts/utils/derive_bridged_token_contract_name.cdc",
        [evmAddressHex]
    )
    Test.expect(nameResult, Test.beSucceeded())
    return nameResult.returnValue as! String? ?? panic("Problem getting derived contract name")
}

access(all)
fun typeRequiresOnboardingByIdentifier(_ identifier: String): Bool? {
    let onboardingRequiredResult: Test.ScriptResult = _executeScript(
        "../scripts/bridge/type_requires_onboarding_by_identifier.cdc",
        [identifier]
    )
    Test.expect(onboardingRequiredResult, Test.beSucceeded())
    return onboardingRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
}

access(all)
fun evmAddressRequiresOnboarding(_ addressHex: String): Bool? {
    var onboardingRequiredResult = _executeScript(
        "../scripts/bridge/evm_address_requires_onboarding.cdc",
        [addressHex]
    )
    Test.expect(onboardingRequiredResult, Test.beSucceeded())
    return onboardingRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
}

access(all)
fun isNFTLocked(nftTypeIdentifier: String, id: UInt64): Bool {
    let isLockedResult = _executeScript(
        "../scripts/escrow/is_nft_locked.cdc",
        [nftTypeIdentifier, id]
    )
    Test.expect(isLockedResult, Test.beSucceeded())
    return isLockedResult.returnValue as! Bool? ?? panic("Problem getting locked status")
}

access(all)
fun getLockedTokenBalance(vaultTypeIdentifier: String): UFix64? {
    let balanceResult = _executeScript(
        "../scripts/escrow/get_locked_token_balance.cdc",
        [vaultTypeIdentifier]
    )
    Test.expect(balanceResult, Test.beSucceeded())
    return balanceResult.returnValue as! UFix64?
}

access(all)
fun resolveLockedNFTView(bridgeAddress: Address, nftTypeIdentifier: String, id: UInt256, viewIdentifier: String): AnyStruct? {
    let resolvedViewResult = _executeScript(
        "../scripts/escrow/resolve_locked_nft_metadata.cdc",
        [bridgeAddress, nftTypeIdentifier, id, viewIdentifier]
    )
    Test.expect(resolvedViewResult, Test.beSucceeded())
    return resolvedViewResult.returnValue as! AnyStruct?
}

access(all)
fun resolveLockedTokenView(bridgeAddress: Address, vaultTypeIdentifier: String, viewIdentifier: String): AnyStruct? {
    let resolvedViewResult = _executeScript(
        "../scripts/escrow/resolve_locked_vault_metadata.cdc",
        [bridgeAddress, vaultTypeIdentifier, viewIdentifier]
    )
    Test.expect(resolvedViewResult, Test.beSucceeded())
    return resolvedViewResult.returnValue as! AnyStruct?
}

/* --- Transaction Helpers --- */

access(all)
fun updateBridgePauseStatus(signer: Test.TestAccount, pause: Bool) {
    let pauseResult = _executeTransaction(
        "../transactions/bridge/admin/pause/update_bridge_pause_status.cdc",
        [pause],
        signer
    )
    Test.expect(pauseResult, Test.beSucceeded())
}

access(all)
fun transferFlow(signer: Test.TestAccount, recipient: Address, amount: UFix64) {
    let transferResult = _executeTransaction(
        "../transactions/flow-token/transfer_flow.cdc",
        [recipient, amount],
        signer
    )
    Test.expect(transferResult, Test.beSucceeded())
}

access(all)
fun createCOA(signer: Test.TestAccount, fundingAmount: UFix64) {
    let createCOAResult = _executeTransaction(
        "../transactions/evm/create_account.cdc",
        [fundingAmount],
        signer
    )
    Test.expect(createCOAResult, Test.beSucceeded())
}

access(all)
fun bridgeNFTToEVM(
    signer: Test.TestAccount,
    nftIdentifier: String,
    nftID: UInt64,
    bridgeAccountAddr: Address,
    beFailed: Bool
) {
    let bridgeResult = _executeTransaction(
        "../transactions/bridge/nft/bridge_nft_to_evm.cdc",
        [nftIdentifier, nftID],
        signer
    )
    if beFailed {
        Test.expect(bridgeResult, Test.beFailed())
        return
    }

    Test.expect(bridgeResult, Test.beSucceeded())

    var events = Test.eventsOfType(Type<NonFungibleToken.Withdrawn>())
    let withdrawnEvent = events[events.length - 1] as! NonFungibleToken.Withdrawn
    Test.assertEqual(nftID, withdrawnEvent.id)
    Test.assertEqual(signer.address, withdrawnEvent.from!)

    events = Test.eventsOfType(Type<NonFungibleToken.Deposited>())
    let depositedEvent = events[events.length - 1] as! NonFungibleToken.Deposited
    Test.assertEqual(nftID, depositedEvent.id)
    Test.assertEqual(bridgeAccountAddr, depositedEvent.to!)
}

access(all)
fun bridgeNFTFromEVM(
    signer: Test.TestAccount,
    nftIdentifier: String,
    erc721ID: UInt256,
    bridgeAccountAddr: Address,
    beFailed: Bool
) {
    let bridgeResult = _executeTransaction(
        "../transactions/bridge/nft/bridge_nft_from_evm.cdc",
        [nftIdentifier, erc721ID],
        signer
    )
    if beFailed {
        Test.expect(bridgeResult, Test.beFailed())
        return
    }

    Test.expect(bridgeResult, Test.beSucceeded())

    var events = Test.eventsOfType(Type<NonFungibleToken.Withdrawn>())
    let withdrawnEvent = events[events.length - 1] as! NonFungibleToken.Withdrawn
    Test.assertEqual(bridgeAccountAddr, withdrawnEvent.from!)

    events = Test.eventsOfType(Type<NonFungibleToken.Deposited>())
    let depositedEvent = events[events.length - 1] as! NonFungibleToken.Deposited
    Test.assertEqual(signer.address, depositedEvent.to!)
}

access(all)
fun bridgeTokensToEVM(
    signer: Test.TestAccount,
    vaultIdentifier: String,
    amount: UFix64,
    beFailed: Bool
) {
    let bridgeResult = _executeTransaction(
        "../transactions/bridge/tokens/bridge_tokens_to_evm.cdc",
        [vaultIdentifier, amount],
        signer
    )
    Test.expect(bridgeResult, beFailed ? Test.beFailed() : Test.beSucceeded())

    // TODO: Add event assertions on bridge events. We can't currently import the event types to do this
    //      so state assertions beyond call scope will need to suffice for now
}

access(all)
fun bridgeTokensFromEVM(
    signer: Test.TestAccount,
    vaultIdentifier: String,
    amount: UInt256,
    beFailed: Bool
) {
    let bridgeResult = _executeTransaction(
        "../transactions/bridge/tokens/bridge_tokens_from_evm.cdc",
        [vaultIdentifier, amount],
        signer
    )
    Test.expect(bridgeResult, beFailed ? Test.beFailed() : Test.beSucceeded())

    // TODO: Add event assertions on bridge events. We can't currently import the event types to do this
    //      so state assertions beyond call scope will need to suffice for now
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeResolver.cdc

```
import "MetadataViews"
import "FungibleTokenMetadataViews"
import "FungibleToken"
import "NonFungibleToken"

import "ICrossVMAsset"
import "CrossVMToken"
import "CrossVMNFT"
import "FlowEVMBridgeUtils"

/// This contract serves as a metadata resolver for shared views on NFTs and FungibleTokens bridged from EVM to Cadence.
/// Upon bridging to Cadence, these tokens must have certain basic metadata views that cannot be retrieved at the time
/// of bridging, such as MetadataViews.Display for NFTs and FungibleTokenMetadataViews.FTDisplay for FungibleTokens.
///
/// This contract then serves as a means of setting and potentially updating base placeholder views for these bridged
/// assets. Anyone wishing to consume the metadata from the source EVM contract should either resolve directly from the
/// EVM contract or leverage the EVMBridgedMetadata view which retains the original token URI and/or contract URI (if
/// implemented in the source contract).
///
access(all) contract FlowEVMBridgeResolver {

    /******************
        Entitlements
    *******************/

    access(all) entitlement Metadata

    /*************
        Fields
    **************/

    /// The views managed by this contract, indexed on the view type
    access(all) let views: {Type: AnyStruct}

    /********************
        Path Constants
    *********************/

    /// The default storage path of the Admin resource
    access(all) let AdminStoragePath: StoragePath

    /*************
        Events
    **************/

    /// Emitted when a view is added, removed, or updated.
    /// added == true -> new | added == false -> removed | added == nil -> updated
    access(all) event ViewUpdated(viewType: String, added: Bool?)

    /*************
        Getters
     *************/

    /// Getter for bridged NFT views.
    ///
    /// @param forNFT: The bridged NFT
    /// @param view: The view type to resolve
    ///
    /// @returns The resolved view or nil if the view type is not supported
    ///
    access(all)
    fun resolveBridgedView(bridgedContract: &{ICrossVMAsset}, view: Type): AnyStruct? {
        /// Return nil if the resource is not defined by a bridge contract
        let contractAddressString = bridgedContract.getType().identifier.split(separator: ".")[1]
        let contractAddress = Address.fromString("0x".concat(contractAddressString))
        if contractAddress != self.account.address {
            return nil
        }
        // Handle based on whether the contract defines a bridged NFT or FungibleToken
        if let crossVMNFT = bridgedContract as? &{ICrossVMAsset, NonFungibleToken} {
            // Dealing with a bridged NFT, continue
            switch view {
                case Type<MetadataViews.Display>():
                    if let baseDisplay = self.views[Type<MetadataViews.Display>()] as! MetadataViews.Display? {
                        return MetadataViews.Display(
                            name: crossVMNFT.getName(),
                            description: "This NFT was bridged from EVM on Flow with the ERC721 contract address of "
                                .concat(crossVMNFT.getEVMContractAddress().toString()),
                            thumbnail: baseDisplay.thumbnail
                        )
                    }
                case Type<MetadataViews.NFTCollectionDisplay>():
                    if let baseCollectionDisplay = self.views[Type<MetadataViews.NFTCollectionDisplay>()] as! MetadataViews.NFTCollectionDisplay? {
                        return MetadataViews.NFTCollectionDisplay(
                            name: crossVMNFT.getName(),
                            description: "This NFT Collection was bridged from EVM on Flow with the ERC721 contract address of "
                                .concat(crossVMNFT.getEVMContractAddress().toString()),
                            externalURL: baseCollectionDisplay.externalURL,
                            squareImage: baseCollectionDisplay.squareImage,
                            bannerImage: baseCollectionDisplay.bannerImage,
                            socials: baseCollectionDisplay.socials
                        )
                    }
            }
            return nil
        } else if let crossVMToken = bridgedContract as? &{ICrossVMAsset, FungibleToken} {
            // Dealing with a bridged FungibleToken, continue
            switch view {
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    if let baseFTDisplay = self.views[Type<FungibleTokenMetadataViews.FTDisplay>()] as! FungibleTokenMetadataViews.FTDisplay? {
                        return FungibleTokenMetadataViews.FTDisplay(
                            name: crossVMToken.getName(),
                            symbol: crossVMToken.getSymbol(),
                            description: "This fungible token was bridged from EVM on Flow with the ERC20 contract address of "
                                .concat(crossVMToken.getEVMContractAddress().toString()),
                            externalURL: baseFTDisplay.externalURL,
                            logos: baseFTDisplay.logos,
                            socials: baseFTDisplay.socials
                        )
                    }
            }
        }
        return nil
    }

    /// Builds a thumbnail file based on the provided thumbnail file type identifier and optional IPFS file path
    ///
    /// @param thumbnailURI: The URI of the thumbnail file
    /// @param thumbnailFileTypeIdentifier: The type identifier of the thumbnail file
    /// @param ipfsFilePath: The optional IPFS file path if the thumbnail file is an IPFS file and has a path
    ///
    /// @returns The built thumbnail file
    ///
    access(all)
    view fun buildFile(uri: String, fileType: Type, ipfsFilePath: String?): {MetadataViews.File}? {
        switch fileType {
            case Type<MetadataViews.HTTPFile>():
                return MetadataViews.HTTPFile(url: uri)
            case Type<MetadataViews.IPFSFile>():
                return MetadataViews.IPFSFile(cid: uri, path: ipfsFilePath)
            default:
                return nil
        }
    }

    /// Builds a dictionary of ExternalURL views from a dictionary of URLs, helpful for creating a socials dictionary
    ///
    /// @param fromDict: The dictionary of URLs to convert
    ///
    /// @returns The dictionary of ExternalURL views
    ///
    access(all)
    view fun buildExternalURLMapping(fromDict: {String: String}): {String: MetadataViews.ExternalURL} {
        let res: {String: MetadataViews.ExternalURL} = {}
        for key in fromDict.keys {
            res[key] = MetadataViews.ExternalURL(fromDict[key]!)
        }
        return res
    }
    

    /*****************
        Constructs
     *****************/

    /// Admin resource allowing for view management
    ///
    access(all) resource Admin {
        /// Sets a view, indexing on the view type and replacing any existing view of the same type
        ///
        /// @param view: The view to set
        ///
        access(Metadata)
        fun setView(_ view: AnyStruct) {
            let old = FlowEVMBridgeResolver.views.remove(key: view.getType())
            FlowEVMBridgeResolver.views[view.getType()] = view

            emit ViewUpdated(viewType: view.getType().identifier, added: old == nil ? true : nil)
        }

        /// Removes the view with the given type
        ///
        /// @param type: The type of the view to remove
        ///
        access(Metadata)
        fun removeView(_ type: Type) {
            let old = FlowEVMBridgeResolver.views.remove(key: type)
            if old != nil {
                emit ViewUpdated(viewType: type.identifier, added: false)
            }
        }
    }

    init() {
        self.views = {}

        self.AdminStoragePath = /storage/flowEVMBridgeResolverAdmin

        // Initialize the Admin resource
        self.account.storage.save(<- create Admin(), to: FlowEVMBridgeResolver.AdminStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/IFlowEVMTokenBridge.cdc

```
import "FungibleToken"
import "NonFungibleToken"

import "EVM"

access(all) contract interface IFlowEVMTokenBridge {
    
    /*************
        Events
    **************/

    /// Broadcasts fungible tokens were bridged from Cadence to EVM
    access(all)
    event BridgedTokensToEVM(
        type: String,
        amount: UFix64,
        bridgedUUID: UInt64,
        to: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )
    /// Broadcasts fungible tokens were bridged from EVM to Cadence
    access(all)
    event BridgedTokensFromEVM(
        type: String,
        amount: UInt256,
        bridgedUUID: UInt64,
        caller: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )

    /**************
        Getters
    ***************/

    /// Returns the EVM address associated with the provided type
    ///
    access(all)
    view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress?

    /// Returns the EVM address of the bridge coordinating COA
    ///
    access(all)
    view fun getBridgeCOAEVMAddress(): EVM.EVMAddress

    /********************************
        Public Bridge Entrypoints
    *********************************/

    /// Public entrypoint to bridge fungible tokens from Cadence to EVM.
    ///
    /// @param token: The token Vault to be bridged
    /// @param to: The token recipient in EVM
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun bridgeTokensToEVM(
        vault: @{FungibleToken.Vault},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            emit BridgedTokensToEVM(
                type: vault.getType().identifier,
                amount: vault.balance,
                bridgedUUID: vault.uuid,
                to: to.toString(),
                evmContractAddress: self.getAssociatedEVMAddress(with: vault.getType())?.toString()
                    ?? panic(
                        "Could not find EVM Contract address associated with provided Token identifier="
                        .concat(vault.getType().identifier)
                    ),
                bridgeAddress: self.account.address
            )
        }
    }

    /// Public entrypoint to bridge fungible tokens from EVM to Cadence
    ///
    /// @param owner: The EVM address of the token owner. Current ownership and successful transfer (via 
    ///     `protectedTransferCall`) is validated before the bridge request is executed.
    /// @param type: The Cadence Type of the fungible token to be bridged. If EVM-native, this would be the Cadence
    ///     Type associated with the EVM contract on the Flow side at onboarding.
    /// @param amount: The amount of tokens to bridge from EVM to Cadence
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the NFT from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    /// @returns The bridged NFT
    ///
    access(account)
    fun bridgeTokensFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        amount: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{FungibleToken.Vault} {
        post {
            emit BridgedTokensFromEVM(
                type: result.getType().identifier,
                amount: amount,
                bridgedUUID: result.uuid,
                caller: owner.toString(),
                evmContractAddress: self.getAssociatedEVMAddress(with: result.getType())?.toString()
                    ?? panic("Could not find EVM Contract address associated with provided Vault"),
                bridgeAddress: self.account.address
            )
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/nft/get_evm_id_from_evm_nft.cdc

```
import "NonFungibleToken"

import "CrossVMNFT"

access(all)
fun main(ownerAddr: Address, cadenceID: UInt64, collectionStoragePath: StoragePath): UInt256? {
    if let collection = getAuthAccount<auth(BorrowValue) &Account>(ownerAddr).storage.borrow<&{NonFungibleToken.Collection}>(
            from: collectionStoragePath
        ) {
        if let nft = collection.borrowNFT(cadenceID) {
            return CrossVMNFT.getEVMID(from: nft)
        }
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/IEVMBridgeTokenMinter.cdc

```
import "FungibleToken"

/// Contract interface enabling FlowEVMBridge to mint fungible tokens from implementing bridge contracts.
///
access(all)
contract interface IEVMBridgeTokenMinter {

    /// Emitted whenever tokens are minted, identifying the type, amount, and minter
    access(all) event Minted(type: String, amount: UFix64, mintedUUID: UInt64, minter: Address)

    /// Account-only method to mint a fungible token of the specified amount.
    ///
    access(account)
    fun mintTokens(amount: UFix64): @{FungibleToken.Vault} {
        post {
            result.balance == amount: "Result does not contained specified amount"
            emit Minted(
                type: result.getType().identifier,
                amount: amount,
                mintedUUID: result.uuid,
                minter: self.account.address
            )
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/flow_evm_bridge_handler_tests.cdc

```
import Test
import BlockchainHelpers

import "FungibleToken"
import "NonFungibleToken"
import "FlowStorageFees"
import "EVM"

import "test_helpers.cdc"

access(all) let serviceAccount = Test.serviceAccount()
access(all) let bridgeAccount = Test.getAccount(0x0000000000000007)
access(all) let exampleNFTAccount = Test.getAccount(0x0000000000000008)
access(all) let exampleERCAccount = Test.getAccount(0x0000000000000009)
access(all) let exampleHandledTokenAccount = Test.getAccount(0x0000000000000011)
access(all) let alice = Test.createAccount()

// ExampleToken
access(all) let exampleTokenIdentifier = "A.0000000000000011.ExampleHandledToken.Vault"
access(all) let exampleTokenMinterIdentifier = "A.0000000000000011.ExampleHandledToken.Minter"
access(all) let exampleTokenMintAmount = 100.0

// ERC20 values
access(all) var erc20AddressHex: String = ""
access(all) let erc20MintAmount: UInt256 = 100_000_000_000_000_000_000

// Fee initialiazation values
access(all) let expectedOnboardFee = 1.0
access(all) let expectedBaseFee = 0.001

// Default decimals for Cadence UFix64 values
access(all) let defaultDecimals: UInt8 = 18

// Test height snapshot for test state resets
access(all) var snapshot: UInt64 = 0

access(all)
fun setup() {
    // Deploy supporting util contracts
    var err = Test.deployContract(
        name: "ArrayUtils",
        path: "../contracts/utils/ArrayUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "StringUtils",
        path: "../contracts/utils/StringUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ScopedFTProviders",
        path: "../contracts/utils/ScopedFTProviders.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "SerializeMetadata",
        path: "../contracts/utils/SerializeMetadata.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Transfer bridge account some $FLOW
    transferFlow(signer: serviceAccount, recipient: bridgeAccount.address, amount: 10_000.0)
    // Configure bridge account with a COA
    createCOA(signer: bridgeAccount, fundingAmount: 1_000.0)

    err = Test.deployContract(
        name: "IBridgePermissions",
        path: "../contracts/bridge/interfaces/IBridgePermissions.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVM",
        path: "../contracts/bridge/interfaces/ICrossVM.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVMAsset",
        path: "../contracts/bridge/interfaces/ICrossVMAsset.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMNFT",
        path: "../contracts/bridge/interfaces/CrossVMNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMToken",
        path: "../contracts/bridge/interfaces/CrossVMToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeHandlerInterfaces",
        path: "../contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeConfig",
        path: "../contracts/bridge/FlowEVMBridgeConfig.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Deploy FlowBridgeFactory.sol
    let deploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledFactoryBytecode(), 15_000_000, 0.0],
        bridgeAccount
    )
    // Get the deployed contract address from the latest EVM event
    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(2, evts.length)
    let factoryAddressHex = getEVMAddressHexFromEvents(evts, idx: 0)

    err = Test.deployContract(
        name: "FlowEVMBridgeUtils",
        path: "../contracts/bridge/FlowEVMBridgeUtils.cdc",
        arguments: [factoryAddressHex]
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeResolver",
        path: "../contracts/bridge/FlowEVMBridgeResolver.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeNFTEscrow",
        path: "../contracts/bridge/FlowEVMBridgeNFTEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTokenEscrow",
        path: "../contracts/bridge/FlowEVMBridgeTokenEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTemplates",
        path: "../contracts/bridge/FlowEVMBridgeTemplates.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    // Commit bridged NFT code
    let bridgedNFTChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedNFT", getBridgedNFTCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())
    // Commit bridged Token code
    let bridgedTokenChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedToken", getBridgedTokenCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())

    err = Test.deployContract(
        name: "IEVMBridgeNFTMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeNFTMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IEVMBridgeTokenMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeTokenMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMNFTBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMNFTBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMTokenBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMTokenBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridge",
        path: "../contracts/bridge/FlowEVMBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeAccessor",
        path: "../contracts/bridge/FlowEVMBridgeAccessor.cdc",
        arguments: [serviceAccount.address]
    )
    Test.expect(err, Test.beNil())

    let claimAccessorResult = executeTransaction(
        "../transactions/bridge/admin/evm-integration/claim_accessor_capability_and_save_router.cdc",
        ["FlowEVMBridgeAccessor", bridgeAccount.address],
        serviceAccount
    )
    Test.expect(claimAccessorResult, Test.beSucceeded())

    // Configure example ERC20 account with $FLOW and a COA
    transferFlow(signer: serviceAccount, recipient: exampleERCAccount.address, amount: 1_000.0)
    createCOA(signer: exampleERCAccount, fundingAmount: 10.0)

    err = Test.deployContract(
        name: "ExampleHandledToken",
        path: "../contracts/example-assets/ExampleHandledToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeHandlers",
        path: "../contracts/bridge/FlowEVMBridgeHandlers.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Set bridge fees
    let updateOnboardFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_onboard_fee.cdc",
        [expectedOnboardFee],
        bridgeAccount
    )
    Test.expect(updateOnboardFeeResult, Test.beSucceeded())
    let updateBaseFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_base_fee.cdc",
        [expectedBaseFee],
        bridgeAccount
    )
    Test.expect(updateBaseFeeResult, Test.beSucceeded())

    // Unpause Bridge
    updateBridgePauseStatus(signer: bridgeAccount, pause: false)
}

/* --- ASSET & ACCOUNT SETUP - Configure test accounts with assets to bridge --- */

// Create a COA in Alice's account who will be the test asset owner for both Cadence & ERC20 FTs
access(all)
fun testCreateCOASucceeds() {
    transferFlow(signer: serviceAccount, recipient: alice.address, amount: 1_000.0)
    createCOA(signer: alice, fundingAmount: 100.0)

    let coaAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
}

// Mint tokens to put some in circulation in Cadence
access(all)
fun testMintExampleTokenSucceeds() {
    let setupVaultResult = executeTransaction(
        "../transactions/example-assets/example-handled-token/setup_vault.cdc",
        [],
        alice
    )
    Test.expect(setupVaultResult, Test.beSucceeded())

    let mintExampleTokenResult = executeTransaction(
        "../transactions/example-assets/example-handled-token/mint_tokens.cdc",
        [alice.address, exampleTokenMintAmount],
        exampleHandledTokenAccount
    )
    Test.expect(mintExampleTokenResult, Test.beSucceeded())

    let aliceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(exampleTokenMintAmount, aliceBalance)

    let events = Test.eventsOfType(Type<FungibleToken.Deposited>())
    let evt = events[events.length - 1] as! FungibleToken.Deposited

    Test.assertEqual(aliceBalance, evt.amount)
}

// Hand off Minter to bridge handler - bridge then has sole authority to mint based on contract logic
// Configuring the Handler also disables onboarding of the Cadence-native token to the bridge
access(all)
fun testConfigureCadenceNativeTokenHandlerSucceeds() {
    // Create TokenHandler for ExampleHandledToken, specifying the target type and expected minter type
    let createHandlerResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/create_cadence_native_token_handler.cdc",
        [exampleTokenIdentifier, exampleTokenMinterIdentifier],
        bridgeAccount
    )
    Test.expect(createHandlerResult, Test.beSucceeded())

    // TODO: Add event validation when EVM and EVM dependent contracts can be imported to Test env
}

// Set the minter in the configured TokenHandler
access(all)
fun testSetTokenHandlerMinterSucceeds() {
    let setHandlerMinterResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/set_token_handler_minter.cdc",
        [exampleTokenIdentifier, /storage/exampleTokenAdmin, bridgeAccount.address],
        exampleHandledTokenAccount
    )
    Test.expect(setHandlerMinterResult, Test.beSucceeded())
}

// ExampleHandledToken no longer has minter after handoff, so minting should fail
access(all)
fun testMintExampleTokenFails() {
    let aliceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(exampleTokenMintAmount, aliceBalance)

    let mintExampleTokenResult = executeTransaction(
        "../transactions/example-assets/example-handled-token/mint_tokens.cdc",
        [alice.address, exampleTokenMintAmount],
        exampleHandledTokenAccount
    )
    Test.expect(mintExampleTokenResult, Test.beFailed())
}

// Should not be able to enable TokenHandler without targetEVMAddress set
access(all)
fun testEnableTokenHandlerFails() {
    let enabledResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/enable_token_handler.cdc",
        [exampleTokenIdentifier],
        bridgeAccount
    )
    Test.expect(enabledResult, Test.beFailed())
}

// ERC20 deploys successfully - this will be used as the targetEVMAddress in our TokenHandler
access(all)
fun testDeployERC20Succeeds() {
    let erc20DeployResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledERC20Bytecode(), UInt64(15_000_000), 0.0],
        exampleERCAccount
    )
    Test.expect(erc20DeployResult, Test.beSucceeded())

    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(7, evts.length)
    erc20AddressHex = getEVMAddressHexFromEvents(evts, idx: 6)
}

// Set the TokenHandler's targetEVMAddress to the deployed ERC20 contract address
// This will filter requests to onboard the ERC20 to the bridge as the Cadence-native token
access(all)
fun testSetHandlerTargetEVMAddressSucceeds() {
    let setHandlerTargetResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/set_handler_target_evm_address.cdc",
        [exampleTokenIdentifier, erc20AddressHex],
        bridgeAccount
    )
    Test.expect(setHandlerTargetResult, Test.beSucceeded())

    // Check EVM Address associated with Type & vice versa
    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)
    Test.assertEqual(erc20AddressHex, associatedEVMAddressHex)
}

// Mint ERC20 tokens to bridge escrow so requests from Cadence to EVM can be fulfilled
access(all)
fun testMintERC20ToBridgeEscrowSucceeds() {
    let bridgeCOAAddressHex = getBridgeCOAAddressHex()
    let exampleTokenTotalSupply = getCadenceTotalSupply(
            contractAddress: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            vaultIdentifier: exampleTokenIdentifier
        ) ?? panic("Problem getting total supply of Cadence tokens")

    // Convert total supply UFix64 to UInt256 for ERC20 minting
    let uintTotalSupply = ufix64ToUInt256(exampleTokenTotalSupply, decimals: defaultDecimals)

    let mintERC20Result = executeTransaction(
        "../transactions/example-assets/evm-assets/mint_erc20.cdc",
        [bridgeCOAAddressHex, uintTotalSupply, erc20AddressHex, UInt64(200_000)],
        exampleERCAccount
    )
    Test.expect(mintERC20Result, Test.beSucceeded())

    let escrowBalance = balanceOf(evmAddressHex: bridgeCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(uintTotalSupply, escrowBalance)
}

// Mint ERC20 tokens to Alice's COA so she can bridge them to the Cadence
access(all)
fun testMintERC20ToArbitraryRecipientSucceeds() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let mintERC20Result = executeTransaction(
        "../transactions/example-assets/evm-assets/mint_erc20.cdc",
        [aliceCOAAddressHex, erc20MintAmount, erc20AddressHex, UInt64(200_000)],
        exampleERCAccount
    )
    Test.expect(mintERC20Result, Test.beSucceeded())

    let aliceBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, aliceBalance)
}

/* --- ONBOARDING - Test asset onboarding to the bridge --- */

// Since the type has a TokenHandler, onboarding should fail
access(all)
fun testOnboardHandledTokenByTypeFails() {
    var onboaringRequiredResult = executeScript(
        "../scripts/bridge/type_requires_onboarding_by_identifier.cdc",
        [exampleTokenIdentifier]
    )
    Test.expect(onboaringRequiredResult, Test.beSucceeded())
    var requiresOnboarding = onboaringRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    // Should fails since request routes to TokenHandler and it's not enabled
    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

// Since the erc20 Address has a TokenHandler, onboarding should fail
access(all)
fun testOnboardHandledERC20ByEVMAddressFails() {

    var onboaringRequiredResult = executeScript(
        "../scripts/bridge/evm_address_requires_onboarding.cdc",
        [erc20AddressHex]
    )
    Test.expect(onboaringRequiredResult, Test.beSucceeded())
    var requiresOnboarding = onboaringRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    // Should fails since request routes to TokenHandler and it's not enabled
    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc20AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

/* --- BRIDGING FUNGIBLE TOKENS - Test bridging both Cadence- & EVM-native fungible tokens --- */

// Bridging to EVM before TokenHandler is enabled should fail
access(all)
fun testBridgeHandledCadenceNativeTokenToEVMFails() {
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assert(cadenceBalance == exampleTokenMintAmount)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM - should fail since Handler is not enabled
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: cadenceBalance,
        beFailed: true
    )
}

// Bridging frrom EVM before TokenHandler is enabled should fail
access(all)
fun testBridgeHandledCadenceNativeTokenFromEVMFails() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    var evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, evmBalance)

    // Execute bridge from EVM
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: evmBalance,
        beFailed: true
    )
}

// Now enable TokenHandler to bridge in both directions
access(all)
fun testEnableTokenHandlerSucceeds() {
    let enabledResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/enable_token_handler.cdc",
        [exampleTokenIdentifier],
        bridgeAccount
    )
    Test.expect(enabledResult, Test.beSucceeded())
    // TODO: Validate event emission and values
}

// Validate that funds can be bridged from Cadence to EVM, resulting in balance increase in deployed ERC20 as target
access(all)
fun testBridgeHandledCadenceNativeTokenToEVMFirstSucceeds() {
    snapshot = getCurrentBlockHeight()

    let erc20TotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)

    // Alice was the only recipient, so their balance should be the total supply
    var exampleTokenTotalSupply = getCadenceTotalSupply(
            contractAddress: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            vaultIdentifier: exampleTokenIdentifier
        ) ?? panic("Problem getting total supply of Cadence tokens")

    let cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assert(cadenceBalance == exampleTokenMintAmount)
    Test.assert(cadenceBalance == exampleTokenTotalSupply)
    let uintCadenceBalance = ufix64ToUInt256(cadenceBalance, decimals: defaultDecimals)

    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: cadenceBalance,
        beFailed: false
    )

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount + uintCadenceBalance, evmBalance) // bridged balance + previously minted ERC20

    // Validate that the originally minted tokens were burned in the process of bridging
    exampleTokenTotalSupply = getCadenceTotalSupply(
            contractAddress: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            vaultIdentifier: exampleTokenIdentifier
        ) ?? panic("Problem getting total supply of Cadence tokens")
    Test.assertEqual(0.0, exampleTokenTotalSupply)

    // Validate that the ERC20 balance in circulation remained the same
    let erc20TotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20TotalSupplyBefore, erc20TotalSupplyAfter)

    let escrowBalance = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: erc20AddressHex)
    // Validate that there are no funds now in escrow since total Cadence circulation was bridged to EVM
    Test.assertEqual(UInt256(0), escrowBalance)
}

// With all funds now in EVM, we can test bridging back to Cadence
access(all)
fun testBridgeHandledCadenceNativeTokenFromEVMSecondSucceeds() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let erc20TotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)

    // Execute bridge from EVM, bridging Alice's full balance to Cadence
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    let ufixEVMbalance = uint256ToUFix64(evmBalance, decimals: defaultDecimals)
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: evmBalance,
        beFailed: false
    )

    // Confirm that Alice's balance is now the total supply
    let cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(ufixEVMbalance, cadenceBalance)

    // Confirm that the ERC20 balance was burned in the process of bridging
    let evmBalanceAfter = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), evmBalanceAfter)

    // Validate that the ERC20 balance in circulation remained the same
    let erc20TotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20TotalSupplyBefore, erc20TotalSupplyAfter)

    // Validate that all ERC20 funds are now in escrow since all bridged to Cadence
    let escrowBalance = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20TotalSupplyAfter, escrowBalance)
}

// Now test bridging with liquidity flow moving entirely from EVM to Cadence and back
access(all)
fun testBridgeHandledCadenceNativeTokenFromEVMFirstSucceeds() {
    // Reset to snapshot before bridging between VMs
    Test.reset(to: snapshot)

    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    var erc20TotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)
    let cadenceTotalSupplyBefore = getCadenceTotalSupply(
            contractAddress: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            vaultIdentifier: exampleTokenIdentifier
        ) ?? panic("Problem getting total supply of Cadence tokens")
    let uintCadenceTotalSupplyBefore = ufix64ToUInt256(cadenceTotalSupplyBefore, decimals: defaultDecimals)
    Test.assertEqual(uintCadenceTotalSupplyBefore + erc20MintAmount, erc20TotalSupplyBefore)

    // Alice should start with amount previously minted
    let aliceEVMBalanceBefore = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, aliceEVMBalanceBefore)
    // Cadence total supply should match the amount in escrow
    let escrowBalanceBefore = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: erc20AddressHex)
    Test.assertEqual(uintCadenceTotalSupplyBefore, escrowBalanceBefore)

    // Alice was the only one minted Cadence tokens, so should have the total supply in Cadence
    let aliceCadenceBalanceBefore = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(exampleTokenMintAmount, aliceCadenceBalanceBefore)
    Test.assertEqual(cadenceTotalSupplyBefore, aliceCadenceBalanceBefore)

    // Convert the bridge amount to UFix64 for Cadence balance comparison
    let ufixBridgeAmount = uint256ToUFix64(erc20MintAmount, decimals: defaultDecimals)

    // Execute bridge from EVM
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: aliceEVMBalanceBefore,
        beFailed: false
    )

    // Confirm that Alice's balance is now the total supply, having incremented by the amount bridged into Cadence
    let aliceCadenceBalanceAfter = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    let cadenceTotalSupplyAfter = getCadenceTotalSupply(
            contractAddress: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            vaultIdentifier: exampleTokenIdentifier
        ) ?? panic("Problem getting total supply of Cadence tokens")
    Test.assertEqual(cadenceTotalSupplyAfter, aliceCadenceBalanceAfter)
    Test.assertEqual(cadenceTotalSupplyAfter, cadenceTotalSupplyBefore + ufixBridgeAmount)

    // Confirm Alice's EVM balance is now 0
    let aliceEVMBalanceAfter = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), aliceEVMBalanceAfter)

    // Confirm that the amount in escrow incremented
    let escrowBalanceAfter = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: erc20AddressHex)
    Test.assertEqual(escrowBalanceBefore + aliceEVMBalanceBefore, escrowBalanceAfter)

    // Ensure the ERC20 balance in circulation remained the same
    let erc20TotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20TotalSupplyBefore, erc20TotalSupplyAfter)
}

// Now return all liquidity back to EVM
access(all)
fun testBridgeHandledCadenceNativeTokenToEVMSecondSucceeds() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let erc20TotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)

    // Alice should start with amount previously minted
    let aliceEVMBalanceBefore = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), aliceEVMBalanceBefore)
    let aliceCadenceBalanceBefore = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")

    // Convert the bridge amount to UInt256 for EVM balance comparison
    let uintBridgeAmount = ufix64ToUInt256(aliceCadenceBalanceBefore, decimals: defaultDecimals)

    // Execute bridge to EVM
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ), amount: aliceCadenceBalanceBefore,
        beFailed: false
    )

    let aliceCadenceBalanceAfter = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, aliceCadenceBalanceAfter)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    let aliceEVMBalanceAfter = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(uintBridgeAmount, aliceEVMBalanceAfter)

    // Confirm that the ERC20 balance in circulation remained the same
    let erc20TotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20TotalSupplyBefore, erc20TotalSupplyAfter)

    // Confirm escrow balance is now 0
    let escrowBalance = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), escrowBalance)
}

// After disabling the handler, funds should not move between VMs
access(all)
fun testBridgeHandledCadenceNativeTokenAfterDisablingFails() {
    let disabledResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/disable_token_handler.cdc",
        [exampleTokenIdentifier],
        bridgeAccount
    )
    Test.expect(disabledResult, Test.beSucceeded())

    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: exampleHandledTokenAccount.address,
            contractName: "ExampleHandledToken",
            resourceName: "Vault"
        ),
        amount: evmBalance,
        beFailed: true
    )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-token/setup_vault.cdc

```
// This transaction is a template for a transaction to allow
// anyone to add a Vault resource to their account so that
// they can use the exampleToken

import "FungibleToken"
import "ExampleToken"
import "ViewResolver"
import "FungibleTokenMetadataViews"

transaction () {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        let vaultData = ExampleToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("ViewResolver does not resolve FTVaultData view")

        // Return early if the account already stores a ExampleToken Vault
        if signer.storage.borrow<&ExampleToken.Vault>(from: vaultData.storagePath) != nil {
            return
        }

        let vault <- ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())

        // Create a new ExampleToken Vault and put it in storage
        signer.storage.save(<-vault, to: vaultData.storagePath)

        // Create a public capability to the Vault that exposes the Vault interfaces
        let vaultCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)

        // Create a public Capability to the Vault's Receiver functionality
        let receiverCap = signer.capabilities.storage.issue<&ExampleToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/evm_address_requires_onboarding.cdc

```
import "EVM"

import "FlowEVMBridge"

/// Returns whether a EVM contract needs to be onboarded to the FlowEVMBridge
///
/// @param evmAddressHex: The hex-encoded address of the EVM contract as a String without 0x prefix
///
/// @return Whether the contract requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///
access(all) fun main(evmAddressHex: String): Bool? {
    let address = EVM.addressFromString(evmAddressHex)
    return FlowEVMBridge.evmAddressRequiresOnboarding(address)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/CrossVMBridgeCallable.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

import {ICrossVMBridgeCallable} from "./ICrossVMBridgeCallable.sol";
import {Context} from "@openzeppelin/contracts/utils/Context.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

/**
 * @title CrossVMBridgeCallable
 * @dev A base contract intended for use in implementations on Flow, allowing a contract to define
 * access to the Cadence X EVM bridge on certain methods.
 */
abstract contract CrossVMBridgeCallable is ICrossVMBridgeCallable, Context, ERC165 {

    address private _vmBridgeAddress;

    /**
     * @dev Sets the bridge EVM address such that only the bridge COA can call the privileged methods
     */
    constructor(address vmBridgeAddress_) {
        if (vmBridgeAddress_ == address(0)) {
            revert CrossVMBridgeCallableZeroInitialization();
        }
        _vmBridgeAddress = vmBridgeAddress_;
    }

    /**
     * @dev Modifier restricting access to the designated VM bridge EVM address 
     */
    modifier onlyVMBridge() {
        _checkVMBridgeAddress();
        _;
    }

    /**
     * @dev Returns the designated VM bridge’s EVM address
     */
    function vmBridgeAddress() public view virtual returns (address) {
        return _vmBridgeAddress;
    }

    /**
     * @dev Checks that msg.sender is the designated VM bridge address
     */
    function _checkVMBridgeAddress() internal view virtual {
        if (_vmBridgeAddress != _msgSender()) {
            revert CrossVMBridgeCallableUnauthorizedAccount(_msgSender());
        }
    }

    /**
     * @dev Allows a caller to determine the contract conforms to the `ICrossVMFulfillment` interface
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {
        return interfaceId == type(ICrossVMBridgeCallable).interfaceId || super.supportsInterface(interfaceId);
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/tokens/bridge_tokens_to_any_evm_address.cdc

```
import "FungibleToken"
import "FlowToken"
import "ViewResolver"
import "NonFungibleToken"
import "FungibleTokenMetadataViews"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridgeUtils"
import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// Bridges a Vault from the signer's storage to any EVM address. The full amount to be transferred is sourced from the
/// signer's Cadence Vault & it's assumed the signer has sufficient funds to cover the amount requested to be bridged.
///
/// NOTE: The Vault being bridged must have first been onboarded to the bridge. This can be checked for with the method
///     FlowEVMBridge.typeRequiresOnboarding(type): Bool?
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from Cadence to the named recipient in EVM
/// @param recipient: The hex-encoded EVM address to send the tokens to
///
transaction(vaultIdentifier: String, amount: UFix64, recipient: String) {

    let sentVault: @{FungibleToken.Vault}
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))
        
        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract with name"
                .concat(tokenContractName).concat(" and address ")
                .concat(tokenContractAddress.toString()))
        let vaultData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view for Vault type ".concat(vaultType.identifier))
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not borrow FungibleToken Vault from storage path ".concat(vaultData.storagePath.toString()))

        // Withdraw the requested balance & set a cap on the withdrawable bridge fee
        self.sentVault <- vault.withdraw(amount: amount)
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Determine if the Vault requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.sentVault.getType())
            ?? panic("Bridge does not support the requested asset type ".concat(vaultIdentifier))
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.sentVault.getType().identifier == vaultIdentifier:
            "Attempting to send invalid vault type - requested: ".concat(vaultIdentifier)
            .concat(", sending: ").concat(self.sentVault.getType().identifier)
        self.sentVault.balance == amount: "Amount to be transferred does not match the requested amount"
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the Vault to the bridge
            FlowEVMBridge.onboardByType(
                self.sentVault.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge transaction
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeTokensToEVM(
            vault: <-self.sentVault,
            to: recipientEVMAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/handled-assets/WETH9.sol

```
// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.22 <0.6;

contract WETH9 {
    string public name     = "Wrapped Flow";
    string public symbol   = "WFLOW";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    function() external payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}


/*
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

*/
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-token/mint_tokens.cdc

```
import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

/// This transaction is what the minter Account uses to mint new ExampleTokens
/// They provide the recipient address and amount to mint, and the tokens
/// are transferred to the address after minting

transaction(recipient: Address, amount: UFix64) {

    /// Reference to the Example Token Minter Resource object
    let tokenMinter: &ExampleToken.Minter

    /// Reference to the Fungible Token Receiver of the recipient
    let tokenReceiver: &{FungibleToken.Receiver}

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    prepare(signer: auth(BorrowValue) &Account) {
        self.supplyBefore = ExampleToken.totalSupply

        // Borrow a reference to the admin object
        self.tokenMinter = signer.storage.borrow<&ExampleToken.Minter>(from: ExampleToken.AdminStoragePath)
            ?? panic("Signer is not the token admin")

        let vaultData = ExampleToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")
    
        self.tokenReceiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow receiver reference to the Vault")
    }

    execute {

        // Create mint tokens
        let mintedVault <- self.tokenMinter.mintTokens(amount: amount)

        // Deposit them to the receiever
        self.tokenReceiver.deposit(from: <-mintedVault)
    }

    post {
        ExampleToken.totalSupply == self.supplyBefore + amount: "The total supply must be increased by the amount"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/tokens/has_vault_configured.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "ViewResolver"

import "FlowEVMBridgeUtils"

/// Returns true if the recipient has Vault configured for the provided FungibleToken contract
///
/// @param vaultIdentifier The type identifier of the Vault to check for
/// @param recipient The address of the recipient
///
/// @returns true if the recipient has Vault configured for the provided FungibleToken contract, false if not. Reverts
///     if the provided contract cannot be accessed or does not have default Vault storage information.
///
access(all)
fun main(vaultIdentifier: String, recipient: Address): Bool {
    let vaultType = CompositeType(vaultIdentifier) ?? panic("Invalid vault identifier: ".concat(vaultIdentifier))
    let contractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
        ?? panic("Could not find contract address for vault: ".concat(vaultIdentifier))
    let contractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
        ?? panic("Could not find contract name for vault: ".concat(vaultIdentifier))
    let tokenContract = getAccount(contractAddress).contracts.borrow<&{FungibleToken}>(name: contractName)
        ?? panic("No such contract found")
    let vaultData = tokenContract.resolveContractView(
            resourceType: vaultType,
            viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
        ) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("FungibleToken does not provide default Vault data")
    return getAccount(recipient).capabilities.exists(vaultData.receiverPath)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/evm/call.cdc

```
import "EVM"

access(all) fun getTypeArray(_ identifiers: [String]): [Type] {
    var types: [Type] = []
    for identifier in identifiers {
        let type = CompositeType(identifier)
            ?? panic("Invalid identifier: ".concat(identifier))
        types.append(type)
    }
    return types
}

/// Supports generic calls to EVM contracts that might have return values
///
access(all) fun main(
    gatewayAddress: Address,
    evmContractAddressHex: String,
    calldata: String,
    gasLimit: UInt64,
    typeIdentifiers: [String]
): [AnyStruct] {

    let evmAddress = EVM.addressFromString(evmContractAddressHex)

    let data = calldata.decodeHex()

    let gatewayCOA = getAuthAccount<auth(BorrowValue) &Account>(gatewayAddress)
        .storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(
            from: /storage/evm
        ) ?? panic("Could not borrow COA from provided gateway address")

    let evmResult = gatewayCOA.call(
        to: evmAddress,
        data: data,
        gasLimit: gasLimit,
        value: EVM.Balance(attoflow: 0)
    )

    if typeIdentifiers.length == 0 {
        return []
    } else {
        return EVM.decodeABI(types: getTypeArray(typeIdentifiers), data: evmResult.data)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/ICrossVMBridgeCallable.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

/**
 * @title ICrossVMBridgeCallable
 * @dev An interface intended for use by implementations on Flow EVM, allowing a contract to define
 * access to the Cadence X EVM bridge on certain methods.
 */
interface ICrossVMBridgeCallable {

    /// @dev Should encounter when the vmBridgeAddress is initialized to 0x0
    error CrossVMBridgeCallableZeroInitialization();
    /// @dev Should encounter when a VM bridge privileged method is triggered by unauthorized caller
    error CrossVMBridgeCallableUnauthorizedAccount(address account);

    /**
     * @dev Returns the designated VM bridge’s EVM address
     */
    function vmBridgeAddress() external view returns (address);
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/derive_bridged_nft_contract_name.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

access(all)
fun main(evmAddressHex: String): String {
    return FlowEVMBridgeUtils.deriveBridgedNFTContractName(
        from: EVM.addressFromString(evmAddressHex)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/deposit.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// Deposits $FLOW to the signer's COA in FlowEVM
///
transaction(amount: UFix64) {
    let preBalance: UFix64
    let coa: &EVM.CadenceOwnedAccount
    let signerVault: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        let storagePath = StoragePath(identifier: "evm")!
        // Create coa if none exists
        if signer.storage.type(at: storagePath) == nil {
            signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: storagePath)
        }

        // Reference the signer's coa
        self.coa = signer.storage.borrow<&EVM.CadenceOwnedAccount>(from: storagePath)
            ?? panic("Could not borrow reference to the signer's bridged account")

        // Note the pre-transfer balance
        self.preBalance = self.coa.balance().inFLOW()
    
        // Reference the signer's FlowToken Vault
        self.signerVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to the owner's vault")
    }

    execute {
        // Withdraw tokens from the signer's vault
        let fromVault <- self.signerVault.withdraw(amount: amount) as! @FlowToken.Vault
        // Deposit tokens into the COA
        self.coa.deposit(from: <-fromVault)
    }

    post {
        // Can't do the following since .balance() isn't view
        self.coa.balance().inFLOW() == self.preBalance + amount: "Error executing transfer!"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/tokens/total_supply.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"

/// Returns the total supply of the tokens defining the Vault at the given address
///
/// @param contractAddress: The address of the token contract
/// @param contractName: The name of the token contract
/// @param vaultTypeIdentifier: The identifier of the vault's Type
///
/// @returns The total supply of tokens in circulation of the specified vault type if the FT contract implements the
///         `FungibleTokenMetadata.TotalSupply` view or nil. A nil value may indicate that either the specified vault
///         type does not exist or the FT contract does not implement the `FungibleTokenMetadata.TotalSupply` view.
///
access(all) fun main(contractAddress: Address, contractName: String, vaultTypeIdentifier: String): UFix64? {
    let ftContract = getAccount(contractAddress).contracts.borrow<&{FungibleToken}>(name: contractName)
    if ftContract == nil {
        return nil
    }
    let vaultType = CompositeType(vaultTypeIdentifier)
    if vaultType == nil {
        return nil
    }

    if let totalSupplyView = ftContract!.resolveContractView(
            resourceType: vaultType!, 
            viewType: Type<FungibleTokenMetadataViews.TotalSupply>()
        ) as! FungibleTokenMetadataViews.TotalSupply? {
        return totalSupplyView.supply
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/batch_bridge_nft_to_any_cadence_address.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges NFTs from EVM to Cadence assuming the NFT has already been onboarded to the FlowEVMBridge.
/// Also know that the recipient Flow account must have a Receiver capable of receiving the this bridged NFT accessible
/// via published Capability at the token's standard path.
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param ids: The ERC721 ids of the NFTs to bridge to Cadence from EVM
/// @param recipient: The Flow account address to receive the bridged NFT
///
transaction(nftIdentifier: String, ids: [UInt256], recipient: Address) {

    let nftType: Type
    let receiver: &{NonFungibleToken.Receiver}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the recipient's NFT Receiver --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        // Configure the signer's account for this NFT
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.receiver = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("Could not borrow NonFungibleToken Receiver from recipient's public capability path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Iterate over the provided ids
        for id in ids {
            // Execute the bridge
            let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
                type: self.nftType,
                id: id,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            // Ensure the bridged nft is the correct type
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Deposit the bridged NFT into the signer's collection
            self.receiver.deposit(token: <-nft)
        }
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/IBridgePermissions.cdc

```
/// This contract defines a simple interface which can be implemented by any resource to prevent it from being
/// onboarded to the Flow-EVM bridge
///
/// NOTE: This is suggested only for cases where your asset (NFT/FT) incorporates non-standard logic that would
///      break your project if not handles properly
///      e.g. assets are reclaimed after a certain period of time, NFTs share IDs, etc.
///
access(all)
contract interface IBridgePermissions {
    /// Contract-level method enabling implementing contracts to identify whether they allow bridging for their
    /// project's assets. Implementers may consider adding a hook which would later enable an update to this value
    /// should either the project be updated or the bridge be updated to handle the asset's non-standard logic which 
    /// would otherwise prevent them from supporting VM bridging at the outset.
    ///
    access(all)
    view fun allowsBridging(): Bool {
        return false
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/ICrossVMAsset.cdc

```
import "EVM"

import "ICrossVM"

/// A simple contract interface for a Cadence contract that represents an asset bridged from Flow EVM such as an ERC20
/// or ERC721 token.
///
access(all) contract interface ICrossVMAsset : ICrossVM {
    /// Returns the name of the asset
    access(all) view fun getName(): String
    /// Returns the symbol of the asset
    access(all) view fun getSymbol(): String

    access(all) resource interface AssetInfo {
        access(all) view fun getName(): String
        access(all) view fun getSymbol(): String
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress        
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/serialize/serialize_nft.cdc

```
import "ViewResolver"
import "MetadataViews"
import "NonFungibleToken"

import "SerializeMetadata"

access(all)
fun main(address: Address, storagePathIdentifier: String, id: UInt64): String? {
    let storagePath = StoragePath(identifier: storagePathIdentifier)
        ?? panic("Could not construct StoragePath from identifier")
    if let collection = getAuthAccount<auth(BorrowValue) &Account>(address).storage
        .borrow<&{NonFungibleToken.Collection}>(
            from: storagePath
        ) {
        if let nft = collection.borrowNFT(id) {
            return SerializeMetadata.serializeNFTMetadataAsURI(nft)
        }
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/FlowEVMBridgedERC20Deployer.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IFlowEVMBridgeDeployer} from "./interfaces/IFlowEVMBridgeDeployer.sol";
import {FlowEVMBridgedERC20} from "./templates/FlowEVMBridgedERC20.sol";

/**
 * @title FlowEVMBridgedERC20Deployer
 * @dev A contract to deploy FlowEVMBridgedERC20 contracts with named associations to Cadence resources types. Only the
 * delegated deployer can deploy new contracts. This contract is used by the Flow EVM bridge to deploy and define
 * bridged ERC20 tokens which are defined natively in Cadence.
 */
contract FlowEVMBridgedERC20Deployer is ERC165, IFlowEVMBridgeDeployer, Ownable {
    // The address of the delegated deployer who can deploy new contracts
    address public delegatedDeployer;

    constructor() Ownable(msg.sender) {}

    /**
     * @dev Modifier to check if the caller is the delegated deployer
     */
    modifier onlyDelegatedDeployer() {
        require(msg.sender == delegatedDeployer, "FlowEVMBridgedERC20Deployer: Only delegated deployer can deploy");
        _;
    }

    /**
     * @dev ERC165 introspection
     */
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool) {
        return interfaceId == type(IFlowEVMBridgeDeployer).interfaceId || interfaceId == type(Ownable).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Deploy a new FlowEVMBridgedERC20 contract with the given name, symbol, and association to a Cadence
     * contract.
     *
     * @param name The name of the ERC20
     * @param symbol The symbol of the ERC20
     * @param cadenceAddress The address of the associated Cadence contract
     * @param cadenceIdentifier The identifier of the associated Cadence asset type
     * @param contractURI The URI of the contract metadata
     *
     * @return The address of the deployed EVM contract
     */
    function deploy(
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) external onlyDelegatedDeployer returns (address) {
        FlowEVMBridgedERC20 newERC20 =
            new FlowEVMBridgedERC20(owner(), name, symbol, cadenceAddress, cadenceIdentifier, contractURI);

        emit Deployed(address(newERC20), name, symbol, cadenceAddress, cadenceIdentifier);

        return address(newERC20);
    }

    /**
     * @dev Set the delegated deployer address as the entity that can deploy new contracts. Only the owner can call this
     * function.
     *
     * @param _delegatedDeployer The address of the delegated deployer
     */
    function setDelegatedDeployer(address _delegatedDeployer) external onlyOwner {
        require(_delegatedDeployer != address(0), "FlowEVMBridgedERC20Deployer: Invalid delegated deployer address");
        delegatedDeployer = _delegatedDeployer;

        emit DeployerAuthorized(_delegatedDeployer);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/flow-token/transfer_flow.cdc

```
import "FungibleToken"
import "FlowToken"

transaction(recipient: Address, amount: UFix64) {

    let providerVault: auth(FungibleToken.Withdraw) &FlowToken.Vault
    let receiver: &{FungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {
        self.providerVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            )!
        self.receiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            ?? panic("Could not borrow receiver reference")
    }

    execute {
        self.receiver.deposit(
            from: <-self.providerVault.withdraw(
                amount: amount
            )
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/testnet/EVMBridgedTokenTemplate.cdc

```
import NonFungibleToken from 0x631e88ae7f1d7c20
import MetadataViews from 0x631e88ae7f1d7c20
import FungibleTokenMetadataViews from 0x9a0766d93b6608b7
import ViewResolver from 0x631e88ae7f1d7c20
import FungibleToken from 0x9a0766d93b6608b7
import FlowToken from 0x7e60df042a9c0868

import EVM from 0x8c5303eaa26202d6

import ICrossVM from 0xdfc20aee650fcbdf
import ICrossVMAsset from 0xdfc20aee650fcbdf
import IEVMBridgeTokenMinter from 0xdfc20aee650fcbdf
import FlowEVMBridgeTokenEscrow from 0xdfc20aee650fcbdf
import FlowEVMBridgeConfig from 0xdfc20aee650fcbdf
import FlowEVMBridgeUtils from 0xdfc20aee650fcbdf
import FlowEVMBridge from 0xdfc20aee650fcbdf
import CrossVMToken from 0xdfc20aee650fcbdf
import FlowEVMBridgeResolver from 0xdfc20aee650fcbdf

/// This contract is a template used by FlowEVMBridge to define EVM-native fungible tokens bridged from Flow EVM to 
/// Cadence. Upon deployment of this contract, the contract name is derived as a function of the asset type (here an 
/// ERC20) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC20 is transferred to the bridge's CadenceOwnedAccount EVM address and tokens are minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is burned
/// in this contract and the ERC20 is transferred to the defined recipient. In this way, the Cadence Vault acts as a
/// representation of both the EVM tokens and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeTokenMinter, FungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmTokenContractAddress: EVM.EVMAddress
    /// Name of the fungible token defined in the corresponding ERC20 contract
    access(all) let name: String
    /// Symbol of the fungible token defined in the corresponding ERC20 contract
    access(all) let symbol: String
    /// Decimal place value defined in the source ERC20 contract
    access(all) let decimals: UInt8
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Total supply of this Cadence token in circulation
    /// NOTE: This does not reflect the total supply of the source ERC20 in circulation within EVM
    access(all) var totalSupply: UFix64
    /// Retain a Vault to reference when resolving Vault Metadata
    access(self) let vault: @Vault

    /// The Vault resource representing the bridged ERC20 token
    ///
    access(all) resource Vault : ICrossVMAsset.AssetInfo, CrossVMToken.EVMTokenInfo, FungibleToken.Vault {
        /// Balance of the tokens in a given Vault
        access(all) var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        /* --- CrossVMToken.EVMFTVault conformance --- */
        //
        /// Gets the ERC20 name value
        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8 {
            return {{CONTRACT_NAME}}.decimals
        }
        /// Returns the EVM contract address of the fungible token
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }

        access(all) view fun getViews(): [Type] {
            return {{CONTRACT_NAME}}.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return {{CONTRACT_NAME}}.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return { self.getType(): true }
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @Vault {
            return <-create Vault(balance: 0.0)
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                {{CONTRACT_NAME}}.totalSupply = {{CONTRACT_NAME}}.totalSupply - self.balance
            }
            self.balance = 0.0
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero and returns it to the calling context. A user must call
    /// this function and store the returned Vault in their storage in order to allow their account to be able to
    /// receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{{CONTRACT_NAME}}.Vault {
        return <- create Vault(balance: 0.0)
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the fungible token this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmTokenContractAddress
    }

    /// Function that returns all the Metadata Views implemented by this fungible token contract.
    ///
    /// @return An array of Types defining the implemented views. This value will be used by developers to know which
    ///         parameter to pass to the resolveContractView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    ///
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let contractRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<FungibleTokenMetadataViews.FTDisplay>())
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/{{CONTRACT_NAME}}Vault,
                    receiverPath: /public/{{CONTRACT_NAME}}Receiver,
                    metadataPath: /public/{{CONTRACT_NAME}}Vault,
                    receiverLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    metadataLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-self.createEmptyVault(vaultType: Type<@{{CONTRACT_NAME}}.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: self.totalSupply
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint tokens from bridge-defined fungible token contracts
    ///
    access(account) fun mintTokens(amount: UFix64): @{FungibleToken.Vault} {
        self.totalSupply = self.totalSupply + amount
        return <- create Vault(balance: amount)
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, decimals: UInt8, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmTokenContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.contractURI = contractURI
        self.totalSupply = 0.0
        self.vault <- create Vault(balance: 0.0)

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.Vault>(), with: self.evmTokenContractAddress)
        FlowEVMBridgeTokenEscrow.initializeEscrow(
            with: <-create Vault(balance: 0.0),
            name: name,
            symbol: symbol,
            decimals: decimals,
            evmTokenAddress: self.evmTokenContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/is_owner_or_approved.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Returns whether the given owner (hex-encoded EVM address) is the owner or approved of the given
/// ERC721 NFT defined at the hex-encoded EVM contract address
///
/// @param ofNFT: The ERC721 ID of the NFT
/// @param owner: The hex-encoded EVM address of the owner
/// @param evmContractAddress: The hex-encoded EVM contract address of the ERC721 contract
///
/// @return Whether the given owner is the owner or approved of the given ERC721 NFT. Reverts on call failure.
///
access(all) fun main(ofNFT: UInt256, owner: String, evmContractAddress: String): Bool {
    return FlowEVMBridgeUtils.isOwnerOrApproved(
        ofNFT: ofNFT,
        owner: EVM.addressFromString(owner),
        evmContractAddress: EVM.addressFromString(evmContractAddress)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/create_wflow_token_handler.cdc

```
import "FlowToken"

import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeHandlers"

/// Creates a WFLOWTokenHandler for moving FLOW between VMs. The TokenHandler is configured in the bridge to handle the 
/// FlowToken Vault type.
///
/// @param wflowEVMAddressHex: The EVM address of the WFLOW contract as a hex string
///
transaction(wflowEVMAddressHex: String) {

    let configurator: auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeHandlers.HandlerConfigurator

    prepare(signer: auth(BorrowValue, LoadValue) &Account) {
        self.configurator = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeHandlers.HandlerConfigurator>(
                from: FlowEVMBridgeHandlers.ConfiguratorStoragePath
            ) ?? panic("Missing configurator")
    }

    execute {
        let wflowEVMAddress = EVM.addressFromString(wflowEVMAddressHex)
        self.configurator.createTokenHandler(
            handlerType: Type<@FlowEVMBridgeHandlers.WFLOWTokenHandler>(),
            targetType: Type<@FlowToken.Vault>(),
            targetEVMAddress: wflowEVMAddress,
            expectedMinterType: nil
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/withdraw.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// Withdraws $FLOW from the signer's COA and deposits it into their FLOW vault in the Cadence environment
///
transaction(amount: UFix64) {

    let coa: auth(EVM.Withdraw) &EVM.CadenceOwnedAccount
    let vault: auth(FungibleToken.Withdraw) &FlowToken.Vault
    let preBalance: UFix64

    prepare(signer: auth(BorrowValue) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow reference to the signer's bridged account")
        
        self.vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow reference to the owner's vault")
        self.preBalance = self.vault.balance
    }

    execute {
        let withdrawBalance = EVM.Balance(attoflow: 0)
        withdrawBalance.setFLOW(flow: amount)
        let bridgedVault <- self.coa.withdraw(balance: withdrawBalance) as! @{FungibleToken.Vault}
        self.vault.deposit(from: <-bridgedVault)
    }

    post {
        self.vault.balance == self.preBalance + amount: "Problem transferring Flow between environments!"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/get_associated_evm_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns the EVM address associated with the given Cadence type (as its identifier String)
///
/// @param typeIdentifier: The Cadence type identifier String
///
/// @return The EVM address as a hex string if the type has an associated EVMAddress, otherwise nil
///
access(all)
fun main(identifier: String): String? {
    if let type = CompositeType(identifier) {
        if let address = FlowEVMBridgeConfig.getEVMAddressAssociated(with: type) {
            return address.toString()
        }
    }
    return nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/flow_evm_wflow_handler_tests.cdc

```
import Test
import BlockchainHelpers

import "FungibleToken"
import "NonFungibleToken"
import "FlowStorageFees"
import "EVM"
import "FlowEVMBridgeConfig"

import "test_helpers.cdc"

access(all) let serviceAccount = Test.serviceAccount()
access(all) let bridgeAccount = Test.getAccount(0x0000000000000007)
access(all) let exampleERCAccount = Test.getAccount(0x0000000000000009)
access(all) let alice = Test.createAccount()
access(all) var aliceCOAAddressHex: String = ""

// FlowToken
access(all) let flowTokenAccountAddress = Address(0x0000000000000003)
access(all) let flowTokenIdentifier = "A.0000000000000003.FlowToken.Vault"
access(all) let flowFundingAmount = 201.0
access(all) let coaFundingAmount = 100.0

// WFLOW values
access(all) var wflowAddressHex: String = ""
access(all) let erc20MintAmount: UInt256 = 100_000_000_000_000_000_000
access(all) let wrapFlowAmount: UFix64 = 100.0

// Fee initialiazation values
access(all) let expectedOnboardFee = 1.0
access(all) let expectedBaseFee = 0.001

// Default decimals for Cadence UFix64 values
access(all) let defaultDecimals: UInt8 = 18

// Test height snapshot for test state resets
access(all) var snapshot: UInt64 = 0

access(all)
fun setup() {
    // Deploy supporting util contracts
    var err = Test.deployContract(
        name: "ArrayUtils",
        path: "../contracts/utils/ArrayUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "StringUtils",
        path: "../contracts/utils/StringUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ScopedFTProviders",
        path: "../contracts/utils/ScopedFTProviders.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "SerializeMetadata",
        path: "../contracts/utils/SerializeMetadata.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Transfer bridge account some $FLOW
    transferFlow(signer: serviceAccount, recipient: bridgeAccount.address, amount: 10_000.0)
    // Configure bridge account with a COA
    createCOA(signer: bridgeAccount, fundingAmount: 1_000.0)

    err = Test.deployContract(
        name: "IBridgePermissions",
        path: "../contracts/bridge/interfaces/IBridgePermissions.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVM",
        path: "../contracts/bridge/interfaces/ICrossVM.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVMAsset",
        path: "../contracts/bridge/interfaces/ICrossVMAsset.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMNFT",
        path: "../contracts/bridge/interfaces/CrossVMNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMToken",
        path: "../contracts/bridge/interfaces/CrossVMToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeHandlerInterfaces",
        path: "../contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeConfig",
        path: "../contracts/bridge/FlowEVMBridgeConfig.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Deploy FlowBridgeFactory.sol
    let deploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledFactoryBytecode(), 15_000_000, 0.0],
        bridgeAccount
    )
    // Get the deployed contract address from the latest EVM event
    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(2, evts.length)
    let factoryAddressHex = getEVMAddressHexFromEvents(evts, idx: 0)

    err = Test.deployContract(
        name: "FlowEVMBridgeUtils",
        path: "../contracts/bridge/FlowEVMBridgeUtils.cdc",
        arguments: [factoryAddressHex]
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeResolver",
        path: "../contracts/bridge/FlowEVMBridgeResolver.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeNFTEscrow",
        path: "../contracts/bridge/FlowEVMBridgeNFTEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTokenEscrow",
        path: "../contracts/bridge/FlowEVMBridgeTokenEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTemplates",
        path: "../contracts/bridge/FlowEVMBridgeTemplates.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    // Commit bridged NFT code
    let bridgedNFTChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedNFT", getBridgedNFTCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())
    // Commit bridged Token code
    let bridgedTokenChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedToken", getBridgedTokenCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())

    err = Test.deployContract(
        name: "IEVMBridgeNFTMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeNFTMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IEVMBridgeTokenMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeTokenMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMNFTBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMNFTBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMTokenBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMTokenBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridge",
        path: "../contracts/bridge/FlowEVMBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeAccessor",
        path: "../contracts/bridge/FlowEVMBridgeAccessor.cdc",
        arguments: [serviceAccount.address]
    )
    Test.expect(err, Test.beNil())

    let claimAccessorResult = executeTransaction(
        "../transactions/bridge/admin/evm-integration/claim_accessor_capability_and_save_router.cdc",
        ["FlowEVMBridgeAccessor", bridgeAccount.address],
        serviceAccount
    )
    Test.expect(claimAccessorResult, Test.beSucceeded())

    err = Test.deployContract(
        name: "FlowEVMBridgeHandlers",
        path: "../contracts/bridge/FlowEVMBridgeHandlers.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Set bridge fees
    let updateOnboardFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_onboard_fee.cdc",
        [expectedOnboardFee],
        bridgeAccount
    )
    Test.expect(updateOnboardFeeResult, Test.beSucceeded())
    let updateBaseFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_base_fee.cdc",
        [expectedBaseFee],
        bridgeAccount
    )
    Test.expect(updateBaseFeeResult, Test.beSucceeded())

    // Unpause Bridge
    updateBridgePauseStatus(signer: bridgeAccount, pause: false)
}

/* --- ASSET & ACCOUNT SETUP - Configure test accounts with assets to bridge --- */

// Create a COA in Alice's account who will be the test asset owner for both Cadence & ERC20 FTs
access(all)
fun testCreateCOASucceeds() {
    // Alice's account gets 201.0 FLOW
    transferFlow(signer: serviceAccount, recipient: alice.address, amount: flowFundingAmount)
    // Fund the COA with 100.0 FLOW of the 201.0 FLOW in Alice's account
    createCOA(signer: alice, fundingAmount: coaFundingAmount)

    aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
}

// WFLOW deploys successfully - this will be used as the targetEVMAddress in our TokenHandler
access(all)
fun testDeployWFLOWSucceeds() {
    // Anyone can deploy WFLOW as its unowned - we just use any account here to deploy
    let wflowDeployResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledWFLOWBytecode(), UInt64(15_000_000), 0.0],
        alice
    )
    Test.expect(wflowDeployResult, Test.beSucceeded())

    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(5, evts.length)
    wflowAddressHex = getEVMAddressHexFromEvents(evts, idx: 4)
    log("WFLOW Address: ".concat(wflowAddressHex))
}

access(all)
fun testWrapFLOWSucceeds() {
    let wrapResult = executeTransaction(
        "../transactions/example-assets/evm-assets/wrap_flow.cdc",
        [wflowAddressHex, coaFundingAmount],
        alice
    )
    Test.expect(wrapResult, Test.beSucceeded())

    // Validate that the wrapping was successful by getting alice's COA's WFLOW balance
    let wflowBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: wflowAddressHex)

    // Get WFLOW total supply
    let wflowTotalSupply = getEVMTotalSupply(erc20AddressHex: wflowAddressHex)
    let coaFundingAmountUInt = ufix64ToUInt256(coaFundingAmount, decimals: defaultDecimals)
    Test.assertEqual(coaFundingAmountUInt, wflowBalance)
}

// Configuring the Handler also disables onboarding of WFLOW to the bridge
access(all)
fun testCreateWFLOWTokenHandlerSucceeds() {
    // Create TokenHandler for WFLOW, specifying the target type and expected minter type
    let createHandlerResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/create_wflow_token_handler.cdc",
        [wflowAddressHex],
        bridgeAccount
    )
    Test.expect(createHandlerResult, Test.beSucceeded())

    // TODO: Add event validation when EVM and EVM dependent contracts can be imported to Test env
}

// /* --- ONBOARDING - Test asset onboarding to the bridge --- */

// Since the type has a TokenHandler, onboarding should fail
access(all)
fun testOnboardFlowTokenByTypeFails() {
    var onboaringRequiredResult = executeScript(
        "../scripts/bridge/type_requires_onboarding_by_identifier.cdc",
        [flowTokenIdentifier]
    )
    Test.expect(onboaringRequiredResult, Test.beSucceeded())
    var requiresOnboarding = onboaringRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    // Should fail since request routes to TokenHandler and it's not enabled
    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [flowTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

// Since the WFLOW Address has a TokenHandler, onboarding should fail
access(all)
fun testOnboardWFLOWByEVMAddressFails() {

    var onboaringRequiredResult = executeScript(
        "../scripts/bridge/evm_address_requires_onboarding.cdc",
        [wflowAddressHex]
    )
    Test.expect(onboaringRequiredResult, Test.beSucceeded())
    var requiresOnboarding = onboaringRequiredResult.returnValue as! Bool? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    // Should fails since request routes to TokenHandler and it's not enabled
    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [wflowAddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

/* --- BRIDGING FLOW to EVM as WFLOW and WFLOW from EVM as FLOW --- */

// Now enable TokenHandler to bridge in both directions
access(all)
fun testEnableWFLOWTokenHandlerSucceeds() {
    let enabledResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/enable_token_handler.cdc",
        [flowTokenIdentifier],
        bridgeAccount
    )
    Test.expect(enabledResult, Test.beSucceeded())
    // TODO: Validate event emission and values
}

// Validate that funds can be bridged from Cadence to EVM, resulting in balance increase in WFLOW as target
access(all)
fun testBridgeZeroFLOWTokenToEVMFails() {
    // Attempt bridge 0 FLOW to EVM - should fail
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: flowTokenAccountAddress,
            contractName: "FlowToken",
            resourceName: "Vault"
        ),
        amount: 0.0,
        beFailed: true
    )
}

// Validate that funds can be bridged from Cadence to EVM, resulting in balance increase in WFLOW as target
access(all)
fun testBridgeFLOWTokenToEVMFirstSucceeds() {
    snapshot = getCurrentBlockHeight()

    // Take note of the total supply before bridging
    let wflowTotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: wflowAddressHex)

    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "flowTokenVault")
        ?? panic("Problem getting FlowToken balance")
    Test.assert(cadenceBalance == flowFundingAmount - coaFundingAmount, message: "Invalid Cadence balance")
    // Leave some FLOW as it's needed for storage, transaction, and bridge fees
    let remainder = 1.0
    let bridgeAmount = cadenceBalance - remainder

    // Convert the bridge amount to UInt256 for EVM balance comparison
    let coaFundingAmountUInt = ufix64ToUInt256(coaFundingAmount, decimals: defaultDecimals)
    let uintBridgeAmount = ufix64ToUInt256(bridgeAmount, decimals: defaultDecimals)

    // Execute bridge to EVM
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: flowTokenAccountAddress,
            contractName: "FlowToken",
            resourceName: "Vault"
        ),
        amount: bridgeAmount,
        beFailed: false
    )

    // Confirm ownership on EVM side with Alice COA as owner of bridged WFLOW
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: wflowAddressHex)
    Test.assertEqual(coaFundingAmountUInt + uintBridgeAmount, evmBalance) // bridged balance + previously minted ERC20

    // Validate that the WFLOW balance in circulation increased by the amount bridged
    let wflowTotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: wflowAddressHex)
    Test.assertEqual(wflowTotalSupplyBefore, wflowTotalSupplyAfter - uintBridgeAmount)

    // Ensure that Alice's WFLOW balance is the sum of the minted amount and the amount bridged
    let aliceEVMBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: wflowAddressHex)
    Test.assertEqual(coaFundingAmountUInt + uintBridgeAmount, aliceEVMBalance)
}

// With all funds now in EVM, we can test bridging back to Cadence
access(all)
fun testBridgeZeroWFLOWTokenFromEVMSecondFails() {
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: flowTokenAccountAddress,
            contractName: "FlowToken",
            resourceName: "Vault"
        ),
        amount: UInt256(0),
        beFailed: true
    )
}

// With all funds now in EVM, we can test bridging back to Cadence
access(all)
fun testBridgeWFLOWTokenFromEVMSecondSucceeds() {
    // let wflowTotalSupplyBefore = getEVMTotalSupply(erc20AddressHex: wflowAddressHex)

    let cadenceBalanceBefore = getBalance(ownerAddr: alice.address, storagePathIdentifier: "flowTokenVault")
        ?? panic("Problem getting FlowToken balance")

    // Execute bridge from EVM, bridging Alice's full balance to Cadence
    let wflowBalanceBefore = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: wflowAddressHex)
    let ufixEVMbalance = uint256ToUFix64(wflowBalanceBefore, decimals: defaultDecimals)
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: flowTokenAccountAddress,
            contractName: "FlowToken",
            resourceName: "Vault"
        ),
        amount: wflowBalanceBefore,
        beFailed: false
    )

    // Confirm that Alice's balance has been bridged to Cadence
    let cadenceBalanceAfter = getBalance(ownerAddr: alice.address, storagePathIdentifier: "flowTokenVault")
        ?? panic("Problem getting FlowToken balance")
    let expectedBalanceAfter = cadenceBalanceBefore + ufixEVMbalance - FlowEVMBridgeConfig.baseFee
    Test.assertEqual(expectedBalanceAfter, cadenceBalanceAfter)

    // Confirm that the WFLOW balance was transferred out in the process of bridging
    let evmBalanceAfter = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: wflowAddressHex)
    Test.assertEqual(UInt256(0), evmBalanceAfter)

    // Validate that the WFLOW supply in circulation reduced to 0
    let wflowTotalSupplyAfter = getEVMTotalSupply(erc20AddressHex: wflowAddressHex)
    Test.assertEqual(UInt256(0), wflowTotalSupplyAfter)

    // Validate that all WFLOW funds are now in escrow since all bridged to Cadence
    let escrowBalance = balanceOf(evmAddressHex: getBridgeCOAAddressHex(), erc20AddressHex: wflowAddressHex)
    Test.assertEqual(wflowTotalSupplyAfter, escrowBalance)
}

access(all)
fun testBridgeWFLOWToCadenceAfterDisablingFails() {
    let disabledResult = executeTransaction(
        "../transactions/bridge/admin/token-handler/disable_token_handler.cdc",
        [flowTokenIdentifier],
        bridgeAccount
    )
    Test.expect(disabledResult, Test.beSucceeded())

    let cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "flowTokenVault")
        ?? panic("Problem getting FlowToken balance")

    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: flowTokenAccountAddress,
            contractName: "FlowToken",
            resourceName: "Vault"
        ),
        amount: cadenceBalance,
        beFailed: true
    )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/create_empty_usdc_vault.cdc

```
import "USDCFlow"

access(all)
fun main() {
    let v <- USDCFlow.createEmptyVault(vaultType: Type<@USDCFlow.Vault>())
    log("Vault creation successful")
    destroy v
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeNFTEscrow.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "MetadataViews"
import "ViewResolver"
import "FlowToken"

import "EVM"

import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"
import "CrossVMNFT"

/// This escrow contract handles the locking of assets that are bridged from Flow to EVM and retrieval of locked
/// assets in escrow when they are bridged back to Flow.
///
access(all) contract FlowEVMBridgeNFTEscrow {

    /**********************
            Getters
    ***********************/

    /// Returns whether the Locker has been initialized for the given NFT type
    ///
    access(all) view fun isInitialized(forType: Type): Bool {
        return self.borrowLocker(forType: forType) != nil
    }

    /// Returns whether an NFT with the given ID is locked
    ///
    /// @param id ID of the NFT to check
    ///
    /// @returns True if the NFT is locked, false otherwise
    ///
    access(all) view fun isLocked(type: Type, id: UInt64): Bool {
        return self.borrowLockedNFT(type: type, id: id) != nil
    }

    /// Retrieves the locked NFT's Cadence ID as defined in the NFT standard's NFT.id value if it is locked
    ///
    /// @param type: Type of the locked NFT
    /// @param evmID: EVM ID of the locked NFT
    ///
    /// @returns Cadence ID of the locked NFT if it exists
    ///
    access(all) view fun getLockedCadenceID(type: Type, evmID: UInt256): UInt64? {
        return self.borrowLocker(forType: type)?.getCadenceID(from: evmID) ?? nil
    }

    /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value
    /// corresponding to the Cadence NFT.
    /// As far as the bridge is concerned, a bridge-deployed ERC721 assigns IDs based on NFT.id value at the time of
    /// bridging unless it implements the CrossVMNFT.EVMNFT in such case .evmID is used.
    /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID,
    /// otherwise the NFT's ID is returned as a UInt256 as this is how the bridge would handle minting in the
    /// corresponding ERC721 contract.
    ///
    /// @param type: Type of the locked NFT
    /// @param cadenceID: Cadence ID of the locked NFT
    ///
    /// @returns EVM ID of the locked NFT if it exists
    ///
    access(all) view fun getLockedEVMID(type: Type, cadenceID: UInt64): UInt256? {
        return self.borrowLocker(forType: type)?.getEVMID(from: cadenceID) ?? nil
    }

    /// Returns the metadata view types supported by a given NFT if it is in escrow, nil otherwise
    ///
    /// @param nftType: Type of the locked NFT
    /// @param id: ID of the locked NFT
    ///
    /// @returns The metadata view types supported by the locked NFT if it is in escrow, nil otherwise
    ///
    access(all) view fun getViews(nftType: Type, id: UInt64): [Type]? {
        if let nft = self.borrowLockedNFT(type: nftType, id: id) {
            return nft.getViews()
        }
        return nil
    }

    /**********************
        Bridge Methods
    ***********************/

    /// Initializes the Locker for the given NFT type if it hasn't been initialized yet
    ///
    access(account) fun initializeEscrow(forType: Type, name: String, symbol: String, erc721Address: EVM.EVMAddress) {
        let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: forType)
            ?? panic("Problem deriving Locker path for NFT type identifier=".concat(forType.identifier))
        if self.account.storage.type(at: lockerPath) != nil {
            panic("NFT Locker already stored at storage path=".concat(lockerPath.toString()))
        }

        let locker <- create Locker(name: name, symbol: symbol, lockedType: forType, erc721Address: erc721Address)
        self.account.storage.save(<-locker, to: lockerPath)
    }

    /// Locks the NFT in escrow, returning the amount of storage used by the locker after storing
    ///
    access(account) fun lockNFT(_ nft: @{NonFungibleToken.NFT}): UInt64 {
        let locker = self.borrowLocker(forType: nft.getType())
            ?? panic("Problem borrowing reference to Locker for NFT type identifier=".concat(nft.getType().identifier))

        let preStorageSnapshot = self.account.storage.used
        locker.deposit(token: <-nft)
        let postStorageSnapshot = self.account.storage.used

        // Return the amount of storage used by the locker after storing the NFT
        if postStorageSnapshot < preStorageSnapshot {
            // Due to atree inlining, account storage usage may counterintuitively decrease at times - return 0
            return 0
        } else {
            // Otherwise, return the storage usage delta
            return postStorageSnapshot - preStorageSnapshot
        }
    }

    /// Unlocks the NFT of the given type and ID, reverting if it isn't in escrow
    ///
    access(account) fun unlockNFT(type: Type, id: UInt64): @{NonFungibleToken.NFT} {
        let locker = self.borrowLocker(forType: type)
            ?? panic("Problem borrowing reference to Locker for NFT type identifier=".concat(type.identifier))
        return <- locker.withdraw(withdrawID: id)
    }


    /// Retrieves a reference to the NFT of the given type and ID if it is locked, otherwise returns nil
    ///
    access(account) view fun borrowLockedNFT(type: Type, id: UInt64): &{NonFungibleToken.NFT}? {
        if let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: type) {
            return self.account.storage.borrow<&Locker>(from: lockerPath)?.borrowNFT(id) ?? nil
        }
        return nil
    }

    /// Retrieves an entitled locker for the given type or nil if it doesn't exist
    ///
    access(self) view fun borrowLocker(forType: Type): auth(NonFungibleToken.Withdraw) &Locker? {
        if let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: forType) {
            if self.account.storage.type(at: lockerPath) == Type<@Locker>() {
                return self.account.storage.borrow<auth(NonFungibleToken.Withdraw) &Locker>(from: lockerPath)
            }
        }
        return nil
    }

    /*********************
            Locker
    *********************/

    /// The resource managing the locking & unlocking of NFTs via this contract's interface
    ///
    access(all) resource Locker : CrossVMNFT.EVMNFTCollection {
        /// Corresponding name assigned in the tokens' corresponding ERC20 contract
        access(all) let name: String
        /// Corresponding symbol assigned in the tokens' corresponding ERC20 contract
        access(all) let symbol: String
        /// Corresponding ERC721 address for the locked NFTs
        access(all) let erc721Address: EVM.EVMAddress
        /// The type of NFTs this Locker escrows
        access(all) let lockedType: Type
        /// Count of locked NFTs as ownedNFTs.length may exceed computation limits
        access(self) var lockedNFTCount: Int
        /// Indexed on NFT UUID to prevent collisions
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Maps EVM NFT ID to Flow NFT ID, covering cross-VM project NFTs
        access(self) let evmIDToFlowID: {UInt256: UInt64}

        init(name: String, symbol: String, lockedType: Type, erc721Address: EVM.EVMAddress) {
            self.name = name
            self.symbol = symbol
            self.lockedType = lockedType
            self.erc721Address = erc721Address
            self.lockedNFTCount = 0
            self.ownedNFTs <- {}
            self.evmIDToFlowID = {}
        }

        access(all)
        view fun getName(): String {
            return self.name
        }

        access(all)
        view fun getSymbol(): String {
            return self.symbol
        }

        /// Returns the number of locked NFTs
        ///
        access(all)
        view fun getLength(): Int {
            return self.lockedNFTCount
        }

        /// Depending on the number of locked NFTs, this may fail.
        ///
        access(all)
        view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Returns all the EVM IDs of the locked NFTs if the locked token implements CrossVMNFT.EVMNFT
        ///
        access(all)
        view fun getEVMIDs(): [UInt256] {
            return self.evmIDToFlowID.keys
        }

        /// Returns the Flow NFT ID associated with the EVM NFT ID if the locked token implements CrossVMNFT.EVMNFT
        ///
        access(all)
        view fun getCadenceID(from evmID: UInt256): UInt64? {
            if self.evmIDToFlowID[evmID] == nil && self.borrowNFT(UInt64(evmID)) != nil {
                return UInt64(evmID)
            }
            return self.evmIDToFlowID[evmID]
        }

        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        ///
        access(all)
        view fun getEVMID(from cadenceID: UInt64): UInt256? {
            if let nft = self.borrowNFT(cadenceID) {
                if let evmNFT = CrossVMNFT.getEVMID(from: nft) {
                    return evmNFT
                }
                return UInt256(nft.id)
            }
            return nil
        }

        access(all) fun contractURI(): String? {
            return nil
        }

        /// Returns a reference to the NFT if it is locked
        ///
        access(all)
        view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Returns a map of supported NFT types - at the moment Lockers only support the lockedNFTType defined by
        /// their contract
        ///
        access(all)
        view fun getSupportedNFTTypes(): {Type: Bool} {
            return {
                self.lockedType: self.isSupportedNFTType(type: self.lockedType)
            }
        }

        /// Returns true if the NFT type is supported
        ///
        access(all)
        view fun isSupportedNFTType(type: Type): Bool {
            return type == self.lockedType
        }

        /// Returns the NFT as a Resolver if it is locked
        ///
        access(all)
        view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            return self.borrowNFT(id)
        }

        /// Deposits the NFT into this locker, noting its EVM ID if it implements CrossVMNFT.EVMNFT
        ///
        access(all)
        fun deposit(token: @{NonFungibleToken.NFT}) {
            pre {
                self.borrowNFT(token.id) == nil:
                "NFT type=".concat(token.getType().identifier).concat(" with id=").concat(token.id.toString())
                    .concat(" already exists in the Locker")
            }
            if let evmID = CrossVMNFT.getEVMID(from: &token as &{NonFungibleToken.NFT}) {
                self.evmIDToFlowID[evmID] = token.id
            }
            self.lockedNFTCount = self.lockedNFTCount + 1
            self.ownedNFTs[token.id] <-! token
        }

        /// Withdraws the NFT from this locker, removing it from the collection and returning it
        ///
        access(NonFungibleToken.Withdraw)
        fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            // Should not happen, but prevent potential underflow
            assert(
                self.lockedNFTCount > 0,
                message: "Attempting to withdraw NFT id=".concat(withdrawID.toString())
                .concat(" - no NFTs of type=").concat(self.lockedType.identifier).concat(" to withdraw")
            )
            self.lockedNFTCount = self.lockedNFTCount - 1
            let token <- self.ownedNFTs.remove(key: withdrawID)!
            if let evmID = CrossVMNFT.getEVMID(from: &token as &{NonFungibleToken.NFT}) {
                self.evmIDToFlowID.remove(key: evmID)
            }
            return <- token
        }

        /// Creates an empty Collection - added here for NFT.Collection conformance
        ///
        access(all)
        fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- create Locker(
                name: self.name,
                symbol: self.symbol,
                lockedType: self.lockedType,
                erc721Address: self.erc721Address
            )
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/SECURITY.md

# Responsible Disclosure Policy

Flow was built from the ground up with security in mind. Our code, infrastructure, and development methodology helps us keep our users safe.

We really appreciate the community's help. Responsible disclosure of vulnerabilities helps to maintain the security and privacy of everyone.

If you care about making a difference, please follow the guidelines below.

# **Guidelines For Responsible Disclosure**

We ask that all researchers adhere to these guidelines [here](https://flow.com/flow-responsible-disclosure/)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/ufix64_to_uint256.cdc

```
import "FlowEVMBridgeUtils"

access(all)
fun main(value: UFix64, decimals: UInt8): UInt256 {
    return FlowEVMBridgeUtils.ufix64ToUInt256(value: value, decimals: decimals)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/safe_mint_erc721.cdc

```
import "EVM"

transaction(
    recipientHexAddress: String,
    tokenId: UInt256,
    uri: String,
    erc721HexAddress: String,
    gasLimit: UInt64
) {
    
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Signer does not have a COA in storage")
    }

    execute {
        let recipientAddress = EVM.addressFromString(recipientHexAddress)
        let erc721Address = EVM.addressFromString(erc721HexAddress)
        let calldata = EVM.encodeABIWithSignature(
            "safeMint(address,uint256,string)",
            [recipientAddress, tokenId, uri]
        )
        let callResult = self.coa.call(
            to: erc721Address,
            data: calldata,
            gasLimit: gasLimit,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "ERC721 mint failed with code: ".concat(callResult.errorCode.toString()))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/transfer_erc20.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Executes a token transfer to the defined recipient address against the specified ERC20 contract.
///
transaction(evmContractAddressHex: String, recipientAddressHex: String, amount: UInt256) {
    
    let evmContractAddress: EVM.EVMAddress
    let recipientAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    let preBalance: UInt256
    var postBalance: UInt256
    
    prepare(signer: auth(BorrowValue) &Account) {
        self.evmContractAddress = EVM.addressFromString(evmContractAddressHex)
        self.recipientAddress = EVM.addressFromString(recipientAddressHex)

        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow CadenceOwnedAccount reference")
        
        self.preBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)
        self.postBalance = 0
    }

    execute {
        let calldata = EVM.encodeABIWithSignature("transfer(address,uint256)", [self.recipientAddress, amount])
        let callResult = self.coa.call(
            to: self.evmContractAddress,
            data: calldata,
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC20 contract failed")
        self.postBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)
    }

    post {
        self.postBalance == self.preBalance - amount: "Transfer failed"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridge.cdc

```
import "Burner"
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "NonFungibleToken"
import "MetadataViews"
import "ViewResolver"

import "EVM"

import "IBridgePermissions"
import "ICrossVM"
import "IEVMBridgeNFTMinter"
import "IEVMBridgeTokenMinter"
import "IFlowEVMNFTBridge"
import "IFlowEVMTokenBridge"
import "CrossVMNFT"
import "CrossVMToken"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeUtils"
import "FlowEVMBridgeNFTEscrow"
import "FlowEVMBridgeTokenEscrow"
import "FlowEVMBridgeTemplates"
import "SerializeMetadata"

/// The FlowEVMBridge contract is the main entrypoint for bridging NFT & FT assets between Flow & FlowEVM.
///
/// Before bridging, be sure to onboard the asset type which will configure the bridge to handle the asset. From there,
/// the asset can be bridged between VMs via the COA as the entrypoint.
///
/// See also:
/// - Code in context: https://github.com/onflow/flow-evm-bridge
/// - FLIP #237: https://github.com/onflow/flips/pull/233
///
access(all)
contract FlowEVMBridge : IFlowEVMNFTBridge, IFlowEVMTokenBridge {

    /*************
        Events
    **************/

    /// Emitted any time a new asset type is onboarded to the bridge
    access(all)
    event Onboarded(type: String, cadenceContractAddress: Address, evmContractAddress: String)
    /// Denotes a defining contract was deployed to the bridge account
    access(all)
    event BridgeDefiningContractDeployed(
        contractName: String,
        assetName: String,
        symbol: String,
        isERC721: Bool,
        evmContractAddress: String
    )

    /**************************
        Public Onboarding
    **************************/


    /// Onboards a given asset by type to the bridge. Since we're onboarding by Cadence Type, the asset must be defined
    /// in a third-party contract. Attempting to onboard a bridge-defined asset will result in an error as the asset has
    /// already been onboarded to the bridge.
    ///
    /// @param type: The Cadence Type of the NFT to be onboarded
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun onboardByType(_ type: Type, feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}) {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !FlowEVMBridgeConfig.isCadenceTypeBlocked(type):
                "This Cadence Type ".concat(type.identifier).concat(" is currently blocked from being onboarded")
            self.typeRequiresOnboarding(type) == true: "Onboarding is not needed for this type"
            FlowEVMBridgeUtils.typeAllowsBridging(type):
                "This type is not supported as defined by the project's development team"
            FlowEVMBridgeUtils.isCadenceNative(type: type): "Only Cadence-native assets can be onboarded by Type"
        }
        /* Provision fees */
        //
        // Withdraw from feeProvider and deposit to self
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: FlowEVMBridgeConfig.onboardFee)

        /* EVM setup */
        //
        // Deploy an EVM defining contract via the FlowBridgeFactory.sol contract
        let onboardingValues = self.deployEVMContract(forAssetType: type)

        /* Cadence escrow setup */
        //
        // Initialize bridge escrow for the asset based on its type
        if type.isSubtype(of: Type<@{NonFungibleToken.NFT}>()) {
            FlowEVMBridgeNFTEscrow.initializeEscrow(
                forType: type,
                name: onboardingValues.name,
                symbol: onboardingValues.symbol,
                erc721Address: onboardingValues.evmContractAddress
            )
        } else if type.isSubtype(of: Type<@{FungibleToken.Vault}>()) {
            let createVaultFunction = FlowEVMBridgeUtils.getCreateEmptyVaultFunction(forType: type)
                ?? panic("Could not retrieve createEmptyVault function for the given type")
            let vault <-createVaultFunction(type)
            assert(
                vault.getType() == type,
                message: "Requested to onboard type=".concat(type.identifier).concat( "but contract returned type=").concat(vault.getType().identifier)
            )
            FlowEVMBridgeTokenEscrow.initializeEscrow(
                with: <-vault,
                name: onboardingValues.name,
                symbol: onboardingValues.symbol,
                decimals: onboardingValues.decimals!,
                evmTokenAddress: onboardingValues.evmContractAddress
            )
        } else {
            panic("Attempted to onboard unsupported type: ".concat(type.identifier))
        }

        /* Confirmation */
        //
        assert(
            FlowEVMBridgeNFTEscrow.isInitialized(forType: type) || FlowEVMBridgeTokenEscrow.isInitialized(forType: type),
            message: "Failed to initialize escrow for given type"
        )

        emit Onboarded(
            type: type.identifier,
            cadenceContractAddress: FlowEVMBridgeUtils.getContractAddress(fromType: type)!,
            evmContractAddress: onboardingValues.evmContractAddress.toString()
        )
    }

    /// Onboards a given EVM contract to the bridge. Since we're onboarding by EVM Address, the asset must be defined in
    /// a third-party EVM contract. Attempting to onboard a bridge-defined asset will result in an error as onboarding
    /// is not required.
    ///
    /// @param address: The EVMAddress of the ERC721 or ERC20 to be onboarded
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun onboardByEVMAddress(
        _ address: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !FlowEVMBridgeConfig.isEVMAddressBlocked(address):
                "This EVM contract ".concat(address.toString()).concat(" is currently blocked from being onboarded")
        }
        /* Validate the EVM contract */
        //
        // Ensure the project has not opted out of bridge support
        assert(
            FlowEVMBridgeUtils.evmAddressAllowsBridging(address),
            message: "This contract is not supported as defined by the project's development team"
        )
        assert(
            self.evmAddressRequiresOnboarding(address) == true,
            message: "Onboarding is not needed for this contract"
        )

        /* Provision fees */
        //
        // Withdraw fee from feeProvider and deposit
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: FlowEVMBridgeConfig.onboardFee)

        /* Setup Cadence-defining contract */
        //
        // Deploy a defining Cadence contract to the bridge account
        self.deployDefiningContract(evmContractAddress: address)
    }

    /*************************
        NFT Handling
    **************************/

    /// Public entrypoint to bridge NFTs from Cadence to EVM as ERC721.
    ///
    /// @param token: The NFT to be bridged
    /// @param to: The NFT recipient in FlowEVM
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun bridgeNFTToEVM(
        token: @{NonFungibleToken.NFT},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !token.isInstance(Type<@{FungibleToken.Vault}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(token.getType()) == false: "NFT must first be onboarded"
            FlowEVMBridgeConfig.isTypePaused(token.getType()) == false: "Bridging is currently paused for this NFT"
        }
        /* Gather identifying information */
        //
        let tokenType = token.getType()
        let tokenID = token.id
        let evmID = CrossVMNFT.getEVMID(from: &token as &{NonFungibleToken.NFT}) ?? UInt256(token.id)

        /* Metadata assignement */
        //
        // Grab the URI from the NFT if available
        var uri: String = ""
        // Default to project-specified URI
        if let metadata = token.resolveView(Type<MetadataViews.EVMBridgedMetadata>()) as! MetadataViews.EVMBridgedMetadata? {
            uri = metadata.uri.uri()
        } else {
            // Otherwise, serialize the NFT
            uri = SerializeMetadata.serializeNFTMetadataAsURI(&token as &{NonFungibleToken.NFT})
        }

        /* Secure NFT in escrow & deposit calculated fees */
        //
        // Lock the NFT & calculate the storage used by the NFT
        let storageUsed = FlowEVMBridgeNFTEscrow.lockNFT(<-token)
        // Calculate the bridge fee on current rates
        let feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: storageUsed)
        // Withdraw fee from feeProvider and deposit
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: feeAmount)

        /* Determine EVM handling */
        //
        // Does the bridge control the EVM contract associated with this type?
        let associatedAddress = FlowEVMBridgeConfig.getEVMAddressAssociated(with: tokenType)
            ?? panic("No EVMAddress found for token type")
        let isFactoryDeployed = FlowEVMBridgeUtils.isEVMContractBridgeOwned(evmContractAddress: associatedAddress)

        /* Third-party controlled ERC721 handling */
        //
        // Not bridge-controlled, transfer existing ownership
        if !isFactoryDeployed {
            FlowEVMBridgeUtils.mustSafeTransferERC721(erc721Address: associatedAddress, to: to, id: evmID)
            return
        }

        /* Bridge-owned ERC721 handling */
        //
        // Check if the ERC721 exists in the EVM contract - determines if bridge mints or transfers
        let exists = FlowEVMBridgeUtils.erc721Exists(erc721Address: associatedAddress, id: evmID)
        if exists {
            // Transfer the existing NFT
            FlowEVMBridgeUtils.mustSafeTransferERC721(erc721Address: associatedAddress, to: to, id: evmID)

            // And update the URI to reflect current metadata
            FlowEVMBridgeUtils.mustUpdateTokenURI(erc721Address: associatedAddress, id: evmID, uri: uri)
        } else {
            // Otherwise mint with current URI
            FlowEVMBridgeUtils.mustSafeMintERC721(erc721Address: associatedAddress, to: to, id: evmID, uri: uri)
        }
    }

    /// Entrypoint to bridge ERC721 from EVM to Cadence as NonFungibleToken.NFT
    ///
    /// @param owner: The EVM address of the NFT owner. Current ownership and successful transfer (via
    ///     `protectedTransferCall`) is validated before the bridge request is executed.
    /// @param calldata: Caller-provided approve() call, enabling contract COA to operate on NFT in EVM contract
    /// @param id: The NFT ID to bridged
    /// @param evmContractAddress: Address of the EVM address defining the NFT being bridged - also call target
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the NFT from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    /// @returns The bridged NFT
    ///
    access(account)
    fun bridgeNFTFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        id: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{NonFungibleToken.NFT} {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !type.isSubtype(of: Type<@{FungibleToken.Vault}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(type) == false: "NFT must first be onboarded"
            FlowEVMBridgeConfig.isTypePaused(type) == false: "Bridging is currently paused for this NFT"
        }
        /* Provision fee */
        //
        // Withdraw from feeProvider and deposit to self
        let feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 0)
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: feeAmount)

        /* Execute escrow transfer */
        //
        // Get the EVMAddress of the ERC721 contract associated with the type
        let associatedAddress = FlowEVMBridgeConfig.getEVMAddressAssociated(with: type)
            ?? panic("No EVMAddress found for token type")
        // Execute the transfer call and make needed state assertions to confirm escrow from named owner
        FlowEVMBridgeUtils.mustEscrowERC721(
            owner: owner,
            id: id,
            erc721Address: associatedAddress,
            protectedTransferCall: protectedTransferCall
        )

        /* Gather identifying info */
        //
        // Derive the defining Cadence contract name & address & attempt to borrow it as IEVMBridgeNFTMinter
        let contractName = FlowEVMBridgeUtils.getContractName(fromType: type)!
        let contractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: type)!
        let nftContract = getAccount(contractAddress).contracts.borrow<&{IEVMBridgeNFTMinter}>(name: contractName)
        // Get the token URI from the ERC721 contract
        let uri = FlowEVMBridgeUtils.getTokenURI(evmContractAddress: associatedAddress, id: id)

        /* Unlock escrowed NFTs */
        //
        // If the NFT is currently locked, unlock and return
        if let cadenceID = FlowEVMBridgeNFTEscrow.getLockedCadenceID(type: type, evmID: id) {
            let nft <- FlowEVMBridgeNFTEscrow.unlockNFT(type: type, id: cadenceID)

            // If the NFT is bridge-defined, update the URI from the source ERC721 contract
            if self.account.address == FlowEVMBridgeUtils.getContractAddress(fromType: type) {
                nftContract!.updateTokenURI(evmID: id, newURI: uri)
            }

            return <-nft
        }

        /* Mint bridge-defined NFT */
        //
        // Ensure the NFT is bridge-defined
        assert(self.account.address == contractAddress, message: "Unexpected error bridging NFT from EVM")

        // We expect the NFT to be minted in Cadence as it is bridge-defined
        let nft <- nftContract!.mintNFT(id: id, tokenURI: uri)
        return <-nft
    }

    /**************************
        FT Handling
    ***************************/

    /// Public entrypoint to bridge FTs from Cadence to EVM as ERC20 tokens.
    ///
    /// @param vault: The fungible token Vault to be bridged
    /// @param to: The fungible token recipient in EVM
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun bridgeTokensToEVM(
        vault: @{FungibleToken.Vault},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !vault.isInstance(Type<@{NonFungibleToken.NFT}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(vault.getType()) == false: "FungibleToken must first be onboarded"
            FlowEVMBridgeConfig.isTypePaused(vault.getType()) == false: "Bridging is currently paused for this token"
        }
        /* Handle $FLOW requests via EVM interface & return */
        //
        let vaultType = vault.getType()

        // Gather the vault balance before acting on the resource
        let vaultBalance = vault.balance
        // Initialize fee amount to 0.0 and assign as appropriate for how the token is handled
        var feeAmount = 0.0

        /* TokenHandler coverage */
        //
        // Some tokens pre-dating bridge require special case handling - borrow handler and passthrough to fulfill
        if FlowEVMBridgeConfig.typeHasTokenHandler(vaultType) {
            let handler = FlowEVMBridgeConfig.borrowTokenHandler(vaultType)
                ?? panic("Could not retrieve handler for the given type")
            handler.fulfillTokensToEVM(tokens: <-vault, to: to)

            // Here we assume burning Vault in Cadence which doesn't require storage consumption
            feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 0)
            FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: feeAmount)
            return
        }

        /* Escrow or burn tokens depending on native environment */
        //
        // In most all other cases, if Cadence-native then tokens must be escrowed
        if FlowEVMBridgeUtils.isCadenceNative(type: vaultType) {
            // Lock the FT balance & calculate the extra used by the FT if any
            let storageUsed = FlowEVMBridgeTokenEscrow.lockTokens(<-vault)
            // Calculate the bridge fee on current rates
            feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: storageUsed)
        } else {
            // Since not Cadence-native, bridge defines the token - burn the vault and calculate the fee
            Burner.burn(<-vault)
            feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 0)
        }

        /* Provision fees */
        //
        // Withdraw fee amount from feeProvider and deposit
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: feeAmount)

        /* Gather identifying information */
        //
        // Does the bridge control the EVM contract associated with this type?
        let associatedAddress = FlowEVMBridgeConfig.getEVMAddressAssociated(with: vaultType)
            ?? panic("No EVMAddress found for vault type")
        // Convert the vault balance to a UInt256
        let bridgeAmount = FlowEVMBridgeUtils.convertCadenceAmountToERC20Amount(
                vaultBalance,
                erc20Address: associatedAddress
            )
        assert(bridgeAmount > UInt256(0), message: "Amount to bridge must be greater than 0")

        // Determine if the EVM contract is bridge-owned - affects how tokens are transmitted to recipient
        let isFactoryDeployed = FlowEVMBridgeUtils.isEVMContractBridgeOwned(evmContractAddress: associatedAddress)

        /* Transmit tokens to recipient */
        //
        // Mint or transfer based on the bridge's EVM contract authority, making needed state assertions to confirm
        if isFactoryDeployed {
            FlowEVMBridgeUtils.mustMintERC20(to: to, amount: bridgeAmount, erc20Address: associatedAddress)
        } else {
            FlowEVMBridgeUtils.mustTransferERC20(to: to, amount: bridgeAmount, erc20Address: associatedAddress)
        }
    }

    /// Entrypoint to bridge ERC20 tokens from EVM to Cadence as FungibleToken Vaults
    ///
    /// @param owner: The EVM address of the FT owner. Current ownership and successful transfer (via
    ///     `protectedTransferCall`) is validated before the bridge request is executed.
    /// @param calldata: Caller-provided approve() call, enabling contract COA to operate on FT in EVM contract
    /// @param amount: The amount of tokens to be bridged
    /// @param evmContractAddress: Address of the EVM address defining the FT being bridged - also call target
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the FT from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    /// @returns The bridged fungible token Vault
    ///
    access(account)
    fun bridgeTokensFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        amount: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{FungibleToken.Vault} {
        pre {
            !FlowEVMBridgeConfig.isPaused(): "Bridge operations are currently paused"
            !type.isSubtype(of: Type<@{NonFungibleToken.Collection}>()): "Mixed asset types are not yet supported"
            self.typeRequiresOnboarding(type) == false: "FungibleToken must first be onboarded"
            FlowEVMBridgeConfig.isTypePaused(type) == false: "Bridging is currently paused for this token"
        }
        /* Provision fees */
        //
        // Withdraw from feeProvider and deposit to self
        let feeAmount = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 0)
        FlowEVMBridgeUtils.depositFee(feeProvider, feeAmount: feeAmount)

        /* TokenHandler case coverage */
        //
        // Some tokens pre-dating bridge require special case handling. If such a case, fulfill via the related handler
        if FlowEVMBridgeConfig.typeHasTokenHandler(type) {
            //  - borrow handler and passthrough to fulfill
            let handler = FlowEVMBridgeConfig.borrowTokenHandler(type)
                ?? panic("Could not retrieve handler for the given type")
            return <-handler.fulfillTokensFromEVM(
                owner: owner,
                type: type,
                amount: amount,
                protectedTransferCall: protectedTransferCall
            )
        }

        /* Gather identifying information */
        //
        // Get the EVMAddress of the ERC20 contract associated with the type
        let associatedAddress = FlowEVMBridgeConfig.getEVMAddressAssociated(with: type)
            ?? panic("No EVMAddress found for token type")
        // Find the Cadence defining address and contract name
        let definingAddress = FlowEVMBridgeUtils.getContractAddress(fromType: type)!
        let definingContractName = FlowEVMBridgeUtils.getContractName(fromType: type)!
        // Convert the amount to a ufix64 so the amount can be settled on the Cadence side
        let ufixAmount = FlowEVMBridgeUtils.convertERC20AmountToCadenceAmount(amount, erc20Address: associatedAddress)
        assert(ufixAmount > 0.0, message: "Amount to bridge must be greater than 0")

        /* Execute the transfer call and make needed state assertions */
        //
        FlowEVMBridgeUtils.mustEscrowERC20(
            owner: owner,
            amount: amount,
            erc20Address: associatedAddress,
            protectedTransferCall: protectedTransferCall
        )

        /* Bridge-defined tokens are minted in Cadence */
        //
        // If the Cadence Vault is bridge-defined, mint the tokens
        if definingAddress == self.account.address {
            let minter = getAccount(definingAddress).contracts.borrow<&{IEVMBridgeTokenMinter}>(name: definingContractName)!
            return <- minter.mintTokens(amount: ufixAmount)
        }

        /* Cadence-native tokens are withdrawn from escrow */
        //
        // Confirm the EVM defining contract is bridge-owned before burning tokens
        assert(
            FlowEVMBridgeUtils.isEVMContractBridgeOwned(evmContractAddress: associatedAddress),
            message: "Unexpected error bridging FT from EVM"
        )
        // Burn the EVM tokens that have now been transferred to the bridge in EVM
        let burnResult: EVM.Result = FlowEVMBridgeUtils.call(
            signature: "burn(uint256)",
            targetEVMAddress: associatedAddress,
            args: [amount],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(burnResult.status == EVM.Status.successful, message: "Burn of EVM tokens failed")

        // Unlock from escrow and return
        return <-FlowEVMBridgeTokenEscrow.unlockTokens(type: type, amount: ufixAmount)
    }

    /**************************
        Public Getters
    **************************/

    /// Returns the EVM address associated with the provided type
    ///
    access(all)
    view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress? {
        return FlowEVMBridgeConfig.getEVMAddressAssociated(with: type)
    }

    /// Retrieves the bridge contract's COA EVMAddress
    ///
    /// @returns The EVMAddress of the bridge contract's COA orchestrating actions in FlowEVM
    ///
    access(all)
    view fun getBridgeCOAEVMAddress(): EVM.EVMAddress {
        return FlowEVMBridgeUtils.borrowCOA().address()
    }

    /// Returns whether an asset needs to be onboarded to the bridge
    ///
    /// @param type: The Cadence Type of the asset
    ///
    /// @returns Whether the asset needs to be onboarded
    ///
    access(all)
    view fun typeRequiresOnboarding(_ type: Type): Bool? {
        if !FlowEVMBridgeUtils.isValidCadenceAsset(type: type) {
            return nil
        }
        return FlowEVMBridgeConfig.getEVMAddressAssociated(with: type) == nil &&
            !FlowEVMBridgeConfig.typeHasTokenHandler(type)
    }

    /// Returns whether an EVM-native asset needs to be onboarded to the bridge
    ///
    /// @param address: The EVMAddress of the asset
    ///
    /// @returns Whether the asset needs to be onboarded, nil if the defined asset is not supported by this bridge
    ///
    access(all)
    fun evmAddressRequiresOnboarding(_ address: EVM.EVMAddress): Bool? {
        // See if the bridge already has a known type associated with the given address
        if FlowEVMBridgeConfig.getTypeAssociated(with: address) != nil {
            return false
        }
        // Dealing with EVM-native asset, check if it's NFT or FT exclusively
        if FlowEVMBridgeUtils.isValidEVMAsset(evmContractAddress: address) {
            return true
        }
        // Not onboarded and not a valid asset, so return nil
        return nil
    }

    /**************************
        Internal Helpers
    ***************************/

    /// Deploys templated EVM contract via Solidity Factory contract supporting bridging of a given asset type
    ///
    /// @param forAssetType: The Cadence Type of the asset
    ///
    /// @returns The EVMAddress of the deployed contract
    ///
    access(self)
    fun deployEVMContract(forAssetType: Type): FlowEVMBridgeUtils.EVMOnboardingValues {
        pre {
            FlowEVMBridgeUtils.isValidCadenceAsset(type: forAssetType):
                "Asset type is not supported by the bridge"
        }
        let isNFT = forAssetType.isSubtype(of: Type<@{NonFungibleToken.NFT}>())

        let onboardingValues = FlowEVMBridgeUtils.getCadenceOnboardingValues(forAssetType: forAssetType)

        let deployedContractAddress = FlowEVMBridgeUtils.mustDeployEVMContract(
                name: onboardingValues.name,
                symbol: onboardingValues.symbol,
                cadenceAddress: onboardingValues.contractAddress,
                flowIdentifier: onboardingValues.identifier,
                contractURI: onboardingValues.contractURI,
                isERC721: isNFT
            )

        // Associate the deployed contract with the given type & return the deployed address
        FlowEVMBridgeConfig.associateType(forAssetType, with: deployedContractAddress)
        return FlowEVMBridgeUtils.EVMOnboardingValues(
            evmContractAddress: deployedContractAddress,
            name: onboardingValues.name,
            symbol: onboardingValues.symbol,
            decimals: isNFT ? nil : FlowEVMBridgeConfig.defaultDecimals,
            contractURI: onboardingValues.contractURI,
            cadenceContractName: FlowEVMBridgeUtils.getContractName(fromType: forAssetType)!,
            isERC721: isNFT
        )
    }

    /// Helper for deploying templated defining contract supporting EVM-native asset bridging to Cadence
    /// Deploys either NFT or FT contract depending on the provided type
    ///
    /// @param evmContractAddress: The EVMAddress currently defining the asset to be bridged
    ///
    access(self)
    fun deployDefiningContract(evmContractAddress: EVM.EVMAddress) {
        // Gather identifying information about the EVM contract
        let evmOnboardingValues = FlowEVMBridgeUtils.getEVMOnboardingValues(evmContractAddress: evmContractAddress)

        // Get Cadence code from template & deploy to the bridge account
        let cadenceCode: [UInt8] = FlowEVMBridgeTemplates.getBridgedAssetContractCode(
                evmOnboardingValues.cadenceContractName,
                isERC721: evmOnboardingValues.isERC721
            ) ?? panic("Problem retrieving code for Cadence-defining contract")
        if evmOnboardingValues.isERC721 {
            self.account.contracts.add(
                name: evmOnboardingValues.cadenceContractName,
                code: cadenceCode,
                evmOnboardingValues.name,
                evmOnboardingValues.symbol,
                evmContractAddress,
                evmOnboardingValues.contractURI
            )
        } else {
            self.account.contracts.add(
                name: evmOnboardingValues.cadenceContractName,
                code: cadenceCode,
                evmOnboardingValues.name,
                evmOnboardingValues.symbol,
                evmOnboardingValues.decimals!,
                evmContractAddress, evmOnboardingValues.contractURI
            )
        }

        emit BridgeDefiningContractDeployed(
            contractName: evmOnboardingValues.cadenceContractName,
            assetName: evmOnboardingValues.name,
            symbol: evmOnboardingValues.symbol,
            isERC721: evmOnboardingValues.isERC721,
            evmContractAddress: evmContractAddress.toString()
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/transfer_flow_to_evm_address.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// Transfers $FLOW from the signer's account Cadence Flow balance to the recipient's hex-encoded EVM address.
///
transaction(recipientEVMAddressHex: String, amount: UFix64) {

    var sentVault: @FlowToken.Vault
    let recipientEVMAddress: EVM.EVMAddress
    let recipientPreBalance: UFix64

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        // Borrow a reference to the signer's FlowToken.Vault and withdraw the amount
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")
        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault

        // Get the recipient's EVM address
        self.recipientEVMAddress = EVM.addressFromString(recipientEVMAddressHex)

        // Get the recipient's balance before the transfer to check the amount transferred
        self.recipientPreBalance = self.recipientEVMAddress.balance().inFLOW()
    }

    execute {
        // Deposit the amount to the recipient's EVM address
        self.recipientEVMAddress.deposit(from: <-self.sentVault)
    }

    post {
        self.recipientEVMAddress.balance().inFLOW() == self.recipientPreBalance + amount:
            "Problem transferring value to EVM address"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/utils/ArrayUtils.cdc

```
// Copied from https://github.com/green-goo-dao/flow-utils/blob/crescendo/contracts/ArrayUtils.cdc
// Special thanks to the Green Goo Dao contributors for creating this contract
access(all) contract ArrayUtils {
    access(all) fun rangeFunc(_ start: Int, _ end: Int, _ f: fun (Int): Void) {
        var current = start
        while current < end {
            f(current)
            current = current + 1
        }
    }

    access(all) fun range(_ start: Int, _ end: Int): [Int] {
        var res: [Int] = []
        self.rangeFunc(start, end, fun (i: Int) {
            res.append(i)
        })
        return res
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/test/FlowBridgeFactory.t.sol

```
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import {Test} from "forge-std/Test.sol";

import {FlowBridgeDeploymentRegistry} from "../src/FlowBridgeDeploymentRegistry.sol";
import {FlowEVMBridgedERC721Deployer} from "../src/FlowEVMBridgedERC721Deployer.sol";
import {FlowEVMBridgedERC20Deployer} from "../src/FlowEVMBridgedERC20Deployer.sol";
import {FlowBridgeFactory} from "../src/FlowBridgeFactory.sol";
import {FlowEVMBridgedERC721} from "../src/templates/FlowEVMBridgedERC721.sol";
import {FlowEVMBridgedERC20} from "../src/templates/FlowEVMBridgedERC20.sol";

contract FlowBridgeFactoryTest is Test {
    FlowBridgeFactory internal factory;
    FlowBridgeDeploymentRegistry internal registry;
    FlowEVMBridgedERC20Deployer internal erc20Deployer;
    FlowEVMBridgedERC721Deployer internal erc721Deployer;
    FlowEVMBridgedERC20 internal deployedERC20Contract;
    FlowEVMBridgedERC721 internal deployedERC721Contract;

    string name;
    string symbol;
    string cadenceNFTAddress;
    string cadenceNFTIdentifier;
    string cadenceTokenAddress;
    string cadenceTokenIdentifier;
    string contractURI;
    address deployedERC20Address;
    address deployedERC721Address;

    function setUp() public virtual {
        name = "name";
        symbol = "symbol";
        cadenceNFTAddress = "cadenceNFTAddress";
        cadenceNFTIdentifier = "cadenceNFTIdentifier";
        cadenceTokenAddress = "cadenceTokenAddress";
        cadenceTokenIdentifier = "cadenceTokenIdentifier";
        contractURI = "contractURI";

        factory = new FlowBridgeFactory();

        registry = new FlowBridgeDeploymentRegistry();
        erc20Deployer = new FlowEVMBridgedERC20Deployer();
        erc721Deployer = new FlowEVMBridgedERC721Deployer();

        factory.setDeploymentRegistry(address(registry));
        registry.setRegistrar(address(factory));

        erc20Deployer.setDelegatedDeployer(address(factory));
        erc721Deployer.setDelegatedDeployer(address(factory));

        factory.addDeployer("ERC20", address(erc20Deployer));
        factory.addDeployer("ERC721", address(erc721Deployer));

        deployedERC20Address = factory.deploy("ERC20", name, symbol, cadenceTokenAddress, cadenceTokenIdentifier, contractURI);
        deployedERC721Address = factory.deploy("ERC721", name, symbol, cadenceNFTAddress, cadenceNFTIdentifier, contractURI);

        deployedERC20Contract = FlowEVMBridgedERC20(deployedERC20Address);
        deployedERC721Contract = FlowEVMBridgedERC721(deployedERC721Address);
    }

    function test_RegistryIsNonZero() public view {
        address registryAddress = factory.getRegistry();
        assertNotEq(registryAddress, address(0));
    }

    function test_GetERC20Deployer() public view {
        address erc20DeployerAddress = factory.getDeployer("ERC20");
        assertEq(erc20DeployerAddress, address(erc20Deployer));
    }

    function test_GetERC721Deployer() public view {
        address erc721DeployerAddress = factory.getDeployer("ERC721");
        assertEq(erc721DeployerAddress, address(erc721Deployer));
    }

    function test_DeployERC721() public view {
        bool isBridgeDeployed = factory.isBridgeDeployed(deployedERC721Address);
        assertEq(isBridgeDeployed, true);
    }

    function test_IsERC721True() public view {
        bool isERC721 = factory.isERC721(deployedERC721Address);
        assertEq(isERC721, true);
    }

    function test_IsERC721False() public view {
        bool isERC721 = factory.isERC721(deployedERC20Address);
        assertEq(isERC721, false);
    }

    function test_DeployERC20() public view {
        bool isBridgeDeployed = factory.isBridgeDeployed(deployedERC20Address);
        assertEq(isBridgeDeployed, true);
    }

    function test_IsERC20True() public view {
        bool isERC20 = factory.isERC20(deployedERC20Address);
        assertEq(isERC20, true);
    }

    function test_IsERC20False() public view {
        bool isERC20 = factory.isERC20(deployedERC721Address);
        assertEq(isERC20, false);
    }

    function test_ValidateDeployedERC721Address() public view {
        string memory _name = deployedERC721Contract.name();
        string memory _symbol = deployedERC721Contract.symbol();
        string memory _cadenceNFTAddress = deployedERC721Contract.getCadenceAddress();
        string memory _cadenceNFTIdentifier = deployedERC721Contract.getCadenceIdentifier();
        string memory _contractURI = deployedERC721Contract.contractURI();

        assertEq(_name, name);
        assertEq(_symbol, symbol);
        assertEq(_cadenceNFTAddress, cadenceNFTAddress);
        assertEq(_cadenceNFTIdentifier, cadenceNFTIdentifier);
        assertEq(_contractURI, contractURI);

        address factoryOwner = factory.owner();
        address erc721Owner = deployedERC721Contract.owner();
        assertEq(factoryOwner, erc721Owner);
    }

    function test_ValidateDeployedERC20Address() public view {
        string memory _name = deployedERC20Contract.name();
        string memory _symbol = deployedERC20Contract.symbol();
        string memory _cadenceTokenAddress = deployedERC20Contract.getCadenceAddress();
        string memory _cadenceTokenIdentifier = deployedERC20Contract.getCadenceIdentifier();
        string memory _contractURI = deployedERC20Contract.contractURI();

        assertEq(_name, name);
        assertEq(_symbol, symbol);
        assertEq(_cadenceTokenAddress, cadenceTokenAddress);
        assertEq(_cadenceTokenIdentifier, cadenceTokenIdentifier);
        assertEq(_contractURI, contractURI);

        address factoryOwner = factory.owner();
        address erc20Owner = deployedERC20Contract.owner();
        assertEq(factoryOwner, erc20Owner);
    }

    function test_MintERC721() public {
        address recipient = address(27);
        uint256 tokenId = 42;
        string memory uri = "MOCK_URI";
        deployedERC721Contract.safeMint(recipient, tokenId, uri);

        address owner = deployedERC721Contract.ownerOf(tokenId);
        assertEq(owner, recipient);
    }

    function test_MintERC20() public {
        address recipient = address(27);
        uint256 amount = 100e18;
        deployedERC20Contract.mint(recipient, amount);

        uint256 balance = deployedERC20Contract.balanceOf(recipient);
        assertEq(balance, amount);
    }

    function test_UpdateERC721Symbol() public {
        string memory _symbol = deployedERC721Contract.symbol();
        assertEq(_symbol, symbol);

        string memory newSymbol = "NEW_SYMBOL";
        deployedERC721Contract.setSymbol(newSymbol);

        _symbol = deployedERC721Contract.symbol();
        assertEq(_symbol, newSymbol);
    }

    function test_UpdateERC20Symbol() public {
        string memory _symbol = deployedERC20Contract.symbol();
        assertEq(_symbol, symbol);

        string memory newSymbol = "NEW_SYMBOL";
        deployedERC20Contract.setSymbol(newSymbol);

        _symbol = deployedERC20Contract.symbol();
        assertEq(_symbol, newSymbol);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/flow-token/dynamic_vm_transfer.cdc

```
import "FlowStorageFees"
import "FungibleToken"
import "FlowToken"

import "EVM"

// Transfers $FLOW from the signer's account to the recipient's address, determining the target VM based on the format
// of the recipient's hex address. Note that the sender's funds are sourced by default from the target VM, pulling any
// difference from the alternate VM if available. e.g. Transfers to Flow addresses will first attempt to withdraw from
// the signer's Flow vault, pulling any remaining funds from the signer's EVM account if available. Transfers to EVM
// addresses will first attempt to withdraw from the signer's EVM account, pulling any remaining funds from the signer's
// Flow vault if available. If the signer's balance across both VMs is insufficient, the transaction will revert.
///
/// @param addressString: The recipient's address in hex format - this should be either an EVM address or a Flow address
/// @param amount: The amount of $FLOW to transfer as a UFix64 value
///
transaction(addressString: String, amount: UFix64) {

    let sentVault: @FlowToken.Vault
    let evmRecipient: EVM.EVMAddress?
    var receiver: &{FungibleToken.Receiver}?

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        // Reference signer's COA if one exists
        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: /storage/evm)

        // Reference signer's FlowToken Vault
        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow signer's FlowToken.Vault")
        // Ensure we don't withdraw more than required for storage
        let cadenceBalance = FlowStorageFees.defaultTokenAvailableBalance(signer.address)

        // Define optional recipients for both VMs
        self.receiver = nil
        let cadenceRecipient = Address.fromString(addressString)
        self.evmRecipient = cadenceRecipient == nil ? EVM.addressFromString(addressString) : nil
        // Validate exactly one target address is assigned
        if cadenceRecipient != nil && self.evmRecipient != nil {
            panic("Malformed recipient address - assignable as both Cadence and EVM addresses")
        } else if cadenceRecipient == nil && self.evmRecipient == nil {
            panic("Malformed recipient address - not assignable as either Cadence or EVM address")
        }

        // Create empty FLOW vault to capture funds
        self.sentVault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())
        /// If the target VM is Flow, does the Vault have sufficient balance to cover?
        if cadenceRecipient != nil {
            // Assign the Receiver of the $FLOW transfer
            self.receiver = getAccount(cadenceRecipient!).capabilities.borrow<&{FungibleToken.Receiver}>(
                    /public/flowTokenReceiver
                ) ?? panic("Could not borrow reference to recipient's FungibleToken.Receiver")

            // Withdraw from the signer's Cadence Vault and deposit to sentVault
            var withdrawAmount = amount < cadenceBalance ? amount : cadenceBalance
            self.sentVault.deposit(from: <-sourceVault.withdraw(amount: withdrawAmount))

            // If the cadence balance didn't cover the amount, check the signer's EVM balance
            if amount > self.sentVault.balance {
                let difference = amount - cadenceBalance
                // Revert if the signer doesn't have an EVM account or EVM balance is insufficient
                if coa == nil || difference > coa!.balance().inFLOW() {
                    panic("Insufficient balance across Flow and EVM accounts")
                }

                // Withdraw from the signer's EVM account and deposit to sentVault
                let withdrawFromEVM = EVM.Balance(attoflow: 0)
                withdrawFromEVM.setFLOW(flow: difference)
                self.sentVault.deposit(from: <-coa!.withdraw(balance: withdrawFromEVM))
            }
        } else if self.evmRecipient != nil {
            // Check signer's balance can cover the amount
            if coa != nil {
                // Determine the amount to withdraw from the signer's EVM account
                let balance = coa!.balance()
                let withdrawAmount = amount < balance.inFLOW() ? amount : balance.inFLOW()
                balance.setFLOW(flow: withdrawAmount)

                // Withdraw funds from EVM to the sentVault
                self.sentVault.deposit(from: <-coa!.withdraw(balance: balance))
            }
            if amount > self.sentVault.balance {
                // Insufficient amount withdrawn from EVM, check signer's Flow balance
                let difference = amount - self.sentVault.balance
                if difference > cadenceBalance {
                    panic("Insufficient balance across Flow and EVM accounts")
                }
                // Withdraw from the signer's Cadence Vault and deposit to sentVault
                self.sentVault.deposit(from: <-sourceVault.withdraw(amount: difference))
            }
        }
    }

    pre {
        self.sentVault.balance == amount: "Attempting to send an incorrect amount of $FLOW"
    }

    execute {
        // Complete Cadence transfer if the FungibleToken Receiver is assigned
        if self.receiver != nil {
            self.receiver!.deposit(from: <-self.sentVault)
        } else {
            // Otherwise, complete EVM transfer
            self.evmRecipient!.deposit(from: <-self.sentVault)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/example-assets/ExampleNFT.cdc

```
/* 
*
*  This is an example implementation of a Flow Non-Fungible Token
*  using the V2 standard.
*  It is not part of the official standard but it assumed to be
*  similar to how many NFTs would implement the core functionality.
*
*  This contract does not implement any sophisticated classification
*  system for its NFTs. It defines a simple NFT with minimal metadata.
*   
*/

import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

access(all) contract ExampleNFT: NonFungibleToken {

    /// Path where the minter should be stored
    /// The standard paths for the collection are stored in the collection resource type
    access(all) let MinterStoragePath: StoragePath

    /// We choose the name NFT here, but this type can have any name now
    /// because the interface does not require it to have a specific name any more
    access(all) resource NFT: NonFungibleToken.NFT, ViewResolver.Resolver {

        access(all) let id: UInt64

        /// From the Display metadata view
        access(all) let name: String
        access(all) let description: String
        access(all) let thumbnail: String

        /// For the Royalties metadata view
        access(self) let royalties: [MetadataViews.Royalty]

        /// Generic dictionary of traits the NFT has
        access(self) let metadata: {String: AnyStruct}
    
        init(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
        ) {
            self.id = self.uuid
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.royalties = royalties
            self.metadata = metadata
        }

        /// createEmptyCollection creates an empty Collection
        /// and returns it to the caller so that they can own NFTs
        /// @{NonFungibleToken.Collection}
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }
    
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Example NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://example-nft.onflow.org/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return ExampleNFT.resolveContractView(resourceType: Type<@ExampleNFT.NFT>(), viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    // foo is a trait with its own rarity
                    let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
                    let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
                    traitsView.addTrait(fooTrait)
                    
                    return traitsView
            }
            return nil
        }
    }

    access(all) resource Collection: NonFungibleToken.Collection {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an `UInt64` ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        access(all) var storagePath: StoragePath
        access(all) var publicPath: PublicPath

        init () {
            self.ownedNFTs <- {}
            let identifier = "cadenceExampleNFTCollection"
            self.storagePath = StoragePath(identifier: identifier)!
            self.publicPath = PublicPath(identifier: identifier)!
        }

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@ExampleNFT.NFT>()] = true
            return supportedTypes
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           if type == Type<@ExampleNFT.NFT>() {
            return true
           } else {
            return false
           }
        }

        /// withdraw removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @ExampleNFT.NFT

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken
        }

        /// getIDs returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return (&self.ownedNFTs[id] as &{NonFungibleToken.NFT}?)
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: /storage/cadenceExampleNFTCollection,
                    publicPath: /public/cadenceExampleNFTCollection,
                    publicCollection: Type<&ExampleNFT.Collection>(),
                    publicLinkedType: Type<&ExampleNFT.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://example-nft.onflow.org"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
        }
        return nil
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    access(all) resource NFTMinter {

        /// mintNFT mints a new NFT with a new ID
        /// and returns it to the calling context
        access(all) fun mintNFT(
            name: String,
            description: String,
            thumbnail: String,
            royalties: [MetadataViews.Royalty]
        ): @ExampleNFT.NFT {

            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp

            // this piece of metadata will be used to show embedding rarity into a trait
            metadata["foo"] = "bar"

            // create a new NFT
            var newNFT <- create NFT(
                name: name,
                description: description,
                thumbnail: thumbnail,
                royalties: royalties,
                metadata: metadata,
            )

            return <-newNFT
        }
    }

    init() {

        // Set the named paths
        self.MinterStoragePath = /storage/cadenceExampleNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        let defaultStoragePath = collection.storagePath
        let defaultPublicPath = collection.publicPath
        self.account.storage.save(<-collection, to: defaultStoragePath)

        // create a public capability for the collection
        let collectionCap = self.account.capabilities.storage.issue<&ExampleNFT.Collection>(defaultStoragePath)
        self.account.capabilities.publish(collectionCap, at: defaultPublicPath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.storage.save(<-minter, to: self.MinterStoragePath)
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/FlowEVMBridgedERC721Deployer.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IFlowEVMBridgeDeployer} from "./interfaces/IFlowEVMBridgeDeployer.sol";
import {FlowEVMBridgedERC721} from "./templates/FlowEVMBridgedERC721.sol";

/**
 * @title FlowEVMBridgedERC721Deployer
 * @dev A contract to deploy FlowEVMBridgedERC721 contracts with named associations to Cadence resource types. Only the
 * delegated deployer can deploy new contracts. This contract is used by the Flow EVM bridge to deploy and define
 * bridged ERC721 tokens which are defined natively in Cadence.
 */
contract FlowEVMBridgedERC721Deployer is ERC165, IFlowEVMBridgeDeployer, Ownable {
    // The address of the delegated deployer who can deploy new contracts
    address public delegatedDeployer;

    constructor() Ownable(msg.sender) {}

    /**
     * @dev Modifier to check if the caller is the delegated deployer
     */
    modifier onlyDelegatedDeployer() {
        require(msg.sender == delegatedDeployer, "FlowEVMBridgedERC721Deployer: Only delegated deployer can deploy");
        _;
    }

    /**
     * @dev ERC165 introspection
     */
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool) {
        return interfaceId == type(IFlowEVMBridgeDeployer).interfaceId || interfaceId == type(Ownable).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Deploy a new FlowEVMBridgedERC721 contract with the given name, symbol, and association to a Cadence
     * contract.
     *
     * @param name The name of the ERC721
     * @param symbol The symbol of the ERC721
     * @param cadenceAddress The address of the associated Cadence contract
     * @param cadenceIdentifier The identifier of the associated Cadence asset type
     * @param contractURI The URI of the contract metadata
     *
     * @return The address of the deployed EVM contract
     */
    function deploy(
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) external onlyDelegatedDeployer returns (address) {
        FlowEVMBridgedERC721 newERC721 =
            new FlowEVMBridgedERC721(owner(), name, symbol, cadenceAddress, cadenceIdentifier, contractURI);

        emit Deployed(address(newERC721), name, symbol, cadenceAddress, cadenceIdentifier);

        return address(newERC721);
    }

    /**
     * @dev Set the address of the delegated deployer
     *
     * @param _delegatedDeployer The address of the delegated deployer
     */
    function setDelegatedDeployer(address _delegatedDeployer) external onlyOwner {
        require(_delegatedDeployer != address(0), "FlowEVMBridgedERC721Deployer: Invalid delegated deployer address");
        delegatedDeployer = _delegatedDeployer;

        emit DeployerAuthorized(_delegatedDeployer);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/IFlowEVMDeploymentRegistry.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

/**
 * @title IFlowEVMDeploymentRegistry
 * @dev Interface for the FlowEVMDeploymentRegistry contract, intended to be used for contracts that need to manage
 * associations between Flow EVM contracts and Cadence contracts.
 */
interface IFlowEVMDeploymentRegistry is IERC165 {
    /**
     * @dev Event emitted when a new entity is authorized to register deployments
     */
    event RegistrarAuthorized(address indexed registrar);

    /**
     * @dev Event emitted when a new deployment is registered
     */
    event DeploymentRegistered(address indexed contractAddr, string cadenceIdentifier);

    /**
     * @dev Get the Cadence type identifier associated with a contract address
     */
    function getCadenceIdentifier(address contractAddr) external view returns (string memory);

    /**
     * @dev Get the contract address associated with a Cadence type identifier
     */
    function getContractAddress(string memory cadenceIdentifier) external view returns (address);

    /**
     * @dev Check if a contract address is associated with a Cadence type identifier
     */
    function isRegisteredDeployment(address contractAddr) external view returns (bool);

    /**
     * @dev Check if a Cadence type identifier is associated with a contract address
     */
    function isRegisteredDeployment(string memory cadenceIdentifier) external view returns (bool);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/.github/ISSUE_TEMPLATE/bug-report.md

---
name: Reporting a Problem/Bug
about: Reporting a Problem/Bug
title: ''
labels: bug, Feedback
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Problem

<what is the problem you've encountered?> 

### Steps to Reproduce 

<share any logs/screenshots or steps to replicate>

### Acceptance Criteria

<if any>
  
### Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/deploy_bridge_utils.cdc

```
transaction(name: String, code: String, factoryAddress: String) {
  prepare(signer: auth(AddContract) &Account) {
    signer.contracts.add(name: name, code: code.utf8, bridgeFactoryAddressHex: factoryAddress)
  }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/unwrap_flow.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

import "FlowEVMBridgeUtils"

/// This transactions wraps FLOW tokens as WFLOW tokens, using the signing COA's EVM FLOW balance primarily. If the
/// EVM balance is insufficient, the transaction will transfer FLOW from the Cadence balance to the EVM balance.
///
/// @param wflowContractHex: The EVM address of the WFLOW contract as a hex string
/// @param amount: The amount of FLOW to wrap as WFLOW
///
transaction(wflowContractHex: String, amount: UInt256) {

    let wflowAddress: EVM.EVMAddress
    let preBalance: UInt
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postBalance: UInt

    prepare(signer: auth(BorrowValue) &Account) {
        self.wflowAddress = EVM.addressFromString(wflowContractHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        self.preBalance = UInt(FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.wflowAddress))
        assert(
            self.preBalance >= UInt(amount),
            message: "Amount exceeds current WFLOW balance of ".concat(self.preBalance.toString())
        )
        self.postBalance = 0
    }

    execute {
        // Encode the withdraw function call
        let calldata = EVM.encodeABIWithSignature("withdraw(uint256)", [UInt(amount)])
        // Define the value to send to the WFLOW contract - 0 to unwrap
        let value = EVM.Balance(attoflow: 0)
        // Call the WFLOW contract which should complete the unwrap
        let result = self.coa.call(
            to: self.wflowAddress,
            data: calldata,
            gasLimit: 15_000_000,
            value: value
        )
        assert(result.status == EVM.Status.successful, message: "Failed to unwrap FLOW as WFLOW")
        self.postBalance = UInt(FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.wflowAddress))
    }

    post {
        self.postBalance == self.preBalance - UInt(amount):
        "Incorrect post balance - expected=".concat((self.preBalance - UInt(amount)).toString())
        .concat(" | actual=").concat(self.postBalance.toString())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/evm/get_evm_address_string_from_bytes.cdc

```
import "EVM"

/// Converts EVM address bytes into to a hex string
///
access(all) fun main(bytes: [UInt8]): String? {
    let constBytes = bytes.toConstantSized<[UInt8; 20]>()
        ?? panic("Problem converting provided EVMAddress compatible byte array - check byte array contains 20 bytes")
    return EVM.EVMAddress(bytes: constBytes).toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/call.cdc

```
import "EVM"

/// Executes the calldata from the signer's COA
///
transaction(evmContractAddressHex: String, calldata: String, gasLimit: UInt64, value: UFix64) {

    let evmAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue) &Account) {
        self.evmAddress = EVM.addressFromString(evmContractAddressHex)

        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
    }

    execute {
        let valueBalance = EVM.Balance(attoflow: 0)
        valueBalance.setFLOW(flow: value)
        let callResult = self.coa.call(
            to: self.evmAddress,
            data: calldata.decodeHex(),
            gasLimit: gasLimit,
            value: valueBalance
        )
        assert(callResult.status == EVM.Status.successful, message: "Call failed")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm/add_deployer.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// This transaction adds the given EVM address as a deployer in the bridge factory contract, indexed on the
/// provided tag.
///
/// @param deployerTag: The tag to index the deployer with - e.g. ERC20, ERC721, etc.
/// @param deployerEVMAddressHex: The EVM address of the deployer contract as a hex string
///
transaction(deployerTag: String, deployerEVMAddressHex: String) {

    let targetDeployerEVMAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postDeployer: EVM.EVMAddress?

    prepare(signer: auth(BorrowValue) &Account) {
        self.targetDeployerEVMAddress = EVM.addressFromString(deployerEVMAddressHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        self.postDeployer = nil
    }

    execute {
        // Execute the call
        let callResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature(
                "addDeployer(string,address)",
                [deployerTag, self.targetDeployerEVMAddress]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Failed to add deployer")

        // Confirm the deployer was added under the tag
        let postDeployerResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature(
                "getDeployer(string)",
                [deployerTag]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(postDeployerResult.status == EVM.Status.successful, message: "Failed to get deployer")

        let decodedResult = EVM.decodeABI(
                types: [Type<EVM.EVMAddress>()],
                data: postDeployerResult.data
            )
        assert(decodedResult.length == 1, message: "Invalid response from getDeployer call")
        self.postDeployer = decodedResult[0] as! EVM.EVMAddress
    }

    post {
        self.postDeployer!.equals(self.targetDeployerEVMAddress): "Deployer was not properly configured"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/token_uri.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Returns the tokenURI of the given tokenID from the given EVM contract address
///
/// @param contractAddressHex: The hex string of the contract address of the ERC721 token
/// @param tokenID: The ID of the ERC721 token
///
/// @return The tokenURI of the given tokenID from the given EVM contract address. Reverts if the call is unsuccessful
///
access(all) fun main(contractAddressHex: String, tokenID: UInt256): String? {
    return FlowEVMBridgeUtils.getTokenURI(
        evmContractAddress: EVM.addressFromString(contractAddressHex),
        id: tokenID
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/batch_get_associated_type.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns a mapping of Cadence Type associated with the given EVM addresses (as hex Strings)
///
/// @param evmAddresses: An array hex-encoded addresses of the EVM contract as a Strings
///
/// @return The Cadence Types associated with indexed EVM address or nil if the address is not onboarded. `nil` may
///        also be returned if the address is not a valid EVM address.
///
access(all)
fun main(addressHex: [String]): {String: Type?} {
    let res: {String: Type?} = {}
    for hex in addressHex {
        // skip if already processed
        if res[hex] != nil {
            continue
        }

        let address = EVM.addressFromString(hex)
        let type = FlowEVMBridgeConfig.getTypeAssociated(with: address)

        res.insert(key: hex, type)
    }
    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/mainnet/EVMBridgedTokenTemplate.cdc

```
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61

import EVM from 0xe467b9dd11fa00df

import ICrossVM from 0x1e4aa0b87d10b141
import ICrossVMAsset from 0x1e4aa0b87d10b141
import IEVMBridgeTokenMinter from 0x1e4aa0b87d10b141
import FlowEVMBridgeTokenEscrow from 0x1e4aa0b87d10b141
import FlowEVMBridgeConfig from 0x1e4aa0b87d10b141
import FlowEVMBridgeUtils from 0x1e4aa0b87d10b141
import FlowEVMBridge from 0x1e4aa0b87d10b141
import CrossVMToken from 0x1e4aa0b87d10b141
import FlowEVMBridgeResolver from 0x1e4aa0b87d10b141

/// This contract is a template used by FlowEVMBridge to define EVM-native fungible tokens bridged from Flow EVM to 
/// Cadence. Upon deployment of this contract, the contract name is derived as a function of the asset type (here an 
/// ERC20) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC20 is transferred to the bridge's CadenceOwnedAccount EVM address and tokens are minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is burned
/// in this contract and the ERC20 is transferred to the defined recipient. In this way, the Cadence Vault acts as a
/// representation of both the EVM tokens and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeTokenMinter, FungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmTokenContractAddress: EVM.EVMAddress
    /// Name of the fungible token defined in the corresponding ERC20 contract
    access(all) let name: String
    /// Symbol of the fungible token defined in the corresponding ERC20 contract
    access(all) let symbol: String
    /// Decimal place value defined in the source ERC20 contract
    access(all) let decimals: UInt8
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Total supply of this Cadence token in circulation
    /// NOTE: This does not reflect the total supply of the source ERC20 in circulation within EVM
    access(all) var totalSupply: UFix64
    /// Retain a Vault to reference when resolving Vault Metadata
    access(self) let vault: @Vault

    /// The Vault resource representing the bridged ERC20 token
    ///
    access(all) resource Vault : ICrossVMAsset.AssetInfo, CrossVMToken.EVMTokenInfo, FungibleToken.Vault {
        /// Balance of the tokens in a given Vault
        access(all) var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        /* --- CrossVMToken.EVMFTVault conformance --- */
        //
        /// Gets the ERC20 name value
        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8 {
            return {{CONTRACT_NAME}}.decimals
        }
        /// Returns the EVM contract address of the fungible token
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }

        access(all) view fun getViews(): [Type] {
            return {{CONTRACT_NAME}}.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return {{CONTRACT_NAME}}.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return { self.getType(): true }
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @Vault {
            return <-create Vault(balance: 0.0)
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                {{CONTRACT_NAME}}.totalSupply = {{CONTRACT_NAME}}.totalSupply - self.balance
            }
            self.balance = 0.0
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero and returns it to the calling context. A user must call
    /// this function and store the returned Vault in their storage in order to allow their account to be able to
    /// receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{{CONTRACT_NAME}}.Vault {
        return <- create Vault(balance: 0.0)
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the fungible token this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmTokenContractAddress
    }

    /// Function that returns all the Metadata Views implemented by this fungible token contract.
    ///
    /// @return An array of Types defining the implemented views. This value will be used by developers to know which
    ///         parameter to pass to the resolveContractView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    ///
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let contractRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<FungibleTokenMetadataViews.FTDisplay>())
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/{{CONTRACT_NAME}}Vault,
                    receiverPath: /public/{{CONTRACT_NAME}}Receiver,
                    metadataPath: /public/{{CONTRACT_NAME}}Vault,
                    receiverLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    metadataLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-self.createEmptyVault(vaultType: Type<@{{CONTRACT_NAME}}.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: self.totalSupply
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint tokens from bridge-defined fungible token contracts
    ///
    access(account) fun mintTokens(amount: UFix64): @{FungibleToken.Vault} {
        self.totalSupply = self.totalSupply + amount
        return <- create Vault(balance: amount)
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, decimals: UInt8, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmTokenContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.contractURI = contractURI
        self.totalSupply = 0.0
        self.vault <- create Vault(balance: 0.0)

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.Vault>(), with: self.evmTokenContractAddress)
        FlowEVMBridgeTokenEscrow.initializeEscrow(
            with: <-create Vault(balance: 0.0),
            name: name,
            symbol: symbol,
            decimals: decimals,
            evmTokenAddress: self.evmTokenContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-nft/setup_collection.cdc

```
/// This transaction is what an account would run
/// to set itself up to receive NFTs

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"

transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        let collectionData = ExampleNFT.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("ExampleNFT did not resolve NFTCollectionData view")
        // Return early if the account already has a collection
        if signer.storage.borrow<&ExampleNFT.Collection>(from: collectionData.storagePath) != nil {
            return
        }

        // Create a new empty collection
        let collection <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())

        // save it to the account
        signer.storage.save(<-collection, to: collectionData.storagePath)

        // create a public capability for the collection
        signer.capabilities.unpublish(collectionData.publicPath)
        let collectionCap = signer.capabilities.storage.issue<&ExampleNFT.Collection>(collectionData.storagePath)
        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/uint256_to_ufix64.cdc

```
import "FlowEVMBridgeUtils"

access(all)
fun main(value: UInt256, decimals: UInt8): UFix64 {
    return FlowEVMBridgeUtils.uint256ToUFix64(value: value, decimals: decimals)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/CrossVMToken.cdc

```
import "FungibleToken"

import "EVM"

/// Contract defining cross-VM Fungible Token Vault interface
///
access(all) contract CrossVMToken {

    /// Interface for a Fungible Token Vault with a corresponding ERC20 contract on EVM
    access(all) resource interface EVMTokenInfo {
        /// Gets the ERC20 name value
        access(all) view fun getName(): String
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8
        /// Get the EVM contract address of the corresponding ERC20 contract address
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/get_block_height.cdc

```
access(all)
fun main(): UInt64 {
    return getCurrentBlock().height
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/flow-token/transfer_flow_to_cadence_or_evm.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

// Transfers $FLOW from the signer's account to the recipient's address, determining the target VM based on the format
// of the recipient's hex address.
///
/// @param addressString: The recipient's address in hex format - this should be either an EVM address or a Flow address
/// @param amount: The amount of $FLOW to transfer as a UFix64 value
///
transaction(addressString: String, amount: UFix64) {

    let sentVault: @FlowToken.Vault
    let evmRecipient: EVM.EVMAddress?
    var receiver: &{FungibleToken.Receiver}?
    
    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        // Reference signer's FlowToken Vault
        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow signer's FlowToken.Vault")
        
        // Init receiver as nil
        self.receiver = nil
        // Ensure address is prefixed with '0x'
        let withPrefix = addressString.slice(from: 0, upTo: 2) == "0x" ? addressString : "0x".concat(addressString)
        // Attempt to parse address as Cadence or EVM address
        let cadenceRecipient = withPrefix.length < 40 ? Address.fromString(withPrefix) : nil
        self.evmRecipient = cadenceRecipient == nil ? EVM.addressFromString(withPrefix) : nil

        // Validate exactly one target address is assigned
        if cadenceRecipient != nil && self.evmRecipient != nil {
            panic("Malformed recipient address - assignable as both Cadence and EVM addresses")
        } else if cadenceRecipient == nil && self.evmRecipient == nil {
            panic("Malformed recipient address - not assignable as either Cadence or EVM address")
        }

        if cadenceRecipient != nil {
            // Assign FungibleToken Receiver if recipient is a Cadence address
            self.receiver = getAccount(cadenceRecipient!).capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
                ?? panic("Could not borrow FungibleToken Receiver from recipient")
        }

        // Create empty FLOW vault to capture funds
        self.sentVault <- sourceVault.withdraw(amount: amount) as! @FlowToken.Vault
    }

    pre {
        self.receiver != nil || self.evmRecipient != nil: "Could not assign a recipient for the transfer"
        self.sentVault.balance == amount: "Attempting to send an incorrect amount of $FLOW"
    }

    execute {
        // Complete Cadence transfer if the FungibleToken Receiver is assigned
        if self.receiver != nil {
            self.receiver!.deposit(from: <-self.sentVault)
        } else {
            // Otherwise, complete EVM transfer
            self.evmRecipient!.deposit(from: <-self.sentVault)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/emulator/EVMBridgedTokenTemplate.cdc

```
import NonFungibleToken from 0xf8d6e0586b0a20c7
import MetadataViews from 0xf8d6e0586b0a20c7
import FungibleTokenMetadataViews from 0xee82856bf20e2aa6
import ViewResolver from 0xf8d6e0586b0a20c7
import FungibleToken from 0xee82856bf20e2aa6
import FlowToken from 0x0ae53cb6e3f42a79

import EVM from 0xf8d6e0586b0a20c7

import ICrossVM from 0xf8d6e0586b0a20c7
import ICrossVMAsset from 0xf8d6e0586b0a20c7
import IEVMBridgeTokenMinter from 0xf8d6e0586b0a20c7
import FlowEVMBridgeTokenEscrow from 0xf8d6e0586b0a20c7
import FlowEVMBridgeConfig from 0xf8d6e0586b0a20c7
import FlowEVMBridgeUtils from 0xf8d6e0586b0a20c7
import FlowEVMBridge from 0xf8d6e0586b0a20c7
import CrossVMToken from 0xf8d6e0586b0a20c7
import FlowEVMBridgeResolver from 0xf8d6e0586b0a20c7

/// This contract is a template used by FlowEVMBridge to define EVM-native fungible tokens bridged from Flow EVM to 
/// Cadence. Upon deployment of this contract, the contract name is derived as a function of the asset type (here an 
/// ERC20) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC20 is transferred to the bridge's CadenceOwnedAccount EVM address and tokens are minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is burned
/// in this contract and the ERC20 is transferred to the defined recipient. In this way, the Cadence Vault acts as a
/// representation of both the EVM tokens and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeTokenMinter, FungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmTokenContractAddress: EVM.EVMAddress
    /// Name of the fungible token defined in the corresponding ERC20 contract
    access(all) let name: String
    /// Symbol of the fungible token defined in the corresponding ERC20 contract
    access(all) let symbol: String
    /// Decimal place value defined in the source ERC20 contract
    access(all) let decimals: UInt8
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Total supply of this Cadence token in circulation
    /// NOTE: This does not reflect the total supply of the source ERC20 in circulation within EVM
    access(all) var totalSupply: UFix64
    /// Retain a Vault to reference when resolving Vault Metadata
    access(self) let vault: @Vault

    /// The Vault resource representing the bridged ERC20 token
    ///
    access(all) resource Vault : ICrossVMAsset.AssetInfo, CrossVMToken.EVMTokenInfo, FungibleToken.Vault {
        /// Balance of the tokens in a given Vault
        access(all) var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        /* --- CrossVMToken.EVMFTVault conformance --- */
        //
        /// Gets the ERC20 name value
        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8 {
            return {{CONTRACT_NAME}}.decimals
        }
        /// Returns the EVM contract address of the fungible token
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }

        access(all) view fun getViews(): [Type] {
            return {{CONTRACT_NAME}}.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return {{CONTRACT_NAME}}.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return { self.getType(): true }
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @Vault {
            return <-create Vault(balance: 0.0)
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                {{CONTRACT_NAME}}.totalSupply = {{CONTRACT_NAME}}.totalSupply - self.balance
            }
            self.balance = 0.0
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero and returns it to the calling context. A user must call
    /// this function and store the returned Vault in their storage in order to allow their account to be able to
    /// receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{{CONTRACT_NAME}}.Vault {
        return <- create Vault(balance: 0.0)
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the fungible token this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmTokenContractAddress
    }

    /// Function that returns all the Metadata Views implemented by this fungible token contract.
    ///
    /// @return An array of Types defining the implemented views. This value will be used by developers to know which
    ///         parameter to pass to the resolveContractView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    ///
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let contractRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<FungibleTokenMetadataViews.FTDisplay>())
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/{{CONTRACT_NAME}}Vault,
                    receiverPath: /public/{{CONTRACT_NAME}}Receiver,
                    metadataPath: /public/{{CONTRACT_NAME}}Vault,
                    receiverLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    metadataLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-self.createEmptyVault(vaultType: Type<@{{CONTRACT_NAME}}.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: self.totalSupply
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint tokens from bridge-defined fungible token contracts
    ///
    access(account) fun mintTokens(amount: UFix64): @{FungibleToken.Vault} {
        self.totalSupply = self.totalSupply + amount
        return <- create Vault(balance: amount)
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, decimals: UInt8, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmTokenContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.contractURI = contractURI
        self.totalSupply = 0.0
        self.vault <- create Vault(balance: 0.0)

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.Vault>(), with: self.evmTokenContractAddress)
        FlowEVMBridgeTokenEscrow.initializeEscrow(
            with: <-create Vault(balance: 0.0),
            name: name,
            symbol: symbol,
            decimals: decimals,
            evmTokenAddress: self.evmTokenContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/get_deployer_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

access(all)
fun main(coaHost: Address, deployerTag: String): String {
    let coa = getAuthAccount<auth(BorrowValue) &Account>(coaHost)
        .storage
        .borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
        ?? panic("Could not borrow CadenceOwnedAccount from host=".concat(coaHost.toString()))
    let res = coa.call(
        to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
        data: EVM.encodeABIWithSignature("getDeployer(string)", [deployerTag]),
        gasLimit: FlowEVMBridgeConfig.gasLimit,
        value: EVM.Balance(attoflow: UInt(0))
    )

    assert(
        res.status == EVM.Status.successful,
        message: "getRegistry call to FlowEVMBridgeFactory failed"
    )

    let decodedRes = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data) 

    assert(decodedRes.length == 1, message: "Invalid response length")

    return (decodedRes[0] as! EVM.EVMAddress).toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeTemplates.cdc

```
import "FungibleToken"
import "NonFungibleToken"

import "EVM"

import "FlowEVMBridgeUtils"

/// This contract serves Cadence code from chunked templates, replacing the contract name with the name derived from
/// given arguments - either Cadence Type or EVM contract address.
///
access(all)
contract FlowEVMBridgeTemplates {

    /// Canonical path for the Admin resource
    access(all)
    let AdminStoragePath: StoragePath
    /// Chunked Hex-encoded Cadence contract code, to be joined on derived contract name
    access(self)
    let templateCodeChunks: {String: [[UInt8]]}

    /// Emitted whenever there is a change to templated code
    access(all)
    event Updated(name: String, isNew: Bool?)

    /**************
        Getters
     **************/

    /// Serves bridged asset contract code for a given type, deriving the contract name from the EVM contract info
    access(all)
    fun getBridgedAssetContractCode(_ cadenceContractName: String, isERC721: Bool): [UInt8]? {
        if isERC721 {
            return self.getBridgedNFTContractCode(contractName: cadenceContractName)
        } else {
            return self.getBridgedTokenContractCode(contractName: cadenceContractName)
        }
    }

    /**************
        Internal
     **************/

    access(self)
    fun getBridgedNFTContractCode(contractName: String): [UInt8]? {
        if let chunks = self.templateCodeChunks["bridgedNFT"] {
            return self.joinChunks(chunks, with: String.encodeHex(contractName.utf8))
        }
        return nil
    }

    access(self)
    fun getBridgedTokenContractCode(contractName: String): [UInt8]? {
        if let chunks = self.templateCodeChunks["bridgedToken"] {
            return self.joinChunks(chunks, with: String.encodeHex(contractName.utf8))
        }
        return nil
    }

    access(self)
    fun joinChunks(_ chunks: [[UInt8]], with name: String): [UInt8] {
        let nameBytes: [UInt8] = name.decodeHex()
        let code: [UInt8] = []
        for i, chunk in chunks {
            code.appendAll(chunk)
            // No need to append the contract name after the last chunk
            if i == chunks.length - 1 {
                break
            }
            code.appendAll(nameBytes)
        }
        return code
    }

    /************
        Admin
     ************/

    /// Resource enabling updates to the contract template code
    ///
    access(all)
    resource Admin {

        /// Adds a new template to the templateCodeChunks mapping, preventing overwrites of existing templates
        ///
        /// @param newTemplate: The name of the new template
        /// @param chunks: The chunks of hex-encoded Cadence contract code
        ///
        /// @emits Updated with the name of the template and `isNew` set to true by way of the pre-condition
        ///
        access(all)
        fun addNewContractCodeChunks(newTemplate: String, chunks: [String]) {
            pre {
                FlowEVMBridgeTemplates.templateCodeChunks[newTemplate] == nil: "Code already exists for template"
            }
            self.upsertContractCodeChunks(forTemplate: newTemplate, chunks: chunks)
        }

        /// Upserts the contract code chunks for a given template, overwriting the existing template if exists
        ///
        /// @param newTemplate: The name of the new template
        /// @param chunks: The chunks of hex-encoded Cadence contract code
        ///
        /// @emits Updated with the name of the template and a boolean indicating if it was a newly named
        ///     template or an existing one was overwritten
        ///
        access(all)
        fun upsertContractCodeChunks(forTemplate: String, chunks: [String]) {
            let byteChunks: [[UInt8]] = []
            for chunk in chunks {
                byteChunks.append(chunk.decodeHex())
            }

            let isNew = FlowEVMBridgeTemplates.templateCodeChunks[forTemplate] == nil
            emit Updated(name: forTemplate, isNew: isNew)

            FlowEVMBridgeTemplates.templateCodeChunks[forTemplate] = byteChunks
        }

        /// Removes the template from the templateCodeChunks mapping
        ///
        /// @param name: The name of the template to remove
        ///
        /// @return true if the template was removed, false if it did not exist
        ///
        /// @emits Updated with the name of the template and `isNew` set `nil`
        ///
        access(all)
        fun removeTemplate(name: String): Bool {
            if let removed = FlowEVMBridgeTemplates.templateCodeChunks.remove(key: name) {
                emit Updated(name: name, isNew: nil)
                return true
            }
            return false
        }
    }

    init() {
        self.AdminStoragePath = /storage/flowEVMBridgeTemplatesAdmin
        self.templateCodeChunks = {}

        self.account.storage.save(<-create Admin(), to: self.AdminStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/metadata/set_bridged_nft_collection_display_view.cdc

```
import "MetadataViews"

import "FlowEVMBridgeResolver"

/// This transaction sets the bridged NFTCollectionDisplay view for all NFTs bridged from Flow EVM
///
transaction(
    externalURL: String,
    squareImageURI: String,
    squareImageFileTypeIdentifier: String,
    squareImageIPFSFilePath: String?,
    squareImageMediaType: String,
    bannerImageURI: String,
    bannerImageFileTypeIdentifier: String,
    bannerImageIPFSFilePath: String?,
    bannerImageMediaType: String,
    socialsDict: {String: String}
) {

    let nftCollectionDisplay: MetadataViews.NFTCollectionDisplay
    let admin: auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // Build the square and banner image files
        let squareImageileType = CompositeType(squareImageFileTypeIdentifier)
            ?? panic("Invalid file type identifier=".concat(squareImageFileTypeIdentifier))
        let bannerImageFileType = CompositeType(bannerImageFileTypeIdentifier)
            ?? panic("Invalid file type identifier=".concat(bannerImageFileTypeIdentifier))
        let squareImageFile = FlowEVMBridgeResolver.buildFile(
                uri: squareImageURI,
                fileType: squareImageileType,
                ipfsFilePath: squareImageIPFSFilePath
            ) ?? panic("Failed to build square image file")
        let bannerImageFile = FlowEVMBridgeResolver.buildFile(
                uri: bannerImageURI,
                fileType: bannerImageFileType,
                ipfsFilePath: bannerImageIPFSFilePath
            ) ?? panic("Failed to build banner image file")
        // Build the socials dictionary
        let socials = FlowEVMBridgeResolver.buildExternalURLMapping(fromDict: socialsDict)
        // Build the NFTCollectionDisplay view
        self.nftCollectionDisplay = MetadataViews.NFTCollectionDisplay(
                name: "This name is replaced by a bridged NFT's collection name",
                description: "This description is replaced by a bridged NFT's collection description",
                externalURL: MetadataViews.ExternalURL(externalURL),
                squareImage: MetadataViews.Media(file: squareImageFile, mediaType: squareImageMediaType),
                bannerImage: MetadataViews.Media(file: bannerImageFile, mediaType: squareImageMediaType),
                socials: socials
            )

        // Borrow the Admin resource
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin>(
                from: FlowEVMBridgeResolver.AdminStoragePath
            ) ?? panic("Missing or mis-typed Admin resource")
    }

    execute {
        self.admin.setView(self.nftCollectionDisplay)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/get_vault_views.cdc

```
import "NonFungibleToken"

import "FlowEVMBridgeTokenEscrow"
import "FlowEVMBridge"

/// Returns the views supported by an escrowed FungibleToken Vault or nil if there is no Vault of the given type locked
/// in escrow
///
/// @param vaultTypeIdentifier: The type identifier of the NFT
///
/// @return The metadata view types supported by the escrowed FT Vault or nil if there is not Vault locked in escrow
///
access(all) fun main(vaultTypeIdentifier: String, id: UInt64): [Type]? {
    let type = CompositeType(vaultTypeIdentifier) ?? panic("Malformed Vault type identifier=".concat(vaultTypeIdentifier))
    return FlowEVMBridgeTokenEscrow.getViews(tokenType: type)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/evm/get_balance.cdc

```
import "EVM"

/// Returns the Flow balance of of a given EVM address in FlowEVM
///
access(all) fun main(address: String): UFix64 {
    return EVM.addressFromString(address).balance().inFLOW()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/transactions/add_contract.cdc

```
transaction(name: String, codeHex: String, arg0: AnyStruct, arg1: AnyStruct) {
    prepare(signer: auth(AddContract) &Account) {
        signer.contracts.add(name: name, code: codeHex.decodeHex(), arg0, arg1)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/transactions/add_key.cdc

```
transaction(pubKey: String) {
    prepare(signer: auth(AddKey) &Account)  {
        signer.keys.add(
            publicKey: PublicKey(
                publicKey: pubKey.decodeHex(),
                signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1
            ),
            hashAlgorithm: HashAlgorithm.SHA2_256,
            weight: 1000.0
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/deploy.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// Deploys a compiled solidity contract from bytecode to the EVM, with the signer's COA as the deployer
///
transaction(bytecode: String, gasLimit: UInt64, value: UFix64) {

    let coa: auth(EVM.Deploy) &EVM.CadenceOwnedAccount
    var sentVault: @FlowToken.Vault?

    prepare(signer: auth(BorrowValue) &Account) {

        let storagePath = StoragePath(identifier: "evm")!
        self.coa = signer.storage.borrow<auth(EVM.Deploy) &EVM.CadenceOwnedAccount>(from: storagePath)
            ?? panic("Could not borrow reference to the signer's bridged account")

        // Rebalance Flow across VMs if there is not enough Flow in the EVM account to cover the value
        let evmFlowBalance: UFix64 = self.coa.balance().inFLOW()
        if self.coa.balance().inFLOW() < value {
            let withdrawAmount: UFix64 = value - evmFlowBalance
            let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                    from: /storage/flowTokenVault
                ) ?? panic("Could not borrow reference to the owner's Vault!")

            self.sentVault <- vaultRef.withdraw(amount: withdrawAmount) as! @FlowToken.Vault
        } else {
            self.sentVault <- nil
        }
    }

    execute {

        // Deposit Flow into the EVM account if necessary otherwise destroy the sent Vault
        if self.sentVault != nil {
            self.coa.deposit(from: <-self.sentVault!)
        } else {
            destroy self.sentVault
        }

        let valueBalance = EVM.Balance(attoflow: 0)
        valueBalance.setFLOW(flow: value)
        // Finally deploy the contract
        let evmResult = self.coa.deploy(
           code: bytecode.decodeHex(),
           gasLimit: gasLimit,
           value: valueBalance
        )
        assert(
            evmResult.status == EVM.Status.successful && evmResult.deployedContract != nil,
            message: "EVM deployment failed with error code: ".concat(evmResult.errorCode.toString())
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/config/get_base_fee.cdc

```
import "FlowEVMBridgeConfig"

access(all) fun main(): UFix64 {
    return FlowEVMBridgeConfig.baseFee
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/metadata/set_bridged_nft_display_view.cdc

```
import "MetadataViews"

import "FlowEVMBridgeResolver"

/// This transaction sets the bridged NFT Display view for all NFTs bridged from Flow EVM
///
transaction(thumbnailURI: String, thumbnailFileTypeIdentifier: String, ipfsFilePath: String?) {

    let display: MetadataViews.Display
    let admin: auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // Determine the intended File type based on the provided file type identifier
        let thumbnailFileType = CompositeType(thumbnailFileTypeIdentifier)
            ?? panic("Invalid file type identifier=".concat(thumbnailFileTypeIdentifier))
        // Build the thumbnail file
        let thumbnailFile = FlowEVMBridgeResolver.buildFile(
                uri: thumbnailURI,
                fileType: thumbnailFileType,
                ipfsFilePath: ipfsFilePath
            ) ?? panic("Failed to build thumbnail file")
        // Build the NFT Display view
        self.display = MetadataViews.Display(
                name: "This name is replaced by a bridged NFT's name",
                description: "This description is replaced by a bridged NFT's collection description",
                thumbnail: thumbnailFile
            )

        // Borrow the Admin resource
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeResolver.Metadata) &FlowEVMBridgeResolver.Admin>(
                from: FlowEVMBridgeResolver.AdminStoragePath
            ) ?? panic("Missing or mis-typed Admin resource")
    }

    execute {
        self.admin.setView(self.display)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/safe_transfer_from_erc721.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Executes an NFT transfer to the defined recipient address against the specified ERC721 contract.
///
transaction(evmContractAddressHex: String, recipientAddressHex: String, id: UInt256) {
    
    let evmContractAddress: EVM.EVMAddress
    let recipientAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var senderOwnerCheck: Bool
    var recipientOwnerCheck: Bool
    
    prepare(signer: auth(BorrowValue) &Account) {
        self.evmContractAddress = EVM.addressFromString(evmContractAddressHex)
        self.recipientAddress = EVM.addressFromString(recipientAddressHex)

        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow CadenceOwnedAccount reference")

        self.senderOwnerCheck = FlowEVMBridgeUtils.isOwnerOrApproved(
                ofNFT: id,
                owner: self.coa.address(),
                evmContractAddress: self.evmContractAddress
            )
        self.recipientOwnerCheck = false
    }

    execute {
        let calldata = EVM.encodeABIWithSignature(
                "safeTransferFrom(address,address,uint256)",
                [self.coa.address(), self.recipientAddress, id]
            )
        let callResult = self.coa.call(
            to: self.evmContractAddress,
            data: calldata,
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC721 contract failed")
        self.recipientOwnerCheck = FlowEVMBridgeUtils.isOwnerOrApproved(
                ofNFT: id,
                owner: self.recipientAddress,
                evmContractAddress: self.evmContractAddress
            )
    }

    post {
        self.recipientOwnerCheck: "Recipient did not receive the token"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/is_cadence_type_blocked.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns whether a Cadence Type is blocked from onboarded to the FlowEVMBridge
///
/// @param typeIdentifier: The Cadence Type identifier of the asset in question
///
/// @return Whether the Cadence type is blocked from onboarding to the FlowEVMBridge
///
access(all) fun main(typeIdentifier: String): Bool {
    let type = CompositeType(typeIdentifier) ?? panic("Invalid type identifier ".concat(typeIdentifier))
    return FlowEVMBridgeConfig.isCadenceTypeBlocked(type)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/batch_bridge_nft_from_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges NFTs from EVM to Cadence assuming the NFT has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param ids: The ERC721 ids of the NFTs to bridge to Cadence from EVM
///
transaction(nftIdentifier: String, ids: [UInt256]) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                    .concat(collectionData.storagePath.toString()))

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Iterate over the provided ids
        for id in ids {
            // Execute the bridge
            let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
                type: self.nftType,
                id: id,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            // Ensure the bridged nft is the correct type
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Deposit the bridged NFT into the signer's collection
            self.collection.deposit(token: <-nft)
        }
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/fee/update_base_fee.cdc

```
import "FlowEVMBridgeConfig"

/// Sets the base fee charged for all bridge requests.
///
/// @param newFee: The new base fee to charge for all bridge requests.
///
/// @emits FlowEVMBridgeConfig.BridgeFeeUpdated(old: FlowEVMBridgeConfig.onboardFee, new: newFee, isOnboarding: false)
///
transaction(newFee: UFix64) {

    let admin: auth(FlowEVMBridgeConfig.Fee) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeConfig.Fee) &FlowEVMBridgeConfig.Admin>(
                from: FlowEVMBridgeConfig.adminStoragePath
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        self.admin.updateBaseFee(newFee)
    }

    post {
        FlowEVMBridgeConfig.baseFee == newFee: "Fee was not set correctly"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-handled-token/transfer_tokens.cdc

```
// This transaction is a template for a transaction that
// could be used by anyone to send ExampleTokens to another 
// account that has been set up to receive tokens.
//
// The withdraw amount and the account from getAccount
// would be the parameters to the transaction

import "FungibleToken"
import "ExampleHandledToken"
import "FungibleTokenMetadataViews"

transaction(amount: UFix64, to: Address) {

    /// FTVaultData metadata view for the token being used
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        self.vaultData = ExampleHandledToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("ViewResolver does not resolve FTVaultData view")

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleHandledToken.Vault>(from: self.vaultData.storagePath)
            ?? panic("Could not borrow reference to the owner's Vault!")

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)
            ?? panic("Could not borrow receiver reference to the recipient's Vault")

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/ICrossVMBridgeERC721Fulfillment.sol

```
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

/**
 * @title ICrossVMBridgeERC721Fulfillment
 * @dev Related to https://github.com/onflow/flips/issues/318[FLIP-318] Cross VM NFT implementations
 * on Flow in the context of Cadence-native NFTs. The following interface must be implemented to
 * integrate with the Flow VM bridge connecting Cadence & EVM implementations so that the canonical
 * VM bridge may move the Cadence NFT into EVM in a mint/escrow pattern.
 */
interface ICrossVMBridgeERC721Fulfillment is IERC165 {

    // Encountered when attempting to fulfill a token that has been previously minted and is not
    // escrowed in EVM under the VM bridge
    error FulfillmentFailedTokenNotEscrowed(uint256 id, address escrowAddress);

    // Emitted when an NFT is moved from Cadence into EVM
    event FulfilledToEVM(address indexed recipient, uint256 indexed tokenId);

    /**
     * @dev Returns whether the token is currently escrowed under custody of the designated VM bridge
     * 
     * @param _id the ID of the token in question
     */
    function isEscrowed(uint256 _id) external view returns (bool);

    function exists(uint256 _id) external view returns (bool);

    /**
     * @dev Fulfills the bridge request, minting (if non-existent) or transferring (if escrowed) the
     * token with the given ID to the provided address. For dynamic metadata handling between
     * Cadence & EVM, implementations should override and assign metadata as encoded from Cadence
     * side. If overriding, be sure to preserve the mint/escrow pattern as shown in the default
     * implementation. See `_beforeFulfillment` and `_afterFulfillment` hooks to enable pre-and/or
     * post-processing without the need to override this function.
     * 
     * @param _to address of the token recipient
     * @param _id the id of the token being moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function fulfillToEVM(address _to, uint256 _id, bytes memory _data) external;
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/send_minter_to_bridge.cdc

```
import "USDCFlow"

/// Sends the USDCFlow Minter to the bridge for use in the TokenHandler
///
/// @param bridgeAddress: The address of the bridge to send the minter to
///
/// NOTE: This transaction should be executed after the TokenHandler has been configured and minter type has been set.
/// As implemented in FlowEVMBridgeHandlers.CadenceNativeTokenHandler, a minter can only be configured once and must
/// be of the expected type when set.
///
transaction(bridgeAddress: Address) {
    prepare(signer: &Account) {
        USDCFlow.sendMinterToBridge(bridgeAddress)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/batch_bridge_nft_to_any_evm_address.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges an NFT from the signer's collection in Cadence to the provided recipient in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
/// @param recipient: The hex-encoded EVM address to receive the NFT
///
transaction(nftIdentifier: String, ids: [UInt64], recipient: String) {

    let nftType: Type
    let collection: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")
        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        self.collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                .concat(collectionData.storagePath.toString()))

        // Withdraw the requested NFT & set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nftType)
            ?? panic("Bridge does not support the requested asset type ".concat(nftIdentifier))
        // Add the onboarding fee if onboarding is necessary
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nftType,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }

        // Iterate over requested IDs and bridge each NFT to the provided recipient in EVM
        for id in ids {
            // Withdraw the NFT & ensure it is the correct type
            let nft <-self.collection.withdraw(withdrawID: id)
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Execute the bridge to EVM
            let recipientEVMAddress = EVM.addressFromString(recipient)
            FlowEVMBridge.bridgeNFTToEVM(
                token: <-nft,
                to: EVM.addressFromString(recipient),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }

        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/onboarding/onboard_by_type_identifier.cdc

```
import "FungibleToken"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param identifer: The Cadence type identifier of the bridgeable asset to onboarded to the bridge
///
transaction(identifier: String) {

    let type: Type
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct the type from identifier --- */
        //
        self.type = CompositeType(identifier) ?? panic("Invalid type identifier")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the asset Type
        FlowEVMBridge.onboardByType(
            self.type,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }

    post {
        FlowEVMBridge.typeRequiresOnboarding(self.type) == false:
            "Asset ".concat(identifier).concat(" was not onboarded to the bridge.")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/utils/SerializeMetadata.cdc

```
import "ViewResolver"
import "MetadataViews"
import "NonFungibleToken"
import "FungibleTokenMetadataViews"

import "Serialize"

/// This contract defines methods for serializing NFT metadata as a JSON compatible string, according to the common
/// OpenSea metadata format. NFTs and metadata views can be serialized by reference via contract methods.
///
/// Special thanks to @austinkline for the idea and initial implementation & @bjartek + @bluesign for optimizations.
///
access(all) contract SerializeMetadata {

    /// Serializes the metadata (as a JSON compatible String) for a given NFT according to formats expected by EVM
    /// platforms like OpenSea. If you are a project owner seeking to expose custom traits on bridged NFTs and your
    /// Trait.value is not natively serializable, you can implement a custom serialization method with the
    /// `{SerializableStruct}` interface's `serialize` method.
    ///
    /// Reference: https://docs.opensea.io/docs/metadata-standards
    ///
    ///
    /// @returns: A JSON compatible data URL string containing the serialized display & collection display views as:
    ///     `data:application/json;utf8,{
    ///         \"name\": \"<display.name>\",
    ///         \"description\": \"<display.description>\",
    ///         \"image\": \"<display.thumbnail.uri()>\",
    ///         \"external_url\": \"<nftCollectionDisplay.externalURL.url>\",
    ///         \"attributes\": [{\"trait_type\": \"<trait.name>\", \"value\": \"<trait.value>\"}, {...}]
    ///     }`
    access(all)
    fun serializeNFTMetadataAsURI(_ nft: &{NonFungibleToken.NFT}): String {
        // Serialize the display values from the NFT's Display & NFTCollectionDisplay views
        let nftDisplay = nft.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?
        let collectionDisplay = nft.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?
        // Serialize the display & collection display views - nil if both views are nil
        let display = self.serializeFromDisplays(nftDisplay: nftDisplay, collectionDisplay: collectionDisplay)

        // Get the Traits view from the NFT, returning early if no traits are found
        let traits = nft.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
        let attributes = self.serializeNFTTraitsAsAttributes(traits ?? MetadataViews.Traits([]))

        // Return an empty string if all views are nil
        if display == nil && traits == nil {
            return ""
        }
        // Init the data format prefix & concatenate the serialized display & attributes
        let parts: [String] = ["data:application/json;utf8,{"]
        if display != nil {
            parts.appendAll([display!, ", "]) // Include display if present & separate with a comma
        }
        parts.appendAll([attributes, "}"]) // Include attributes & close the JSON object

        return String.join(parts, separator: "")
    }

    /// Serializes the display & collection display views of a given NFT as a JSON compatible string. If nftDisplay is
    /// present, the value is returned as token-level metadata. If nftDisplay is nil and collectionDisplay is present,
    /// the value is returned as contract-level metadata. If both values are nil, nil is returned.
    ///
    /// @param nftDisplay: The NFT's Display view from which values `name`, `description`, and `thumbnail` are serialized
    /// @param collectionDisplay: The NFT's NFTCollectionDisplay view from which the `externalURL` is serialized
    ///
    /// @returns: A JSON compatible string containing the serialized display & collection display views as either:
    ///         \"name\": \"<nftDisplay.name>\", \"description\": \"<nftDisplay.description>\", \"image\": \"<nftDisplay.thumbnail.uri()>\", \"external_url\": \"<collectionDisplay.externalURL.url>\",
    ///         \"name\": \"<collectionDisplay.name>\", \"description\": \"<collectionDisplay.description>\", \"image\": \"<collectionDisplay.squareImage.file.uri()>\", \"external_link\": \"<collectionDisplay.externalURL.url>\",
    ///
    access(all)
    fun serializeFromDisplays(nftDisplay: MetadataViews.Display?, collectionDisplay: MetadataViews.NFTCollectionDisplay?): String? {
        // Return early if both values are nil
        if nftDisplay == nil && collectionDisplay == nil {
            return nil
        }

        // Initialize JSON fields
        let name = "\"name\": "
        let description = "\"description\": "
        let image = "\"image\": "
        let externalURL = "\"external_url\": "
        let externalLink = "\"external_link\": "
        var serializedResult = ""
        let parts: [String] = []

        // Append results from the token-level Display view to the serialized JSON compatible string
        if nftDisplay != nil {
            parts.appendAll([
                name, Serialize.tryToJSONString(nftDisplay!.name)!, ", ",
                description, Serialize.tryToJSONString(nftDisplay!.description)!, ", ",
                image, Serialize.tryToJSONString(nftDisplay!.thumbnail.uri())!
            ])
            // Append the `external_url` value from NFTCollectionDisplay view if present
            if collectionDisplay != nil {
                parts.appendAll([", ", externalURL, Serialize.tryToJSONString(collectionDisplay!.externalURL.url)!])
                return String.join(parts, separator: "")
            }
        }

        if collectionDisplay == nil {
            return String.join(parts, separator: "")
        }

        // Without token-level view, serialize as contract-level metadata
        parts.appendAll([
            name, Serialize.tryToJSONString(collectionDisplay!.name)!, ", ",
            description, Serialize.tryToJSONString(collectionDisplay!.description)!, ", ",
            image, Serialize.tryToJSONString(collectionDisplay!.squareImage.file.uri())!, ", ",
            externalLink, Serialize.tryToJSONString(collectionDisplay!.externalURL.url)!
        ])
        return String.join(parts, separator: "")
    }

    /// Serializes given Traits view as a JSON compatible string. If a given Trait is not serializable, it is skipped
    /// and not included in the serialized result.
    ///
    /// @param traits: The Traits view to be serialized
    ///
    /// @returns: A JSON compatible string containing the serialized traits as follows
    ///     (display_type omitted if trait.displayType == nil):
    ///     `\"attributes\": [{\"trait_type\": \"<trait.name>\", \"display_type\": \"<trait.displayType>\", \"value\": \"<trait.value>\"}, {...}]`
    ///
    access(all)
    fun serializeNFTTraitsAsAttributes(_ traits: MetadataViews.Traits): String {
        // Serialize each trait as an attribute, building the serialized JSON compatible string
        let parts: [String] = []
        let traitsLength = traits.traits.length
        for trait in traits.traits {
            let attribute = self.serializeNFTTraitAsAttribute(trait)
            if attribute == nil {
                continue
            }
            parts.append(attribute!)
        }
        // Join all serialized attributes with a comma separator, wrapping the result in square brackets under the
        // `attributes` key
        return "\"attributes\": [".concat(String.join(parts, separator: ", ")).concat("]")
    }

    /// Serializes a given Trait as an attribute in a JSON compatible format. If the trait's value is not serializable,
    /// nil is returned.
    /// The format of the serialized trait is as follows (display_type omitted if trait.displayType == nil):
    ///     `{"trait_type": "<trait.name>", "display_type": "<trait.displayType>", "value": "<trait.value>"}`
    access(all)
    fun serializeNFTTraitAsAttribute(_ trait: MetadataViews.Trait): String? {
        let value = Serialize.tryToJSONString(trait.value)
        if value == nil {
            return nil
        }
        let parts: [String] = ["{"]
        parts.appendAll( [ "\"trait_type\": ", Serialize.tryToJSONString(trait.name)! ] )
        if trait.displayType != nil {
            parts.appendAll( [ ", \"display_type\": ", Serialize.tryToJSONString(trait.displayType)! ] )
        }
        parts.appendAll( [ ", \"value\": ", value! , "}" ] )
        return String.join(parts, separator: "")
    }

    /// Serializes the FTDisplay view of a given fungible token as a JSON compatible data URL. The value is returned as
    /// contract-level metadata.
    ///
    /// @param ftDisplay: The tokens's FTDisplay view from which values `name`, `symbol`, `description`, and
    ///     `externaURL` are serialized
    ///
    /// @returns: A JSON compatible data URL string containing the serialized view as:
    ///     `data:application/json;utf8,{
    ///         \"name\": \"<ftDisplay.name>\",
    ///         \"symbol\": \"<ftDisplay.symbol>\",
    ///         \"description\": \"<ftDisplay.description>\",
    ///         \"external_link\": \"<ftDisplay.externalURL.url>\",
    ///     }`
    access(all)
    fun serializeFTDisplay(_ ftDisplay: FungibleTokenMetadataViews.FTDisplay): String {
        let name = "\"name\": "
        let symbol = "\"symbol\": "
        let description = "\"description\": "
        let externalLink = "\"external_link\": "
        let parts: [String] = ["data:application/json;utf8,{"]

        parts.appendAll([
            name, Serialize.tryToJSONString(ftDisplay.name)!, ", ",
            symbol, Serialize.tryToJSONString(ftDisplay.symbol)!, ", ",
            description, Serialize.tryToJSONString(ftDisplay.description)!, ", ",
            externalLink, Serialize.tryToJSONString(ftDisplay.externalURL.url)!
        ])
        return String.join(parts, separator: "")
    }

    /// Derives a symbol for use as an ERC20 or ERC721 symbol from a given string, presumably a Cadence contract name.
    /// Derivation is a process of slicing the first 4 characters of the string and converting them to uppercase.
    ///
    /// @param fromString: The string from which to derive a symbol
    ///
    /// @returns: A derived symbol for use as an ERC20 or ERC721 symbol based on the provided string, presumably a
    ///    Cadence contract name
    ///
    access(all) view fun deriveSymbol(fromString: String): String {
        let defaultLen = 4
        let len = fromString.length < defaultLen ? fromString.length : defaultLen
        return self.toUpperAlphaNumerical(fromString, upTo: len)
    }

    /// Returns the uppercase alphanumeric version of a given string. If upTo is nil or exceeds the length of the string,
    /// the entire string is converted to uppercase.
    ///
    /// @param str: The string to convert to uppercase
    /// @param upTo: The maximum number of characters to convert to uppercase
    ///
    /// @returns: The uppercase version of the given string
    ///
    access(all) view fun toUpperAlphaNumerical(_ str: String, upTo: Int?): String {
        let len = upTo ?? str.length
        var upper: String = ""
        for char in str {
            if upper.length == len {
                break
            }
            let bytes = char.utf8
            if bytes.length != 1 {
                continue
            }
            let byte = bytes[0]
            if byte >= 97 && byte <= 122 {
                // Convert lower case to upper case
                let upperChar = String.fromUTF8([byte - UInt8(32)])!
                upper = upper.concat(upperChar)
            } else if byte >= 65 && byte <= 90 {
                // Keep upper case
                upper = upper.concat(char.toString())
            } else if byte >= 48 && byte <= 57 {
                // Keep numbers
                upper = upper.concat(String.fromCharacters([char]))
            } else {
                // Skip non-alphanumeric characters
                continue
            }
        }
        return upper
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/templates/FlowEVMBridgedERC721.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {IERC721Metadata} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721URIStorage} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {ERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import {IERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import {ERC721Burnable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ICrossVM} from "../interfaces/ICrossVM.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

contract FlowEVMBridgedERC721 is ERC721, ERC721URIStorage, ERC721Burnable, ERC721Enumerable, Ownable, ICrossVM {
    string public cadenceNFTAddress;
    string public cadenceNFTIdentifier;
    string public contractMetadata;

    string private _customSymbol;

    constructor(
        address owner,
        string memory name_,
        string memory symbol_,
        string memory _cadenceNFTAddress,
        string memory _cadenceNFTIdentifier,
        string memory _contractMetadata
    ) ERC721(name_, symbol_) Ownable(owner) {
        _customSymbol = symbol_;
        cadenceNFTAddress = _cadenceNFTAddress;
        cadenceNFTIdentifier = _cadenceNFTIdentifier;
        contractMetadata = _contractMetadata;
    }

    function getCadenceAddress() external view returns (string memory) {
        return cadenceNFTAddress;
    }

    function getCadenceIdentifier() external view returns (string memory) {
        return cadenceNFTIdentifier;
    }

    function symbol() public view override returns (string memory) {
        return _customSymbol;
    }

    function safeMint(address to, uint256 tokenId, string memory uri) public onlyOwner {
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    function updateTokenURI(uint256 tokenId, string memory uri) public onlyOwner {
        _setTokenURI(tokenId, uri);
    }

    function setSymbol(string memory newSymbol) public onlyOwner {
        _setSymbol(newSymbol);
    }

    function contractURI() public view returns (string memory) {
        return contractMetadata;
    }

    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage)
        returns (bool)
    {
        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721Metadata).interfaceId
            || interfaceId == type(IERC721Enumerable).interfaceId || interfaceId == type(ERC721Burnable).interfaceId
            || interfaceId == type(Ownable).interfaceId || interfaceId == type(ICrossVM).interfaceId
            || super.supportsInterface(interfaceId);
    }

    function exists(uint256 tokenId) public view returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    function _setSymbol(string memory newSymbol) internal {
        _customSymbol = newSymbol;
    }

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/resolve_bridged_nft_views.cdc

```
import "MetadataViews"
import "NonFungibleToken"

access(all)
fun main(address: Address, collectionPathIdentifier: String, id: UInt64): Bool {
    let path = StoragePath(identifier: collectionPathIdentifier) ?? panic("Malformed StoragePath identifier")
    if let collection = getAuthAccount<auth(BorrowValue) &Account>(address).storage.borrow<&{NonFungibleToken.Collection}>(
            from: path
        ) {
        if let nft = collection.borrowNFT(id) {
            let display = nft.resolveView(Type<MetadataViews.Display>()) ?? panic("Display was not resolved")
            let collectionDisplay = nft.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) ?? panic("NFTCollectionDisplay was not resolved")
            return true
        }
    }
    return false
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/emulator/EVMBridgedNFTTemplate.cdc

```
import NonFungibleToken from 0xf8d6e0586b0a20c7
import MetadataViews from 0xf8d6e0586b0a20c7
import ViewResolver from 0xf8d6e0586b0a20c7
import FungibleToken from 0xee82856bf20e2aa6
import FlowToken from 0x0ae53cb6e3f42a79

import EVM from 0xf8d6e0586b0a20c7

import ICrossVM from 0xf8d6e0586b0a20c7
import ICrossVMAsset from 0xf8d6e0586b0a20c7
import IEVMBridgeNFTMinter from 0xf8d6e0586b0a20c7
import FlowEVMBridgeNFTEscrow from 0xf8d6e0586b0a20c7
import FlowEVMBridgeConfig from 0xf8d6e0586b0a20c7
import FlowEVMBridgeUtils from 0xf8d6e0586b0a20c7
import FlowEVMBridge from 0xf8d6e0586b0a20c7
import CrossVMNFT from 0xf8d6e0586b0a20c7
import FlowEVMBridgeResolver from 0xf8d6e0586b0a20c7

/// This contract is a template used by FlowEVMBridge to define EVM-native NFTs bridged from Flow EVM to Flow.
/// Upon deployment of this contract, the contract name is derived as a function of the asset type (here an ERC721 aka
/// an NFT) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC721 is transferred to the bridge's CadenceOwnedAccount EVM address and a new NFT is minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is locked
/// in NFT escrow and the ERC721 is transferred to the defined recipient. In this way, the Cadence token acts as a
/// representation of both the EVM NFT and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeNFTMinter, NonFungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmNFTContractAddress: EVM.EVMAddress
    /// Name of the NFT collection defined in the corresponding ERC721 contract
    access(all) let name: String
    /// Symbol of the NFT collection defined in the corresponding ERC721 contract
    access(all) let symbol: String
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Retain a Collection to reference when resolving Collection Metadata
    access(self) let collection: @Collection
    /// Mapping of token URIs indexed on their ERC721 ID. This would not normally be retained within a Cadence NFT
    /// contract, but since NFT metadata may be updated in EVM, it's retained here so that the bridge can update
    /// it against the source ERC721 contract which is treated as the NFT's source of truth.
    access(all) let tokenURIs: {UInt256: String}

    /// The NFT resource representing the bridged ERC721 token
    ///
    access(all) resource NFT : ICrossVMAsset.AssetInfo, CrossVMNFT.EVMNFT {
        /// The Cadence ID of the NFT
        access(all) let id: UInt64
        /// The ERC721 ID of the NFT
        access(all) let evmID: UInt256
        /// Additional onchain metadata
        access(all) let metadata: {String: AnyStruct}

        init(
            evmID: UInt256,
            metadata: {String: AnyStruct}
        ) {
            self.id = self.uuid
            self.evmID = evmID
            self.metadata = metadata
        }

        /// Returns the metadata view types supported by this NFT
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        access(all) view fun tokenURI(): String {
            return {{CONTRACT_NAME}}.tokenURIs[self.evmID] ?? ""
        }

        /// Resolves a metadata view for this NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let contractRef = {{CONTRACT_NAME}}.borrowThisContract()
                    return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<MetadataViews.Display>())
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionData>()
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionDisplay>()
                    )
                case Type<MetadataViews.EVMBridgedMetadata>():
                    return MetadataViews.EVMBridgedMetadata(
                        name: self.getName(),
                        symbol: self.getSymbol(),
                        uri: MetadataViews.URI(baseURI: nil, value: self.tokenURI())
                    )
            }
            return nil
        }

        /// public function that anyone can call to create a new empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- {{CONTRACT_NAME}}.createEmptyCollection(nftType: self.getType())
        }

        /* --- CrossVMNFT conformance --- */
        //
        /// Returns the EVM contract address of the NFT
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }
    }

    /// This resource holds associated NFTs, and serves queries about stored NFTs
    access(all) resource Collection : CrossVMNFT.EVMNFTCollection {
        /// dictionary of NFT conforming tokens indexed on their ID
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Mapping of EVM IDs to Flow NFT IDs
        access(contract) let evmIDToFlowID: {UInt256: UInt64}

        access(all) var storagePath: StoragePath
        access(all) var publicPath: PublicPath

        init () {
            self.ownedNFTs <- {}
            self.evmIDToFlowID = {}
            let collectionData = {{CONTRACT_NAME}}.resolveContractView(
                    resourceType: Type<@{{CONTRACT_NAME}}.NFT>(),
                    viewType: Type<MetadataViews.NFTCollectionData>()
                ) as! MetadataViews.NFTCollectionData?
                ?? panic("Could not resolve the collection data view for the NFT collection")
            self.storagePath = collectionData.storagePath
            self.publicPath = collectionData.publicPath
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        /// Returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            return { Type<@{{CONTRACT_NAME}}.NFT>(): true }
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           return type == Type<@{{CONTRACT_NAME}}.NFT>()
        }

        /// Removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// Withdraws an NFT from the collection by its EVM ID
        access(NonFungibleToken.Withdraw) fun withdrawByEVMID(_ id: UInt256): @{NonFungibleToken.NFT} {
            return <- self.withdraw(withdrawID: 
                self.getCadenceID(from: id) ?? panic("Could not withdraw an NFT with the provided EVM ID from the collection")
            )
        }

        /// Ttakes a NFT and adds it to the collections dictionary and adds the ID to the evmIDToFlowID mapping
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @{{CONTRACT_NAME}}.NFT

            // add the new token to the dictionary which removes the old one
            self.evmIDToFlowID[token.evmID] = token.id
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Returns an array of the EVM IDs that are in the collection
        access(all) view fun getEVMIDs(): [UInt256] {
            return self.evmIDToFlowID.keys
        }

        /// Returns the Cadence NFT.id for the given EVM NFT ID if it exists in the collection
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64? {
            if self.evmIDToFlowID[evmID] != nil {
                return self.evmIDToFlowID[evmID]
            } else if evmID < UInt256(UInt64.max) && self.borrowNFT(UInt64(evmID)) != nil {
                return UInt64(evmID)
            } else {
                return nil
            }
        }

        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        ///
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256? {
            if let nft = self.borrowNFT(cadenceID) {
                if let evmNFT = CrossVMNFT.getEVMID(from: nft) {
                    return evmNFT
                }
                return UInt256(nft.id)
            }
            return nil
        }

        /// Returns the contractURI for the NFT collection as defined in the source ERC721 contract. If none was
        /// defined at the time of bridging, an empty string is returned.
        access(all) view fun contractURI(): String? {
            return {{CONTRACT_NAME}}.contractURI
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        /// Retrieves a reference to the NFT stored in the collection by its ID
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            return &self.ownedNFTs[id] as &{ViewResolver.Resolver}? ?? nil
        }

        /// Creates an empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection}  {
            return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the NFT this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmNFTContractAddress
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let identifier = "{{CONTRACT_NAME}}Collection"
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: StoragePath(identifier: identifier)!,
                    publicPath: PublicPath(identifier: identifier)!,
                    publicCollection: Type<&{{CONTRACT_NAME}}.Collection>(),
                    publicLinkedType: Type<&{{CONTRACT_NAME}}.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let selfRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: selfRef, view: Type<MetadataViews.NFTCollectionDisplay>())
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint NFTs from bridge-defined NFT contracts
    ///
    access(account)
    fun mintNFT(id: UInt256, tokenURI: String): @NFT {
        pre {
            self.tokenURIs[id] == nil: "A token with the given ERC721 ID already exists"
        }
        self.tokenURIs[id] = tokenURI
        return <-create NFT(
            evmID: id,
            metadata: {
                "Bridged Block": getCurrentBlock().height,
                "Bridged Timestamp": getCurrentBlock().timestamp
            }
        )
    }

    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    ///
    access(account)
    fun updateTokenURI(evmID: UInt256, newURI: String) {
        pre {
            self.tokenURIs[evmID] != nil: "No token with the given ERC721 ID exists"
        }
        if self.tokenURIs[evmID] != newURI {
            self.tokenURIs[evmID] = newURI
        }
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmNFTContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.contractURI = contractURI
        self.tokenURIs = {}
        self.collection <- create Collection()

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.NFT>(), with: self.evmNFTContractAddress)
        FlowEVMBridgeNFTEscrow.initializeEscrow(
            forType: Type<@{{CONTRACT_NAME}}.NFT>(),
            name: name,
            symbol: symbol,
            erc721Address: self.evmNFTContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/resolve_bridged_token_views.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"

access(all)
fun main(address: Address, vaultPathIdentifier: String): Bool {
    let path = StoragePath(identifier: vaultPathIdentifier) ?? panic("Malformed StoragePath identifier")
    if let vault = getAuthAccount<auth(BorrowValue) &Account>(address).storage.borrow<&{FungibleToken.Vault}>(
            from: path
        ) {
        let ftdisplay = vault.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) ?? panic("FTDisplay was not resolved")
        return true
    }
    return false
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/get_registry.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

access(all)
fun main(): String {
    let coa = getAuthAccount<auth(BorrowValue) &Account>(0xdfc20aee650fcbdf)
        .storage
        .borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(
            from: /storage/evm
        ) ?? panic("Problem borrowing COA")
    // Confirm the registry address was set
    let postRegistryResult = coa.call(
        to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
        data: EVM.encodeABIWithSignature("owner()", []),
        gasLimit: 15_000_000,
        value: EVM.Balance(attoflow: 0)
    )
    assert(
        postRegistryResult.status == EVM.Status.successful,
        message: "Failed to get registry address from FlowBridgeFactory contract"
    )

    let decodedResult = EVM.decodeABI(
            types: [Type<EVM.EVMAddress>()],
            data: postRegistryResult.data
        )
    assert(decodedResult.length == 1, message: "Invalid response from getRegistry() call to FlowBridgeFactory contract")
    return (decodedResult[0] as! EVM.EVMAddress).toString()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/flow_evm_bridge_tests.cdc

```
import Test
import BlockchainHelpers

import "FungibleToken"
import "NonFungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"
import "ExampleNFT"
import "ExampleToken"
import "FlowStorageFees"
import "EVM"

import "test_helpers.cdc"

access(all) let serviceAccount = Test.serviceAccount()
access(all) let bridgeAccount = Test.getAccount(0x0000000000000007)
access(all) let exampleNFTAccount = Test.getAccount(0x0000000000000008)
access(all) let exampleERCAccount = Test.getAccount(0x0000000000000009)
access(all) let exampleTokenAccount = Test.getAccount(0x0000000000000010)
access(all) let alice = Test.createAccount()
access(all) let bob = Test.createAccount()

// ExampleNFT values
access(all) let exampleNFTIdentifier = "A.0000000000000008.ExampleNFT.NFT"
access(all) let exampleNFTTokenName = "Example NFT"
access(all) let exampleNFTTokenDescription = "Example NFT token description"
access(all) let exampleNFTTokenThumbnail = "https://examplenft.com/thumbnail.png"
access(all) var mintedNFTID1: UInt64 = 0
access(all) var mintedNFTID2: UInt64 = 0

// ExampleToken
access(all) let exampleTokenIdentifier = "A.0000000000000010.ExampleToken.Vault"
access(all) let exampleTokenMintAmount = 100.0

// Bridge-related EVM contract values
access(all) var registryAddressHex: String = ""
access(all) var erc20DeployerAddressHex: String = ""
access(all) var erc721DeployerAddressHex: String = ""

// ERC721 values
access(all) var erc721AddressHex: String = ""
access(all) let erc721Name = "NAME"
access(all) let erc721Symbol = "SYMBOL"
access(all) let erc721ID: UInt256 = 42
access(all) let erc721URI = "URI"

// ERC20 values
access(all) var erc20AddressHex: String = ""
access(all) let erc20MintAmount: UInt256 = 100_000_000_000_000_000_000 // 100.0 as uint256 (100e18)

// Fee initialiazation values
access(all) let expectedOnboardFee = 1.0
access(all) let expectedBaseFee = 0.001

// Test height snapshot for test state resets
access(all) var snapshot: UInt64 = 0

access(all)
fun setup() {
    // Deploy supporting util contracts
    var err = Test.deployContract(
        name: "ArrayUtils",
        path: "../contracts/utils/ArrayUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "StringUtils",
        path: "../contracts/utils/StringUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ScopedFTProviders",
        path: "../contracts/utils/ScopedFTProviders.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "SerializeMetadata",
        path: "../contracts/utils/SerializeMetadata.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Transfer bridge account some $FLOW
    transferFlow(signer: serviceAccount, recipient: bridgeAccount.address, amount: 10_000.0)
    // Configure bridge account with a COA
    createCOA(signer: bridgeAccount, fundingAmount: 1_000.0)

    err = Test.deployContract(
        name: "IBridgePermissions",
        path: "../contracts/bridge/interfaces/IBridgePermissions.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVM",
        path: "../contracts/bridge/interfaces/ICrossVM.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVMAsset",
        path: "../contracts/bridge/interfaces/ICrossVMAsset.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMNFT",
        path: "../contracts/bridge/interfaces/CrossVMNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMToken",
        path: "../contracts/bridge/interfaces/CrossVMToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeHandlerInterfaces",
        path: "../contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeConfig",
        path: "../contracts/bridge/FlowEVMBridgeConfig.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Deploy registry
    let registryDeploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getRegistryBytecode(), UInt64(15_000_000), 0.0],
        bridgeAccount
    )
    Test.expect(registryDeploymentResult, Test.beSucceeded())
    // Deploy ERC20Deployer
    let erc20DeployerDeploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getERC20DeployerBytecode(), UInt64(15_000_000), 0.0],
        bridgeAccount
    )
    Test.expect(erc20DeployerDeploymentResult, Test.beSucceeded())
    // Deploy ERC721Deployer
    let erc721DeployerDeploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getERC721DeployerBytecode(), UInt64(15_000_000), 0.0],
        bridgeAccount
    )
    Test.expect(erc721DeployerDeploymentResult, Test.beSucceeded())
    // Assign contract addresses
    var evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(5, evts.length)
    registryAddressHex = getEVMAddressHexFromEvents(evts, idx: 2)
    erc20DeployerAddressHex = getEVMAddressHexFromEvents(evts, idx: 3)
    erc721DeployerAddressHex = getEVMAddressHexFromEvents(evts, idx: 4)

    // Deploy factory
    let deploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledFactoryBytecode(), UInt64(15_000_000), 0.0],
        bridgeAccount
    )
    Test.expect(deploymentResult, Test.beSucceeded())
    // Assign the factory contract address
    evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(6, evts.length)
    let factoryAddressHex = getEVMAddressHexFromEvents(evts, idx: 5)
    Test.assertEqual(factoryAddressHex.length, 40)

    err = Test.deployContract(
        name: "FlowEVMBridgeUtils",
        path: "../contracts/bridge/FlowEVMBridgeUtils.cdc",
        arguments: [factoryAddressHex]
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "FlowEVMBridgeResolver",
        path: "../contracts/bridge/FlowEVMBridgeResolver.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    err = Test.deployContract(
        name: "FlowEVMBridgeHandlers",
        path: "../contracts/bridge/FlowEVMBridgeHandlers.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    /* Integrate EVM bridge contract */

    // Set factory as registrar in registry
    let setRegistrarResult = executeTransaction(
        "../transactions/bridge/admin/evm/set_registrar.cdc",
        [registryAddressHex],
        bridgeAccount
    )
    Test.expect(setRegistrarResult, Test.beSucceeded())
    // Set registry as registry in factory
    let setRegistryResult = executeTransaction(
        "../transactions/bridge/admin/evm/set_deployment_registry.cdc",
        [registryAddressHex],
        bridgeAccount
    )
    Test.expect(setRegistryResult, Test.beSucceeded())
    // Set factory as delegatedDeployer in erc20Deployer
    var setDelegatedDeployerResult = executeTransaction(
        "../transactions/bridge/admin/evm/set_delegated_deployer.cdc",
        [erc20DeployerAddressHex],
        bridgeAccount
    )
    Test.expect(setDelegatedDeployerResult, Test.beSucceeded())
    // Set factory as delegatedDeployer in erc721Deployer
    setDelegatedDeployerResult = executeTransaction(
        "../transactions/bridge/admin/evm/set_delegated_deployer.cdc",
        [erc721DeployerAddressHex],
        bridgeAccount
    )
    Test.expect(setDelegatedDeployerResult, Test.beSucceeded())
    // add erc20Deployer under "ERC20" tag to factory
    var addDeployerResult = executeTransaction(
        "../transactions/bridge/admin/evm/add_deployer.cdc",
        ["ERC20", erc20DeployerAddressHex],
        bridgeAccount
    )
    Test.expect(addDeployerResult, Test.beSucceeded())
    // add erc721Deployer under "ERC721" tag to factory
    addDeployerResult = executeTransaction(
        "../transactions/bridge/admin/evm/add_deployer.cdc",
        ["ERC721", erc721DeployerAddressHex],
        bridgeAccount
    )
    Test.expect(addDeployerResult, Test.beSucceeded())

    /* End EVM bridge integration txns */

    err = Test.deployContract(
        name: "FlowEVMBridgeNFTEscrow",
        path: "../contracts/bridge/FlowEVMBridgeNFTEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTokenEscrow",
        path: "../contracts/bridge/FlowEVMBridgeTokenEscrow.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeTemplates",
        path: "../contracts/bridge/FlowEVMBridgeTemplates.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    // Commit bridged NFT code
    let bridgedNFTChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedNFT", getBridgedNFTCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())
    // Commit bridged Token code
    let bridgedTokenChunkResult = executeTransaction(
        "../transactions/bridge/admin/templates/upsert_contract_code_chunks.cdc",
        ["bridgedToken", getBridgedTokenCodeChunks()],
        bridgeAccount
    )
    Test.expect(bridgedNFTChunkResult, Test.beSucceeded())

    err = Test.deployContract(
        name: "IEVMBridgeNFTMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeNFTMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IEVMBridgeTokenMinter",
        path: "../contracts/bridge/interfaces/IEVMBridgeTokenMinter.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMNFTBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMNFTBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "IFlowEVMTokenBridge",
        path: "../contracts/bridge/interfaces/IFlowEVMTokenBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridge",
        path: "../contracts/bridge/FlowEVMBridge.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeAccessor",
        path: "../contracts/bridge/FlowEVMBridgeAccessor.cdc",
        arguments: [serviceAccount.address]
    )
    Test.expect(err, Test.beNil())

    let claimAccessorResult = executeTransaction(
        "../transactions/bridge/admin/evm-integration/claim_accessor_capability_and_save_router.cdc",
        ["FlowEVMBridgeAccessor", bridgeAccount.address],
        serviceAccount
    )
    Test.expect(claimAccessorResult, Test.beSucceeded())

    // Configure example ERC20 account with a COA
    transferFlow(signer: serviceAccount, recipient: exampleERCAccount.address, amount: 1_000.0)
    createCOA(signer: exampleERCAccount, fundingAmount: 10.0)

    err = Test.deployContract(
        name: "ExampleNFT",
        path: "../contracts/example-assets/ExampleNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ExampleToken",
        path: "../contracts/example-assets/ExampleToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Configure metadata views for bridged NFTS & FTs
    let setBridgedNFTDisplayViewResult = executeTransaction(
        "../transactions/bridge/admin/metadata/set_bridged_nft_display_view.cdc",
        [
            "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg", // thumbnailURI
            Type<MetadataViews.HTTPFile>().identifier, // thumbnailFileTypeIdentifier
            nil // ipfsFilePath
        ],
        bridgeAccount
    )
    Test.expect(setBridgedNFTDisplayViewResult, Test.beSucceeded())

    let socialsDict: {String: String} = {}
    let setBridgedNFTCollectionDisplayResult = executeTransaction(
        "../transactions/bridge/admin/metadata/set_bridged_nft_collection_display_view.cdc",
        [
            "https://port.flow.com", // externalURL
            "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg", // squareImageURI
            Type<MetadataViews.HTTPFile>().identifier, // squareImageFileTypeIdentifier
            nil, // squareImageIPFSFilePath
            "image/svg+xml", // squareImageMediaType
            "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg", // bannerImageURI
            Type<MetadataViews.HTTPFile>().identifier, // bannerImageFileTypeIdentifier
            nil, // bannerImageIPFSFilePath
            "image/svg+xml", // bannerImageMediaType
            socialsDict // socialsDict
        ],
        bridgeAccount
    )
    Test.expect(setBridgedNFTCollectionDisplayResult, Test.beSucceeded())

    let setFTDisplayResult = executeTransaction(
        "../transactions/bridge/admin/metadata/set_bridged_ft_display_view.cdc",
        [
            "https://port.flow.com", // externalURL
            "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg", // logoURI
            Type<MetadataViews.HTTPFile>().identifier, // logoFileTypeIdentifier
            nil, // logoIPFSFilePath
            "image/svg+xml", // logoMediaType
            socialsDict // socialsDict
        ],
        bridgeAccount
    )
    Test.expect(setFTDisplayResult, Test.beSucceeded())
}

/* --- CONFIG TEST --- */

access(all)
fun testUnpauseBridgeSucceeds() {
    updateBridgePauseStatus(signer: bridgeAccount, pause: false)
}

access(all)
fun testSetGasLimitSucceeds() {

    fun getGasLimit(): UInt64 {
        let gasLimitResult = executeScript(
            "../scripts/bridge/get_gas_limit.cdc",
            []
        )
        Test.expect(gasLimitResult, Test.beSucceeded())
        return gasLimitResult.returnValue as! UInt64? ?? panic("Problem getting gas limit")
    }

    snapshot = getCurrentBlockHeight()

    let preGasLimit = getGasLimit()
    let gasLimit = preGasLimit + 1_000

    let setGasLimitResult = executeTransaction(
        "../transactions/bridge/admin/gas/set_gas_limit.cdc",
        [gasLimit],
        bridgeAccount
    )
    Test.expect(setGasLimitResult, Test.beSucceeded())

    let postGasLimit = getGasLimit()
    Test.assertEqual(gasLimit, postGasLimit)

    Test.reset(to: snapshot)
}

/* --- ASSET & ACCOUNT SETUP - Configure test accounts with assets to bridge --- */

access(all)
fun testDeployERC721Succeeds() {
    let erc721DeployResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledERC721Bytecode(), UInt64(15_000_000), 0.0],
        exampleERCAccount
    )
    Test.expect(erc721DeployResult, Test.beSucceeded())

    // Get ERC721 & ERC20 deployed contract addresses
    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(21, evts.length)
    erc721AddressHex = getEVMAddressHexFromEvents(evts, idx: 20)
}

access(all)
fun testDeployERC20Succeeds() {
    let erc20DeployResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledERC20Bytecode(), UInt64(15_000_000), 0.0],
        exampleERCAccount
    )
    Test.expect(erc20DeployResult, Test.beSucceeded())

    // Get ERC721 & ERC20 deployed contract addresses
    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(22, evts.length)
    erc20AddressHex = getEVMAddressHexFromEvents(evts, idx: 21)

}

access(all)
fun testCreateCOASucceeds() {
    transferFlow(signer: serviceAccount, recipient: alice.address, amount: 1_000.0)
    transferFlow(signer: serviceAccount, recipient: bob.address, amount: 1_000.0)
    createCOA(signer: alice, fundingAmount: 100.0)
    createCOA(signer: bob, fundingAmount: 100.0)

    let aliceCOAAddress = getCOAAddressHex(atFlowAddress: alice.address)
    let bobCOAAddress = getCOAAddressHex(atFlowAddress: bob.address)
}

access(all)
fun testMintExampleNFTSucceeds() {
    let setupCollectionResult = executeTransaction(
        "../transactions/example-assets/example-nft/setup_collection.cdc",
        [],
        alice
    )
    Test.expect(setupCollectionResult, Test.beSucceeded())
    let hasCollection = executeScript(
        "../scripts/nft/has_collection_configured.cdc",
        [exampleNFTIdentifier, alice.address]
    )
    Test.expect(hasCollection, Test.beSucceeded())
    Test.assertEqual(true, hasCollection.returnValue as! Bool? ?? panic("Problem getting collection status"))

    var mintExampleNFTResult = executeTransaction(
        "../transactions/example-assets/example-nft/mint_nft.cdc",
        [alice.address, exampleNFTTokenName, exampleNFTTokenDescription, exampleNFTTokenThumbnail, [], [], []],
        exampleNFTAccount
    )
    Test.expect(mintExampleNFTResult, Test.beSucceeded())

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)

    var events = Test.eventsOfType(Type<NonFungibleToken.Deposited>())
    Test.assertEqual(1, events.length)
    var evt = events[0] as! NonFungibleToken.Deposited
    mintedNFTID1 = evt.id

    mintExampleNFTResult = executeTransaction(
        "../transactions/example-assets/example-nft/mint_nft.cdc",
        [alice.address, exampleNFTTokenName, exampleNFTTokenDescription, exampleNFTTokenThumbnail, [], [], []],
        exampleNFTAccount
    )
    Test.expect(mintExampleNFTResult, Test.beSucceeded())

    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    events = Test.eventsOfType(Type<NonFungibleToken.Deposited>())
    Test.assertEqual(2, events.length)
    evt = events[1] as! NonFungibleToken.Deposited
    mintedNFTID2 = evt.id

    Test.assert(mintedNFTID1 != mintedNFTID2)
    Test.assertEqual(true, aliceOwnedIDs.contains(mintedNFTID1) && aliceOwnedIDs.contains(mintedNFTID2))
}

access(all)
fun testMintExampleTokenSucceeds() {
    let setupVaultResult = executeTransaction(
        "../transactions/example-assets/example-token/setup_vault.cdc",
        [],
        alice
    )
    Test.expect(setupVaultResult, Test.beSucceeded())
    let hasVault = executeScript(
        "../scripts/tokens/has_vault_configured.cdc",
        [exampleTokenIdentifier, alice.address]
    )
    Test.expect(hasVault, Test.beSucceeded())
    Test.assertEqual(true, hasVault.returnValue as! Bool? ?? panic("Problem getting vault status"))

    let mintExampleTokenResult = executeTransaction(
        "../transactions/example-assets/example-token/mint_tokens.cdc",
        [alice.address, exampleTokenMintAmount],
        exampleTokenAccount
    )
    Test.expect(mintExampleTokenResult, Test.beSucceeded())

    let aliceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(exampleTokenMintAmount, aliceBalance)

    let events = Test.eventsOfType(Type<FungibleToken.Deposited>())
    let evt = events[events.length - 1] as! FungibleToken.Deposited

    Test.assertEqual(aliceBalance, evt.amount)
}

access(all)
fun testMintERC721Succeeds() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    Test.assertEqual(40, erc721AddressHex.length)

    let mintERC721Result = executeTransaction(
        "../transactions/example-assets/evm-assets/safe_mint_erc721.cdc",
        [aliceCOAAddressHex, erc721ID, erc721URI, erc721AddressHex, UInt64(200_000)],
        exampleERCAccount
    )
    Test.expect(mintERC721Result, Test.beSucceeded())

    let aliceIsOwner = isOwner(of: erc721ID, ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: erc721AddressHex)
    Test.assertEqual(true, aliceIsOwner)
}

access(all)
fun testMintERC20Succeeds() {
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let mintERC20Result = executeTransaction(
        "../transactions/example-assets/evm-assets/mint_erc20.cdc",
        [aliceCOAAddressHex, erc20MintAmount, erc20AddressHex, UInt64(200_000)],
        exampleERCAccount
    )
    Test.expect(mintERC20Result, Test.beSucceeded())

    let aliceBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, aliceBalance)
}

access(all)
fun testUpdateBridgeFeesSucceeds() {
    fun getFee(feeType: String): UFix64 {
        let feeResult = executeScript(
            "../scripts/config/get_".concat(feeType).concat(".cdc"),
            []
        )
        Test.expect(feeResult, Test.beSucceeded())
        return feeResult.returnValue as! UFix64? ?? panic("Problem getting fee: ".concat(feeType))
    }

    fun calculateBridgeFee(bytesUsed: UInt64): UFix64 {
        let calculatedResult = executeScript(
            "../scripts/bridge/calculate_bridge_fee.cdc",
            [bytesUsed]
        )
        Test.expect(calculatedResult, Test.beSucceeded())
        return calculatedResult.returnValue as! UFix64? ?? panic("Problem getting calculated fee")
    }

    let bytesUsed: UInt64 = 1024
    let expectedFinalFee = FlowStorageFees.storageCapacityToFlow(
            FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(bytesUsed)
        ) + expectedBaseFee

    // Validate the initialized values are set to 0.0
    var actualOnboardFee = getFee(feeType: "onboard_fee")
    var actualBaseFee = getFee(feeType: "base_fee")

    Test.assertEqual(0.0, actualOnboardFee)
    Test.assertEqual(0.0, actualBaseFee)

    var actualCalculated = calculateBridgeFee(bytesUsed: bytesUsed)
    Test.assertEqual(0.0, actualCalculated)

    // Set the fees to new values
    let updateOnboardFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_onboard_fee.cdc",
        [expectedOnboardFee],
        bridgeAccount
    )
    Test.expect(updateOnboardFeeResult, Test.beSucceeded())
    let updateBaseFeeResult = executeTransaction(
        "../transactions/bridge/admin/fee/update_base_fee.cdc",
        [expectedBaseFee],
        bridgeAccount
    )
    Test.expect(updateBaseFeeResult, Test.beSucceeded())

    // Validate the values have been updated
    actualOnboardFee = getFee(feeType: "onboard_fee")
    actualBaseFee = getFee(feeType: "base_fee")

    Test.assertEqual(expectedOnboardFee, actualOnboardFee)
    Test.assertEqual(expectedBaseFee, actualBaseFee)

    actualCalculated = calculateBridgeFee(bytesUsed: bytesUsed)
    Test.assertEqual(expectedFinalFee, actualCalculated)
}

/* --- ONBOARDING - Test asset onboarding to the bridge --- */

access(all)
fun testOnboardNFTByTypeSucceeds() {
    snapshot = getCurrentBlockHeight()

    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleNFTIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleNFTIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

access(all)
fun testOnboardAndBridgeNFTToEVMSucceeds() {
    // Revert to state before ExampleNFT was onboarded
    Test.reset(to: snapshot)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    // Execute bridge NFT to EVM - should also onboard the NFT type
    bridgeNFTToEVM(
        signer: alice,
        nftIdentifier: exampleNFTIdentifier,
        nftID: mintedNFTID1,
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: false
    )

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleNFTIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm the NFT is no longer in Alice's Collection
    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    let isOwnerResult = executeScript(
        "../scripts/utils/is_owner.cdc",
        [UInt256(mintedNFTID1), aliceCOAAddressHex, associatedEVMAddressHex]
    )
    Test.expect(isOwnerResult, Test.beSucceeded())
    Test.assertEqual(true, isOwnerResult.returnValue as! Bool? ?? panic("Problem getting owner status"))
}

access(all)
fun testOnboardAndCrossVMTransferNFTToEVMSucceeds() {
    // Revert to state before ExampleNFT was onboarded
    Test.reset(to: snapshot)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    let recipient = getCOAAddressHex(atFlowAddress: bob.address)

    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    // Execute bridge NFT to EVM recipient - should also onboard the NFT type
    let crossVMTransferResult = executeTransaction(
        "../transactions/bridge/nft/bridge_nft_to_any_evm_address.cdc",
        [ exampleNFTIdentifier, mintedNFTID1, recipient ],
        alice
    )
    Test.expect(crossVMTransferResult, Test.beSucceeded())

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleNFTIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm the NFT is no longer in Alice's Collection
    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    var aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: recipient, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)
}

access(all)
fun testOnboardTokenByTypeSucceeds() {
    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

access(all)
fun testOnboardAndBridgeTokensToEVMSucceeds() {
    // Revert to state before ExampleNFT was onboarded
    Test.reset(to: snapshot)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Could not get ExampleToken balance")

    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    // Execute bridge to EVM - should also onboard the token type
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: exampleTokenIdentifier,
        amount: cadenceBalance,
        beFailed: false
    )

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm Alice's token balance is now 0.0
    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, cadenceBalance)

    // Confirm balance on EVM side has been updated
    let decimals = getTokenDecimals(erc20AddressHex: associatedEVMAddressHex)
    let expectedEVMBalance = ufix64ToUInt256(exampleTokenMintAmount, decimals: decimals)
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    Test.assertEqual(expectedEVMBalance, evmBalance)
}

access(all)
fun testOnboardAndCrossVMTransferTokensToEVMSucceeds() {
    // Revert to state before ExampleNFT was onboarded
    Test.reset(to: snapshot)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Could not get ExampleToken balance")
    let recipient = getCOAAddressHex(atFlowAddress: bob.address)

    var requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, requiresOnboarding)

    // Execute bridge to EVM - should also onboard the token type
    let crossVMTransferResult = executeTransaction(
        "../transactions/bridge/tokens/bridge_tokens_to_any_evm_address.cdc",
        [ exampleTokenIdentifier, cadenceBalance, recipient ],
        alice
    )
    Test.expect(crossVMTransferResult, Test.beSucceeded())

    requiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(false, requiresOnboarding)

    let onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_type_identifier.cdc",
        [exampleTokenIdentifier],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm Alice's token balance is now 0.0
    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, cadenceBalance)

    // Confirm balance on EVM side has been updated
    let decimals = getTokenDecimals(erc20AddressHex: associatedEVMAddressHex)
    let expectedEVMBalance = ufix64ToUInt256(exampleTokenMintAmount, decimals: decimals)
    let evmBalance = balanceOf(evmAddressHex: recipient, erc20AddressHex: associatedEVMAddressHex)
    Test.assertEqual(expectedEVMBalance, evmBalance)
}

access(all)
fun testBatchOnboardByTypeSucceeds() {
    Test.assert(snapshot != 0, message: "Expected snapshot to be taken before onboarding any types")
    Test.reset(to: snapshot)

    let nftRequiresOnboarding = typeRequiresOnboardingByIdentifier(exampleNFTIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, nftRequiresOnboarding)
    let tokenRequiresOnboarding = typeRequiresOnboardingByIdentifier(exampleTokenIdentifier)
        ?? panic("Problem getting onboarding status for type")
    Test.assertEqual(true, tokenRequiresOnboarding)

    let exampleNFTType = Type<@ExampleNFT.NFT>()
    let exampleTokenType = Type<@ExampleToken.Vault>()
    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/batch_onboard_by_type.cdc",
        [[exampleNFTType, exampleTokenType]],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())

    let expectedBatchOnboardingRequired: {Type: Bool?} = {
        exampleNFTType: false,
        exampleTokenType: false
    }
    let batchOnboardingRequiredResult = executeScript(
        "../scripts/bridge/batch_type_requires_onboarding.cdc",
        [[exampleNFTType, exampleTokenType]]
    )
    Test.expect(batchOnboardingRequiredResult, Test.beSucceeded())
    let batchRequiresOnboarding = batchOnboardingRequiredResult.returnValue as! {Type: Bool?}? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(expectedBatchOnboardingRequired, batchRequiresOnboarding)

    // Should succeed as batch onboarding skips already onboarded types
    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/batch_onboard_by_type.cdc",
        [[exampleNFTType, exampleTokenType]],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())
}

access(all)
fun testOnboardERC721ByEVMAddressSucceeds() {
    snapshot = getCurrentBlockHeight()

    // Validate EVMBlocklist works by blocking the EVM address
    let blockResult = executeTransaction(
        "../transactions/bridge/admin/blocklist/block_evm_address.cdc",
        [erc721AddressHex],
        bridgeAccount
    )
    Test.expect(blockResult, Test.beSucceeded())

    // onboarding should fail as the EVM address is blocked
    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc721AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())

    // Unblock the EVM address
    let unblockResult = executeTransaction(
        "../transactions/bridge/admin/blocklist/unblock_evm_address.cdc",
        [erc721AddressHex],
        bridgeAccount
    )
    Test.expect(unblockResult, Test.beSucceeded())

    // And now onboarding should succeed

    var requiresOnboarding = evmAddressRequiresOnboarding(erc721AddressHex)
        ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(true, requiresOnboarding)

    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc721AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())

    requiresOnboarding = evmAddressRequiresOnboarding(erc721AddressHex)
        ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc721AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

access(all)
fun testOnboardERC20ByEVMAddressSucceeds() {

    var requiresOnboarding = evmAddressRequiresOnboarding(erc20AddressHex)
        ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(true, requiresOnboarding)

    var onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc20AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beSucceeded())

    requiresOnboarding = evmAddressRequiresOnboarding(erc20AddressHex)
        ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(false, requiresOnboarding)

    onboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/onboard_by_evm_address.cdc",
        [erc20AddressHex],
        alice
    )
    Test.expect(onboardingResult, Test.beFailed())
}

access(all)
fun testBatchOnboardByEVMAddressSucceeds() {
    Test.assert(snapshot != 0, message: "Expected snapshot to be taken before onboarding any EVM contracts")
    Test.reset(to: snapshot)

    var erc721RequiresOnboarding = evmAddressRequiresOnboarding(erc721AddressHex)
        ?? panic("Problem getting onboarding requirement")
    var erc20RequiresOnboarding = evmAddressRequiresOnboarding(erc20AddressHex)
        ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(true, erc721RequiresOnboarding)
    Test.assertEqual(true, erc20RequiresOnboarding)

    var batchOnboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/batch_onboard_by_evm_address.cdc",
        [[erc721AddressHex, erc20AddressHex]],
        alice
    )
    Test.expect(batchOnboardingResult, Test.beSucceeded())

    let expectedBatchRequiresOnboarding: {String: Bool?} = {
        erc721AddressHex: false,
        erc20AddressHex: false
    }
    let batchOnboardingRequiredResult = executeScript(
        "../scripts/bridge/batch_evm_address_requires_onboarding.cdc",
        [[erc721AddressHex, erc20AddressHex]]
    )
    Test.expect(batchOnboardingRequiredResult, Test.beSucceeded())
    let batchRequiresOnboarding = batchOnboardingRequiredResult.returnValue as! {String: Bool?}? ?? panic("Problem getting onboarding requirement")
    Test.assertEqual(expectedBatchRequiresOnboarding, batchRequiresOnboarding)

    // Batch onboarding should succeed as it skips already onboarded contracts
    batchOnboardingResult = executeTransaction(
        "../transactions/bridge/onboarding/batch_onboard_by_evm_address.cdc",
        [[erc721AddressHex, erc20AddressHex]],
        alice
    )
    Test.expect(batchOnboardingResult, Test.beSucceeded())

}

/* --- BRIDGING NFTS - Test bridging both Cadence- & EVM-native NFTs --- */

access(all)
fun testPauseBridgeSucceeds() {
    // Pause the bridge
    updateBridgePauseStatus(signer: bridgeAccount, pause: true)

    var isPausedResult = executeScript(
        "../scripts/bridge/is_paused.cdc",
        []
    )
    Test.expect(isPausedResult, Test.beSucceeded())
    Test.assertEqual(true, isPausedResult.returnValue as! Bool? ?? panic("Problem getting pause status"))

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM - should fail after pausing
    bridgeNFTToEVM(
        signer: alice,
        nftIdentifier: exampleNFTIdentifier,
        nftID: aliceOwnedIDs[0],
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: true
    )

    // Unpause bridging
    updateBridgePauseStatus(signer: bridgeAccount, pause: false)

    isPausedResult = executeScript(
        "../scripts/bridge/is_paused.cdc",
        []
    )
    Test.expect(isPausedResult, Test.beSucceeded())
    Test.assertEqual(false, isPausedResult.returnValue as! Bool? ?? panic("Problem getting pause status"))
}

access(all)
fun testBridgeCadenceNativeNFTToEVMSucceeds() {
    snapshot = getCurrentBlockHeight()

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM
    bridgeNFTToEVM(
        signer: alice,
        nftIdentifier: exampleNFTIdentifier,
        nftID: mintedNFTID1,
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: false
    )

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm the NFT is no longer in Alice's Collection
    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    let isOwnerResult = executeScript(
        "../scripts/utils/is_owner.cdc",
        [UInt256(mintedNFTID1), aliceCOAAddressHex, associatedEVMAddressHex]
    )
    Test.expect(isOwnerResult, Test.beSucceeded())
    Test.assertEqual(true, isOwnerResult.returnValue as! Bool? ?? panic("Problem getting owner status"))

    let isNFTLocked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID1)
    Test.assertEqual(true, isNFTLocked)

    let metadata = resolveLockedNFTView(bridgeAddress: bridgeAccount.address, nftTypeIdentifier: exampleNFTIdentifier, id: UInt256(mintedNFTID1), viewIdentifier: Type<MetadataViews.Display>().identifier)
    Test.assert(metadata != nil, message: "Expected NFT metadata to be resolved from escrow but none was returned")
}

access(all)
fun testBatchBridgeCadenceNativeNFTToEVMSucceeds() {
    let tmp = snapshot
    Test.reset(to: snapshot)
    snapshot = tmp

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM
    let bridgeResult = executeTransaction(
        "../transactions/bridge/nft/batch_bridge_nft_to_evm.cdc",
        [ exampleNFTIdentifier, aliceOwnedIDs ],
        alice
    )
    Test.expect(bridgeResult, Test.beSucceeded())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm the NFT is no longer in Alice's Collection
    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(0, aliceOwnedIDs.length)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    var aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID2), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)

    let isNFT1Locked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID1)
    let isNFT2Locked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID2)
    Test.assertEqual(true, isNFT1Locked)
    Test.assertEqual(true, isNFT2Locked)

    let metadata1 = resolveLockedNFTView(bridgeAddress: bridgeAccount.address, nftTypeIdentifier: exampleNFTIdentifier, id: UInt256(mintedNFTID1), viewIdentifier: Type<MetadataViews.Display>().identifier)
    let metadata2 = resolveLockedNFTView(bridgeAddress: bridgeAccount.address, nftTypeIdentifier: exampleNFTIdentifier, id: UInt256(mintedNFTID2), viewIdentifier: Type<MetadataViews.Display>().identifier)
    Test.assert(metadata1 != nil, message: "Expected NFT metadata to be resolved from escrow but none was returned")
    Test.assert(metadata2 != nil, message: "Expected NFT metadata to be resolved from escrow but none was returned")
}

access(all)
fun testBatchBridgeCadenceNativeNFTFromEVMSucceeds() {
    snapshot = getCurrentBlockHeight()

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)
    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)
    
    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    var aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID2), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)

    // Execute bridge from EVM
    let bridgeResult = executeTransaction(
        "../transactions/bridge/nft/batch_bridge_nft_from_evm.cdc",
        [ exampleNFTIdentifier, [UInt256(mintedNFTID1), UInt256(mintedNFTID2)] ],
        alice
    )
    Test.expect(bridgeResult, Test.beSucceeded())

    // Confirm the NFT is no longer in Alice's Collection
    let aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(2, aliceOwnedIDs.length)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(false, aliceIsOwner)
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID2), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(false, aliceIsOwner)

    let isNFT1Locked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID1)
    let isNFT2Locked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID2)
    Test.assertEqual(false, isNFT1Locked)
    Test.assertEqual(false, isNFT2Locked)
}

access(all)
fun testCrossVMTransferCadenceNativeNFTFromEVMSucceeds() {
    let tmp = snapshot
    Test.reset(to: snapshot)
    snapshot = getCurrentBlockHeight()

    // Configure recipient's Collection first, using generic setup transaction
    let setupCollectionResult = executeTransaction(
        "../transactions/example-assets/setup/setup_generic_nft_collection.cdc",
        [exampleNFTIdentifier],
        bob
    )
    Test.expect(setupCollectionResult, Test.beSucceeded())

    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Assert ownership of the bridged NFT in EVM
    var aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)

    // Execute bridge NFT from EVM to Cadence recipient (Bob in this case)
    let crossVMTransferResult = executeTransaction(
        "../transactions/bridge/nft/bridge_nft_to_any_cadence_address.cdc",
        [ exampleNFTIdentifier, UInt256(mintedNFTID1), bob.address ],
        alice
    )
    Test.expect(crossVMTransferResult, Test.beSucceeded())

    // Assert ownership of the bridged NFT in EVM has transferred
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(false, aliceIsOwner)

    // Assert the NFT is now in Bob's Collection
    let bobOwnedIDs = getIDs(ownerAddr: bob.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, bobOwnedIDs.length)
    Test.assertEqual(mintedNFTID1, bobOwnedIDs[0])

    let isNFTLocked = isNFTLocked(nftTypeIdentifier: exampleNFTIdentifier, id: mintedNFTID1)
    Test.assertEqual(false, isNFTLocked)
}

access(all)
fun testBridgeCadenceNativeNFTFromEVMSucceeds() {
    Test.reset(to: snapshot)
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleNFTIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Assert ownership of the bridged NFT in EVM
    var aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(true, aliceIsOwner)

    // Execute bridge from EVM
    bridgeNFTFromEVM(
        signer: alice,
        nftIdentifier: exampleNFTIdentifier,
        erc721ID: UInt256(mintedNFTID1),
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: false
    )

    // Assert ownership of the bridged NFT in EVM has transferred
    aliceIsOwner = isOwner(of: UInt256(mintedNFTID1), ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: associatedEVMAddressHex)
    Test.assertEqual(false, aliceIsOwner)

    // Assert the NFT is back in Alice's Collection
    let aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)
    Test.assertEqual(true, aliceOwnedIDs.contains(mintedNFTID1))
}

access(all)
fun testBridgeEVMNativeNFTFromEVMSucceeds() {

    let derivedERC721ContractName = deriveBridgedNFTContractName(evmAddressHex: erc721AddressHex)
    let bridgedCollectionPathIdentifier = derivedERC721ContractName.concat("Collection")
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    bridgeNFTFromEVM(
        signer: alice,
        nftIdentifier: buildTypeIdentifier(
            address: bridgeAccount.address,
            contractName: derivedERC721ContractName,
            resourceName: "NFT"
        ), erc721ID: erc721ID,
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: false
    )

    let aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: bridgedCollectionPathIdentifier)
    Test.assertEqual(1, aliceOwnedIDs.length)

    let evmIDResult = executeScript(
        "../scripts/nft/get_evm_id_from_evm_nft.cdc",
        [alice.address, aliceOwnedIDs[0], StoragePath(identifier: bridgedCollectionPathIdentifier)!]
    )
    Test.expect(evmIDResult, Test.beSucceeded())
    let evmID = evmIDResult.returnValue as! UInt256? ?? panic("Problem getting EVM ID")
    Test.assertEqual(erc721ID, evmID)

    let viewsResolved = executeScript(
        "./scripts/resolve_bridged_nft_views.cdc",
        [alice.address, bridgedCollectionPathIdentifier, aliceOwnedIDs[0]]
    )
    Test.expect(viewsResolved, Test.beSucceeded())
    Test.assertEqual(true, viewsResolved.returnValue as! Bool? ?? panic("Problem resolving views"))
}


access(all)
fun testPauseByTypeSucceeds() {
    // Pause the bridge
    let pauseResult = executeTransaction(
        "../transactions/bridge/admin/pause/update_type_pause_status.cdc",
        [exampleNFTIdentifier, true],
        bridgeAccount
    )
    Test.expect(pauseResult, Test.beSucceeded())
    var isPausedResult = executeScript(
        "../scripts/bridge/is_type_paused.cdc",
        [exampleNFTIdentifier]
    )
    Test.expect(isPausedResult, Test.beSucceeded())
    Test.assertEqual(true, isPausedResult.returnValue as! Bool? ?? panic("Problem getting pause status"))

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: "cadenceExampleNFTCollection")
    Test.assertEqual(1, aliceOwnedIDs.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM - should fail after pausing
    bridgeNFTToEVM(
        signer: alice,
        nftIdentifier: exampleNFTIdentifier,
        nftID: mintedNFTID1,
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: true
    )

    // Unpause bridging
    let unpauseResult = executeTransaction(
        "../transactions/bridge/admin/pause/update_type_pause_status.cdc",
        [exampleNFTIdentifier, false],
        bridgeAccount
    )
    Test.expect(unpauseResult, Test.beSucceeded())

    isPausedResult = executeScript(
        "../scripts/bridge/is_type_paused.cdc",
        [exampleNFTIdentifier]
    )
    Test.expect(isPausedResult, Test.beSucceeded())
    Test.assertEqual(false, isPausedResult.returnValue as! Bool? ?? panic("Problem getting pause status"))
}

access(all)
fun testBridgeEVMNativeNFTToEVMSucceeds() {

    let derivedERC721ContractName = deriveBridgedNFTContractName(evmAddressHex: erc721AddressHex)
    let bridgedCollectionPathIdentifier = derivedERC721ContractName.concat("Collection")
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    var aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: bridgedCollectionPathIdentifier)
    Test.assertEqual(1, aliceOwnedIDs.length)

    bridgeNFTToEVM(
        signer: alice,
        nftIdentifier: buildTypeIdentifier(
            address: bridgeAccount.address,
            contractName: derivedERC721ContractName,
            resourceName: "NFT"
        ), nftID: aliceOwnedIDs[0],
        bridgeAccountAddr: bridgeAccount.address,
        beFailed: false
    )

    aliceOwnedIDs = getIDs(ownerAddr: alice.address, storagePathIdentifier: bridgedCollectionPathIdentifier)
    Test.assertEqual(0, aliceOwnedIDs.length)

    let aliceIsOwner = isOwner(of: erc721ID, ownerEVMAddrHex: aliceCOAAddressHex, erc721AddressHex: erc721AddressHex)
    Test.assertEqual(true, aliceIsOwner)
}

/* --- BRIDGING FUNGIBLE TOKENS - Test bridging both Cadence- & EVM-native fungible tokens --- */

access(all)
fun testBridgeCadenceNativeTokenToEVMSucceeds() {
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assert(cadenceBalance == exampleTokenMintAmount)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Execute bridge to EVM
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: exampleTokenIdentifier,
        amount: cadenceBalance,
        beFailed: false
    )

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    // Confirm Alice's token balance is now 0.0
    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, cadenceBalance)

    // Confirm balance on EVM side has been updated
    let decimals = getTokenDecimals(erc20AddressHex: associatedEVMAddressHex)
    let expectedEVMBalance = ufix64ToUInt256(exampleTokenMintAmount, decimals: decimals)
    let evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    Test.assertEqual(expectedEVMBalance, evmBalance)

    // Confirm the token is locked
    let lockedBalance = getLockedTokenBalance(vaultTypeIdentifier: exampleTokenIdentifier) ?? panic("Problem getting locked balance")
    Test.assertEqual(exampleTokenMintAmount, lockedBalance)

    let metadata = resolveLockedTokenView(bridgeAddress: bridgeAccount.address, vaultTypeIdentifier: exampleTokenIdentifier, viewIdentifier: Type<FungibleTokenMetadataViews.FTDisplay>().identifier)
    Test.assert(metadata != nil, message: "Expected Vault metadata to be resolved from escrow but none was returned")
}

access(all)
fun testCrossVMTransferCadenceNativeTokenFromEVMSucceeds() {
    snapshot = getCurrentBlockHeight()
    // Configure recipient's Vault first, using generic setup transaction
    let setupVaultResult = executeTransaction(
        "../transactions/example-assets/setup/setup_generic_vault.cdc",
        [exampleTokenIdentifier],
        bob
    )
    Test.expect(setupVaultResult, Test.beSucceeded())

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Confirm Alice is starting with 0.0 balance in their Cadence Vault
    let preCadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, preCadenceBalance)

    // Get Alice's ERC20 balance & convert to UFix64
    var evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    let decimals = getTokenDecimals(erc20AddressHex: associatedEVMAddressHex)
    let ufixValue = uint256ToUFix64(evmBalance, decimals: decimals)
    // Assert the converted balance is equal to the originally minted amount that was bridged in the previous step
    Test.assertEqual(exampleTokenMintAmount, ufixValue)

    // Execute bridge tokens from EVM to Cadence recipient (Bob in this case)
    let crossVMTransferResult = executeTransaction(
        "../transactions/bridge/tokens/bridge_tokens_to_any_cadence_address.cdc",
        [ exampleTokenIdentifier, evmBalance, bob.address ],
        alice
    )
    Test.expect(crossVMTransferResult, Test.beSucceeded())

    // Confirm ExampleToken balance has been bridged back to Alice's Cadence vault
    let recipientCadenceBalance = getBalance(ownerAddr: bob.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(ufixValue, recipientCadenceBalance)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    Test.assertEqual(UInt256(0), evmBalance)
}

access(all)
fun testBridgeCadenceNativeTokenFromEVMSucceeds() {
    Test.reset(to: snapshot)

    let associatedEVMAddressHex = getAssociatedEVMAddressHex(with: exampleTokenIdentifier)
    Test.assertEqual(40, associatedEVMAddressHex.length)

    var aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Confirm Alice is starting with 0.0 balance in their Cadence Vault
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(0.0, cadenceBalance)

    // Get Alice's ERC20 balance & convert to UFix64
    var evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    let decimals = getTokenDecimals(erc20AddressHex: associatedEVMAddressHex)
    let ufixValue = uint256ToUFix64(evmBalance, decimals: decimals)
    // Assert the converted balance is equal to the originally minted amount that was bridged in the previous step
    Test.assertEqual(exampleTokenMintAmount, ufixValue)

    // Execute bridge from EVM
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: exampleTokenIdentifier,
        amount: evmBalance,
        beFailed: false
    )

    // Confirm ExampleToken balance has been bridged back to Alice's Cadence vault
    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: "exampleTokenVault")
        ?? panic("Problem getting ExampleToken balance")
    Test.assertEqual(ufixValue, cadenceBalance)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: associatedEVMAddressHex)
    Test.assertEqual(UInt256(0), evmBalance)
}

access(all)
fun testBridgeEVMNativeTokenFromEVMSucceeds() {

    let derivedERC20ContractName = deriveBridgedTokenContractName(evmAddressHex: erc20AddressHex)
    let bridgedVaultPathIdentifier = derivedERC20ContractName.concat("Vault")
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    var evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, evmBalance)

    // Confirm Alice does not yet have a bridged Vault configured
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: bridgedVaultPathIdentifier)
    Test.assertEqual(nil, cadenceBalance)

    // Execute bridge from EVM
    bridgeTokensFromEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: bridgeAccount.address,
            contractName: derivedERC20ContractName,
            resourceName: "Vault"
        ), amount: evmBalance,
        beFailed: false
    )

    // Confirm EVM balance is no 0
    evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), evmBalance)

    // Confirm the Cadence Vault is now configured and contains the bridged balance
    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: bridgedVaultPathIdentifier)
        ?? panic("Bridged token Vault was not found in Alice's account after bridging")
    let decimals = getTokenDecimals(erc20AddressHex: erc20AddressHex)
    let expectedCadenceBalance = uint256ToUFix64(erc20MintAmount, decimals: decimals)
    Test.assertEqual(expectedCadenceBalance, cadenceBalance!)

    // With the bridge executed, confirm the bridge COA escrows the ERC20 tokens
    let bridgeCOAAddressHex = getCOAAddressHex(atFlowAddress: bridgeAccount.address)
    let bridgeCOAEscrowBalance = balanceOf(evmAddressHex: bridgeCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, bridgeCOAEscrowBalance)

    let viewsResolved = executeScript(
        "./scripts/resolve_bridged_token_views.cdc",
        [alice.address, bridgedVaultPathIdentifier]
    )
    Test.expect(viewsResolved, Test.beSucceeded())
    Test.assertEqual(true, viewsResolved.returnValue as! Bool? ?? panic("Problem resolving views"))
}

access(all)
fun testBridgeEVMNativeTokenToEVMSucceeds() {

    let derivedERC20ContractName = deriveBridgedTokenContractName(evmAddressHex: erc20AddressHex)
    let bridgedVaultPathIdentifier = derivedERC20ContractName.concat("Vault")
    let aliceCOAAddressHex = getCOAAddressHex(atFlowAddress: alice.address)

    // Confirm Cadence Vault has the expected balance
    var cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: bridgedVaultPathIdentifier)
        ?? panic("Bridged token Vault was not found in Alice's account after bridging")
    let decimals = getTokenDecimals(erc20AddressHex: erc20AddressHex)
    let expectedCadenceBalance = uint256ToUFix64(erc20MintAmount, decimals: decimals)
    Test.assertEqual(expectedCadenceBalance, cadenceBalance)

    // Confirm EVM balance is 0
    var evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), evmBalance)

    // Confirm the bridge COA currently escrows the ERC20 tokens we will be bridging
    let bridgeCOAAddressHex = getCOAAddressHex(atFlowAddress: bridgeAccount.address)
    var bridgeCOAEscrowBalance = balanceOf(evmAddressHex: bridgeCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, bridgeCOAEscrowBalance)

    // Execute bridge from EVM
    bridgeTokensToEVM(
        signer: alice,
        vaultIdentifier: buildTypeIdentifier(
            address: bridgeAccount.address,
            contractName: derivedERC20ContractName,
            resourceName: "Vault"
        ), amount: cadenceBalance,
        beFailed: false
    )

    // Confirm ownership on EVM side with Alice COA as owner of ERC721 representation
    evmBalance = balanceOf(evmAddressHex: aliceCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(erc20MintAmount, evmBalance)

    cadenceBalance = getBalance(ownerAddr: alice.address, storagePathIdentifier: bridgedVaultPathIdentifier)
        ?? panic("Bridged token Vault was not found in Alice's account after bridging")
    Test.assertEqual(0.0, cadenceBalance)

    // Confirm the bridge COA no longer escrows the ERC20 tokens
    bridgeCOAEscrowBalance = balanceOf(evmAddressHex: bridgeCOAAddressHex, erc20AddressHex: erc20AddressHex)
    Test.assertEqual(UInt256(0), bridgeCOAEscrowBalance)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/flow_evm_bridge_utils_tests.cdc

```
import Test
import BlockchainHelpers

import "EVM"

import "test_helpers.cdc"

access(all) let serviceAccount = Test.serviceAccount()
access(all) let bridgeAccount = Test.getAccount(0x0000000000000007)

access(all)
fun setup() {
    // Deploy supporting util contracts
    var err = Test.deployContract(
        name: "ArrayUtils",
        path: "../contracts/utils/ArrayUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "StringUtils",
        path: "../contracts/utils/StringUtils.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ScopedFTProviders",
        path: "../contracts/utils/ScopedFTProviders.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "SerializeMetadata",
        path: "../contracts/utils/SerializeMetadata.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())

    // Transfer bridge account some $FLOW
    transferFlow(signer: serviceAccount, recipient: bridgeAccount.address, amount: 10_000.0)
    // Configure bridge account with a COA
    createCOA(signer: bridgeAccount, fundingAmount: 1_000.0)

    err = Test.deployContract(
        name: "IBridgePermissions",
        path: "../contracts/bridge/interfaces/IBridgePermissions.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVM",
        path: "../contracts/bridge/interfaces/ICrossVM.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "ICrossVMAsset",
        path: "../contracts/bridge/interfaces/ICrossVMAsset.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMNFT",
        path: "../contracts/bridge/interfaces/CrossVMNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "CrossVMToken",
        path: "../contracts/bridge/interfaces/CrossVMToken.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeHandlerInterfaces",
        path: "../contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "FlowEVMBridgeConfig",
        path: "../contracts/bridge/FlowEVMBridgeConfig.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    let deploymentResult = executeTransaction(
        "../transactions/evm/deploy.cdc",
        [getCompiledFactoryBytecode(), UInt64(15_000_000), 0.0],
        bridgeAccount
    )
    Test.expect(deploymentResult, Test.beSucceeded())
    let evts = Test.eventsOfType(Type<EVM.TransactionExecuted>())
    Test.assertEqual(3, evts.length)
    let factoryAddressHex = getEVMAddressHexFromEvents(evts, idx: 0)
    err = Test.deployContract(
        name: "FlowEVMBridgeUtils",
        path: "../contracts/bridge/FlowEVMBridgeUtils.cdc",
        arguments: [factoryAddressHex]
    )
    Test.expect(err, Test.beNil())
}

access(all)
fun testReducedPrecisionUInt256ToUFix64Succeeds() {
    let uintAmount: UInt256 = 24_244_814_054_591
    let ufixAmount: UFix64 = 24_244_814.05459100

    let actualUFixAmount = uint256ToUFix64(uintAmount, decimals: 6)
    Test.assertEqual(ufixAmount, actualUFixAmount)
}

access(all)
fun testReducedPrecisionUInt256SmallChangeToUFix64Succeeds() {
    let uintAmount: UInt256 = 24_244_814_000_020
    let ufixAmount: UFix64 = 24_244_814.000020

    let actualUFixAmount = uint256ToUFix64(uintAmount, decimals: 6)
    Test.assertEqual(ufixAmount, actualUFixAmount)
}

// Converting from UFix64 to UInt256 with reduced point precision (6 vs. 8) should round down
access(all)
fun testReducedPrecisionUFix64ToUInt256Succeeds() {
    let uintAmount: UInt256 = 24_244_814_054_591
    let ufixAmount: UFix64 = 24_244_814.05459154

    let actualUIntAmount = ufix64ToUInt256(ufixAmount, decimals: 6)
    Test.assertEqual(uintAmount, actualUIntAmount)
}

access(all)
fun testDustUInt256ToUFix64Succeeds() {
    let dustUFixAmount: UFix64 = 0.00002547
    let dustUIntAmount: UInt256 = 25_470_000_000_000

    let actualUFixAmount = uint256ToUFix64(dustUIntAmount, decimals: 18)
    Test.assertEqual(dustUFixAmount, actualUFixAmount)
    Test.assert(actualUFixAmount > 0.0)
}

access(all)
fun testDustUFix64ToUInt256Succeeds() {
    let dustUFixAmount: UFix64 = 0.00002547
    let dustUIntAmount: UInt256 = 25_470_000_000_000

    let actualUIntAmount = ufix64ToUInt256(dustUFixAmount, decimals: 18)
    Test.assertEqual(dustUIntAmount, actualUIntAmount)
    Test.assert(actualUIntAmount > 0)
}

access(all)
fun testZeroUInt256ToUFix64Succeeds() {
    let zeroUFixAmount: UFix64 = 0.0
    let zeroUIntAmount: UInt256 = 0

    let actualUFixAmount = uint256ToUFix64(zeroUIntAmount, decimals: 18)
    Test.assertEqual(zeroUFixAmount, actualUFixAmount)
}

access(all)
fun testZeroUFix64ToUInt256Succeeds() {
    let zeroUFixAmount: UFix64 = 0.0
    let zeroUIntAmount: UInt256 = 0

    let actualUIntAmount = ufix64ToUInt256(zeroUFixAmount, decimals: 18)
    Test.assertEqual(zeroUIntAmount, actualUIntAmount)
}

access(all)
fun testNonFractionalUInt256ToUFix64Succeeds() {
    let nonFractionalUFixAmount: UFix64 = 100.0
    let nonFractionalUIntAmount: UInt256 = 100_000_000_000_000_000_000

    let actualUFixAmount = uint256ToUFix64(nonFractionalUIntAmount, decimals: 18)
    Test.assertEqual(nonFractionalUFixAmount, actualUFixAmount)
}

access(all)
fun testNonFractionalUFix64ToUInt256Succeeds() {
    let nonFractionalUFixAmount: UFix64 = 100.0
    let nonFractionalUIntAmount: UInt256 = 100_000_000_000_000_000_000

    let actualUIntAmount = ufix64ToUInt256(nonFractionalUFixAmount, decimals: 18)
    Test.assertEqual(nonFractionalUIntAmount, actualUIntAmount)
}

access(all)
fun testLargeFractionalUInt256ToUFix64Succeeds() {
    let largeFractionalUFixAmount: UFix64 = 1.99785982
    let largeFractionalUIntAmount: UInt256 = 1_997_859_829_999_999_999

    let actualUFixAmount = uint256ToUFix64(largeFractionalUIntAmount, decimals: 18)
    Test.assertEqual(largeFractionalUFixAmount, actualUFixAmount)
}

access(all)
fun testLargeFractionalTrailingZerosUInt256ToUFix64Succeeds() {
    let largeFractionalUFixAmount: UFix64 = 1.99785982
    let largeFractionalUIntAmount: UInt256 = 1_997_859_829_999_000_000

    let actualUFixAmount = uint256ToUFix64(largeFractionalUIntAmount, decimals: 18)
    Test.assertEqual(largeFractionalUFixAmount, actualUFixAmount)
}

access(all)
fun testlargeFractionalUFix64ToUInt256Succeeds() {
    let largeFractionalUFixAmount: UFix64 = 1.99785982
    let largeFractionalUIntAmount: UInt256 = 1_997_859_820_000_000_000

    let actualUIntAmount = ufix64ToUInt256(largeFractionalUFixAmount, decimals: 18)
    Test.assertEqual(largeFractionalUIntAmount, actualUIntAmount)
}

access(all)
fun testIntegerAndLeadingZeroFractionalUInt256ToUFix64Succeeds() {
    let ufixAmount: UFix64 = 100.00000500
    let uintAmount: UInt256 = 100_000_005_000_000_888_999

    let actualUFixAmount = uint256ToUFix64(uintAmount, decimals: 18)
    Test.assertEqual(ufixAmount, actualUFixAmount)
}

access(all)
fun testIntegerAndLeadingZeroFractionalUFix64ToUInt256Succeeds() {
    let ufixAmount: UFix64 = 100.00000500
    let uintAmount: UInt256 = 100_000_005_000_000_000_000

    let actualUIntAmount = ufix64ToUInt256(ufixAmount, decimals: 18)
    Test.assertEqual(uintAmount, actualUIntAmount)
}

access(all)
fun testMaxUFix64ToUInt256Succeeds() {
    let ufixAmount: UFix64 = UFix64.max
    let uintAmount: UInt256 = 184467440737_095516150000000000

    let actualUIntAmount = ufix64ToUInt256(ufixAmount, decimals: 18)

    Test.assertEqual(uintAmount, actualUIntAmount)
}

access(all)
fun testMaxUFix64AsUInt256ToUFix64Succeds() {
    let ufixAmount: UFix64 = UFix64.max
    var uintAmount: UInt256 = 184467440737_095516150000000000

    let actualUFixAmount = uint256ToUFix64(uintAmount, decimals: 18)

    Test.assertEqual(ufixAmount, actualUFixAmount)
}

access(all)
fun testFractionalPartMaxUFix64AsUInt256ToUFix64Fails() {
    let ufixAmount: UFix64 = UFix64.max
    var uintAmount: UInt256 = 184467440737_095_516_150_000_000_000 + 10_000_000_000

    let convertedResult = executeScript(
        "../scripts/utils/uint256_to_ufix64.cdc",
        [uintAmount, UInt8(18)]
    )
    Test.expect(convertedResult, Test.beFailed())
}

access(all)
fun testIntegerPartMaxUFix64AsUInt256ToUFix64Fails() {
    let ufixAmount: UFix64 = UFix64.max
    var uintAmount: UInt256 = 184467440737_095_516_150_000_000_000 + 100_000_000_000_000_000_000_000

    let convertedResult = executeScript(
        "../scripts/utils/uint256_to_ufix64.cdc",
        [uintAmount, UInt8(18)]
    )
    Test.expect(convertedResult, Test.beFailed())
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/example-assets/ExampleHandledToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

import "FlowEVMBridgeHandlerInterfaces"

access(all) contract ExampleHandledToken: FungibleToken {

    /// The event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64, type: String)

    /// Total supply of ExampleTokens in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath
    access(all) let AdminStoragePath: StoragePath

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Example Fungible Token",
                    symbol: "EFT",
                    description: "This fungible token is used as an example to help you develop your next FT #onFlow.",
                    externalURL: MetadataViews.ExternalURL("https://example-ft.onflow.org"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/exampleTokenVault,
                    receiverPath: /public/exampleTokenReceiver,
                    metadataPath: /public/exampleTokenVault,
                    receiverLinkedType: Type<&ExampleHandledToken.Vault>(),
                    metadataLinkedType: Type<&ExampleHandledToken.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-ExampleHandledToken.createEmptyVault(vaultType: Type<@ExampleHandledToken.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: ExampleHandledToken.totalSupply
                )
        }
        return nil
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                ExampleHandledToken.totalSupply = ExampleHandledToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        access(all) view fun getViews(): [Type] {
            return ExampleHandledToken.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return ExampleHandledToken.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @ExampleHandledToken.Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @ExampleHandledToken.Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @ExampleHandledToken.Vault {
            return <-create Vault(balance: 0.0)
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    access(all) resource Minter : FlowEVMBridgeHandlerInterfaces.TokenMinter {
        /// getMintedType
        ///
        /// Function that returns the type of token that this minter can mint.
        ///
        access(all)
        view fun getMintedType(): Type {
            return Type<@ExampleHandledToken.Vault>()
        }
        
        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        access(FlowEVMBridgeHandlerInterfaces.Mint)
        fun mint(amount: UFix64): @ExampleHandledToken.Vault {
            ExampleHandledToken.totalSupply = ExampleHandledToken.totalSupply + amount
            emit TokensMinted(amount: amount, type: self.getType().identifier)
            return <-create Vault(balance: amount)
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @ExampleHandledToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 0.0

        self.VaultStoragePath = /storage/exampleTokenVault
        self.VaultPublicPath = /public/exampleTokenVault
        self.ReceiverPublicPath = /public/exampleTokenReceiver
        self.AdminStoragePath = /storage/exampleTokenAdmin 

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)

        // Create a public capability to the stored Vault that exposes
        // the `deposit` method and getAcceptedTypes method through the `Receiver` interface
        // and the `balance` method through the `Balance` interface
        //
        let exampleTokenCap = self.account.capabilities.storage.issue<&ExampleHandledToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(exampleTokenCap, at: self.VaultPublicPath)
        let receiverCap = self.account.capabilities.storage.issue<&ExampleHandledToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(receiverCap, at: self.ReceiverPublicPath)

        self.account.storage.save(<-vault, to: /storage/exampleTokenVault)

        let admin <- create Minter()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/BridgePermissions.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IBridgePermissions} from "./IBridgePermissions.sol";

/**
 * @dev Contract for which implementation is checked by the Flow VM bridge as an opt-out mechanism
 * for non-standard asset contracts that wish to opt-out of bridging between Cadence & EVM. By
 * default, the VM bridge operates on a permissionless basis, meaning anyone can request an asset
 * be onboarded. However, some small subset of non-standard projects may wish to opt-out of this
 * and this contract provides a way to do so while also enabling future opt-in.
 *
 * Note: The Flow VM bridge checks for permissions at asset onboarding. If your asset has already
 * been onboarded, setting `permissions` to `false` will not affect movement between VMs.
 */
abstract contract BridgePermissions is ERC165, IBridgePermissions {
    // The permissions for the contract to allow or disallow bridging of its assets.
    bool private _permissions;

    constructor() {
        _permissions = false;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IBridgePermissions).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns true if the contract allows bridging of its assets. Checked by the Flow VM
     *     bridge at asset onboarding to enable non-standard asset contracts to opt-out of bridging
     *     between Cadence & EVM. Implementing this contract opts out by default but can be
     *     overridden to opt-in or used in conjunction with a switch to enable opting in.
     */
    function allowsBridging() external view virtual returns (bool) {
        return _permissions;
    }

    /**
     * @dev Set the permissions for the contract to allow or disallow bridging of its assets.
     *
     * Emits a {PermissionsUpdated} event.
     */
    function _setPermissions(bool permissions) internal {
        _permissions = permissions;
        emit PermissionsUpdated(permissions);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/bridge_nft_to_any_evm_address.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges an NFT from the signer's collection in Cadence to the named recipient in EVM.
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
/// @param recipient: The hex-encoded EVM address to receive the NFT
///
transaction(nftIdentifier: String, id: UInt64, recipient: String) {
    
    let nft: @{NonFungibleToken.NFT}
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(nftType.identifier))
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                .concat(collectionData.storagePath.toString()))

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        self.nft <- collection.withdraw(withdrawID: id)
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support the requested asset type ".concat(nftIdentifier))
        // Add the onboarding fee if onboarding is necessary
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.nft.getType().identifier == nftIdentifier:
            "Attempting to send invalid nft type - requested: ".concat(nftIdentifier)
            .concat(", sending: ").concat(self.nft.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge to EVM
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeNFTToEVM(
            token: <-self.nft,
            to: EVM.addressFromString(recipient),
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-handled-token/setup_vault.cdc

```
// This transaction is a template for a transaction to allow
// anyone to add a Vault resource to their account so that
// they can use the exampleToken

import "FungibleToken"
import "ExampleHandledToken"
import "ViewResolver"
import "FungibleTokenMetadataViews"

transaction () {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        let vaultData = ExampleHandledToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("ViewResolver does not resolve FTVaultData view")

        // Return early if the account already stores a ExampleToken Vault
        if signer.storage.borrow<&ExampleHandledToken.Vault>(from: vaultData.storagePath) != nil {
            return
        }

        let vault <- ExampleHandledToken.createEmptyVault(vaultType: Type<@ExampleHandledToken.Vault>())

        // Create a new ExampleToken Vault and put it in storage
        signer.storage.save(<-vault, to: vaultData.storagePath)

        // Create a public capability to the Vault that exposes the Vault interfaces
        let vaultCap = signer.capabilities.storage.issue<&ExampleHandledToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(vaultCap, at: vaultData.metadataPath)

        // Create a public Capability to the Vault's Receiver functionality
        let receiverCap = signer.capabilities.storage.issue<&ExampleHandledToken.Vault>(
            vaultData.storagePath
        )
        signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/.github/ISSUE_TEMPLATE/feature-request.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/get_evm_address_from_hex.cdc

```
import "EVM"

access(all)
fun main(hex: String): EVM.EVMAddress? {
    return EVM.addressFromString(hex)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/batch_type_requires_onboarding.cdc

```
import "FlowEVMBridge"

/// Returns whether a type needs to be onboarded to the FlowEVMBridge
///
/// @param Types: The array of types to check for onboarding status
///
/// @return Whether the type requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil indexed
///     on the type
///
access(all) fun main(types: [Type]): {Type: Bool?} {
    let results: {Type: Bool?} = {}
    for type in types {
        if results[type] != nil {
            continue
        }
        results.insert(key: type, FlowEVMBridge.typeRequiresOnboarding(type))
    }
    return results
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/is_paused.cdc

```
import "FlowEVMBridgeConfig"

access(all)
fun main(): Bool {
    return FlowEVMBridgeConfig.isPaused()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/README.md

![Tests](https://github.com/onflow/flow-evm-bridge/actions/workflows/cadence_test.yml/badge.svg)
[![codecov](https://codecov.io/gh/onflow/flow-evm-bridge/graph/badge.svg?token=C1vCK0t88F)](https://codecov.io/gh/onflow/flow-evm-bridge)

# Flow EVM Bridge

This repo contains contracts enabling bridging of fungible & non-fungible tokens between Cadence and EVM on Flow.

## Deployments

The bridge contracts in this repo are deployed to the following addresses:

|Contracts|Testnet|Mainnet|
|---|---|---|
|All Cadence Bridge contracts|[`0xdfc20aee650fcbdf`](https://contractbrowser.com/account/0xdfc20aee650fcbdf/contracts)|[`0x1e4aa0b87d10b141`](https://contractbrowser.com/account/0x1e4aa0b87d10b141/contracts)|
|[`FlowEVMBridgeFactory.sol`](./solidity/src/FlowBridgeFactory.sol)|[`0xf8146b4aef631853f0eb98dbe28706d029e52c52`](https://evm-testnet.flowscan.io/address/0xF8146B4aEF631853F0eB98DBE28706d029e52c52)|[`0x1c6dea788ee774cf15bcd3d7a07ede892ef0be40`](https://evm.flowscan.io/address/0x1C6dEa788Ee774CF15bCd3d7A07ede892ef0bE40)|
|[`FlowEVMBridgeDeploymentRegistry.sol`](./solidity/src/FlowEVMBridgeDeploymentRegistry.sol)|[`0x8781d15904d7e161f421400571dea24cc0db6938`](https://evm-testnet.flowscan.io/address/0x8781d15904d7e161f421400571dea24cc0db6938)|[`0x8fdec2058535a2cb25c2f8cec65e8e0d0691f7b0`](https://evm.flowscan.io/address/0x8FDEc2058535A2Cb25C2f8ceC65e8e0D0691f7B0)|
|[`FlowEVMBridgedERC20Deployer.sol`](./solidity/src/FlowEVMBridgedERC20Deployer.sol)|[`0x4d45CaD104A71D19991DE3489ddC5C7B284cf263`](https://evm-testnet.flowscan.io/address/0x4d45CaD104A71D19991DE3489ddC5C7B284cf263)|[`0x49631Eac7e67c417D036a4d114AD9359c93491e7`](https://evm.flowscan.io/address/0x49631Eac7e67c417D036a4d114AD9359c93491e7)|
|[`FlowEVMBridgedERC721Deployer.sol`](./solidity/src/FlowEVMBridgedERC721Deployer.sol)|[`0x1B852d242F9c4C4E9Bb91115276f659D1D1f7c56`](https://evm-testnet.flowscan.io/address/0x1B852d242F9c4C4E9Bb91115276f659D1D1f7c56)|[`0xe7c2B80a9de81340AE375B3a53940E9aeEAd79Df`](https://evm.flowscan.io/address/0xe7c2B80a9de81340AE375B3a53940E9aeEAd79Df)|

And below are the bridge escrow's EVM addresses. These addresses are [`CadenceOwnedAccount`s (COA)](https://developers.flow.com/evm/cadence/interacting-with-coa#coa-interface) and they are stored stored in the same Flow account as you'll find the Cadence contracts (see above).

|Network|Address|
|---|---|
|Testnet|[`0x0000000000000000000000023f946ffbc8829bfd`](https://evm-testnet.flowscan.io/address/0x0000000000000000000000023f946FFbc8829BFD)|
|Mainnet|[`0x00000000000000000000000249250a5c27ecab3b`](https://evm.flowscan.io/address/0x00000000000000000000000249250a5C27Ecab3B)|

## Interacting with the bridge

> :information_source: All bridging activity in either direction is orchestrated via Cadence on `CadenceOwnedAccount`
> (COA) resources. This means that all bridging activity must be initiated via a Cadence transaction, not an EVM
> transaction regardless of the directionality of the bridge request. For more information on the interplay between
> Cadence and EVM, see [EVM Integration FLIP #223](https://github.com/onflow/flips/pull/225/files)

### Overview

The Flow EVM bridge allows both fungible and non-fungible tokens to move atomically between Cadence and EVM. In the
context of EVM, fungible tokens are defined as ERC20 tokens, and non-fungible tokens as ERC721 tokens. In Cadence,
fungible tokens are defined by contracts implementing FungibleToken and non-fungible tokens the NonFungibleToken
standard contract interfaces.

Like all operations on Flow, there are native fees associated with both computation and storage. To prevent spam and
sustain the bridge account's storage consumption, fees are charged for both onboarding assets and bridging assets. In
the case where storage consumption is expected, fees are charges based on the storage consumed at the current network
rates. In all cases, there is a flat-rate fee in addition to any storage fees.

### Onboarding

Since a contract must define the asset in the target VM, an asset must be "onboarded" to the bridge before requests can
be fulfilled. Moving from Cadence to EVM, onboarding can occur on the fly, deploying a template contract in the same
transaction as the asset is bridged to EVM if the transaction so specifies. Moving from EVM to Cadence, however,
requires that onboarding occur in a separate transaction due to the fact that a Cadence contract is initialized at the
end of a transaction and isn't available in the runtime until after the transaction has executed.

Below are transactions relevant to onboarding assets:
- [`onboard_by_type.cdc`](./cadence/transactions/bridge/onboarding/onboard_by_type.cdc)
- [`onboard_by_evm_address.cdc`](./cadence/transactions/bridge/onboarding/onboard_by_evm_address.cdc)


### Bridging

Once an asset has been onboarded, either by its Cadence type or EVM contract address, it can be bridged in either
direction referred to by its Cadence type. For Cadence-native assets, this is simply its native type. For EVM-native
assets, this is in most cases a templated Cadence contract deployed to the bridge account, the name of which is derived
from the EVM contract address. For instance, an ERC721 contract at address `0x1234` would be onboarded to the bridge as
`EVMVMBridgedNFT_0x1234`, making its type identifier `A.<BRIDGE_ADDRESS>.EVMVMBridgedNFT_0x1234.NFT`.

However, the derivation of these identifiers can be abstracted within transactions. For example, calling applications 
can provide the defining contract address and name of the bridged asset (see
[`bridge_nft_to_evm.cdc`](./cadence/transactions/bridge/nft/bridge_nft_to_evm.cdc)). Alternatively, the defining EVM
contract could be provided, etc - this flexibility is thanks to Cadence's scripted transactions.

#### NFTs

Any Cadence NFTs bridging to EVM are escrowed in the bridge account and either minted in a bridge-deployed ERC721
contract or transferred from escrow to the calling COA in EVM. On the return trip, NFTs are escrowed in EVM - owned by
the bridge's COA - and either unlocked from escrow if locked or minted from a bridge-owned NFT contract.

Below are transactions relevant to bridging NFTs:
- [`bridge_nft_to_evm.cdc`](./cadence/transactions/bridge/nft/bridge_nft_to_evm.cdc)
- [`bridge_nft_from_evm.cdc`](./cadence/transactions/bridge/nft/bridge_nft_from_evm.cdc)

#### Fungible Tokens

Any Cadence fungible tokens bridging to EVM are escrowed in the bridge account only if they are Cadence-native. If the
bridge defines the tokens, they are burned. On the return trip the pattern is similar, with the bridge burning
bridge-defined tokens or escrowing them if they are EVM-native. In all cases, if the bridge has authority to mint on one
side, it must escrow on the other as the native VM contract is owned by an external party.

With fungible tokens in particular, there may be some cases where the Cadence contract is not deployed to the bridge
account, but the bridge still follows a mint/burn pattern in Cadence. These cases are handled via
[`TokenHandler`](./cadence/contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc) implementations.

Also know that moving $FLOW to EVM is built into the `EVMAddress` object via `EVMAddress.deposit(from: @FlowToken.Vault)`.
Conversely, moving $FLOW from EVM is facilitated via the `CadenceOwnedAccount.withdraw(balance: Balance): @FlowToken.Vault`
method. Given these existing interfaces, the bridge instead handles $FLOW as corresponding fungible token
implementations - `FungibleToken.Vault` in Cadence & ERC20 in EVM. Therefore, the bridge wraps $FLOW en route to EVM
(depositing WFLOW to the recipient) and unwraps WFLOW when bridging when moving from EVM. In short, the cross-VM
association for $FLOW as far as the bridge is concerned is `@FlowToken.Vault` <> WFLOW
(`0xd3bF53DAC106A0290B0483EcBC89d40FcC961f3e` on
[Testnet](https://evm-testnet.flowscan.io/address/0xd3bF53DAC106A0290B0483EcBC89d40FcC961f3e) &
[Mainnet](https://evm.flowscan.io/address/0xd3bF53DAC106A0290B0483EcBC89d40FcC961f3e)).

Below are transactions relevant to bridging fungible tokens:
- [`bridge_tokens_to_evm.cdc`](./cadence/transactions/bridge/tokens/bridge_tokens_to_evm.cdc)
- [`bridge_tokens_from_evm.cdc`](./cadence/transactions/bridge/tokens/bridge_tokens_from_evm.cdc)


## Prep Your Assets for Bridging

### Context

To maximize utility to the ecosystem, this bridge is permissionless and open to any fungible or non-fungible token as
defined by the respective Cadence standards and limited to ERC20 and ERC721 Solidity standards. Ultimately, a project
does not have to do anything for users to be able to bridge their assets between VMs. However, there are some
considerations developers may take to enhance the representation of their assets in non-native VMs. These largely relate
to asset metadata and ensuring that bridging does not compromise critical user assumptions about asset ownership.

### EVMBridgedMetadata

Proposed in [@onflow/flow-nft/pull/203](https://github.com/onflow/flow-nft/pull/203), the `EVMBridgedMetadata` view
presents a mechanism to both represent metadata from bridged EVM assets as well as enable Cadence-native projects to
specify the representation of their assets in EVM. Implementing this view is not required for assets to be bridged, but
the bridge does default to it when available as a way to provide projects greater control over their EVM asset
definitions within the scope of ERC20 and ERC721 standards.

The interface for this view is as follows:

```cadence
access(all) struct URI: MetadataViews.File {
    /// The base URI prefix, if any. Not needed for all URIs, but helpful
    /// for some use cases For example, updating a whole NFT collection's
    /// image host easily
    access(all) let baseURI: String?
    /// The URI string value
    /// NOTE: this is set on init as a concatenation of the baseURI and the
    /// value if baseURI != nil
    access(self) let value: String

    access(all) view fun uri(): String
        
}

access(all) struct EVMBridgedMetadata {
    access(all) let name: String
    access(all) let symbol: String

    access(all) let uri: {MetadataViews.File}
}
```

This uri value could be a pointer to some offchain metadata if you expect your metadata to be static. Or you could
couple the `uri()` method with the utility contract below to serialize the onchain metadata on the fly.

### SerializeMetadata

The key consideration with respect to metadata is the distinct metadata storage patterns between ecosystem. It's
critical for NFT utility that the metadata be bridged in addition to the representation of the NFTs ownership. However,
it's commonplace for Cadence NFTs to store metadata onchain while EVM NFTs often store an onchain pointer to metadata
stored offchain. In order for Cadence NFTs to be properly represented in EVM platforms, the metadata must be bridged in
a format expected by those platforms and be done in a manner that also preserves the atomicity of bridge requests. The
path forward on this was decided to be a commitment of serialized Cadence NFT metadata into formats popular in the EVM
ecosystem.

For assets that do not implement `EVMBridgedMetadata`, the bridge will attempt to serialize the metadata of the asset as
a JSON data URL string. This is done via the [`SerializeMetadata`
contract](./cadence/contracts/utils/SerializeMetadata.cdc) which serializes metadata values into a JSON blob compatible
with the OpenSea metadata standard. The serialized metadata is then committed as the ERC721 `tokenURI` upon bridging
Cadence-native NFTs to EVM. Since Cadence NFTs can easily update onchain metadata either by field or by the ownership of
sub-NFTs, this serialization pattern enables token URI updates on subsequent bridge requests.

### Opting Out

It's also recognized that the logic of some use cases may actually be compromised by the act of bridging, particularly
in such a unique runtime environment. These would be cases that do not maintain ownership assumptions implicit to
ecosystem standards. For instance, an ERC721 implementation may reclaim a user's assets after a month of inactivity time
period. In such a case, bridging that ERC721 to Cadence would decouple the representation of ownership of the bridged
NFT from the actual ownership in the definining ERC721 contract after the token had been reclaimed - there would be no
NFT in escrow for the bridge to transfer on fulfillment of the NFT back to EVM. In such cases, projects may choose to
opt-out of bridging, but **importantly must do so before the asset has been onboarded to the bridge**.

For Solidity contracts, opting out is as simple as extending the [`BridgePermissions.sol` abstract
contract](./solidity/src/interfaces/BridgePermissions.sol) which defaults `allowsBridging()` to false. The bridge explicitly checks
for the implementation of `IBridgePermissions` and the value of `allowsBridging()` to validate that the contract has not
opted out of bridging.

Similarly, Cadence contracts can implement the [`IBridgePermissions.cdc` contract
interface](./cadence/contracts/bridge/interfaces/IBridgePermissions.cdc). This contract has a single method
`allowsBridging()` with a default implementation returning `false`. Again, the bridge explicitly checks for the
implementation of `IBridgePermissions` and the value of `allowsBridging()` to validate that the contract has not opted
out of bridging. Should you later choose to enable bridging, you can simply override the default implementation and
return true.

In both cases, `allowsBridging()` gates onboarding to the bridge. Once onboarded - **a permissionless operation anyone can
execute** - the value of `allowsBridging()` is irrelevant and assets can move between VMs permissionlessly.

## Under the Hood

For an in-depth look at the high-level architecture of the bridge, see [FLIP
#237](https://github.com/onflow/flips/blob/main/application/20231222-evm-vm-bridge.md)

## Local Development

The contracts in this repo are not yet included in the Flow emulator. For local development against the bridge, follow
the steps below to stand up a local Flow emulator instance and deploy the bridge contracts:

### Prerequisites

- Install Flow CLI on your machine. For instructions, see the [Flow CLI documentation](https://developers.flow.com/tools/flow-cli/install).
- Download and install Go. For instructions, see the [Go documentation](https://go.dev/doc/install).

Ensure both are installed with:

```sh
flow version
```

and go with:

```sh
go version
```

### Start your local emulator

Start the Flow emulator with the following command:

```sh
flow emulator
```

### Run the deployment script

In a separate terminal window, run the deployment script to deploy the bridge contracts to your local emulator:

```sh
go run main.go
```

If all is successful, you should see a long flow of event and transaction logs in your terminal with a final line resulting in:

```sh
SETUP COMPLETE! Bridge is now unpaused and ready for use.
```

### Interact with the bridge

You're now ready to interact with the bridge!

### Additional Resources

For the current state of Flow EVM across various task paths, see the following resources:

- [Flow EVM Equivalence forum post](https://forum.flow.com/t/evm-equivalence-on-flow-proposal-and-path-forward/5478)
- [EVM Integration FLIP #223](https://github.com/onflow/flips/pull/225/files)
- [Gateway & JSON RPC FLIP #235](https://github.com/onflow/flips/pull/235)




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/handled-tokens/USDCFlow.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "MetadataViews"
import "Burner"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeConfig"

/// USDCFlow
///
/// Defines the Cadence version of bridged Flow USDC. 
/// Before the Sept 4th, 2024 Crescendo migration, users can send
/// `FiatToken` vaults to the `USDCFlow.wrapFiatToken()` function
/// and receive `USDCFlow` vaults back with the exact same balance.

/// After the Crescendo migration, the `USDCFlow` smart contract
/// will integrate directly with the Flow VM bridge to become
/// the bridged version of Flow EVM USDC. These tokens will be backed
/// by real USDC via Flow EVM.

/// This is not the official Circle USDC, only a bridged version
/// that is still backed by official USDC on the other side of the bridge

access(all) contract USDCFlow: FungibleToken {

    /// Total supply of USDCFlows in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath

    /// The event that is emitted when new tokens are minted
    access(all) event Minted(amount: UFix64, mintedUUID: UInt64)
    access(all) event Burned(amount: UFix64, burntUUID: UInt64)

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "USDC (Flow)",
                    symbol: "USDCf",
                    description: "This fungible token representation of USDC is bridged from Flow EVM.",
                    externalURL: MetadataViews.ExternalURL("https://www.circle.com/en/usdc"),
                    logos: medias,
                    socials: {
                        "x": MetadataViews.ExternalURL("https://x.com/circle")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: USDCFlow.VaultStoragePath,
                    receiverPath: USDCFlow.ReceiverPublicPath,
                    metadataPath: USDCFlow.VaultPublicPath,
                    receiverLinkedType: Type<&USDCFlow.Vault>(),
                    metadataLinkedType: Type<&USDCFlow.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-USDCFlow.createEmptyVault(vaultType: Type<@USDCFlow.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: USDCFlow.totalSupply
                )
        }
        return nil
    }

    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        /// Initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        /// The total supply will only reflect the supply in the Cadence version
        /// of the USDCFlow smart contract
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                assert(USDCFlow.totalSupply >= self.balance, message: "Cannot burn more than the total supply")
                emit Burned(amount: self.balance, burntUUID: self.uuid)
                USDCFlow.totalSupply = USDCFlow.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        /// Returns whether the specified type can be deposited
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        access(all) fun createEmptyVault(): @USDCFlow.Vault {
            return <-create Vault(balance: 0.0)
        }

        /// withdraw
        /// @param amount: The amount of tokens to be withdrawn from the vault
        /// @return The Vault resource containing the withdrawn funds
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault} {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        /// @param from: The Vault resource containing the funds that will be deposited
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @USDCFlow.Vault
            self.balance = self.balance + vault.balance
            destroy vault
        }

        /// Gets an array of all the Metadata Views implemented by USDCFlow
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        access(all) view fun getViews(): [Type] {
            return USDCFlow.getContractViews(resourceType: nil)
        }

        /// Resolves Metadata Views out of the USDCFlow
        ///
        /// @param view: The Type of the desired view.
        /// @return A structure representing the requested view.
        ///
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return USDCFlow.resolveContractView(resourceType: nil, viewType: view)
        }
    }

    access(all) resource Minter: FlowEVMBridgeHandlerInterfaces.TokenMinter {

        /// Required function for the bridge to be able to work with the Minter
        access(all) view fun getMintedType(): Type {
            return Type<@USDCFlow.Vault>()
        }

        /// Function for the bridge to mint tokens that are bridged from Flow EVM
        access(FlowEVMBridgeHandlerInterfaces.Mint) fun mint(amount: UFix64): @{FungibleToken.Vault} {
            let newTotalSupply = USDCFlow.totalSupply + amount
            USDCFlow.totalSupply = newTotalSupply

            let vault <-create Vault(balance: amount)

            emit Minted(amount: amount, mintedUUID: vault.uuid)
            return <-vault
        }

        /// Function for the bridge to burn tokens that are bridged back to Flow EVM
        access(all) fun burn(vault: @{FungibleToken.Vault}) {
            let toBurn <- vault as! @USDCFlow.Vault
            let amount = toBurn.balance

            // This function updates USDCFlow.totalSupply
            Burner.burn(<-toBurn)
        }
    }

    /// Sends the USDCFlow Minter to the Flow/EVM bridge
    /// without giving any account access to the minter
    /// before it is safely in the decentralized bridge
    access(all) fun sendMinterToBridge(_ bridgeAddress: Address) {
        let minter <- create Minter()
        // borrow a reference to the bridge's configuration admin resource from public Capability
        let bridgeAdmin = getAccount(bridgeAddress).capabilities.borrow<&FlowEVMBridgeConfig.Admin>(
                FlowEVMBridgeConfig.adminPublicPath
            ) ?? panic("FlowEVMBridgeConfig.Admin could not be referenced from ".concat(bridgeAddress.toString()))
            
        // sets the USDCFlow as the minter resource for all USDCFlow bridge requests
        // prior to transferring the Minter, a TokenHandler will be set for USDCFlow during the bridge's initial
        // configuration, setting the stage for this minter to be sent.
        bridgeAdmin.setTokenHandlerMinter(targetType: Type<@USDCFlow.Vault>(), minter: <-minter)
    }

    /// createEmptyVault
    ///
    /// @return The new Vault resource with a balance of zero
    ///
    access(all) fun createEmptyVault(vaultType: Type): @Vault {
        let r <-create Vault(balance: 0.0)
        return <-r
    }

    init() {
        self.totalSupply = 0.0
        self.VaultStoragePath = /storage/usdcFlowVault
        self.VaultPublicPath = /public/usdcFlowMetadata
        self.ReceiverPublicPath = /public/usdcFlowReceiver

        let minter <- create Minter()
        self.account.storage.save(<-minter, to: /storage/usdcFlowMinter)

        // Create the Vault with the total supply of tokens and save it in storage.
        let vault <- create Vault(balance: self.totalSupply)
        self.account.storage.save(<-vault, to: self.VaultStoragePath)

        let tokenCap = self.account.capabilities.storage.issue<&USDCFlow.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(tokenCap, at: self.ReceiverPublicPath)
        self.account.capabilities.publish(tokenCap, at: self.VaultPublicPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/serialize_metadata_tests.cdc

```
import Test
import BlockchainHelpers

import "MetadataViews"

import "Serialize"
import "SerializeMetadata"

access(all) let admin = Test.getAccount(0x0000000000000008)
access(all) let alice = Test.createAccount()

access(all) var mintedBlockHeight: UInt64 = 0

access(all)
fun setup() {
    var err = Test.deployContract(
        name: "ExampleNFT",
        path: "../contracts/example-assets/ExampleNFT.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "Serialize",
        path: "../contracts/utils/Serialize.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
    err = Test.deployContract(
        name: "SerializeMetadata",
        path: "../contracts/utils/SerializeMetadata.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
}

access(all)
fun testSerializeNFTSucceeds() {
    let setupResult = executeTransaction(
        "../transactions/example-assets/example-nft/setup_collection.cdc",
        [],
        alice
    )
    Test.expect(setupResult, Test.beSucceeded())

    let mintResult = executeTransaction(
        "../transactions/example-assets/example-nft/mint_nft.cdc",
        [alice.address, "ExampleNFT", "Example NFT Collection", "https://flow.com/examplenft.jpg", [], [], []],
        admin
    )
    Test.expect(mintResult, Test.beSucceeded())

    let heightResult = executeScript(
        "./scripts/get_block_height.cdc",
        []
    )
    mintedBlockHeight = heightResult.returnValue! as! UInt64
    let heightString = mintedBlockHeight.toString()

    // Cadence dictionaries are not ordered by insertion order, so we need to check for both possible orderings
    let expectedPrefix = "data:application/json;utf8,{\"name\": \"ExampleNFT\", \"description\": \"Example NFT Collection\", \"image\": \"https://flow.com/examplenft.jpg\", \"external_url\": \"https://example-nft.onflow.org\", "
    let altSuffix1 = "\"attributes\": [{\"trait_type\": \"mintedBlock\", \"value\": \"".concat(heightString).concat("\"}, {\"trait_type\": \"foo\", \"value\": \"bar\"}]}")
    let altSuffix2 = "\"attributes\": [{\"trait_type\": \"foo\", \"value\": \"nil\"}, {\"trait_type\": \"mintedBlock\", \"value\": \"".concat(heightString).concat("\"}]}")

    let idsResult = executeScript(
        "../scripts/nft/get_ids.cdc",
        [alice.address, "cadenceExampleNFTCollection"]
    )
    Test.expect(idsResult, Test.beSucceeded())
    let ids = idsResult.returnValue! as! [UInt64]

    let serializeMetadataResult = executeScript(
        "../scripts/serialize/serialize_nft.cdc",
        [alice.address, "cadenceExampleNFTCollection", ids[0]]
    )
    Test.expect(serializeMetadataResult, Test.beSucceeded())

    let serializedMetadata = serializeMetadataResult.returnValue! as! String
    Test.assertEqual(true, serializedMetadata == expectedPrefix.concat(altSuffix1) || serializedMetadata == expectedPrefix.concat(altSuffix2))
}

// Returns nil when no displays are provided
access(all)
fun testSerializeNilDisplaysReturnsNil() {
    let serializedResult = SerializeMetadata.serializeFromDisplays(nftDisplay: nil, collectionDisplay: nil)
    Test.assertEqual(nil, serializedResult)
}

// Given just token-level Display, serialize as tokenURI format
access(all)
fun testSerializeNFTDisplaySucceeds() {
    let display = MetadataViews.Display(
        name: "NAME",
        description: "NFT Description",
        thumbnail: MetadataViews.HTTPFile(url: "https://flow.com/examplenft.jpg"),
    )

    let expected = "\"name\": \"NAME\", \"description\": \"NFT Description\", \"image\": \"https://flow.com/examplenft.jpg\""

    let serializedResult = SerializeMetadata.serializeFromDisplays(nftDisplay: display, collectionDisplay: nil)
    Test.assertEqual(expected, serializedResult!)
}

// Given just contract-level Display, serialize as contractURI format
access(all)
fun testSerializeNFTCollectionDisplaySucceeds() {
    let collectionDisplay = MetadataViews.NFTCollectionDisplay(
        name: "NAME",
        description: "NFT Description",
        externalURL: MetadataViews.ExternalURL("https://flow.com"),
        squareImage: MetadataViews.Media(file: MetadataViews.HTTPFile(url: "https://flow.com/square_image.jpg"), mediaType: "image"),
        bannerImage: MetadataViews.Media(file: MetadataViews.HTTPFile(url: "https://flow.com/square_image.jpg"), mediaType: "image"),
        socials: {}
    )

    let expected = "\"name\": \"NAME\", \"description\": \"NFT Description\", \"image\": \"https://flow.com/square_image.jpg\", \"external_link\": \"https://flow.com\""

    let serializedResult = SerializeMetadata.serializeFromDisplays(nftDisplay: nil, collectionDisplay: collectionDisplay)
    Test.assertEqual(expected, serializedResult!)
}

// Given bol token- & contract-level Displays, serialize as tokenURI format
access(all)
fun testSerializeBothDisplaysSucceeds() {
    let nftDisplay = MetadataViews.Display(
        name: "NAME",
        description: "NFT Description",
        thumbnail: MetadataViews.HTTPFile(url: "https://flow.com/examplenft.jpg"),
    )

    let collectionDisplay = MetadataViews.NFTCollectionDisplay(
        name: "NAME",
        description: "NFT Description",
        externalURL: MetadataViews.ExternalURL("https://flow.com"),
        squareImage: MetadataViews.Media(file: MetadataViews.HTTPFile(url: "https://flow.com/square_image.jpg"), mediaType: "image"),
        bannerImage: MetadataViews.Media(file: MetadataViews.HTTPFile(url: "https://flow.com/square_image.jpg"), mediaType: "image"),
        socials: {}
    )

    let expected = "\"name\": \"NAME\", \"description\": \"NFT Description\", \"image\": \"https://flow.com/examplenft.jpg\", \"external_url\": \"https://flow.com\""

    let serializedResult = SerializeMetadata.serializeFromDisplays(nftDisplay: nftDisplay, collectionDisplay: collectionDisplay)
    Test.assertEqual(expected, serializedResult!)
}


access(all)
fun testDeriveSymbolSucceeds() {
    let expectedSymbol = "TEST"

    var contractName = "Te_stContract"

    var symbolResult = SerializeMetadata.deriveSymbol(fromString: contractName)
    Test.assertEqual(expectedSymbol, symbolResult)

    contractName = "T_e_stContract"
    symbolResult = SerializeMetadata.deriveSymbol(fromString: contractName)
    Test.assertEqual(expectedSymbol, symbolResult)
    
    contractName = "_t_E_+*__&__stContract"
    symbolResult = SerializeMetadata.deriveSymbol(fromString: contractName)
    Test.assertEqual(expectedSymbol, symbolResult)
}

access(all)
fun testDeriveSymbolFromShortStringSucceeds() {
    let expectedSymbol = "C"

    let contractName = "c"

    var symbolResult = SerializeMetadata.deriveSymbol(fromString: contractName)
    Test.assertEqual(expectedSymbol, symbolResult)
}

access(all)
fun testToUpperSucceeds() {
    let expected = "BTC2"

    let contractName = " Btc2contract"

    let actual = SerializeMetadata.toUpperAlphaNumerical(contractName, upTo: 4)
    Test.assertEqual(expected, actual)
}

access(all)
fun testToUpperExceedingStringLengthSucceeds() {
    let expected = "BTC2CONTRACT"

    let contractName = " Btc2contract"

    let actual = SerializeMetadata.toUpperAlphaNumerical(contractName, upTo: contractName.length + 1)
    Test.assertEqual(expected, actual)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/CrossVMBridgeERC721Fulfillment.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ICrossVMBridgeERC721Fulfillment} from "./ICrossVMBridgeERC721Fulfillment.sol";
import {ICrossVMBridgeCallable} from "./CrossVMBridgeCallable.sol";
import {CrossVMBridgeCallable} from "./CrossVMBridgeCallable.sol";

/**
 * @title CrossVMBridgeERC721Fulfillment
 * @dev Related to https://github.com/onflow/flips/issues/318[FLIP-318] Cross VM NFT implementations
 * on Flow in the context of Cadence-native NFTs. The following base contract should be implemented to
 * integrate with the Flow VM bridge connecting Cadence & EVM implementations so that the canonical
 * VM bridge may move the Cadence NFT into EVM in a mint/escrow pattern.
 */
abstract contract CrossVMBridgeERC721Fulfillment is ICrossVMBridgeERC721Fulfillment, CrossVMBridgeCallable, ERC721 {

    /**
     * Initializes the bridge EVM address such that only the bridge COA can call privileged methods
     */
    constructor(address _vmBridgeAddress) CrossVMBridgeCallable(_vmBridgeAddress) {}

    /**
     * @dev Fulfills the bridge request, minting (if non-existent) or transferring (if escrowed) the
     * token with the given ID to the provided address. For dynamic metadata handling between
     * Cadence & EVM, implementations should override and assign metadata as encoded from Cadence
     * side. If overriding, be sure to preserve the mint/escrow pattern as shown in the default
     * implementation. See `_beforeFulfillment` and `_afterFulfillment` hooks to enable pre-and/or
     * post-processing without the need to override this function.
     * 
     * @param _to address of the token recipient
     * @param _id the id of the token being moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function fulfillToEVM(address _to, uint256 _id, bytes memory _data) external onlyVMBridge {
        _beforeFulfillment(_to, _id, _data); // hook allowing implementation to perform pre-fulfillment validation
        if (_ownerOf(_id) == address(0)) {
            _mint(_to, _id); // Doesn't exist, mint the token
        } else {
            // Should be escrowed under vm bridge - transfer from escrow to recipient
            _requireEscrowed(_id);
            safeTransferFrom(vmBridgeAddress(), _to, _id);
        }
        _afterFulfillment(_to, _id, _data); // hook allowing implementation to perform post-fulfillment processing
        emit FulfilledToEVM(_to, _id);
    }

    /**
     * @dev Returns whether the token is currently escrowed under custody of the designated VM bridge
     * 
     * @param _id the ID of the token in question
     */
    function isEscrowed(uint256 _id) public view returns (bool) {
        return _ownerOf(_id) == vmBridgeAddress();
    }

    /**
     * @dev Returns whether the token is exists or not defined positively by whether the owner of
     * the token is 0x0.
     * 
     * @param _id the ID of the token in question
     */
    function exists(uint256 _id) public view returns (bool) {
        return _ownerOf(_id) != address(0);
    }

    /**
     * @dev Allows a caller to determine the contract conforms to implemented interfaces
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(CrossVMBridgeCallable, ERC721, IERC165) returns (bool) {
        return interfaceId == type(ICrossVMBridgeERC721Fulfillment).interfaceId
            || interfaceId == type(ICrossVMBridgeCallable).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Internal method that reverts with FulfillmentFailedTokenNotEscrowed if the provided
     * token is not escrowed with the assigned vm bridge address as owner.
     * 
     * @param _id the token id that must be escrowed
     */
    function _requireEscrowed(uint256 _id) internal view {
        if (!isEscrowed(_id)) {
            revert FulfillmentFailedTokenNotEscrowed(_id, vmBridgeAddress());
        }
    }

    /**
     * @dev This internal method is included as a step implementations can override and have
     * executed in the default fullfillToEVM call.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _beforeFulfillment(address _to, uint256 _id, bytes memory _data) internal virtual {
        // No-op by default, meant to be overridden by implementations
    }

    /**
     * @dev This internal method is included as a step implementations can override and have
     * executed in the default fullfillToEVM call.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _afterFulfillment(address _to, uint256 _id, bytes memory _data) internal virtual {
        // No-op by default, meant to be overridden by implementations for things like processing
        // and setting metadata
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/testnet/EVMBridgedNFTTemplate.cdc

```
import NonFungibleToken from 0x631e88ae7f1d7c20
import MetadataViews from 0x631e88ae7f1d7c20
import ViewResolver from 0x631e88ae7f1d7c20
import FungibleToken from 0x9a0766d93b6608b7
import FlowToken from 0x7e60df042a9c0868

import EVM from 0x8c5303eaa26202d6

import ICrossVM from 0xdfc20aee650fcbdf
import ICrossVMAsset from 0xdfc20aee650fcbdf
import IEVMBridgeNFTMinter from 0xdfc20aee650fcbdf
import FlowEVMBridgeNFTEscrow from 0xdfc20aee650fcbdf
import FlowEVMBridgeConfig from 0xdfc20aee650fcbdf
import FlowEVMBridgeUtils from 0xdfc20aee650fcbdf
import FlowEVMBridge from 0xdfc20aee650fcbdf
import CrossVMNFT from 0xdfc20aee650fcbdf
import FlowEVMBridgeResolver from 0xdfc20aee650fcbdf

/// This contract is a template used by FlowEVMBridge to define EVM-native NFTs bridged from Flow EVM to Flow.
/// Upon deployment of this contract, the contract name is derived as a function of the asset type (here an ERC721 aka
/// an NFT) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC721 is transferred to the bridge's CadenceOwnedAccount EVM address and a new NFT is minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is locked
/// in NFT escrow and the ERC721 is transferred to the defined recipient. In this way, the Cadence token acts as a
/// representation of both the EVM NFT and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeNFTMinter, NonFungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmNFTContractAddress: EVM.EVMAddress
    /// Name of the NFT collection defined in the corresponding ERC721 contract
    access(all) let name: String
    /// Symbol of the NFT collection defined in the corresponding ERC721 contract
    access(all) let symbol: String
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Retain a Collection to reference when resolving Collection Metadata
    access(self) let collection: @Collection
    /// Mapping of token URIs indexed on their ERC721 ID. This would not normally be retained within a Cadence NFT
    /// contract, but since NFT metadata may be updated in EVM, it's retained here so that the bridge can update
    /// it against the source ERC721 contract which is treated as the NFT's source of truth.
    access(all) let tokenURIs: {UInt256: String}

    /// The NFT resource representing the bridged ERC721 token
    ///
    access(all) resource NFT : ICrossVMAsset.AssetInfo, CrossVMNFT.EVMNFT {
        /// The Cadence ID of the NFT
        access(all) let id: UInt64
        /// The ERC721 ID of the NFT
        access(all) let evmID: UInt256
        /// Additional onchain metadata
        access(all) let metadata: {String: AnyStruct}

        init(
            evmID: UInt256,
            metadata: {String: AnyStruct}
        ) {
            self.id = self.uuid
            self.evmID = evmID
            self.metadata = metadata
        }

        /// Returns the metadata view types supported by this NFT
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        access(all) view fun tokenURI(): String {
            return {{CONTRACT_NAME}}.tokenURIs[self.evmID] ?? ""
        }

        /// Resolves a metadata view for this NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let contractRef = {{CONTRACT_NAME}}.borrowThisContract()
                    return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<MetadataViews.Display>())
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionData>()
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionDisplay>()
                    )
                case Type<MetadataViews.EVMBridgedMetadata>():
                    return MetadataViews.EVMBridgedMetadata(
                        name: self.getName(),
                        symbol: self.getSymbol(),
                        uri: MetadataViews.URI(baseURI: nil, value: self.tokenURI())
                    )
            }
            return nil
        }

        /// public function that anyone can call to create a new empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- {{CONTRACT_NAME}}.createEmptyCollection(nftType: self.getType())
        }

        /* --- CrossVMNFT conformance --- */
        //
        /// Returns the EVM contract address of the NFT
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }
    }

    /// This resource holds associated NFTs, and serves queries about stored NFTs
    access(all) resource Collection : CrossVMNFT.EVMNFTCollection {
        /// dictionary of NFT conforming tokens indexed on their ID
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Mapping of EVM IDs to Flow NFT IDs
        access(contract) let evmIDToFlowID: {UInt256: UInt64}

        access(all) var storagePath: StoragePath
        access(all) var publicPath: PublicPath

        init () {
            self.ownedNFTs <- {}
            self.evmIDToFlowID = {}
            let collectionData = {{CONTRACT_NAME}}.resolveContractView(
                    resourceType: Type<@{{CONTRACT_NAME}}.NFT>(),
                    viewType: Type<MetadataViews.NFTCollectionData>()
                ) as! MetadataViews.NFTCollectionData?
                ?? panic("Could not resolve the collection data view for the NFT collection")
            self.storagePath = collectionData.storagePath
            self.publicPath = collectionData.publicPath
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        /// Returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            return { Type<@{{CONTRACT_NAME}}.NFT>(): true }
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           return type == Type<@{{CONTRACT_NAME}}.NFT>()
        }

        /// Removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// Withdraws an NFT from the collection by its EVM ID
        access(NonFungibleToken.Withdraw) fun withdrawByEVMID(_ id: UInt256): @{NonFungibleToken.NFT} {
            return <- self.withdraw(withdrawID: 
                self.getCadenceID(from: id) ?? panic("Could not withdraw an NFT with the provided EVM ID from the collection")
            )
        }

        /// Ttakes a NFT and adds it to the collections dictionary and adds the ID to the evmIDToFlowID mapping
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @{{CONTRACT_NAME}}.NFT

            // add the new token to the dictionary which removes the old one
            self.evmIDToFlowID[token.evmID] = token.id
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Returns an array of the EVM IDs that are in the collection
        access(all) view fun getEVMIDs(): [UInt256] {
            return self.evmIDToFlowID.keys
        }

        /// Returns the Cadence NFT.id for the given EVM NFT ID if it exists in the collection
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64? {
            if self.evmIDToFlowID[evmID] != nil {
                return self.evmIDToFlowID[evmID]
            } else if evmID < UInt256(UInt64.max) && self.borrowNFT(UInt64(evmID)) != nil {
                return UInt64(evmID)
            } else {
                return nil
            }
        }

        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        ///
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256? {
            if let nft = self.borrowNFT(cadenceID) {
                if let evmNFT = CrossVMNFT.getEVMID(from: nft) {
                    return evmNFT
                }
                return UInt256(nft.id)
            }
            return nil
        }

        /// Returns the contractURI for the NFT collection as defined in the source ERC721 contract. If none was
        /// defined at the time of bridging, an empty string is returned.
        access(all) view fun contractURI(): String? {
            return {{CONTRACT_NAME}}.contractURI
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        /// Retrieves a reference to the NFT stored in the collection by its ID
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            return &self.ownedNFTs[id] as &{ViewResolver.Resolver}? ?? nil
        }

        /// Creates an empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection}  {
            return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the NFT this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmNFTContractAddress
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let identifier = "{{CONTRACT_NAME}}Collection"
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: StoragePath(identifier: identifier)!,
                    publicPath: PublicPath(identifier: identifier)!,
                    publicCollection: Type<&{{CONTRACT_NAME}}.Collection>(),
                    publicLinkedType: Type<&{{CONTRACT_NAME}}.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let selfRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: selfRef, view: Type<MetadataViews.NFTCollectionDisplay>())
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint NFTs from bridge-defined NFT contracts
    ///
    access(account)
    fun mintNFT(id: UInt256, tokenURI: String): @NFT {
        pre {
            self.tokenURIs[id] == nil: "A token with the given ERC721 ID already exists"
        }
        self.tokenURIs[id] = tokenURI
        return <-create NFT(
            evmID: id,
            metadata: {
                "Bridged Block": getCurrentBlock().height,
                "Bridged Timestamp": getCurrentBlock().timestamp
            }
        )
    }

    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    ///
    access(account)
    fun updateTokenURI(evmID: UInt256, newURI: String) {
        pre {
            self.tokenURIs[evmID] != nil: "No token with the given ERC721 ID exists"
        }
        if self.tokenURIs[evmID] != newURI {
            self.tokenURIs[evmID] = newURI
        }
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmNFTContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.contractURI = contractURI
        self.tokenURIs = {}
        self.collection <- create Collection()

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.NFT>(), with: self.evmNFTContractAddress)
        FlowEVMBridgeNFTEscrow.initializeEscrow(
            forType: Type<@{{CONTRACT_NAME}}.NFT>(),
            name: name,
            symbol: symbol,
            erc721Address: self.evmNFTContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/onboarding/batch_onboard_by_evm_address.cdc

```
import "FungibleToken"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// This transaction onboards ERC20/ERC721 assets to the bridge, configuring the bridge to move assets between
/// environments
/// NOTE: This must be done before bridging a Cadence-native NFT to EVM
///
/// @param addressesAsHex: Array of EVM contract addresses defining the 
///     bridgeable asset to be onboarded
///
transaction(addressesAsHex: [String]) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        // Set a withdrawal limit for the provider
        let providerLimit = FlowEVMBridgeConfig.onboardFee * UFix64(addressesAsHex.length)
        let providerFilter = ScopedFTProviders.AllowanceFilter(providerLimit)
        // Create ScopedFTProvider to expire just after this transaction
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Iterate over provided array
        for addressHex in addressesAsHex {
            // Convert hex string to EVMAddress
            let address = EVM.addressFromString(addressHex)
            // Continue if the hex is not a valid EVM address or if the address is already onboarded
            if address == nil || FlowEVMBridge.evmAddressRequiresOnboarding(address!) != true {
                continue
            }

            FlowEVMBridge.onboardByEVMAddress(
                address!,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/.github/PULL_REQUEST_TEMPLATE.md

Closes: #???

## Description

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review.
-->

______

For contributor use:

- [ ] Targeted PR against `main` branch
- [ ] Linked to Github issue with discussion and accepted design OR link to spec that describes this work.
- [ ] Code follows the [standards mentioned here](https://github.com/onflow/flow-evm-bridge/blob/master/CONTRIBUTING.md#styleguides).
- [ ] Updated relevant documentation 
- [ ] Re-reviewed `Files changed` in the Github PR explorer
- [ ] Added appropriate labels 




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/IBridgePermissions.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

interface IBridgePermissions is IERC165 {
    /**
     * @dev Emitted when the permissions for the contract are updated.
     */
    event PermissionsUpdated(bool newPermissions);

    /**
     * @dev Returns true if the contract allows bridging of its assets.
     */
    function allowsBridging() external view returns (bool);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/is_nft_locked.cdc

```
import "NonFungibleToken"

import "FlowEVMBridgeNFTEscrow"
import "FlowEVMBridge"

/// Returns true if the NFT is locked in escrow and false otherwise.
///
/// @param nftTypeIdentifier: The type identifier of the NFT
/// @param id: The ID of the NFT
///
/// @return true if the NFT is locked in escrow and false otherwise
///
access(all) fun main(nftTypeIdentifier: String, id: UInt64): Bool {
    let type = CompositeType(nftTypeIdentifier) ?? panic("Malformed NFT type identifier=".concat(nftTypeIdentifier))
    return FlowEVMBridgeNFTEscrow.isLocked(type: type, id: id)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/get_gas_limit.cdc

```
import "FlowEVMBridgeConfig"

/// Returns the gas limit for the Flow-EVM bridge.
///
/// @returns The current gas limit shared by all the bridge-related EVM operations.
///
access(all)
fun main(): UInt64 {
    return FlowEVMBridgeConfig.gasLimit
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/create_account.cdc

```
import "Burner"
import "FungibleToken"
import "FlowToken"
import "EVM"

/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM
///
transaction(amount: UFix64) {
    let fundingVault: @FlowToken.Vault?
    let coa: &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability) &Account) {
        /* --- Configure COA --- */
        //
        // Ensure there is not yet a CadenceOwnedAccount in the standard path
        let coaPath = /storage/evm
        if signer.storage.type(at: coaPath) != nil {
            panic(
                "Object already exists in signer's account at path=".concat(coaPath.toString())
                .concat(". Make sure the signing account does not already have a CadenceOwnedAccount.")
            )
        }
        // COA not found in standard path, create and publish a public **unentitled** capability
        signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: coaPath)
        let coaCapability = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(coaPath)
        signer.capabilities.publish(coaCapability, at: /public/evm)

        // Borrow the CadenceOwnedAccount reference
        self.coa = signer.storage.borrow<&EVM.CadenceOwnedAccount>(
                from: coaPath
            ) ?? panic(
                "Could not find CadenceOwnedAccount (COA) in signer's account at path=".concat(coaPath.toString())
                .concat(". Make sure the signing account has initialized a COA at the expected path.")
            )

        /* --- Assign fundingVault --- */
        //
        if amount > 0.0 {
            // Reference the signer's FLOW vault & withdraw the funding amount
            let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
                ?? panic("Could not borrow a reference to the signer's FLOW vault from path=/storage/flowTokenVault")
            self.fundingVault <- vault.withdraw(amount: amount) as! @FlowToken.Vault
        } else {
            // No funding requested, so no need to withdraw from the vault
            self.fundingVault <- nil
        }
    }

    pre {
        self.fundingVault == nil || self.fundingVault?.balance ?? 0.0 == amount:
            "Mismatched funding vault acquired given requested amount=".concat(amount.toString())
    }

    execute {
        // Fund if necessary
        if self.fundingVault != nil || self.fundingVault?.balance ?? 0.0 > 0.0 {
            self.coa.deposit(from: <-self.fundingVault!)
        } else {
            Burner.burn(<-self.fundingVault)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/batch_bridge_nft_to_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges NFTs (from the same collection) from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftIdentifier: String, ids: [UInt64]) {

    let nftType: Type
    let collection: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")
        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        self.collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                .concat(collectionData.storagePath.toString()))

        // Withdraw the requested NFT & set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nftType)
            ?? panic("Bridge does not support the requested asset type ".concat(nftIdentifier))
        // Add the onboarding fee if onboarding is necessary
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nftType,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }

        // Iterate over requested IDs and bridge each NFT to the signer's COA in EVM
        for id in ids {
            // Withdraw the NFT & ensure it's the correct type
            let nft <-self.collection.withdraw(withdrawID: id)
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Execute the bridge to EVM for the current ID
            self.coa.depositNFT(
                nft: <-nft,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }

        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/fee/update_onboard_fee.cdc

```
import "FlowEVMBridgeConfig"

/// Sets the onboarding fee charged to onboard an asset to the bridge.
///
/// @param newFee: The fee paid to onboard an asset.
///
/// @emits FlowEVMBridgeConfig.BridgeFeeUpdated(old: FlowEVMBridgeConfig.onboardFee, new: newFee, isOnboarding: true)
///
transaction(newFee: UFix64) {

    let admin: auth(FlowEVMBridgeConfig.Fee) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeConfig.Fee) &FlowEVMBridgeConfig.Admin>(
                from: FlowEVMBridgeConfig.adminStoragePath
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        self.admin.updateOnboardingFee(newFee)
    }

    post {
        FlowEVMBridgeConfig.onboardFee == newFee: "Fee was not set correctly"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/ICrossVM.sol

```
pragma solidity 0.8.24;

interface ICrossVM {
    function getCadenceAddress() external view returns (string memory);
    function getCadenceIdentifier() external view returns (string memory);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/onboarding/batch_onboard_by_type.cdc

```
import "FungibleToken"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// This transaction onboards ERC20/ERC721 assets to the bridge, configuring the bridge to move assets between
/// environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param types: The Cadence types of the bridgeable asset to onboard to the bridge
///
transaction(types: [Type]) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        // Set a withdrawal limit for the provider
        let providerLimit = FlowEVMBridgeConfig.onboardFee * UFix64(types.length)
        let providerFilter = ScopedFTProviders.AllowanceFilter(providerLimit)
        // Create ScopedFTProvider to expire just after this transaction
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        for type in types { 
            // Continue on if the type does not require onboarding
            if FlowEVMBridge.typeRequiresOnboarding(type) != true {
                continue
            }
            // Onboard the asset Type
            FlowEVMBridge.onboardByType(
                type,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/FlowEVMBridgeHandlerInterfaces.cdc

```
import "FungibleToken"
import "NonFungibleToken"

import "EVM"

/// FlowEVMBridgeHandlerInterfaces
///
/// This contract defines the interfaces for the FlowEVM Bridge Handlers. These Handlers are intended to encapsulate
/// the logic for bridging edge case assets between Cadence and EVM and require configuration by the bridge account to
/// enable. Contracts implementing these resources should be deployed to the bridge account so that privileged methods,
/// particularly those related to fulfilling bridge requests remain in the closed loop of bridge contract logic and
/// defined assets in the custody of the bridge account.
///
access(all) contract FlowEVMBridgeHandlerInterfaces {

    /******************
        Entitlements
    *******************/

    /// Entitlement related to administrative setters
    access(all) entitlement Admin
    /// Entitlement related to minting handled assets
    access(all) entitlement Mint

    /*************
        Events
    **************/
    
    /// Event emitted when a handler is enabled between a Cadence type and an EVM address
    access(all) event HandlerEnabled(
        handlerType: String,
        handlerUUID: UInt64,
        targetType: String,
        targetEVMAddress: String
    )
    /// Event emitted when a handler is disabled, pausing bridging between VMs
    access(all) event HandlerDisabled(
        handlerType: String,
        handlerUUID: UInt64,
        targetType: String?,
        targetEVMAddress: String?
    )
    /// Emitted when a minter resource is set in a handler
    access(all) event MinterSet(handlerType: String,
        handlerUUID: UInt64,
        targetType: String?,
        targetEVMAddress: String?,
        minterType: String,
        minterUUID: UInt64
    )

    /****************
        Constructs
    *****************/
    
    /// Non-privileged interface for querying handler information
    ///
    access(all) resource interface HandlerInfo {
        /// Returns whether the Handler is enabled
        access(all) view fun isEnabled(): Bool
        /// Returns the Cadence type handled by the Handler, nil if not set
        access(all) view fun getTargetType(): Type?
        /// Returns the EVM address handled by the Handler, nil if not set
        access(all) view fun getTargetEVMAddress(): EVM.EVMAddress?
        /// Returns the Type of the expected minter if the handler utilizes one
        access(all) view fun getExpectedMinterType(): Type?
    }

    /// Administrative interface for Handler configuration
    ///
    access(all) resource interface HandlerAdmin : HandlerInfo {
        /// Sets the target Cadence Type handled by this resource. Once the targe type is set - whether by this method
        /// or on initialization - this setter will fail.
        access(Admin) fun setTargetType(_ type: Type) {
            pre {
                self.getTargetType() == nil: "Target Type has already been set"
            }
            post {
                self.getTargetType()! == type: "Problem setting target type"
            }
        }
        /// Sets the target EVM address handled by this resource
        access(Admin) fun setTargetEVMAddress(_ address: EVM.EVMAddress) {
            pre {
                self.getTargetEVMAddress() == nil: "Target EVM address has already been set"
            }
            post {
                self.getTargetEVMAddress()!.equals(address!): "Problem setting target EVM address"
            }
        }
        access(Admin) fun setMinter(_ minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}) {
            pre {
                self.getExpectedMinterType() == minter.getType(): "Minter is not of the expected type"
                minter.getMintedType() == self.getTargetType(): "Minter does not mint the target type"
                emit MinterSet(
                    handlerType: self.getType().identifier,
                    handlerUUID: self.uuid,
                    targetType: self.getTargetType()?.identifier,
                    targetEVMAddress: self.getTargetEVMAddress()?.toString(),
                    minterType: minter.getType().identifier,
                    minterUUID: minter.uuid
                )
            }
        }
        /// Enables the Handler to fulfill bridge requests for the configured targets. If implementers utilize a minter,
        /// they should additionally ensure the minter is set before enabling.
        access(Admin) fun enableBridging() {
            pre {
                self.getTargetType() != nil && self.getTargetEVMAddress() != nil:
                "Cannot enable before setting bridge target Type and EVM Address"
                !self.isEnabled(): "Handler has already been enabled"
            }
            post {
                self.isEnabled(): "Problem enabling Handler"
                emit HandlerEnabled(
                    handlerType: self.getType().identifier,
                    handlerUUID: self.uuid,
                    targetType: self.getTargetType()!.identifier,
                    targetEVMAddress: self.getTargetEVMAddress()!.toString()
                )
            }
        }

        /// Disables the Handler from fulfilling bridge requests.
        access(Admin) fun disableBridging() {
            pre {
                self.isEnabled():
                "Cannot disable: ".concat(self.getType().identifier).concat(" is already disabled")
            }
            post {
                !self.isEnabled():
                "Problem disabling ".concat(self.getType().identifier)
                emit HandlerDisabled(
                    handlerType: self.getType().identifier,
                    handlerUUID: self.uuid,
                    targetType: self.getTargetType()?.identifier,
                    targetEVMAddress: self.getTargetEVMAddress()?.toString()
                )
            }
        }
    }

    /// Minter interface for configurations requiring the minting of Cadence fungible tokens
    ///
    access(all) resource interface TokenMinter {
        /// Returns the Cadence type minted by this resource
        access(all) view fun getMintedType(): Type
        /// Mints the specified amount of tokens
        access(Mint) fun mint(amount: UFix64): @{FungibleToken.Vault} {
            pre {
                amount > 0.0: "Attempting to mint 0.0 - Amount minted must be greater than 0"
            }
            post {
                result.getType() == self.getMintedType():
                "TokenMinter ".concat(self.getType().identifier).concat(" with uuid ").concat(self.uuid.toString())
                    .concat(" expected to mint ").concat(self.getMintedType().identifier)
                    .concat(" but returned ").concat(result.getType().identifier)
                result.balance == amount:
                "Minted amount ".concat(result.balance.toString())
                    .concat(" does not match requested amount ").concat(amount.toString())
            }
        }
    }

    /// Handler interface for bridging FungibleToken assets. Implementations should be stored within the bridge account
    /// and called be the bridge contract for bridging operations on the Handler's target Type and EVM contract.
    ///
    access(all) resource interface TokenHandler : HandlerAdmin {
        /// Fulfills a request to bridge tokens from the Cadence side to the EVM side
        access(account) fun fulfillTokensToEVM(
            tokens: @{FungibleToken.Vault},
            to: EVM.EVMAddress
        ) {
            pre {
                self.isEnabled():
                "TokenHandler ".concat(self.getType().identifier).concat(" with uuid ")
                    .concat(self.uuid.toString()).concat(" is not yet enabled")
                tokens.getType() == self.getTargetType():
                "TokenHandler ".concat(self.getType().identifier).concat(" with uuid ").concat(self.uuid.toString())
                    .concat(" expects ").concat(self.getTargetType()?.identifier ?? "nil")
                    .concat(" but received ").concat(tokens.getType().identifier)
                tokens.balance > 0.0:
                "Attempting to bridge 0.0 tokens - zero amounts are unsupported"
            }
        }
        /// Fulfills a request to bridge tokens from the EVM side to the Cadence side
        access(account) fun fulfillTokensFromEVM(
            owner: EVM.EVMAddress,
            type: Type,
            amount: UInt256,
            protectedTransferCall: fun (): EVM.Result
        ): @{FungibleToken.Vault} {
            pre {
                self.isEnabled():
                "TokenHandler ".concat(self.getType().identifier).concat(" with uuid ")
                    .concat(self.uuid.toString()).concat(" is not yet enabled")
                amount > UInt256(0): "Attempting to bridge 0 tokens from EVM - zero amounts are unsupported"
            }
            post {
                result.getType() == self.getTargetType():
                "TokenHandler ".concat(self.getType().identifier).concat(" with uuid ").concat(self.uuid.toString())
                    .concat(" expected to return ").concat(self.getTargetType()?.identifier ?? "nil")
                    .concat(" but returned ").concat(result.getType().identifier)
            }
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/type_requires_onboarding_by_identifier.cdc

```
import "FlowEVMBridge"

/// Returns whether a type needs to be onboarded to the FlowEVMBridge
///
/// @param identifier: The identifier of the Cadence Type in question
///
/// @return Whether the type requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///
access(all) fun main(identifier: String): Bool? {
    if let type = CompositeType(identifier) {
        return FlowEVMBridge.typeRequiresOnboarding(type)
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/balance_of.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Returns the balance of the owner (hex-encoded EVM address) of a given ERC20 fungible token defined
/// at the hex-encoded EVM contract address
///
/// @param owner: The hex-encoded EVM address of the owner
/// @param evmContractAddress: The hex-encoded EVM contract address of the ERC20 contract
///
/// @return The balance of the address, reverting if the given contract address does not implement the ERC20 method
///     "balanceOf(address)(uint256)"
///
access(all) fun main(owner: String, evmContractAddress: String): UInt256 {
    return FlowEVMBridgeUtils.balanceOf(
        owner: EVM.addressFromString(owner),
        evmContractAddress: EVM.addressFromString(evmContractAddress)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/transfer_flow_from_coa_to_evm_address.cdc

```
import "EVM"

/// Transfers FLOW to another EVM address from the signer's COA
transaction(to: String, amount: UInt) {

    let recipient: EVM.EVMAddress
    let recipientPreBalance: UInt
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue) &Account) {
        self.recipient = EVM.addressFromString(to)
        self.recipientPreBalance = self.recipient.balance().attoflow
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("No COA found in signer's account")
    }

    execute {
        let res = self.coa.call(
            to: self.recipient,
            data: [],
            gasLimit: 100_000,
            value: EVM.Balance(attoflow: amount)
        )

        assert(res.status == EVM.Status.successful, message: "Failed to transfer FLOW to EVM address")
    }

    post {
        self.recipient.balance().attoflow == self.recipientPreBalance + amount:
            "Problem transferring value to EVM address"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/bridge_nft_to_any_cadence_address.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge.
/// Also know that the recipient Flow account must have a Receiver capable of receiving the this bridged NFT accessible
/// via published Capability at the token's standard path.
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
/// @param recipient: The Flow account address to receive the bridged NFT
///
transaction(nftIdentifier: String, id: UInt256, recipient: Address) {

    let nftType: Type
    let receiver: &{NonFungibleToken.Receiver}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the recipient's NFT Receiver --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        // Configure the signer's account for this NFT
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.receiver = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("Could not borrow NonFungibleToken Receiver from recipient's public capability path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged nft is the correct type
        assert(
            nft.getType() == self.nftType,
            message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                .concat(", received: ").concat(nft.getType().identifier)
        )
        // Deposit the bridged NFT into the signer's collection
        self.receiver.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/nft/has_collection_configured.cdc

```
import "NonFungibleToken"
import "MetadataViews"
import "ViewResolver"

import "FlowEVMBridgeUtils"

/// Returns true if the recipient has Collection configured for the provided NFT contract
///
/// @param nftIdentifier The type identifier of the NFT Collection to check for
/// @param recipient The address of the recipient
///
/// @returns true if the recipient has Collection configured for the provided NFT contract, false if not. Reverts if the
///     provided contract cannot be accessed or does not have default Collection storage information.
///
access(all)
fun main(nftIdentifier: String, recipient: Address): Bool {
    let nftType = CompositeType(nftIdentifier) ?? panic("Invalid nft identifier: ".concat(nftIdentifier))
    let contractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
        ?? panic("Could not find contract address for nft: ".concat(nftIdentifier))
    let contractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
        ?? panic("Could not find contract name for nft: ".concat(nftIdentifier))
    let nftContract = getAccount(contractAddress).contracts.borrow<&{NonFungibleToken}>(name: contractName)
        ?? panic("No such contract found")
    let collectionData = nftContract.resolveContractView(
            resourceType: nftType,
            viewType: Type<MetadataViews.NFTCollectionData>()
        ) as! MetadataViews.NFTCollectionData?
        ?? panic("FungibleToken does not provide default Collection data")
    return getAccount(recipient).capabilities.exists(collectionData.publicPath)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/IFlowEVMNFTBridge.cdc

```
import "FungibleToken"
import "NonFungibleToken"

import "EVM"

import "FlowEVMBridgeConfig"
import "CrossVMNFT"

access(all) contract interface IFlowEVMNFTBridge {
    
    /*************
        Events
    **************/

    /// Broadcasts an NFT was bridged from Cadence to EVM
    access(all)
    event BridgedNFTToEVM(
        type: String,
        id: UInt64,
        uuid: UInt64,
        evmID: UInt256,
        to: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )
    /// Broadcasts an NFT was bridged from EVM to Cadence
    access(all)
    event BridgedNFTFromEVM(
        type: String,
        id: UInt64,
        uuid: UInt64,
        evmID: UInt256,
        caller: String,
        evmContractAddress: String,
        bridgeAddress: Address
    )

    /**************
        Getters
    ***************/

    /// Returns the EVM address associated with the provided type
    ///
    access(all)
    view fun getAssociatedEVMAddress(with type: Type): EVM.EVMAddress?

    /// Returns the EVM address of the bridge coordinating COA
    ///
    access(all)
    view fun getBridgeCOAEVMAddress(): EVM.EVMAddress

    /********************************
        Public Bridge Entrypoints
    *********************************/

    /// Public entrypoint to bridge NFTs from Cadence to EVM.
    ///
    /// @param token: The NFT to be bridged
    /// @param to: The NFT recipient in FlowEVM
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    ///
    access(all)
    fun bridgeNFTToEVM(
        token: @{NonFungibleToken.NFT},
        to: EVM.EVMAddress,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
    ) {
        pre {
            emit BridgedNFTToEVM(
                type: token.getType().identifier,
                id: token.id,
                uuid: token.uuid,
                evmID: CrossVMNFT.getEVMID(from: &token as &{NonFungibleToken.NFT}) ?? UInt256(token.id),
                to: to.toString(),
                evmContractAddress: self.getAssociatedEVMAddress(with: token.getType())?.toString()
                    ?? panic(
                        "Could not find EVM Contract address associated with provided NFT identifier="
                        .concat(token.getType().identifier)
                    ),
                bridgeAddress: self.account.address
            )
        }
    }

    /// Public entrypoint to bridge NFTs from EVM to Cadence
    ///
    /// @param owner: The EVM address of the NFT owner. Current ownership and successful transfer (via 
    ///     `protectedTransferCall`) is validated before the bridge request is executed.
    /// @param type: The Cadence Type of the NFT to be bridged. If EVM-native, this would be the Cadence Type associated
    ///     with the EVM contract on the Flow side at onboarding.
    /// @param id: The NFT ID to bridged
    /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
    /// @param protectedTransferCall: A function that executes the transfer of the NFT from the named owner to the
    ///     bridge's COA. This function is expected to return a Result indicating the status of the transfer call.
    ///
    /// @returns The bridged NFT
    ///
    access(account)
    fun bridgeNFTFromEVM(
        owner: EVM.EVMAddress,
        type: Type,
        id: UInt256,
        feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider},
        protectedTransferCall: fun (): EVM.Result
    ): @{NonFungibleToken.NFT} {
        post {
            emit BridgedNFTFromEVM(
                type: result.getType().identifier,
                id: result.id,
                uuid: result.uuid,
                evmID: id,
                caller: owner.toString(),
                evmContractAddress: self.getAssociatedEVMAddress(with: result.getType())?.toString()
                    ?? panic("Could not find EVM Contract address associated with provided NFT"),
                bridgeAddress: self.account.address
            )
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/pause/update_bridge_pause_status.cdc

```
import "FlowEVMBridgeConfig"

/// Sets the pause status of the FlowEVM Bridge as specified, affecting cross-VM bridging globally via FlowEVMBridge.
///
/// @param pause: A boolean indicating whether the FlowEVM Bridge should be paused or unpaused.
///
/// @emits FlowEVMBridgeConfig.BridgePauseStatusUpdated(paused: true)
///
transaction(pause: Bool) {

    let admin: auth(FlowEVMBridgeConfig.Pause) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeConfig.Pause) &FlowEVMBridgeConfig.Admin>(from: FlowEVMBridgeConfig.adminStoragePath)
            ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        if pause {
            self.admin.pauseBridge()
        } else {
            self.admin.unpauseBridge()
        }
    }

    post {
        FlowEVMBridgeConfig.isPaused() == pause: "Problem updating pause status in FlowEVMBridgeConfig"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/IEVMBridgeNFTMinter.cdc

```
import "NonFungibleToken"

/// Contract interface enabling FlowEVMBridge to mint NFTs from implementing bridge contracts.
///
access(all)
contract interface IEVMBridgeNFTMinter {

    access(all) event Minted(type: String, id: UInt64, uuid: UInt64, evmID: UInt256, tokenURI: String, minter: Address)
    access(all) event TokenURIUpdated(evmID: UInt256, newURI: String, updater: Address)

    /// Account-only method to mint an NFT
    ///
    access(account)
    fun mintNFT(id: UInt256, tokenURI: String): @{NonFungibleToken.NFT} {
        post {
            emit Minted(
                type: result.getType().identifier,
                id: result.id,
                uuid: result.uuid,
                evmID: id,
                tokenURI: tokenURI,
                minter: self.account.address
            )
        }
    }

    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    ///
    access(account)
    fun updateTokenURI(evmID: UInt256, newURI: String) {
        post {
            emit TokenURIUpdated(evmID: evmID, newURI: newURI, updater: self.account.address)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/blocklist/unblock_cadence_type.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Unblocks the given Cadence Type from onboarding.
///
/// @param typeIdentifier: The Cadence identifier of the type to block
///
transaction(typeIdentifier: String) {

    let cadenceBlocklist: auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.CadenceBlocklist
    let type: Type

    prepare(signer: auth(BorrowValue) &Account) {
        self.cadenceBlocklist = signer.storage.borrow<auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.CadenceBlocklist>(
                from: /storage/cadenceBlocklist
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
        self.type = CompositeType(typeIdentifier) ?? panic("Invalid type identifier ".concat(typeIdentifier))
    }

    execute {
        self.cadenceBlocklist.unblock(self.type)
    }

    post {
        !FlowEVMBridgeConfig.isCadenceTypeBlocked(self.type): "Type was not unblocked"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeHandlers.cdc

```
import "Burner"
import "FungibleToken"
import "NonFungibleToken"
import "FlowToken"

import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// FlowEVMBridgeHandlers
///
/// This contract is responsible for defining and configuring bridge handlers for special cased assets.
///
access(all) contract FlowEVMBridgeHandlers {

    /**********************
        Contract Fields
    ***********************/

    /// The storage path for the HandlerConfigurator resource
    access(all) let ConfiguratorStoragePath: StoragePath

    /****************
        Constructs
    *****************/

    /// Handler for bridging Cadence native fungible tokens to EVM. In the event a Cadence project migrates native
    /// support to EVM, this Hander can be configured to facilitate bridging the Cadence tokens to EVM. This Handler
    /// then effectively allows the bridge to treat such tokens as bridge-defined on the Cadence side and EVM-native on
    /// the EVM side minting/burning in Cadence and escrowing in EVM.
    /// In order for this to occur, neither the Cadence token nor the EVM contract can be onboarded to the bridge - in
    /// essence, neither side of the asset can be onboarded to the bridge.
    /// The Handler must be configured in the bridge via the HandlerConfigurator. Once added, the bridge will filter
    /// requests to bridge the token Vault to EVM through this Handler which cannot be enabled until a target EVM
    /// address is set. Once the corresponding EVM contract address is known, it can be set and the Handler. It's also
    /// suggested that the Handler only be enabled once sufficient liquidity has been arranged in bridge escrow on the
    /// EVM side.
    ///
    access(all) resource CadenceNativeTokenHandler : FlowEVMBridgeHandlerInterfaces.TokenHandler {
        /// Flag determining if request handling is enabled
        access(self) var enabled: Bool
        /// The Cadence Type this handler fulfills requests for
        access(self) var targetType: Type
        /// The EVM contract address this handler fulfills requests for. This field is optional in the event the EVM
        /// contract address is not yet known but the Cadence type must still be filtered via Handler to prevent the
        /// type from being onboarded otherwise.
        access(self) var targetEVMAddress: EVM.EVMAddress?
        /// The expected minter type for minting tokens on fulfillment
        access(self) let expectedMinterType: Type
        /// The Minter enabling minting of Cadence tokens on fulfillment from EVM
        access(self) var minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}?

        init(targetType: Type, targetEVMAddress: EVM.EVMAddress?, expectedMinterType: Type) {
            pre {
                expectedMinterType.isSubtype(of: Type<@{FlowEVMBridgeHandlerInterfaces.TokenMinter}>()):
                    "Invalid minter type"
            }
            self.enabled = false
            self.targetType = targetType
            self.targetEVMAddress = targetEVMAddress
            self.expectedMinterType = expectedMinterType
            self.minter <- nil
        }

        /* --- HandlerInfo --- */

        /// Returns the enabled status of the handler
        access(all) view fun isEnabled(): Bool {
            return self.enabled
        }

        /// Returns the type of the asset the handler is configured to handle
        access(all) view fun getTargetType(): Type? {
            return self.targetType
        }

        /// Returns the EVM contract address the handler is configured to handle
        access(all) view fun getTargetEVMAddress(): EVM.EVMAddress? {
            return self.targetEVMAddress
        }

        /// Returns the expected minter type for the handler
        access(all) view fun getExpectedMinterType(): Type? {
            return self.expectedMinterType
        }

        /* --- TokenHandler --- */

        /// Fulfill a request to bridge tokens from Cadence to EVM, burning the provided Vault and transferring from
        /// EVM escrow to the named recipient. Assumes any fees are handled by the caller within the bridge contracts
        ///
        /// @param tokens: The Vault containing the tokens to bridge
        /// @param to: The EVM address to transfer the tokens to
        ///
        access(account)
        fun fulfillTokensToEVM(
            tokens: @{FungibleToken.Vault},
            to: EVM.EVMAddress
        ) {
            let evmAddress = self.getTargetEVMAddress()!

            // Get values from vault and burn
            let amount = tokens.balance
            let uintAmount = FlowEVMBridgeUtils.convertCadenceAmountToERC20Amount(amount, erc20Address: evmAddress)

            assert(uintAmount > UInt256(0), message: "Amount to bridge must be greater than 0")

            Burner.burn(<-tokens)

            FlowEVMBridgeUtils.mustTransferERC20(to: to, amount: uintAmount, erc20Address: evmAddress)
        }

        /// Fulfill a request to bridge tokens from EVM to Cadence, minting the provided amount of tokens in Cadence
        /// and transferring from the named owner to bridge escrow in EVM.
        ///
        /// @param owner: The EVM address of the owner of the tokens. Should also be the caller executing the protected
        ///              transfer call.
        /// @param type: The type of the asset being bridged
        /// @param amount: The amount of tokens to bridge
        ///
        /// @return The minted Vault containing the the requested amount of Cadence tokens
        ///
        access(account)
        fun fulfillTokensFromEVM(
            owner: EVM.EVMAddress,
            type: Type,
            amount: UInt256,
            protectedTransferCall: fun (): EVM.Result
        ): @{FungibleToken.Vault} {
            let evmAddress = self.getTargetEVMAddress()!

            // Convert the amount to a UFix64
            let ufixAmount = FlowEVMBridgeUtils.convertERC20AmountToCadenceAmount(
                    amount,
                    erc20Address: evmAddress
                )
            assert(ufixAmount > 0.0, message: "Amount to bridge must be greater than 0")

            FlowEVMBridgeUtils.mustEscrowERC20(
                owner: owner,
                amount: amount,
                erc20Address: evmAddress,
                protectedTransferCall: protectedTransferCall
            )

            // After state confirmation, mint the tokens and return
            let minter = self.borrowMinter()
                ?? panic("Cannot bridge - Minter not set in ".concat(self.getType().identifier))
            let minted <- minter.mint(amount: ufixAmount)
            return <-minted
        }

        /* --- Admin --- */

        /// Sets the target type for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setTargetType(_ type: Type) {
            self.targetType = type
        }

        /// Sets the target EVM address for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setTargetEVMAddress(_ address: EVM.EVMAddress) {
            self.targetEVMAddress = address
        }

        /// Sets the target type for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setMinter(_ minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}) {
            pre {
                self.minter == nil: "Minter has already been set in ".concat(self.getType().identifier)
            }
            self.minter <-! minter
        }

        /// Enables the handler for request handling.
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun enableBridging() {
            pre {
                self.minter != nil: "Cannot enable ".concat(self.getType().identifier).concat(" without a minter")
            }
            self.enabled = true
        }

        /// Disables the handler for request handling.
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun disableBridging() {
            self.enabled = false
        }

        /* --- Internal --- */

        /// Returns an entitled reference to the encapsulated minter resource
        access(self)
        view fun borrowMinter(): auth(FlowEVMBridgeHandlerInterfaces.Mint) &{FlowEVMBridgeHandlerInterfaces.TokenMinter}? {
            return &self.minter
        }
    }

    /// Facilitates moving Flow between Cadence and EVM as WFLOW. Since WFLOW is an artifact of the EVM ecosystem, 
    /// wrapping the native token as an ERC20, it does not have a place in Cadence's fungible token ecosystem.
    /// Given the native interface on EVM.CadenceOwnedAccount and EVM.EVMAddress to move FLOW between Cadence and EVM,
    /// this handler treats requests to bridge FLOW as WFLOW as a special case.
    ///
    access(all) resource WFLOWTokenHandler : FlowEVMBridgeHandlerInterfaces.TokenHandler {
        /// Flag determining if request handling is enabled
        access(self) var enabled: Bool
        /// The Cadence Type this handler fulfills requests for
        access(self) var targetType: Type
        /// The EVM contract address this handler fulfills requests for
        access(self) var targetEVMAddress: EVM.EVMAddress

        init(wflowEVMAddress: EVM.EVMAddress) {
            self.enabled = false
            self.targetType = Type<@FlowToken.Vault>()
            self.targetEVMAddress = wflowEVMAddress
        }

        /// Returns whether the Handler is enabled
        access(all) view fun isEnabled(): Bool {
            return self.enabled
        }
        /// Returns the Cadence type handled by the Handler, nil if not set
        access(all) view fun getTargetType(): Type? {
            return self.targetType
        }
        /// Returns the EVM address handled by the Handler, nil if not set
        access(all) view fun getTargetEVMAddress(): EVM.EVMAddress? {
            return self.targetEVMAddress
        }
        /// Returns nil as this handler simply unwraps WFLOW to FLOW
        access(all) view fun getExpectedMinterType(): Type? {
            return nil
        }

        /* --- TokenHandler --- */

        /// Fulfill a request to bridge tokens from Cadence to EVM, burning the provided Vault and transferring from
        /// EVM escrow to the named recipient. Assumes any fees are handled by the caller within the bridge contracts
        ///
        /// @param tokens: The Vault containing the tokens to bridge
        /// @param to: The EVM address to transfer the tokens to
        ///
        access(account)
        fun fulfillTokensToEVM(
            tokens: @{FungibleToken.Vault},
            to: EVM.EVMAddress
        ) {
            let flowVault <- tokens as! @FlowToken.Vault
            let wflowAddress = self.getTargetEVMAddress()!

            // Get balance from vault
            let balance = flowVault.balance
            let uintAmount = FlowEVMBridgeUtils.convertCadenceAmountToERC20Amount(balance, erc20Address: wflowAddress)

            // Deposit to bridge COA
            let coa = FlowEVMBridgeUtils.borrowCOA()
            coa.deposit(from: <-flowVault)

            let preBalance = FlowEVMBridgeUtils.balanceOf(owner: coa.address(), evmContractAddress: wflowAddress)

            // Wrap the deposited FLOW as WFLOW, giving the bridge COA the necessary WFLOW to transfer
            let wrapResult = FlowEVMBridgeUtils.call(
                signature: "deposit()",
                targetEVMAddress: wflowAddress,
                args: [],
                gasLimit: FlowEVMBridgeConfig.gasLimit,
                value: balance
            )
            assert(wrapResult.status == EVM.Status.successful, message: "Failed to wrap FLOW as WFLOW")
            
            let postBalance = FlowEVMBridgeUtils.balanceOf(owner: coa.address(), evmContractAddress: wflowAddress)

            // Cover underflow
            assert(
                postBalance > preBalance,
                message: "Escrowed WFLOW balance did not increment after wrapping FLOW - pre: "
                    .concat(preBalance.toString()).concat(" | post: ").concat(postBalance.toString())
            )
            // Confirm bridge COA's WFLOW balance has incremented by the expected amount
            assert(
                postBalance - preBalance == uintAmount,
                message: "Escrowed WFLOW balance after wrapping does not match requested amount - expected: "
                    .concat((preBalance + uintAmount).toString())
                    .concat(" | actual: ")
                    .concat((postBalance - preBalance).toString())
            )

            // Transfer WFLOW to recipient
            FlowEVMBridgeUtils.mustTransferERC20(to: to, amount: uintAmount, erc20Address: wflowAddress)
        }

        /// Fulfill a request to bridge tokens from EVM to Cadence, minting the provided amount of tokens in Cadence
        /// and transferring from the named owner to bridge escrow in EVM.
        ///
        /// @param owner: The EVM address of the owner of the tokens. Should also be the caller executing the protected
        ///              transfer call.
        /// @param type: The type of the asset being bridged
        /// @param amount: The amount of tokens to bridge
        ///
        /// @return The minted Vault containing the the requested amount of Cadence tokens
        ///
        access(account)
        fun fulfillTokensFromEVM(
            owner: EVM.EVMAddress,
            type: Type,
            amount: UInt256,
            protectedTransferCall: fun (): EVM.Result
        ): @{FungibleToken.Vault} {
            let wflowAddress = self.getTargetEVMAddress()!

            // Convert the amount to a UFix64
            let ufixAmount = FlowEVMBridgeUtils.convertERC20AmountToCadenceAmount(
                    amount,
                    erc20Address: wflowAddress
                )
            assert(
                ufixAmount > 0.0,
                message: "Requested UInt256 amount ".concat(amount.toString()).concat(" converted to 0.0 ")
                    .concat(" - try bridging a larger amount to avoid UFix64 precision loss during conversion")
            )

            // Transfers WFLOW to bridge COA as escrow
            FlowEVMBridgeUtils.mustEscrowERC20(
                owner: owner,
                amount: amount,
                erc20Address: wflowAddress,
                protectedTransferCall: protectedTransferCall
            )

            // Get the bridge COA's FLOW balance before unwrapping WFLOW
            let coa = FlowEVMBridgeUtils.borrowCOA()
            let preBalance = coa.balance().attoflow

            // Unwrap the transferred WFLOW to FLOW, giving the bridge COA the necessary FLOW to withdraw from EVM
            let unwrapResult = FlowEVMBridgeUtils.call(
                signature: "withdraw(uint256)",
                targetEVMAddress: wflowAddress,
                args: [amount],
                gasLimit: FlowEVMBridgeConfig.gasLimit,
                value: 0.0
            )
            assert(unwrapResult.status == EVM.Status.successful, message: "Failed to unwrap WFLOW as FLOW")

            let postBalance = coa.balance().attoflow

            // Cover underflow
            assert(
                postBalance > preBalance,
                message: "Escrowed FLOW Balance did not increment after unwrapping WFLOW - pre: ".concat(preBalance.toString())
                    .concat(" | post: ").concat(postBalance.toString())
            )
            // Confirm bridge COA's FLOW balance has incremented by the expected amount
            assert(
                UInt256(postBalance - preBalance) == amount,
                message: "Escrowed WFLOW balance after unwrapping does not match requested amount - expected: "
                    .concat((UInt256(preBalance) + amount).toString())
                    .concat(" | actual: ")
                    .concat((postBalance - preBalance).toString())
            )

            // Withdraw escrowed FLOW from bridge COA
            let withdrawBalance = EVM.Balance(attoflow: UInt(amount))
            assert(
                UInt256(withdrawBalance.attoflow) == amount,
                message: "Requested balance failed to convert to attoflow - expected: "
                    .concat(amount.toString())
                    .concat(" | actual: ")
                    .concat(withdrawBalance.attoflow.toString())
            )
            let flowVault <- coa.withdraw(balance: withdrawBalance)
            assert(
                flowVault.balance == ufixAmount,
                message: "Resulting FLOW Vault balance does not match requested amount - expected: "
                    .concat(ufixAmount.toString())
                    .concat(" | actual: ")
                    .concat(flowVault.balance.toString())
            )
            return <-flowVault
        }

        /* --- HandlerAdmin --- */
        // Conforms to HandlerAdmin for enableBridging, but most of the methods are unnecessary given the strict
        // association between FLOW and WFLOW

        /// Sets the target type for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setTargetType(_ type: Type) {
            panic("WFLOWTokenHandler has targetType set to "
                .concat(self.targetType.identifier).concat(" at initialization"))
        }

        /// Sets the target EVM address for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setTargetEVMAddress(_ address: EVM.EVMAddress) {
            panic("WFLOWTokenHandler has EVMAddress set to "
                .concat(self.targetEVMAddress.toString()).concat(" at initialization"))
        }

        /// Sets the target type for the handler
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun setMinter(_ minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}) {
            panic("WFLOWTokenHandler does not utilize a minter")
        }

        /// Enables the handler for request handling. The
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun enableBridging() {
            self.enabled = true
        }

        /// Disables the handler for request handling.
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun disableBridging() {
            self.enabled = false
        }
    }

    /// This resource enables the configuration of Handlers. These Handlers are stored in FlowEVMBridgeConfig from which
    /// further setting and getting can be executed.
    ///
    access(all) resource HandlerConfigurator {
        /// Creates a new Handler and adds it to the bridge configuration
        ///
        /// @param handlerType: The type of handler to create as defined in this contract
        /// @param targetType: The type of the asset the handler will handle
        /// @param targetEVMAddress: The EVM contract address the handler will handle, can be nil if still unknown
        /// @param expectedMinterType: The Type of the expected minter to be set for the created TokenHandler
        ///
        access(FlowEVMBridgeHandlerInterfaces.Admin)
        fun createTokenHandler(
            handlerType: Type,
            targetType: Type,
            targetEVMAddress: EVM.EVMAddress?,
            expectedMinterType: Type?
        ) {
            switch handlerType {
                case Type<@CadenceNativeTokenHandler>():
                    assert(
                        expectedMinterType != nil,
                        message: "CadenceNativeTokenHandler requires an expected minter type but received nil"
                    )
                    let handler <-create CadenceNativeTokenHandler(
                        targetType: targetType,
                        targetEVMAddress: targetEVMAddress,
                        expectedMinterType: expectedMinterType!
                    )
                    FlowEVMBridgeConfig.addTokenHandler(<-handler)
                case Type<@WFLOWTokenHandler>():
                    assert(
                        targetEVMAddress != nil,
                        message: "WFLOWTokenHandler requires a target EVM address but received nil"
                    )
                    let handler <-create WFLOWTokenHandler(wflowEVMAddress: targetEVMAddress!)
                    FlowEVMBridgeConfig.addTokenHandler(<-handler)
                default:
                    panic("Invalid Handler type requested")
            }
        }
    }

    init() {
        self.ConfiguratorStoragePath = /storage/BridgeHandlerConfigurator
        self.account.storage.save(<-create HandlerConfigurator(), to: self.ConfiguratorStoragePath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/get_locked_token_balance.cdc

```
import "FlowEVMBridgeTokenEscrow"

/// Returns the balance of a given FungibleToken Vault type locked in escrow or nil if a vault of the given type is not
/// locked in escrow
///
/// @param vaultTypeIdentifier: The type identifier of the FungibleToken Vault
///
access(all) fun main(vaultTypeIdentifier: String): UFix64? {
    let tokenType = CompositeType(vaultTypeIdentifier) ?? panic("Malformed Vault type identifier=".concat(vaultTypeIdentifier))
    return FlowEVMBridgeTokenEscrow.getLockedTokenBalance(tokenType: tokenType)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/testing/EVMBridgedTokenTemplate.cdc

```
import NonFungibleToken from 0x0000000000000001
import MetadataViews from 0x0000000000000001
import FungibleTokenMetadataViews from 0x0000000000000002
import ViewResolver from 0x0000000000000001
import FungibleToken from 0x0000000000000002
import FlowToken from 0x0000000000000003

import EVM from 0x0000000000000001

import ICrossVM from 0x0000000000000007
import ICrossVMAsset from 0x0000000000000007
import IEVMBridgeTokenMinter from 0x0000000000000007
import FlowEVMBridgeTokenEscrow from 0x0000000000000007
import FlowEVMBridgeConfig from 0x0000000000000007
import FlowEVMBridgeUtils from 0x0000000000000007
import FlowEVMBridge from 0x0000000000000007
import CrossVMToken from 0x0000000000000007
import FlowEVMBridgeResolver from 0x0000000000000007

/// This contract is a template used by FlowEVMBridge to define EVM-native fungible tokens bridged from Flow EVM to 
/// Cadence. Upon deployment of this contract, the contract name is derived as a function of the asset type (here an 
/// ERC20) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC20 is transferred to the bridge's CadenceOwnedAccount EVM address and tokens are minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is burned
/// in this contract and the ERC20 is transferred to the defined recipient. In this way, the Cadence Vault acts as a
/// representation of both the EVM tokens and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeTokenMinter, FungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmTokenContractAddress: EVM.EVMAddress
    /// Name of the fungible token defined in the corresponding ERC20 contract
    access(all) let name: String
    /// Symbol of the fungible token defined in the corresponding ERC20 contract
    access(all) let symbol: String
    /// Decimal place value defined in the source ERC20 contract
    access(all) let decimals: UInt8
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Total supply of this Cadence token in circulation
    /// NOTE: This does not reflect the total supply of the source ERC20 in circulation within EVM
    access(all) var totalSupply: UFix64
    /// Retain a Vault to reference when resolving Vault Metadata
    access(self) let vault: @Vault

    /// The Vault resource representing the bridged ERC20 token
    ///
    access(all) resource Vault : ICrossVMAsset.AssetInfo, CrossVMToken.EVMTokenInfo, FungibleToken.Vault {
        /// Balance of the tokens in a given Vault
        access(all) var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        /* --- CrossVMToken.EVMFTVault conformance --- */
        //
        /// Gets the ERC20 name value
        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8 {
            return {{CONTRACT_NAME}}.decimals
        }
        /// Returns the EVM contract address of the fungible token
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }

        access(all) view fun getViews(): [Type] {
            return {{CONTRACT_NAME}}.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return {{CONTRACT_NAME}}.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return { self.getType(): true }
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @Vault {
            return <-create Vault(balance: 0.0)
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                {{CONTRACT_NAME}}.totalSupply = {{CONTRACT_NAME}}.totalSupply - self.balance
            }
            self.balance = 0.0
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero and returns it to the calling context. A user must call
    /// this function and store the returned Vault in their storage in order to allow their account to be able to
    /// receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{{CONTRACT_NAME}}.Vault {
        return <- create Vault(balance: 0.0)
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the fungible token this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmTokenContractAddress
    }

    /// Function that returns all the Metadata Views implemented by this fungible token contract.
    ///
    /// @return An array of Types defining the implemented views. This value will be used by developers to know which
    ///         parameter to pass to the resolveContractView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    ///
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let contractRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<FungibleTokenMetadataViews.FTDisplay>())
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/{{CONTRACT_NAME}}Vault,
                    receiverPath: /public/{{CONTRACT_NAME}}Receiver,
                    metadataPath: /public/{{CONTRACT_NAME}}Vault,
                    receiverLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    metadataLinkedType: Type<&{{CONTRACT_NAME}}.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-self.createEmptyVault(vaultType: Type<@{{CONTRACT_NAME}}.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: self.totalSupply
                )
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint tokens from bridge-defined fungible token contracts
    ///
    access(account) fun mintTokens(amount: UFix64): @{FungibleToken.Vault} {
        self.totalSupply = self.totalSupply + amount
        return <- create Vault(balance: amount)
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, decimals: UInt8, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmTokenContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.contractURI = contractURI
        self.totalSupply = 0.0
        self.vault <- create Vault(balance: 0.0)

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.Vault>(), with: self.evmTokenContractAddress)
        FlowEVMBridgeTokenEscrow.initializeEscrow(
            with: <-create Vault(balance: 0.0),
            name: name,
            symbol: symbol,
            decimals: decimals,
            evmTokenAddress: self.evmTokenContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/set_handler_target_evm_address.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeConfig"

/// Sets the target EVM address for the associated type in the configured TokenHandler
///
/// @param targetTypeIdentifier: The identifier of the target type.
/// @param targetEVMAddressHex: The EVM address of the target EVM contract.
///
transaction(targetTypeIdentifier: String, targetEVMAddressHex: String) {

    let admin: auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin>(
                from: FlowEVMBridgeConfig.adminStoragePath
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        let targetType = CompositeType(targetTypeIdentifier)
            ?? panic("Invalid Type identifier provided")
        let targetEVMAddress = EVM.addressFromString(targetEVMAddressHex)
        self.admin.setHandlerTargetEVMAddress(
            targetType: targetType,
            targetEVMAddress: targetEVMAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/set_token_handler_minter.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeHandlers"
import "FlowEVMBridgeConfig"

/// Sets the minter
///
/// @param vaultIdentifier: The type identifier of the vault to create the TokenHandler for
/// @param minterStoragePath: The type identifier of the TokenMinter implementing resource
///
transaction(vaultIdentifier: String, minterStoragePath: StoragePath, adminAddress: Address) {

    let configAdmin: &FlowEVMBridgeConfig.Admin
    let minter: @{FlowEVMBridgeHandlerInterfaces.TokenMinter}

    prepare(signer: auth(LoadValue) &Account) {
        self.configAdmin = getAccount(adminAddress).capabilities.borrow<&FlowEVMBridgeConfig.Admin>(
                FlowEVMBridgeConfig.adminPublicPath
            ) ?? panic("Could not borrow reference to FlowEVMBridgeConfig.Admin")
        self.minter <- signer.storage.load<@{FlowEVMBridgeHandlerInterfaces.TokenMinter}>(from: minterStoragePath)
            ?? panic("No minter found at provided storage path")
    }

    execute {
        let targetType = CompositeType(vaultIdentifier)
            ?? panic("Invalid vault identifier")
        self.configAdmin.setTokenHandlerMinter(targetType: targetType, minter: <-self.minter)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/batch_get_associated_evm_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns the EVM addresses associated with given Cadence types (as identifier String)
///
/// @param typeIdentifiers: The Cadence type identifier Strings
///
/// @return The EVM addresses as hex strings indexed on the associated Cadence type identifier string if the type has an
///      associated EVMAddress, otherwise nil
access(all)
fun main(identifiers: [String]): {String: String?} {
    let res: {String: String?} = {}
    for identifier in identifiers {
        // skip if already processed
        if res[identifier] != nil {
            continue
        }

        if let type = CompositeType(identifier) {
            if let address = FlowEVMBridgeConfig.getEVMAddressAssociated(with: type) {
                res.insert(key: identifier, address.toString())
            }
        }
    }
    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/nft/get_ids.cdc

```
import "NonFungibleToken"

/// Returns the IDs of all the NFTs in a collection
///
/// @param address: The address of the account that owns the collection
/// @param collectionPathIdentifier: The identifier of the collection's storage path
///
/// @returns An array of the UInt64 IDs of all the NFTs in the collection or nil if the account is not configured
///     with a Collection at the given path
///
access(all) fun main(address: Address, collectionPathIdentifier: String): [UInt64]? {
    let path = StoragePath(identifier: collectionPathIdentifier) ?? panic("Malformed StoragePath identifier")
    return getAuthAccount<auth(BorrowValue) &Account>(address).storage.borrow<&{NonFungibleToken.Collection}>(
            from: path
        )?.getIDs()
        ?? nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/disable_token_handler.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeConfig"

/// Disables the TokenHandler from fulfilling bridge requests.
///
/// @param targetTypeIdentifier: The identifier of the handler's target type.
///
transaction(targetTypeIdentifier: String) {

    let admin: auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin>(
                from: FlowEVMBridgeConfig.adminStoragePath
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        let targetType = CompositeType(targetTypeIdentifier)
            ?? panic("Invalid Type identifier provided")
        self.admin.disableHandler(targetType: targetType)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/transactions/deploy_using_evm_deployer.cdc

```
import "EVMDeployer"

transaction(name: String, bytecode: String, value: UInt) {
    prepare(signer: &Account) {}

    execute {
        EVMDeployer.deploy(name: name, bytecode: bytecode, value: value)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/testing/EVMBridgedNFTTemplate.cdc

```
import NonFungibleToken from 0x0000000000000001
import MetadataViews from 0x0000000000000001
import ViewResolver from 0x0000000000000001
import FungibleToken from 0x0000000000000002
import FlowToken from 0x0000000000000003

import EVM from 0x0000000000000001

import ICrossVM from 0x0000000000000007
import ICrossVMAsset from 0x0000000000000007
import IEVMBridgeNFTMinter from 0x0000000000000007
import FlowEVMBridgeNFTEscrow from 0x0000000000000007
import FlowEVMBridgeConfig from 0x0000000000000007
import FlowEVMBridgeUtils from 0x0000000000000007
import FlowEVMBridge from 0x0000000000000007
import CrossVMNFT from 0x0000000000000007
import FlowEVMBridgeResolver from 0x0000000000000007

/// This contract is a template used by FlowEVMBridge to define EVM-native NFTs bridged from Flow EVM to Flow.
/// Upon deployment of this contract, the contract name is derived as a function of the asset type (here an ERC721 aka
/// an NFT) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC721 is transferred to the bridge's CadenceOwnedAccount EVM address and a new NFT is minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is locked
/// in NFT escrow and the ERC721 is transferred to the defined recipient. In this way, the Cadence token acts as a
/// representation of both the EVM NFT and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeNFTMinter, NonFungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmNFTContractAddress: EVM.EVMAddress
    /// Name of the NFT collection defined in the corresponding ERC721 contract
    access(all) let name: String
    /// Symbol of the NFT collection defined in the corresponding ERC721 contract
    access(all) let symbol: String
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Retain a Collection to reference when resolving Collection Metadata
    access(self) let collection: @Collection
    /// Mapping of token URIs indexed on their ERC721 ID. This would not normally be retained within a Cadence NFT
    /// contract, but since NFT metadata may be updated in EVM, it's retained here so that the bridge can update
    /// it against the source ERC721 contract which is treated as the NFT's source of truth.
    access(all) let tokenURIs: {UInt256: String}

    /// The NFT resource representing the bridged ERC721 token
    ///
    access(all) resource NFT : ICrossVMAsset.AssetInfo, CrossVMNFT.EVMNFT {
        /// The Cadence ID of the NFT
        access(all) let id: UInt64
        /// The ERC721 ID of the NFT
        access(all) let evmID: UInt256
        /// Additional onchain metadata
        access(all) let metadata: {String: AnyStruct}

        init(
            evmID: UInt256,
            metadata: {String: AnyStruct}
        ) {
            self.id = self.uuid
            self.evmID = evmID
            self.metadata = metadata
        }

        /// Returns the metadata view types supported by this NFT
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        access(all) view fun tokenURI(): String {
            return {{CONTRACT_NAME}}.tokenURIs[self.evmID] ?? ""
        }

        /// Resolves a metadata view for this NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let contractRef = {{CONTRACT_NAME}}.borrowThisContract()
                    return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<MetadataViews.Display>())
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionData>()
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionDisplay>()
                    )
                case Type<MetadataViews.EVMBridgedMetadata>():
                    return MetadataViews.EVMBridgedMetadata(
                        name: self.getName(),
                        symbol: self.getSymbol(),
                        uri: MetadataViews.URI(baseURI: nil, value: self.tokenURI())
                    )
            }
            return nil
        }

        /// public function that anyone can call to create a new empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- {{CONTRACT_NAME}}.createEmptyCollection(nftType: self.getType())
        }

        /* --- CrossVMNFT conformance --- */
        //
        /// Returns the EVM contract address of the NFT
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }
    }

    /// This resource holds associated NFTs, and serves queries about stored NFTs
    access(all) resource Collection : CrossVMNFT.EVMNFTCollection {
        /// dictionary of NFT conforming tokens indexed on their ID
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Mapping of EVM IDs to Flow NFT IDs
        access(contract) let evmIDToFlowID: {UInt256: UInt64}

        access(all) var storagePath: StoragePath
        access(all) var publicPath: PublicPath

        init () {
            self.ownedNFTs <- {}
            self.evmIDToFlowID = {}
            let collectionData = {{CONTRACT_NAME}}.resolveContractView(
                    resourceType: Type<@{{CONTRACT_NAME}}.NFT>(),
                    viewType: Type<MetadataViews.NFTCollectionData>()
                ) as! MetadataViews.NFTCollectionData?
                ?? panic("Could not resolve the collection data view for the NFT collection")
            self.storagePath = collectionData.storagePath
            self.publicPath = collectionData.publicPath
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        /// Returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            return { Type<@{{CONTRACT_NAME}}.NFT>(): true }
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           return type == Type<@{{CONTRACT_NAME}}.NFT>()
        }

        /// Removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// Withdraws an NFT from the collection by its EVM ID
        access(NonFungibleToken.Withdraw) fun withdrawByEVMID(_ id: UInt256): @{NonFungibleToken.NFT} {
            return <- self.withdraw(withdrawID: 
                self.getCadenceID(from: id) ?? panic("Could not withdraw an NFT with the provided EVM ID from the collection")
            )
        }

        /// Ttakes a NFT and adds it to the collections dictionary and adds the ID to the evmIDToFlowID mapping
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @{{CONTRACT_NAME}}.NFT

            // add the new token to the dictionary which removes the old one
            self.evmIDToFlowID[token.evmID] = token.id
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Returns an array of the EVM IDs that are in the collection
        access(all) view fun getEVMIDs(): [UInt256] {
            return self.evmIDToFlowID.keys
        }

        /// Returns the Cadence NFT.id for the given EVM NFT ID if it exists in the collection
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64? {
            if self.evmIDToFlowID[evmID] != nil {
                return self.evmIDToFlowID[evmID]
            } else if evmID < UInt256(UInt64.max) && self.borrowNFT(UInt64(evmID)) != nil {
                return UInt64(evmID)
            } else {
                return nil
            }
        }

        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        ///
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256? {
            if let nft = self.borrowNFT(cadenceID) {
                if let evmNFT = CrossVMNFT.getEVMID(from: nft) {
                    return evmNFT
                }
                return UInt256(nft.id)
            }
            return nil
        }

        /// Returns the contractURI for the NFT collection as defined in the source ERC721 contract. If none was
        /// defined at the time of bridging, an empty string is returned.
        access(all) view fun contractURI(): String? {
            return {{CONTRACT_NAME}}.contractURI
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        /// Retrieves a reference to the NFT stored in the collection by its ID
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            return &self.ownedNFTs[id] as &{ViewResolver.Resolver}? ?? nil
        }

        /// Creates an empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection}  {
            return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the NFT this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmNFTContractAddress
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let identifier = "{{CONTRACT_NAME}}Collection"
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: StoragePath(identifier: identifier)!,
                    publicPath: PublicPath(identifier: identifier)!,
                    publicCollection: Type<&{{CONTRACT_NAME}}.Collection>(),
                    publicLinkedType: Type<&{{CONTRACT_NAME}}.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let selfRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: selfRef, view: Type<MetadataViews.NFTCollectionDisplay>())
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint NFTs from bridge-defined NFT contracts
    ///
    access(account)
    fun mintNFT(id: UInt256, tokenURI: String): @NFT {
        pre {
            self.tokenURIs[id] == nil: "A token with the given ERC721 ID already exists"
        }
        self.tokenURIs[id] = tokenURI
        return <-create NFT(
            evmID: id,
            metadata: {
                "Bridged Block": getCurrentBlock().height,
                "Bridged Timestamp": getCurrentBlock().timestamp
            }
        )
    }

    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    ///
    access(account)
    fun updateTokenURI(evmID: UInt256, newURI: String) {
        pre {
            self.tokenURIs[evmID] != nil: "No token with the given ERC721 ID exists"
        }
        if self.tokenURIs[evmID] != newURI {
            self.tokenURIs[evmID] = newURI
        }
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmNFTContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.contractURI = contractURI
        self.tokenURIs = {}
        self.collection <- create Collection()

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.NFT>(), with: self.evmNFTContractAddress)
        FlowEVMBridgeNFTEscrow.initializeEscrow(
            forType: Type<@{{CONTRACT_NAME}}.NFT>(),
            name: name,
            symbol: symbol,
            erc721Address: self.evmNFTContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/setup/setup_generic_nft_collection.cdc

```
import "NonFungibleToken"
import "MetadataViews"

import "FlowEVMBridgeUtils"

/// Configures a Collection according to the shared NonFungibleToken standard and the defaults specified by the NFT's
/// defining contract.
///
/// @param nftIdentifier: The identifier of the NFT to configure.
///
transaction(nftIdentifier: String) {

    prepare(signer: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {
        // Gather identifying information about the NFT and its defining contract
        let nftType = CompositeType(nftIdentifier) ?? panic("Invalid NFT identifier: ".concat(nftIdentifier))
        let contractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not derive contract address from identifier: ".concat(nftIdentifier))
        let contractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not derive contract name from identifier: ".concat(nftIdentifier))
        // Borrow the contract and resolve its collection data
        let nftContract = getAccount(contractAddress).contracts.borrow<&{NonFungibleToken}>(name: contractName)
            ?? panic("No such NFT contract found")
        let data = nftContract.resolveContractView(
                resourceType: nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollection data for NFT type: ".concat(nftIdentifier))

        // Check for collision, returning if the collection already exists or reverting on unexpected collision
        let storedType = signer.storage.type(at: data.storagePath)
        if storedType == nftType {
            return
        } else if storedType != nil {
            panic(
                "Another resource of type "
                .concat(storedType!.identifier)
                .concat(" already exists at the storage path: ")
                .concat(data.storagePath.toString())
            )
        }

        // Create a new collection and save it to signer's storage at the collection's default storage path
        signer.storage.save(<-data.createEmptyCollection(), to: data.storagePath)

        // Issue a public Collection capability and publish it to the collection's default public path
        signer.capabilities.unpublish(data.publicPath)
        let receiverCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(data.storagePath)
        signer.capabilities.publish(receiverCap, at: data.publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/evm-assets/wrap_flow.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// This transactions wraps FLOW tokens as WFLOW tokens, using the signing COA's EVM FLOW balance primarily. If the 
/// EVM balance is insufficient, the transaction will transfer FLOW from the Cadence balance to the EVM balance.
///
/// @param wflowContractHex: The EVM address of the WFLOW contract as a hex string
/// @param amount: The amount of FLOW to wrap as WFLOW
///
transaction(wflowContractHex: String, amount: UFix64) {
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    let vault: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        self.vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
                ?? panic("Missing FLOW vault")
    }

    execute {
        // Transfer from Cadence balance to EVM balance if EVM balance is insufficient
        let evmBalance = self.coa.balance().inFLOW()
        if evmBalance < amount {
            let fundVault <- self.vault.withdraw(amount: amount - evmBalance) as! @FlowToken.Vault
            self.coa.deposit(from: <-fundVault)
        }
        // Define the value to send to the WFLOW contract
        let balance = EVM.Balance(attoflow: 0)
        balance.setFLOW(flow: amount)
        let calldata = EVM.encodeABIWithSignature("deposit()", [])
        let result = self.coa.call(
            to: EVM.addressFromString(wflowContractHex),
            data: calldata,
            gasLimit: 15_000_000,
            value: balance
        )
        assert(result.status == EVM.Status.successful, message: "Failed to wrap FLOW as WFLOW")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/onboarding/onboard_by_type.cdc

```
import "FungibleToken"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param type: The Cadence type of the bridgeable asset to onboard to the bridge
///
transaction(type: Type) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the asset Type
        FlowEVMBridge.onboardByType(
            type,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }

    post {
        FlowEVMBridge.typeRequiresOnboarding(type) == false:
            "Asset ".concat(type.identifier).concat(" was not onboarded to the bridge.")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/tokens/get_balance.cdc

```
import "FungibleToken"

/// Returns the balance of the stored Vault at the given address if exists, otherwise nil
///
/// @param address: The address of the account that owns the vault
/// @param vaultPathIdentifier: The identifier of the vault's storage path
///
/// @returns The balance of the stored Vault at the given address
///
access(all) fun main(address: Address, vaultPathIdentifier: String): UFix64? {
    let path = StoragePath(identifier: vaultPathIdentifier) ?? panic("Malformed StoragePath identifier")
    return getAuthAccount<auth(BorrowValue) &Account>(address).storage.borrow<&{FungibleToken.Vault}>(
            from: path
        )?.balance ?? nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/is_bridge_router_configured.cdc

```
import "EVMBridgeRouter"

access(all)
fun main(): Bool {
    let serviceAccount = getAuthAccount<auth(Storage) &Account>(0x0000000000000001)
    let router = serviceAccount.storage.borrow<&EVMBridgeRouter.Router>(
        from: /storage/evmBridgeRouter
    ) ?? panic("Could not borrow Router")

    assert(router.bridgeAddress == 0x0000000000000007)
    assert(router.bridgeContractName == "FlowEVMBridge")

    return true
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/scripts/type_at.cdc

```
access(all)
fun main(addr: Address, sp: StoragePath): Type? {
    return getAuthAccount<auth(BorrowValue) &Account>(addr).storage.type(at: sp)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/evm/get_evm_address_string.cdc

```
import "EVM"

/// Returns the hex encoded address of the COA in the given Flow address
///
access(all) fun main(flowAddress: Address): String? {
    return getAuthAccount<auth(BorrowValue) &Account>(flowAddress)
        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)
        ?.address()
        ?.toString()
        ?? nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm/set_registrar.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Sets the bridge factory contract address as the registrar for the provided FlowBridgeDeploymentRegistry address.
/// Should be called by the owner of the registry contract.
///
/// @param registryEVMAddressHex The EVM address of the FlowBridgeDeploymentRegistry contract.
///
transaction(registryEVMAddressHex: String) {

    let targetRegistryEVMAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postRegistrar: EVM.EVMAddress?

    prepare(signer: auth(BorrowValue) &Account) {
        self.targetRegistryEVMAddress = EVM.addressFromString(registryEVMAddressHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        self.postRegistrar = nil
    }

    execute {
        let callResult = self.coa.call(
            to: self.targetRegistryEVMAddress,
            data: EVM.encodeABIWithSignature(
                "setRegistrar(address)",
                [FlowEVMBridgeUtils.getBridgeFactoryEVMAddress()]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Failed to set registrar")

        // Confirm the registrar was set
        let postRegistrarResult = self.coa.call(
            to: self.targetRegistryEVMAddress,
            data: EVM.encodeABIWithSignature("registrar()", []),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(postRegistrarResult.status == EVM.Status.successful, message: "Failed to get registrar")

        let decodedResult = EVM.decodeABI(
                types: [Type<EVM.EVMAddress>()],
                data: postRegistrarResult.data
            )
        assert(decodedResult.length == 1, message: "Invalid response from registrar() call to registry contract")
        self.postRegistrar = decodedResult[0] as! EVM.EVMAddress
    }

    post {
        self.postRegistrar!.equals(FlowEVMBridgeUtils.getBridgeFactoryEVMAddress()):
            "FlowBridgeFactory address "
            .concat(FlowEVMBridgeUtils.getBridgeFactoryEVMAddress().toString())
            .concat(" was not set as the registrar in the registry contract ")
            .concat(registryEVMAddressHex)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/interfaces/FlowEVMDeploymentRegistry.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IFlowEVMDeploymentRegistry} from "./IFlowEVMDeploymentRegistry.sol";

/**
 * @title FlowEVMDeploymentRegistry
 * @dev A contract to manage the deployment of Flow EVM contracts and their association with Cadence contracts. Only the
 * registrar can register new deployments.
 */
abstract contract FlowEVMDeploymentRegistry is IFlowEVMDeploymentRegistry, ERC165 {
    // The address of the registrar who can register new deployments
    address public registrar;
    // Association between Cadence type identifiers and deployed contract addresses
    mapping(string => address) private cadenceIdentifierToContract;
    // Reverse association between deployed contract addresses and Cadence type identifiers
    mapping(address => string) private contractToCadenceIdentifier;

    modifier onlyRegistrar() {
        require(msg.sender == registrar, "FlowBridgeDeploymentRegistry: Only registrar can register association");
        _;
    }

    /**
     * @dev ERC165 introspection
     */
    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC165) returns (bool) {
        return interfaceId == type(IFlowEVMDeploymentRegistry).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Get the Cadence type identifier associated with a contract address
     *
     * @param contractAddr The address of the deployed contract
     *
     * @return The Cadence type identifier
     */
    function getCadenceIdentifier(address contractAddr) external view returns (string memory) {
        return contractToCadenceIdentifier[contractAddr];
    }

    /**
     * @dev Get the contract address associated with a Cadence type identifier
     *
     * @param cadenceIdentifier The Cadence type identifier
     *
     * @return The address of the associated contract
     */
    function getContractAddress(string memory cadenceIdentifier) external view returns (address) {
        return cadenceIdentifierToContract[cadenceIdentifier];
    }

    /**
     * @dev Check if a contract address is a registered deployment
     *
     * @param cadenceIdentifier The Cadence type identifier in question
     *
     * @return True if the contract address is associated with a Cadence type identifier as a registered deployment
     */
    function isRegisteredDeployment(string memory cadenceIdentifier) external view returns (bool) {
        return cadenceIdentifierToContract[cadenceIdentifier] != address(0);
    }

    /**
     * @dev Check if a Cadence type identifier is associated with a registered deployment
     *
     * @param contractAddr The address of the contract in question
     *
     * @return True if the contract address is associated with a Cadence type identifier as a registered deployment
     */
    function isRegisteredDeployment(address contractAddr) external view returns (bool) {
        return bytes(contractToCadenceIdentifier[contractAddr]).length != 0;
    }

    /**
     * @dev Register a new deployment address with the given Cadence type identifier. Can only be called by the
     * current registrar.
     *
     * @param cadenceIdentifier The Cadence type identifier
     * @param contractAddr The address of the deployed contract
     */
    function registerDeployment(string memory cadenceIdentifier, address contractAddr) external onlyRegistrar {
        _registerDeployment(cadenceIdentifier, contractAddr);
    }

    /**
     * @dev Internal function to register a new deployment address with the given Cadence type identifier
     *
     * @param cadenceIdentifier The Cadence type identifier
     * @param contractAddr The address of the deployed contract
     */
    function _registerDeployment(string memory cadenceIdentifier, address contractAddr) internal {
        require(contractAddr != address(0), "FlowEVMDeploymentRegistry: Contract address cannot be 0");
        require(bytes(cadenceIdentifier).length != 0, "FlowEVMDeploymentRegistry: Cadence identifier cannot be empty");
        require(
            cadenceIdentifierToContract[cadenceIdentifier] == address(0),
            "FlowEVMDeploymentRegistry: Cadence identifier already registered"
        );
        require(
            bytes(contractToCadenceIdentifier[contractAddr]).length == 0,
            "FlowEVMDeploymentRegistry: Contract address already registered"
        );

        cadenceIdentifierToContract[cadenceIdentifier] = contractAddr;
        contractToCadenceIdentifier[contractAddr] = cadenceIdentifier;

        emit DeploymentRegistered(contractAddr, cadenceIdentifier);
    }

    /**
     * @dev Set the registrar address as the entity that can register new deployments. Only the owner can execute this.
     */
    function _setRegistrar(address _registrar) internal {
        require(_registrar != address(0), "FlowEVMDeploymentRegistry: Registrar cannot be 0");
        registrar = _registrar;

        emit RegistrarAuthorized(_registrar);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/example-assets/ExampleERC721.sol

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract ExampleERC721 is ERC721, ERC721URIStorage, ERC721Burnable, Ownable {
    constructor() ERC721("NAME", "SYMBOL") Ownable(msg.sender) {}

    function safeMint(address to, uint256 tokenId, string memory uri) public onlyOwner {
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/dry_run.cdc

```
transaction {
    prepare(signer: &Account)  {
        log("SUCCESS")
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-token/transfer_tokens.cdc

```
// This transaction is a template for a transaction that
// could be used by anyone to send ExampleTokens to another 
// account that has been set up to receive tokens.
//
// The withdraw amount and the account from getAccount
// would be the parameters to the transaction

import "FungibleToken"
import "ExampleToken"
import "FungibleTokenMetadataViews"

transaction(amount: UFix64, to: Address) {

    /// FTVaultData metadata view for the token being used
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    // The Vault resource that holds the tokens that are being transferred
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(BorrowValue) &Account) {

        self.vaultData = ExampleToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("ViewResolver does not resolve FTVaultData view")

        // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(from: self.vaultData.storagePath)
            ?? panic("Could not borrow reference to the owner's Vault!")

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)
            ?? panic("Could not borrow receiver reference to the recipient's Vault")

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm/set_deployment_registry.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// This transaction sets the address of the registry contract in the bridge factory contract. The registry contract
/// is tasked with maintaining associations between bridge-deployed EVM contracts and their corresponding Cadence
/// implementations.
///
/// NOTE: This is a sensitive operation as the registry contract serves as the source of truth for bridge-deployed
/// contracts.
///
/// @param registryEVMAddressHex The EVM address of the registry contract as a hex string
///
transaction(registryEVMAddressHex: String) {

    let targetRegistryEVMAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postRegistry: EVM.EVMAddress?

    prepare(signer: auth(BorrowValue) &Account) {
        self.targetRegistryEVMAddress = EVM.addressFromString(registryEVMAddressHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
            self.postRegistry = nil
    }

    execute {
        // Execute call
        let callResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature(
                "setDeploymentRegistry(address)",
                [self.targetRegistryEVMAddress]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Failed to set registry in FlowBridgeFactory contract")

        // Confirm the registry address was set
        let postRegistryResult = self.coa.call(
            to: FlowEVMBridgeUtils.getBridgeFactoryEVMAddress(),
            data: EVM.encodeABIWithSignature("getRegistry()", []),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(
            postRegistryResult.status == EVM.Status.successful,
            message: "Failed to get registry address from FlowBridgeFactory contract"
        )

        let decodedResult = EVM.decodeABI(
                types: [Type<EVM.EVMAddress>()],
                data: postRegistryResult.data
            )
        assert(decodedResult.length == 1, message: "Invalid response from getRegistry() call to FlowBridgeFactory contract")
        self.postRegistry = decodedResult[0] as! EVM.EVMAddress
    }

    post {
        self.postRegistry!.equals(self.targetRegistryEVMAddress):
            "Registry address "
            .concat(registryEVMAddressHex)
            .concat(" was not set in the FlowBridgeFactory contract ")
            .concat(FlowEVMBridgeUtils.getBridgeFactoryEVMAddress().toString())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeUtils.cdc

```
import "NonFungibleToken"
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"
import "ViewResolver"
import "FlowToken"
import "FlowStorageFees"

import "EVM"

import "SerializeMetadata"
import "FlowEVMBridgeConfig"
import "CrossVMNFT"
import "IBridgePermissions"

/// This contract serves as a source of utility methods leveraged by FlowEVMBridge contracts
//
access(all)
contract FlowEVMBridgeUtils {

    /// Address of the bridge factory Solidity contract
    access(self)
    var bridgeFactoryEVMAddress: EVM.EVMAddress
    /// Delimeter used to derive contract names
    access(self)
    let delimiter: String
    /// Mapping containing contract name prefixes
    access(self)
    let contractNamePrefixes: {Type: {String: String}}

    /****************
        Constructs
    *****************/

    /// Struct used to preserve and pass around multiple values relating to Cadence asset onboarding
    ///
    access(all) struct CadenceOnboardingValues {
        access(all) let contractAddress: Address
        access(all) let name: String
        access(all) let symbol: String
        access(all) let identifier: String
        access(all) let contractURI: String

        init(
            contractAddress: Address,
            name: String,
            symbol: String,
            identifier: String,
            contractURI: String
        ) {
            self.contractAddress = contractAddress
            self.name = name
            self.symbol = symbol
            self.identifier = identifier
            self.contractURI = contractURI
        }
    }

    /// Struct used to preserve and pass around multiple values preventing the need to make multiple EVM calls
    /// during EVM asset onboarding
    ///
    access(all) struct EVMOnboardingValues {
        access(all) let evmContractAddress: EVM.EVMAddress
        access(all) let name: String
        access(all) let symbol: String
        access(all) let decimals: UInt8?
        access(all) let contractURI: String?
        access(all) let cadenceContractName: String
        access(all) let isERC721: Bool

        init(
            evmContractAddress: EVM.EVMAddress,
            name: String,
            symbol: String,
            decimals: UInt8?,
            contractURI: String?,
            cadenceContractName: String,
            isERC721: Bool
        ) {
            self.evmContractAddress = evmContractAddress
            self.name = name
            self.symbol = symbol
            self.decimals = decimals
            self.contractURI = contractURI
            self.cadenceContractName = cadenceContractName
            self.isERC721 = isERC721
        }
    }

    /**************************
        Public Bridge Utils
     **************************/

    /// Retrieves the bridge factory contract address
    ///
    /// @returns The EVMAddress of the bridge factory contract in EVM
    ///
    access(all)
    view fun getBridgeFactoryEVMAddress(): EVM.EVMAddress {
        return self.bridgeFactoryEVMAddress
    }

    /// Calculates the fee bridge fee based on the given storage usage + the current base fee.
    ///
    /// @param used: The amount of storage used by the asset
    ///
    /// @return The calculated fee amount
    ///
    access(all)
    view fun calculateBridgeFee(bytes used: UInt64): UFix64 {
        let megabytesUsed = FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(used)
        let storageFee = FlowStorageFees.storageCapacityToFlow(megabytesUsed)
        return storageFee + FlowEVMBridgeConfig.baseFee
    }

    /// Returns whether the given type is allowed to be bridged as defined by the IBridgePermissions contract interface.
    /// If the type's defining contract does not implement IBridgePermissions, the method returns true as the bridge
    /// operates permissionlessly by default. Otherwise, the result of {IBridgePermissions}.allowsBridging() is returned
    ///
    /// @param type: The Type of the asset to check
    ///
    /// @return true if the type is allowed to be bridged, false otherwise
    ///
    access(all)
    view fun typeAllowsBridging(_ type: Type): Bool {
        let contractAddress = self.getContractAddress(fromType: type)
            ?? panic("Could not construct contract address from type identifier: ".concat(type.identifier))
        let contractName = self.getContractName(fromType: type)
            ?? panic("Could not construct contract name from type identifier: ".concat(type.identifier))
        if let bridgePermissions = getAccount(contractAddress).contracts.borrow<&{IBridgePermissions}>(name: contractName) {
            return bridgePermissions.allowsBridging()
        }
        return true
    }

    /// Returns whether the given address has opted out of enabling bridging for its defined assets
    ///
    /// @param address: The EVM contract address to check
    ///
    /// @return false if the address has opted out of enabling bridging, true otherwise
    ///
    access(all)
    fun evmAddressAllowsBridging(_ address: EVM.EVMAddress): Bool {
        let callResult = self.call(
            signature: "allowsBridging()",
            targetEVMAddress: address,
            args: [],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        // Contract doesn't support the method - proceed permissionlessly
        if callResult.status != EVM.Status.successful {
            return true
        }
        // Contract is IBridgePermissions - return the result
        let decodedResult = EVM.decodeABI(types: [Type<Bool>()], data: callResult.data) as! [AnyStruct]
        return (decodedResult.length == 1 && decodedResult[0] as! Bool) == true ? true : false
    }

    /// Identifies if an asset is Cadence- or EVM-native, defined by whether a bridge contract defines it or not
    ///
    /// @param type: The Type of the asset to check
    ///
    /// @return True if the asset is Cadence-native, false if it is EVM-native
    ///
    access(all)
    view fun isCadenceNative(type: Type): Bool {
        let definingAddress = self.getContractAddress(fromType: type)
            ?? panic("Could not construct address from type identifier: ".concat(type.identifier))
        return definingAddress != self.account.address
    }

    /// Identifies if an asset is Cadence- or EVM-native, defined by whether a bridge-owned contract defines it or not.
    /// Reverts on EVM call failure.
    ///
    /// @param type: The Type of the asset to check
    ///
    /// @return True if the asset is EVM-native, false if it is Cadence-native
    ///
    access(all)
    fun isEVMNative(evmContractAddress: EVM.EVMAddress): Bool {
        return self.isEVMContractBridgeOwned(evmContractAddress: evmContractAddress) == false
    }

    /// Determines if the given EVM contract address was deployed by the bridge by querying the factory contract
    /// Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to check
    ///
    /// @return True if the contract was deployed by the bridge, false otherwise
    ///
    access(all)
    fun isEVMContractBridgeOwned(evmContractAddress: EVM.EVMAddress): Bool {
        // Ask the bridge factory if the given contract address was deployed by the bridge
        let callResult = self.call(
                signature: "isBridgeDeployed(address)",
                targetEVMAddress: self.bridgeFactoryEVMAddress,
                args: [evmContractAddress],
                gasLimit: FlowEVMBridgeConfig.gasLimit,
                value: 0.0
            )

        assert(callResult.status == EVM.Status.successful, message: "Call to bridge factory failed")
        let decodedResult = EVM.decodeABI(types: [Type<Bool>()], data: callResult.data)
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! Bool
    }

    /// Identifies if an asset is ERC721. Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to check
    ///
    /// @return True if the asset is an ERC721, false otherwise
    ///
    access(all)
    fun isERC721(evmContractAddress: EVM.EVMAddress): Bool {
        let callResult = self.call(
            signature: "isERC721(address)",
            targetEVMAddress: self.bridgeFactoryEVMAddress,
            args: [evmContractAddress],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )

        assert(callResult.status == EVM.Status.successful, message: "Call to bridge factory failed")
        let decodedResult = EVM.decodeABI(types: [Type<Bool>()], data: callResult.data)
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! Bool
    }

    /// Identifies if an asset is ERC20 as far as is possible without true EVM type introspection. Reverts on EVM call
    /// failure.
    ///
    /// @param evmContractAddress: The EVM contract address to check
    ///
    /// @return true if the asset is an ERC20, false otherwise
    ///
    access(all)
    fun isERC20(evmContractAddress: EVM.EVMAddress): Bool {
        let callResult = self.call(
            signature: "isERC20(address)",
            targetEVMAddress: self.bridgeFactoryEVMAddress,
            args: [evmContractAddress],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )

        assert(callResult.status == EVM.Status.successful, message: "Call to bridge factory failed")
        let decodedResult = EVM.decodeABI(types: [Type<Bool>()], data: callResult.data)
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! Bool
    }

    /// Returns whether the contract address is either an ERC721 or ERC20 exclusively. Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to check
    ///
    /// @return True if the contract is either an ERC721 or ERC20, false otherwise
    ///
    access(all)
    fun isValidEVMAsset(evmContractAddress: EVM.EVMAddress): Bool {
        let callResult = self.call(
            signature: "isValidAsset(address)",
            targetEVMAddress: self.bridgeFactoryEVMAddress,
            args: [evmContractAddress],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        let decodedResult = EVM.decodeABI(types: [Type<Bool>()], data: callResult.data)
        assert(decodedResult.length == 1, message: "Invalid response length")
        return decodedResult[0] as! Bool
    }

    /// Returns whether the given type is either an NFT or FT exclusively
    ///
    /// @param type: The Type of the asset to check
    ///
    /// @return True if the type is either an NFT or FT, false otherwise
    ///
    access(all)
    view fun isValidCadenceAsset(type: Type): Bool {
        let isCadenceNFT = type.isSubtype(of: Type<@{NonFungibleToken.NFT}>())
        let isCadenceFungibleToken = type.isSubtype(of: Type<@{FungibleToken.Vault}>())
        return isCadenceNFT != isCadenceFungibleToken
    }

    /// Retrieves the bridge contract's COA EVMAddress
    ///
    /// @returns The EVMAddress of the bridge contract's COA orchestrating actions in FlowEVM
    ///
    access(all)
    view fun getBridgeCOAEVMAddress(): EVM.EVMAddress {
        return self.borrowCOA().address()
    }

    /// Retrieves the relevant information for onboarding a Cadence asset to the bridge. This method is used to
    /// retrieve the name, symbol, contract address, and contract URI for a given Cadence asset type. These values
    /// are used to then deploy a corresponding EVM contract. If EVMBridgedMetadata is supported by the asset's
    /// defining contract, the values are retrieved from that view. Otherwise, the values are derived from other
    /// common metadata views.
    ///
    /// @param forAssetType: The Type of the asset to retrieve onboarding values for
    ///
    /// @return The CadenceOnboardingValues struct containing the asset's name, symbol, identifier, contract address,
    ///     and contract URI
    ///
    access(all)
    fun getCadenceOnboardingValues(forAssetType: Type): CadenceOnboardingValues {
        pre {
            self.isValidCadenceAsset(type: forAssetType): "This type is not a supported Flow asset type."
        }
        // If not an NFT, assumed to be fungible token.
        let isNFT = forAssetType.isSubtype(of: Type<@{NonFungibleToken.NFT}>())

        // Retrieve the Cadence type's defining contract name, address, & its identifier
        var name = self.getContractName(fromType: forAssetType)
            ?? panic("Could not contract name from type: ".concat(forAssetType.identifier))
        let identifier = forAssetType.identifier
        let cadenceAddress = self.getContractAddress(fromType: forAssetType)
            ?? panic("Could not derive contract address for token type: ".concat(identifier))
        // Initialize asset symbol which will be assigned later
        // based on presence of asset-defined metadata
        var symbol: String? = nil
        // Borrow the ViewResolver to attempt to resolve the EVMBridgedMetadata view
        let viewResolver = getAccount(cadenceAddress).contracts.borrow<&{ViewResolver}>(name: name)!
        var contractURI = ""

        // Try to resolve the EVMBridgedMetadata
        let bridgedMetadata = viewResolver.resolveContractView(
                resourceType: forAssetType,
                viewType: Type<MetadataViews.EVMBridgedMetadata>()
            ) as! MetadataViews.EVMBridgedMetadata?
        // Default to project-defined URI if available
        if bridgedMetadata != nil {
            name = bridgedMetadata!.name
            symbol = bridgedMetadata!.symbol
            contractURI = bridgedMetadata!.uri.uri()
        } else {
            if isNFT {
                // Otherwise, serialize collection-level NFTCollectionDisplay
                if let collectionDisplay = viewResolver.resolveContractView(
                    resourceType: forAssetType,
                    viewType: Type<MetadataViews.NFTCollectionDisplay>()
                ) as! MetadataViews.NFTCollectionDisplay? {
                    name = collectionDisplay.name
                    let serializedDisplay = SerializeMetadata.serializeFromDisplays(nftDisplay: nil, collectionDisplay: collectionDisplay)!
                    contractURI = "data:application/json;utf8,{".concat(serializedDisplay).concat("}")
                }
                if symbol == nil {
                    symbol = SerializeMetadata.deriveSymbol(fromString: name)
                }
            } else {
                let ftDisplay = viewResolver.resolveContractView(
                    resourceType: forAssetType,
                    viewType: Type<FungibleTokenMetadataViews.FTDisplay>()
                ) as! FungibleTokenMetadataViews.FTDisplay?
                if ftDisplay != nil {
                    name = ftDisplay!.name
                    symbol = ftDisplay!.symbol
                }
                if contractURI.length == 0 && ftDisplay != nil {
                    let serializedDisplay = SerializeMetadata.serializeFTDisplay(ftDisplay!)
                    contractURI = "data:application/json;utf8,{".concat(serializedDisplay).concat("}")
                }
            }
        }

        return CadenceOnboardingValues(
            contractAddress: cadenceAddress,
            name: name,
            symbol: symbol!,
            identifier: identifier,
            contractURI: contractURI
        )
    }

    /// Retrieves identifying information about an EVM contract related to bridge onboarding.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve onboarding values for
    ///
    /// @return The EVMOnboardingValues struct containing the asset's name, symbol, decimals, contractURI, and
    ///    Cadence contract name as well as whether the asset is an ERC721
    ///
    access(all)
    fun getEVMOnboardingValues(evmContractAddress: EVM.EVMAddress): EVMOnboardingValues {
        // Retrieve the EVM contract's name, symbol, and contractURI
        let name: String = self.getName(evmContractAddress: evmContractAddress)
        let symbol: String = self.getSymbol(evmContractAddress: evmContractAddress)
        let contractURI = self.getContractURI(evmContractAddress: evmContractAddress)
        // Default to 18 decimals for ERC20s
        var decimals: UInt8 = FlowEVMBridgeConfig.defaultDecimals

        // Derive Cadence contract name
        let isERC721: Bool = self.isERC721(evmContractAddress: evmContractAddress)
        var cadenceContractName: String = ""
        if isERC721 {
            // Assert the contract is not mixed asset
            let isERC20 = self.isERC20(evmContractAddress: evmContractAddress)
            assert(!isERC20, message: "Contract is mixed asset and is not currently supported by the bridge")
            // Derive the contract name from the ERC721 contract
            cadenceContractName = self.deriveBridgedNFTContractName(from: evmContractAddress)
        } else {
            // Otherwise, treat as ERC20
            let isERC20 = self.isERC20(evmContractAddress: evmContractAddress)
            assert(
                isERC20,
                message: "Contract ".concat(evmContractAddress.toString()).concat("defines an asset that is not currently supported by the bridge")
            )
            cadenceContractName = self.deriveBridgedTokenContractName(from: evmContractAddress)
            decimals = self.getTokenDecimals(evmContractAddress: evmContractAddress)
        }

        return EVMOnboardingValues(
            evmContractAddress: evmContractAddress,
            name: name,
            symbol: symbol,
            decimals: decimals,
            contractURI: contractURI,
            cadenceContractName: cadenceContractName,
            isERC721: isERC721
        )
    }

    /************************
        EVM Call Wrappers
     ************************/

    /// Retrieves the NFT/FT name from the given EVM contract address - applies for both ERC20 & ERC721.
    /// Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve the name from
    ///
    /// @return the name of the asset
    ///
    access(all)
    fun getName(evmContractAddress: EVM.EVMAddress): String {
        let callResult = self.call(
            signature: "name()",
            targetEVMAddress: evmContractAddress,
            args: [],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )

        assert(callResult.status == EVM.Status.successful, message: "Call for EVM asset name failed")
        let decodedResult = EVM.decodeABI(types: [Type<String>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! String
    }

    /// Retrieves the NFT/FT symbol from the given EVM contract address - applies for both ERC20 & ERC721
    /// Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve the symbol from
    ///
    /// @return the symbol of the asset
    ///
    access(all)
    fun getSymbol(evmContractAddress: EVM.EVMAddress): String {
        let callResult = self.call(
            signature: "symbol()",
            targetEVMAddress: evmContractAddress,
            args: [],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(callResult.status == EVM.Status.successful, message: "Call for EVM asset symbol failed")
        let decodedResult = EVM.decodeABI(types: [Type<String>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")
        return decodedResult[0] as! String
    }

    /// Retrieves the tokenURI for the given NFT ID from the given EVM contract address. Reverts on EVM call failure.
    /// Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve the tokenURI from
    /// @param id: The ID of the NFT for which to retrieve the tokenURI value
    ///
    /// @return the tokenURI of the ERC721
    ///
    access(all)
    fun getTokenURI(evmContractAddress: EVM.EVMAddress, id: UInt256): String {
        let callResult = self.call(
            signature: "tokenURI(uint256)",
            targetEVMAddress: evmContractAddress,
            args: [id],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )

        assert(callResult.status == EVM.Status.successful, message: "Call to EVM for tokenURI failed")
        let decodedResult = EVM.decodeABI(types: [Type<String>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! String
    }

    /// Retrieves the contract URI from the given EVM contract address. Returns nil on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve the contractURI from
    ///
    /// @return the contract's contractURI
    ///
    access(all)
    fun getContractURI(evmContractAddress: EVM.EVMAddress): String? {
        let callResult = self.call(
            signature: "contractURI()",
            targetEVMAddress: evmContractAddress,
            args: [],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        if callResult.status != EVM.Status.successful {
            return nil
        }
        let decodedResult = EVM.decodeABI(types: [Type<String>()], data: callResult.data) as! [AnyStruct]
        return decodedResult.length == 1 ? decodedResult[0] as! String : nil
    }

    /// Retrieves the number of decimals for a given ERC20 contract address. Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The ERC20 contract address to retrieve the token decimals from
    ///
    /// @return the token decimals of the ERC20
    ///
    access(all)
    fun getTokenDecimals(evmContractAddress: EVM.EVMAddress): UInt8 {
        let callResult = self.call(
                signature: "decimals()",
                targetEVMAddress: evmContractAddress,
                args: [],
                gasLimit: FlowEVMBridgeConfig.gasLimit,
                value: 0.0
            )

        assert(callResult.status == EVM.Status.successful, message: "Call for EVM asset decimals failed")
        let decodedResult = EVM.decodeABI(types: [Type<UInt8>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")

        return decodedResult[0] as! UInt8
    }

    /// Determines if the provided owner address is either the owner or approved for the NFT in the ERC721 contract
    /// Reverts on EVM call failure.
    ///
    /// @param ofNFT: The ID of the NFT to query
    /// @param owner: The owner address to query
    /// @param evmContractAddress: The ERC721 contract address to query
    ///
    /// @return true if the owner is either the owner or approved for the NFT, false otherwise
    ///
    access(all)
    fun isOwnerOrApproved(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool {
        return self.isOwner(ofNFT: ofNFT, owner: owner, evmContractAddress: evmContractAddress) ||
            self.isApproved(ofNFT: ofNFT, owner: owner, evmContractAddress: evmContractAddress)
    }

    /// Returns whether the given owner is the owner of the given NFT. Reverts on EVM call failure.
    ///
    /// @param ofNFT: The ID of the NFT to query
    /// @param owner: The owner address to query
    /// @param evmContractAddress: The ERC721 contract address to query
    ///
    /// @return true if the owner is in fact the owner of the NFT, false otherwise
    ///
    access(all)
    fun isOwner(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool {
        let callResult = self.call(
                signature: "ownerOf(uint256)",
                targetEVMAddress: evmContractAddress,
                args: [ofNFT],
                gasLimit: FlowEVMBridgeConfig.gasLimit,
                value: 0.0
            )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC721.ownerOf(uint256) failed")
        let decodedCallResult = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: callResult.data)
        if decodedCallResult.length == 1 {
            let actualOwner = decodedCallResult[0] as! EVM.EVMAddress
            return actualOwner.equals(owner)
        }
        return false
    }

    /// Returns whether the given owner is approved for the given NFT. Reverts on EVM call failure.
    ///
    /// @param ofNFT: The ID of the NFT to query
    /// @param owner: The owner address to query
    /// @param evmContractAddress: The ERC721 contract address to query
    ///
    /// @return true if the owner is in fact approved for the NFT, false otherwise
    ///
    access(all)
    fun isApproved(ofNFT: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool {
        let callResult = self.call(
            signature: "getApproved(uint256)",
            targetEVMAddress: evmContractAddress,
            args: [ofNFT],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC721.getApproved(uint256) failed")
        let decodedCallResult = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: callResult.data)
        if decodedCallResult.length == 1 {
            let actualApproved = decodedCallResult[0] as! EVM.EVMAddress
            return actualApproved.equals(owner)
        }
        return false
    }

    /// Returns whether the given ERC721 exists, assuming the ERC721 contract implements the `exists` method. While this
    /// method is not part of the ERC721 standard, it is implemented in the bridge-deployed ERC721 implementation.
    /// Reverts on EVM call failure.
    ///
    /// @param erc721Address: The EVM contract address of the ERC721 token
    /// @param id: The ID of the ERC721 token to check
    ///
    /// @return true if the ERC721 token exists, false otherwise
    ///
    access(all)
    fun erc721Exists(erc721Address: EVM.EVMAddress, id: UInt256): Bool {
        let existsResponse = EVM.decodeABI(
                types: [Type<Bool>()],
                data: self.call(
                    signature: "exists(uint256)",
                    targetEVMAddress: erc721Address,
                    args: [id],
                    gasLimit: FlowEVMBridgeConfig.gasLimit,
                    value: 0.0
                ).data,
            )
        assert(existsResponse.length == 1, message: "Invalid response length")
        return existsResponse[0] as! Bool
    }

    /// Returns the ERC20 balance of the owner at the given ERC20 contract address. Reverts on EVM call failure.
    ///
    /// @param owner: The owner address to query
    /// @param evmContractAddress: The ERC20 contract address to query
    ///
    /// @return The UInt256 balance of the owner at the ERC20 contract address. Callers may wish to convert the return
    ///     value to a UFix64 via convertERC20AmountToCadenceAmount, though note there may be a loss of precision.
    ///
    access(all)
    fun balanceOf(owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): UInt256 {
        let callResult = self.call(
            signature: "balanceOf(address)",
            targetEVMAddress: evmContractAddress,
            args: [owner],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC20.balanceOf(address) failed")
        let decodedResult = EVM.decodeABI(types: [Type<UInt256>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")
        return decodedResult[0] as! UInt256
    }

    /// Determines if the owner has sufficient funds to bridge the given amount at the ERC20 contract address
    /// Reverts on EVM call failure.
    ///
    /// @param amount: The amount to check if the owner has enough balance to cover
    /// @param owner: The owner address to query
    /// @param evmContractAddress: The ERC20 contract address to query
    ///
    /// @return true if the owner's balance >= amount, false otherwise
    ///
    access(all)
    fun hasSufficientBalance(amount: UInt256, owner: EVM.EVMAddress, evmContractAddress: EVM.EVMAddress): Bool {
        return self.balanceOf(owner: owner, evmContractAddress: evmContractAddress) >= amount
    }

    /// Retrieves the total supply of the ERC20 contract at the given EVM contract address. Reverts on EVM call failure.
    ///
    /// @param evmContractAddress: The EVM contract address to retrieve the total supply from
    ///
    /// @return the total supply of the ERC20
    ///
    access(all)
    fun totalSupply(evmContractAddress: EVM.EVMAddress): UInt256 {
        let callResult = self.call(
            signature: "totalSupply()",
            targetEVMAddress: evmContractAddress,
            args: [],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(callResult.status == EVM.Status.successful, message: "Call to ERC20.totalSupply() failed")
        let decodedResult = EVM.decodeABI(types: [Type<UInt256>()], data: callResult.data) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response length")
        return decodedResult[0] as! UInt256
    }

    /// Converts the given amount of ERC20 tokens to the equivalent amount in FLOW tokens based on the ERC20s decimals
    /// value. Note that may be some loss of decimal precision as UFix64 supports precision for 8 decimal places.
    /// Reverts on EVM call failure.
    ///
    /// @param amount: The amount of ERC20 tokens to convert
    /// @param erc20Address: The EVM contract address of the ERC20 token
    ///
    /// @return the equivalent amount in FLOW tokens as a UFix64
    ///
    access(all)
    fun convertERC20AmountToCadenceAmount(_ amount: UInt256, erc20Address: EVM.EVMAddress): UFix64 {
        return self.uint256ToUFix64(
            value: amount,
            decimals: self.getTokenDecimals(evmContractAddress: erc20Address)
        )
    }

    /// Converts the given amount of Cadence fungible tokens to the equivalent amount in ERC20 tokens based on the
    /// ERC20s decimals. Note that there may be some loss of decimal precision as UFix64 supports precision for 8 
    /// decimal places. Reverts on EVM call failure.
    ///
    /// @param amount: The amount of Cadence fungible tokens to convert
    /// @param erc20Address: The EVM contract address of the ERC20 token
    ///
    /// @return the equivalent amount in ERC20 tokens as a UInt256
    ///
    access(all)
    fun convertCadenceAmountToERC20Amount(_ amount: UFix64, erc20Address: EVM.EVMAddress): UInt256 {
        return self.ufix64ToUInt256(value: amount, decimals: self.getTokenDecimals(evmContractAddress: erc20Address))
    }

    /************************
        Derivation Utils
     ************************/

    /// Derives the StoragePath where the escrow locker is stored for a given Type of asset & returns. The given type
    /// must be of an asset supported by the bridge.
    ///
    /// @param fromType: The type of the asset the escrow locker is being derived for
    ///
    /// @return The StoragePath associated with the type's escrow Locker, or nil if the type is not supported
    ///
    access(all)
    view fun deriveEscrowStoragePath(fromType: Type): StoragePath? {
        if !self.isValidCadenceAsset(type: fromType) {
            return nil
        }
        var prefix = ""
        if fromType.isSubtype(of: Type<@{NonFungibleToken.NFT}>()) {
            prefix = "flowEVMBridgeNFTEscrow"
        } else if fromType.isSubtype(of: Type<@{FungibleToken.Vault}>()) {
            prefix = "flowEVMBridgeTokenEscrow"
        }
        assert(prefix.length > 1, message: "Invalid prefix")
        if let splitIdentifier = self.splitObjectIdentifier(identifier: fromType.identifier) {
            let sourceContractAddress = Address.fromString("0x".concat(splitIdentifier[1]))!
            let sourceContractName = splitIdentifier[2]
            let resourceName = splitIdentifier[3]
            return StoragePath(
                identifier: prefix.concat(self.delimiter)
                    .concat(sourceContractAddress.toString()).concat(self.delimiter)
                    .concat(sourceContractName).concat(self.delimiter)
                    .concat(resourceName)
            ) ?? nil
        }
        return nil
    }

    /// Derives the Cadence contract name for a given EVM NFT of the form
    /// EVMVMBridgedNFT_<0xCONTRACT_ADDRESS>
    ///
    /// @param from evmContract: The EVM contract address to derive the Cadence NFT contract name for
    ///
    /// @return The derived Cadence FT contract name
    ///
    access(all)
    view fun deriveBridgedNFTContractName(from evmContract: EVM.EVMAddress): String {
        return self.contractNamePrefixes[Type<@{NonFungibleToken.NFT}>()]!["bridged"]!
            .concat(self.delimiter)
            .concat(evmContract.toString())
    }

    /// Derives the Cadence contract name for a given EVM fungible token of the form
    /// EVMVMBridgedToken_<0xCONTRACT_ADDRESS>
    ///
    /// @param from evmContract: The EVM contract address to derive the Cadence FT contract name for
    ///
    /// @return The derived Cadence FT contract name
    ///
    access(all)
    view fun deriveBridgedTokenContractName(from evmContract: EVM.EVMAddress): String {
        return self.contractNamePrefixes[Type<@{FungibleToken.Vault}>()]!["bridged"]!
            .concat(self.delimiter)
            .concat(evmContract.toString())
    }

    /****************
        Math Utils
     ****************/

    /// Raises the base to the power of the exponent
    ///
    access(all)
    view fun pow(base: UInt256, exponent: UInt8): UInt256 {
        if exponent == 0 {
            return 1
        }

        var r = base
        var exp: UInt8 = 1
        while exp < exponent {
            r = r * base
            exp = exp + 1
        }

        return r
    }

    /// Raises the fixed point base to the power of the exponent
    ///
    access(all)
    view fun ufixPow(base: UFix64, exponent: UInt8): UFix64 {
        if exponent == 0 {
            return 1.0
        }

        var r = base
        var exp: UInt8 = 1
        while exp < exponent {
            r = r * base
            exp = exp + 1
        }

        return r
    }

    /// Converts a UFix64 to a UInt256
    //
    access(all)
    view fun ufix64ToUInt256(value: UFix64, decimals: UInt8): UInt256 {
        // Default to 10e8 scale, catching instances where decimals are less than default and scale appropriately
        let ufixScaleExp: UInt8 = decimals < 8 ? decimals : 8
        var ufixScale = self.ufixPow(base: 10.0, exponent: ufixScaleExp)

        // Separate the fractional and integer parts of the UFix64
        let integer = UInt256(value)
        var fractional = (value % 1.0) * ufixScale

        // Calculate the multiplier for integer and fractional parts
        var integerMultiplier: UInt256 = self.pow(base:10, exponent: decimals)
        let fractionalMultiplierExp: UInt8 = decimals < 8 ? 0 : decimals - 8
        var fractionalMultiplier: UInt256 = self.pow(base:10, exponent: fractionalMultiplierExp)

        // Scale and sum the parts
        return integer * integerMultiplier + UInt256(fractional) * fractionalMultiplier
    }

    /// Converts a UInt256 to a UFix64
    ///
    access(all)
    view fun uint256ToUFix64(value: UInt256, decimals: UInt8): UFix64 {
        // Calculate scale factors for the integer and fractional parts
        let absoluteScaleFactor = self.pow(base: 10, exponent: decimals)

        // Separate the integer and fractional parts of the value
        let scaledValue = value / absoluteScaleFactor
        var fractional = value % absoluteScaleFactor
        // Scale the fractional part
        let scaledFractional = self.uint256FractionalToScaledUFix64Decimals(value: fractional, decimals: decimals)

        // Ensure the parts do not exceed the max UFix64 value before conversion
        assert(
            scaledValue <= UInt256(UFix64.max),
            message: "Scaled integer value ".concat(value.toString()).concat(" exceeds max UFix64 value")
        )
        /// Check for the max value that can be converted to a UFix64 without overflowing
        assert(
            scaledValue == UInt256(UFix64.max) ? scaledFractional < 0.09551616 : true,
            message: "Scaled integer value ".concat(value.toString()).concat(" exceeds max UFix64 value")
        )

        return UFix64(scaledValue) + scaledFractional
    }

    /// Converts a UInt256 fractional value with the given decimal places to a scaled UFix64. Note that UFix64 has
    /// decimal precision of 8 places so converted values may lose precision and be rounded down.
    ///
    access(all)
    view fun uint256FractionalToScaledUFix64Decimals(value: UInt256, decimals: UInt8): UFix64 {
        pre {
            self.getNumberOfDigits(value) <= decimals: "Fractional digits exceed the defined decimal places"
        }
        post {
            result < 1.0: "Resulting scaled fractional exceeds 1.0"
        }

        var fractional = value
        // Truncate fractional to the first 8 decimal places which is the max precision for UFix64
        if decimals >= 8 {
            fractional = fractional / self.pow(base: 10, exponent: decimals - 8)
        }
        // Return early if the truncated fractional part is now 0
        if fractional == 0 {
            return 0.0
        }

        // Scale the fractional part
        let fractionalMultiplier = self.ufixPow(base: 0.1, exponent: decimals < 8 ? decimals : 8)
        return UFix64(fractional) * fractionalMultiplier
    }

    /// Returns the value as a UInt64 if it fits, otherwise panics
    ///
    access(all)
    view fun uint256ToUInt64(value: UInt256): UInt64 {
        return value <= UInt256(UInt64.max) ? UInt64(value) : panic("Value too large to fit into UInt64")
    }

    /// Returns the number of digits in the given UInt256
    ///
    access(all)
    view fun getNumberOfDigits(_ value: UInt256): UInt8 {
        var tmp = value
        var digits: UInt8 = 0
        while tmp > 0 {
            tmp = tmp / 10
            digits = digits + 1
        }
        return digits
    }

    /***************************
        Type Identifier Utils
     ***************************/

    /// Returns the contract address from the given Type's identifier
    ///
    /// @param fromType: The Type to extract the contract address from
    ///
    /// @return The defining contract's Address, or nil if the identifier does not have an associated Address
    ///
    access(all)
    view fun getContractAddress(fromType: Type): Address? {
        // Split identifier of format A.<CONTRACT_ADDRESS>.<CONTRACT_NAME>.<OBJECT_NAME>
        if let identifierSplit = self.splitObjectIdentifier(identifier: fromType.identifier) {
            return Address.fromString("0x".concat(identifierSplit[1]))
        }
        return nil
    }

    /// Returns the contract name from the given Type's identifier
    ///
    /// @param fromType: The Type to extract the contract name from
    ///
    /// @return The defining contract's name, or nil if the identifier does not have an associated contract name
    ///
    access(all)
    view fun getContractName(fromType: Type): String? {
        // Split identifier of format A.<CONTRACT_ADDRESS>.<CONTRACT_NAME>.<OBJECT_NAME>
        if let identifierSplit = self.splitObjectIdentifier(identifier: fromType.identifier) {
            return identifierSplit[2]
        }
        return nil
    }

    /// Returns the object's name from the given Type's identifier
    ///
    /// @param fromType: The Type to extract the object name from
    ///
    /// @return The object's name, or nil if the identifier does identify an object
    ///
    access(all)
    view fun getObjectName(fromType: Type): String? {
        // Split identifier of format A.<CONTRACT_ADDRESS>.<CONTRACT_NAME>.<OBJECT_NAME>
        if let identifierSplit = self.splitObjectIdentifier(identifier: fromType.identifier) {
            return identifierSplit[3]
        }
        return nil
    }

    /// Splits the given identifier into its constituent parts defined by a delimiter of '".'"
    ///
    /// @param identifier: The identifier to split
    ///
    /// @return An array of the identifier's constituent parts, or nil if the identifier does not have 4 parts
    ///
    access(all)
    view fun splitObjectIdentifier(identifier: String): [String]? {
        let identifierSplit = identifier.split(separator: ".")
        return identifierSplit.length != 4 ? nil : identifierSplit
    }

    /// Builds a composite type from the given identifier parts
    ///
    /// @param address: The defining contract address
    /// @param contractName: The defining contract name
    /// @param resourceName: The resource name
    ///
    access(all)
    view fun buildCompositeType(address: Address, contractName: String, resourceName: String): Type? {
        let addressStr = address.toString()
        let subtract0x = addressStr.slice(from: 2, upTo: addressStr.length)
        let identifier = "A".concat(".").concat(subtract0x).concat(".").concat(contractName).concat(".").concat(resourceName)
        return CompositeType(identifier)
    }

    /**************************
        FungibleToken Utils
     **************************/

    /// Returns the `createEmptyVault()` function from a Vault Type's defining contract or nil if either the Type is not
    access(all) fun getCreateEmptyVaultFunction(forType: Type): (fun (Type): @{FungibleToken.Vault})? {
        // We can only reasonably assume that the requested function is accessible from a FungibleToken contract
        if !forType.isSubtype(of: Type<@{FungibleToken.Vault}>()) {
            return nil
        }
        // Vault Types should guarantee that the following forced optionals are safe
        let contractAddress = self.getContractAddress(fromType: forType)!
        let contractName = self.getContractName(fromType: forType)!
        let tokenContract: &{FungibleToken} = getAccount(contractAddress).contracts.borrow<&{FungibleToken}>(
                name: contractName
            )!
        return tokenContract.createEmptyVault
    }

    /******************************
        Bridge-Access Only Utils
     ******************************/

    /// Deposits fees to the bridge account's FlowToken Vault - helps fund asset storage
    ///
    access(account)
    fun depositFee(_ feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}, feeAmount: UFix64) {
        let vault = self.account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow FlowToken.Vault reference")

        let feeVault <-feeProvider.withdraw(amount: feeAmount) as! @FlowToken.Vault
        assert(feeVault.balance == feeAmount, message: "Fee provider did not return the requested fee")

        vault.deposit(from: <-feeVault)
    }

    /// Enables other bridge contracts to orchestrate bridge operations from contract-owned COA
    ///
    access(account)
    view fun borrowCOA(): auth(EVM.Call, EVM.Withdraw) &EVM.CadenceOwnedAccount {
        return self.account.storage.borrow<auth(EVM.Call, EVM.Withdraw) &EVM.CadenceOwnedAccount>(
            from: FlowEVMBridgeConfig.coaStoragePath
        ) ?? panic("Could not borrow COA reference")
    }

    /// Shared helper simplifying calls using the bridge account's COA
    ///
    access(account)
    fun call(
        signature: String,
        targetEVMAddress: EVM.EVMAddress,
        args: [AnyStruct],
        gasLimit: UInt64,
        value: UFix64
    ): EVM.Result {
        let calldata = EVM.encodeABIWithSignature(signature, args)
        let valueBalance = EVM.Balance(attoflow: 0)
        valueBalance.setFLOW(flow: value)
        return self.borrowCOA().call(
            to: targetEVMAddress,
            data: calldata,
            gasLimit: gasLimit,
            value: valueBalance
        )
    }

    /// Executes a safeTransferFrom call on the given ERC721 contract address, transferring the NFT from bridge escrow
    /// in EVM to the named recipient and asserting pre- and post-state changes.
    ///
    access(account)
    fun mustSafeTransferERC721(erc721Address: EVM.EVMAddress, to: EVM.EVMAddress, id: UInt256) {
        let bridgeCOAAddress = self.getBridgeCOAEVMAddress()

        let bridgePreStatus = self.isOwner(ofNFT: id, owner: bridgeCOAAddress, evmContractAddress: erc721Address)
        let toPreStatus = self.isOwner(ofNFT: id, owner: to, evmContractAddress: erc721Address)
        assert(bridgePreStatus, message: "Bridge COA does not own ERC721 requesting to be transferred")
        assert(!toPreStatus, message: "Recipient already owns ERC721 attempting to be transferred")

        let transferResult: EVM.Result = self.call(
            signature: "safeTransferFrom(address,address,uint256)",
            targetEVMAddress: erc721Address,
            args: [bridgeCOAAddress, to, id],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(
            transferResult.status == EVM.Status.successful,
            message: "safeTransferFrom call to ERC721 transferring NFT from escrow to bridge recipient failed"
        )

        let bridgePostStatus = self.isOwner(ofNFT: id, owner: bridgeCOAAddress, evmContractAddress: erc721Address)
        let toPostStatus = self.isOwner(ofNFT: id, owner: to, evmContractAddress: erc721Address)
        assert(!bridgePostStatus, message: "ERC721 is still in escrow after transfer")
        assert(toPostStatus, message: "ERC721 was not successfully transferred to recipient from escrow")
    }

    /// Executes a safeMint call on the given ERC721 contract address, minting an ERC721 to the named recipient and
    /// asserting pre- and post-state changes. Assumes the bridge COA has the authority to mint the NFT.
    ///
    access(account)
    fun mustSafeMintERC721(erc721Address: EVM.EVMAddress, to: EVM.EVMAddress, id: UInt256, uri: String) {
        let bridgeCOAAddress = self.getBridgeCOAEVMAddress()

        let mintResult: EVM.Result = self.call(
            signature: "safeMint(address,uint256,string)",
            targetEVMAddress: erc721Address,
            args: [to, id, uri],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(mintResult.status == EVM.Status.successful, message: "Mint to bridge recipient failed")

        let toPostStatus = self.isOwner(ofNFT: id, owner: to, evmContractAddress: erc721Address)
        assert(toPostStatus, message: "Recipient does not own the NFT after minting")
    }

    /// Executes updateTokenURI call on the given ERC721 contract address, updating the tokenURI of the NFT. This is
    /// not a standard ERC721 function, but is implemented in the bridge-deployed ERC721 implementation to enable
    /// synchronization of token metadata with Cadence NFT state on bridging.
    ///
    access(account)
    fun mustUpdateTokenURI(erc721Address: EVM.EVMAddress, id: UInt256, uri: String) {
        let bridgeCOAAddress = self.getBridgeCOAEVMAddress()

        let updateResult: EVM.Result = self.call(
            signature: "updateTokenURI(uint256,string)",
            targetEVMAddress: erc721Address,
            args: [id, uri],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(updateResult.status == EVM.Status.successful, message: "URI update failed")
    }

    /// Executes the provided method, assumed to be a protected transfer call, and confirms that the transfer was
    /// successful by validating the named owner is authorized to act on the NFT before the transfer, the transfer
    /// was successful, and the bridge COA owns the NFT after the protected transfer call.
    ///
    access(account)
    fun mustEscrowERC721(
        owner: EVM.EVMAddress,
        id: UInt256,
        erc721Address: EVM.EVMAddress,
        protectedTransferCall: fun (): EVM.Result
    ) {
        // Ensure the named owner is authorized to act on the NFT
        let isAuthorized = self.isOwnerOrApproved(ofNFT: id, owner: owner, evmContractAddress: erc721Address)
        assert(isAuthorized, message: "Named owner is not the owner of the ERC721")

        // Call the protected transfer function which should execute a transfer call from the owner to escrow
        let transferResult = protectedTransferCall()
        assert(transferResult.status == EVM.Status.successful, message: "Transfer ERC721 to escrow via callback failed")

        // Validate the NFT is now owned by the bridge COA, escrow the NFT
        let isEscrowed = self.isOwner(ofNFT: id, owner: self.getBridgeCOAEVMAddress(), evmContractAddress: erc721Address)
        assert(isEscrowed, message: "ERC721 was not successfully escrowed")
    }

    /// Mints ERC20 tokens to the recipient and confirms that the recipient's balance was updated
    ///
    access(account)
    fun mustMintERC20(to: EVM.EVMAddress, amount: UInt256, erc20Address: EVM.EVMAddress) {
        let toPreBalance = self.balanceOf(owner: to, evmContractAddress: erc20Address)
        // Mint tokens to the recipient
        let mintResult: EVM.Result = self.call(
            signature: "mint(address,uint256)",
            targetEVMAddress: erc20Address,
            args: [to, amount],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(mintResult.status == EVM.Status.successful, message: "Mint to bridge ERC20 contract failed")
        // Ensure bridge to recipient was succcessful
        let toPostBalance = self.balanceOf(owner: to, evmContractAddress: erc20Address)
        assert(
            toPostBalance == toPreBalance + amount,
            message: "Recipient didn't receive minted ERC20 tokens during bridging"
        )
    }

    /// Transfers ERC20 tokens to the recipient and confirms that the recipient's balance was incremented and the escrow
    /// balance was decremented by the requested amount.
    ///
    access(account)
    fun mustTransferERC20(to: EVM.EVMAddress, amount: UInt256, erc20Address: EVM.EVMAddress) {
        let bridgeCOAAddress = self.getBridgeCOAEVMAddress()

        let toPreBalance = self.balanceOf(owner: to, evmContractAddress: erc20Address)
        let escrowPreBalance = self.balanceOf(
            owner: bridgeCOAAddress,
            evmContractAddress: erc20Address
        )

        // Transfer tokens to the recipient
        let transferResult: EVM.Result = self.call(
            signature: "transfer(address,uint256)",
            targetEVMAddress: erc20Address,
            args: [to, amount],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(transferResult.status == EVM.Status.successful, message: "transfer call to ERC20 contract failed")

        // Ensure bridge to recipient was succcessful
        let toPostBalance = self.balanceOf(owner: to, evmContractAddress: erc20Address)
        let escrowPostBalance = self.balanceOf(
            owner: bridgeCOAAddress,
            evmContractAddress: erc20Address
        )
        assert(
            toPostBalance == toPreBalance + amount,
            message: "Recipient's ERC20 balance did not increment by the requested amount after transfer from escrow"
        )
        assert(
            escrowPostBalance == escrowPreBalance - amount,
            message: "Escrow ERC20 balance did not decrement by the requested amount after transfer from escrow"
        )
    }

    /// Executes the provided method, assumed to be a protected transfer call, and confirms that the transfer was
    /// successful by validating that the named owner's balance was decremented by the requested amount and the bridge
    /// escrow balance was incremented by the same amount.
    ///
    access(account)
    fun mustEscrowERC20(
        owner: EVM.EVMAddress,
        amount: UInt256,
        erc20Address: EVM.EVMAddress,
        protectedTransferCall: fun (): EVM.Result
    ) {
        // Ensure the caller is has sufficient balance to bridge the requested amount
        let hasSufficientBalance = self.hasSufficientBalance(
            amount: amount,
            owner: owner,
            evmContractAddress: erc20Address
        )
        assert(hasSufficientBalance, message: "Caller does not have sufficient balance to bridge requested tokens")

        // Get the owner and escrow balances before transfer
        let ownerPreBalance = self.balanceOf(owner: owner, evmContractAddress: erc20Address)
        let bridgePreBalance = self.balanceOf(
                owner: self.getBridgeCOAEVMAddress(),
                evmContractAddress: erc20Address
            )

        // Call the protected transfer function which should execute a transfer call from the owner to escrow
        let transferResult = protectedTransferCall()
        assert(transferResult.status == EVM.Status.successful, message: "Transfer via callback failed")

        // Get the resulting balances after transfer
        let ownerPostBalance = self.balanceOf(owner: owner, evmContractAddress: erc20Address)
        let bridgePostBalance = self.balanceOf(
                owner: self.getBridgeCOAEVMAddress(),
                evmContractAddress: erc20Address
            )

        // Confirm the transfer of the expected was successful in both sending owner and recipient escrow
        assert(ownerPostBalance == ownerPreBalance - amount, message: "Transfer to owner failed")
        assert(bridgePostBalance == bridgePreBalance + amount, message: "Transfer to bridge escrow failed")
    }

    /// Calls to the bridge factory to deploy an ERC721/ERC20 contract and returns the deployed contract address
    ///
    access(account)
    fun mustDeployEVMContract(
        name: String,
        symbol: String,
        cadenceAddress: Address,
        flowIdentifier: String,
        contractURI: String,
        isERC721: Bool
    ): EVM.EVMAddress {
        let deployerTag = isERC721 ? "ERC721" : "ERC20"
        let deployResult: EVM.Result = self.call(
            signature: "deploy(string,string,string,string,string,string)",
            targetEVMAddress: self.bridgeFactoryEVMAddress,
            args: [deployerTag, name, symbol, cadenceAddress.toString(), flowIdentifier, contractURI],
            gasLimit: FlowEVMBridgeConfig.gasLimit,
            value: 0.0
        )
        assert(deployResult.status == EVM.Status.successful, message: "EVM Token contract deployment failed")
        let decodedResult: [AnyStruct] = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: deployResult.data)
        assert(decodedResult.length == 1, message: "Invalid response length")
        return decodedResult[0] as! EVM.EVMAddress
    }

    init(bridgeFactoryAddressHex: String) {
        self.delimiter = "_"
        self.contractNamePrefixes = {
            Type<@{NonFungibleToken.NFT}>(): {
                "bridged": "EVMVMBridgedNFT"
            },
            Type<@{FungibleToken.Vault}>(): {
                "bridged": "EVMVMBridgedToken"
            }
        }
        self.bridgeFactoryEVMAddress = EVM.addressFromString(bridgeFactoryAddressHex.toLower())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/test/CrossVMBridgeERC721Fulfillment.t.sol

```
pragma solidity 0.8.24;

import {Test} from "forge-std/Test.sol";

import {IERC721Errors} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ICrossVMBridgeCallable} from "../src/interfaces/ICrossVMBridgeCallable.sol";
import {ICrossVMBridgeERC721Fulfillment} from "../src/interfaces/ICrossVMBridgeERC721Fulfillment.sol";
import {ICrossVMBridgeERC721Fulfillment} from "../src/interfaces/ICrossVMBridgeERC721Fulfillment.sol";
import {CadenceNativeERC721} from "../src/example-assets/CadenceNativeERC721.sol";

contract CrossVMBridgeERC721FulfillmentTest is Test {
    CadenceNativeERC721 internal erc721Impl;

    string name;
    string symbol;
    address vmBridge;

    address recipient;

    uint256 fulfilledId;
    bytes emptyBytes;

    function setUp() public {
        name = "name";
        symbol = "symbol";

        vmBridge = address(100);
        recipient = address(101);

        fulfilledId = 42;
        emptyBytes = new bytes(0);

        erc721Impl = new CadenceNativeERC721(name, symbol, vmBridge);
    }

    function test_VMBridgeAddressMatches() public view {
        address actualVMBridge = erc721Impl.vmBridgeAddress();
        assertEq(vmBridge, actualVMBridge);
    }

    function test_FulfillToEVMAsUnauthorizedFails() public {
        vm.prank(recipient);
        vm.expectRevert(
            abi.encodeWithSelector(ICrossVMBridgeCallable.CrossVMBridgeCallableUnauthorizedAccount.selector, recipient)
        );
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);
    }

    function test_FulfillToEVMMintSucceeds() public {
        bool exists = erc721Impl.exists(fulfilledId);
        assertFalse(exists);

        // Ensure fulfilledId is nonexistent
        vm.expectRevert(
            abi.encodeWithSelector(IERC721Errors.ERC721NonexistentToken.selector, fulfilledId)
        );
        erc721Impl.ownerOf(fulfilledId);

        // Check current counter values
        uint256 beforeCounter = erc721Impl.beforeCounter();
        uint256 afterCounter = erc721Impl.afterCounter();

        // Call fulfillToEVM minting fulfilledId & incrementing before and after counters
        vm.expectEmit();
        emit ICrossVMBridgeERC721Fulfillment.FulfilledToEVM(recipient, fulfilledId);

        vm.prank(vmBridge);
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);

        // Confirm id was fulfilled to recipient
        address ownerOf = erc721Impl.ownerOf(fulfilledId);
        exists = erc721Impl.exists(fulfilledId);
        assertEq(recipient, ownerOf);
        assertTrue(exists);

        // Confirm overridden before & after hooks executed
        uint256 postFulfillmentBeforeCounter = erc721Impl.beforeCounter();
        uint256 postFulfillmentAfterCounter = erc721Impl.afterCounter();
        assertEq(postFulfillmentBeforeCounter, beforeCounter + 1);
        assertEq(postFulfillmentAfterCounter, afterCounter + 1);
    }

    function test_FulfillToEVMUnescrowedFails() public {
        // Ensure fulfilledId is nonexistent
        vm.expectRevert(
            abi.encodeWithSelector(IERC721Errors.ERC721NonexistentToken.selector, fulfilledId)
        );
        erc721Impl.ownerOf(fulfilledId);

        // Check current counter values
        uint256 beforeCounter = erc721Impl.beforeCounter();
        uint256 afterCounter = erc721Impl.afterCounter();

        // Call fulfillToEVM minting fulfilledId & incrementing before and after counters
        vm.expectEmit();
        emit ICrossVMBridgeERC721Fulfillment.FulfilledToEVM(recipient, fulfilledId);

        vm.prank(vmBridge);
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);

        // Confirm id was fulfilled to recipient
        address ownerOf = erc721Impl.ownerOf(fulfilledId);
        assertEq(recipient, ownerOf);

        // Confirm overridden before & after hooks executed
        uint256 postFulfillmentBeforeCounter = erc721Impl.beforeCounter();
        uint256 postFulfillmentAfterCounter = erc721Impl.afterCounter();
        assertEq(postFulfillmentBeforeCounter, beforeCounter + 1);
        assertEq(postFulfillmentAfterCounter, afterCounter + 1);

        // Ensure call fails without token in escrow
        vm.prank(vmBridge);
        vm.expectRevert(
            abi.encodeWithSelector(ICrossVMBridgeERC721Fulfillment.FulfillmentFailedTokenNotEscrowed.selector, fulfilledId, vmBridge)
        );
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);
    }

    function test_FulfillToEVMFromEscrowSucceeds() public {
        // Ensure fulfilledId is nonexistent
        vm.expectRevert(
            abi.encodeWithSelector(IERC721Errors.ERC721NonexistentToken.selector, fulfilledId)
        );
        erc721Impl.ownerOf(fulfilledId);

        // Check current counter values
        uint256 beforeCounter = erc721Impl.beforeCounter();
        uint256 afterCounter = erc721Impl.afterCounter();

        // Call fulfillToEVM minting fulfilledId & incrementing before and after counters
        vm.expectEmit();
        emit ICrossVMBridgeERC721Fulfillment.FulfilledToEVM(recipient, fulfilledId);

        vm.prank(vmBridge);
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);

        // Confirm id was fulfilled to recipient
        address ownerOf = erc721Impl.ownerOf(fulfilledId);
        assertEq(recipient, ownerOf);

        // Confirm overridden before & after hooks executed
        uint256 postFulfillmentBeforeCounter = erc721Impl.beforeCounter();
        uint256 postFulfillmentAfterCounter = erc721Impl.afterCounter();
        assertEq(postFulfillmentBeforeCounter, beforeCounter + 1);
        assertEq(postFulfillmentAfterCounter, afterCounter + 1);

        // Confirm escrow status
        bool isEscrowed = ICrossVMBridgeERC721Fulfillment(erc721Impl).isEscrowed(fulfilledId);
        assertFalse(isEscrowed);
        
        // Transfer from recipient to escrow & confirm escrow status
        vm.prank(recipient);
        erc721Impl.safeTransferFrom(recipient, vmBridge, fulfilledId);

        address currentOwner = erc721Impl.ownerOf(fulfilledId);
        isEscrowed = ICrossVMBridgeERC721Fulfillment(erc721Impl).isEscrowed(fulfilledId);
        assertEq(vmBridge, currentOwner);
        assertTrue(isEscrowed);
 
        // Call fulfillToEVM minting fulfilledId & incrementing before and after counters
        vm.expectEmit();
        emit ICrossVMBridgeERC721Fulfillment.FulfilledToEVM(recipient, fulfilledId);

        vm.prank(vmBridge);
        ICrossVMBridgeERC721Fulfillment(erc721Impl).fulfillToEVM(recipient, fulfilledId, emptyBytes);

        // Confirm id was fulfilled to recipient
        ownerOf = erc721Impl.ownerOf(fulfilledId);
        assertEq(recipient, ownerOf);

        // Confirm overridden before & after hooks executed
        postFulfillmentBeforeCounter = erc721Impl.beforeCounter();
        postFulfillmentAfterCounter = erc721Impl.afterCounter();
        assertEq(postFulfillmentBeforeCounter, beforeCounter + 2);
        assertEq(postFulfillmentAfterCounter, afterCounter + 2);
    }

    function test_SupportsAllExpectedInterfacesSucceeds() public view {
        assertTrue(erc721Impl.supportsInterface(type(IERC721).interfaceId));
        assertTrue(erc721Impl.supportsInterface(type(ICrossVMBridgeERC721Fulfillment).interfaceId));
        assertTrue(erc721Impl.supportsInterface(type(ICrossVMBridgeCallable).interfaceId));
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/example-assets/CadenceNativeERC721.sol

```
pragma solidity 0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {CrossVMBridgeERC721Fulfillment} from "../interfaces/CrossVMBridgeERC721Fulfillment.sol";

/**
  * @title CadenceNativeERC721
  * @dev This contract is a minimal ERC721 implementation demonstrating the use of the
 * CrossVMBridgeERC721Fulfillment base contract. Such ERC721 contracts are intended for use in
 * cross-VM NFT implementations where projects deploy both a Cadence & Solidity definition with
 * movement of individual NFTs facilitated by Flow's canonical VM bridge.
 * In such cases, NFTs must be distributed in either Cadence or EVM - this is termed the NFT's
 * "native" VM. When moving the NFT into the non-native VM, the bridge implements a mint/escrow
 * pattern, minting if the NFT does not exist and unlocking from escrow if it does.
 * The contract below demonstrates the Solidity implementation for a Cadence-native NFT. By
 * implementing CrossVMBridgeERC721Fulfillment and correctly naming the vmBridgeAddress as the
 * bridge's CadenceOwnedAccount EVM address, this ERC721 enables the bridge to execute the
 * mint/escrow needed to fulfill bridge requests.
 *
 * For more information on cross-VM NFTs, see Flow's developer documentation as well as
 * FLIP-318: https://github.com/onflow/flips/issues/318
 */
contract CadenceNativeERC721 is CrossVMBridgeERC721Fulfillment {
    
    // included to test before & after fulfillment hooks
    uint256 public beforeCounter;
    uint256 public afterCounter;
    
    constructor(
        string memory name_,
        string memory symbol_,
        address _vmBridgeAddress
    ) CrossVMBridgeERC721Fulfillment(_vmBridgeAddress) ERC721(name_, symbol_) {}

    /**
     * @dev This hook executes before the fulfillment into EVM executes. It's overridden here as
     * a simple demonstration and for testing; however, you might include your own validation or
     * pre-processing.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _beforeFulfillment(address _to, uint256 _id, bytes memory _data) internal override {
        beforeCounter += 1;
    }

    /**
     * @dev This hook executes after the fulfillment into EVM executes. It's overridden here as
     * a simple demonstration and for testing; however, you might include your own validation or
     * post-processing. For instance, you may decode the bytes passed by the VM bridge at the
     * time of bridging into EVM and update the token's metadata. Since you presumably control the
     * corresponding Cadence implementation, what is passed to your at fulfillment is in your
     * control by having your Cadence NFT resolve the `EVMBytesMetadata` view.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _afterFulfillment(address _to, uint256 _id, bytes memory _data) internal override {
        afterCounter += 1;
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/onboarding/onboard_by_evm_address.cdc

```
import "FungibleToken"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"

/// This transaction onboards the NFT type to the bridge, configuring the bridge to move NFTs between environments
/// NOTE: This must be done before bridging a Cadence-native NFT to EVM
///
/// @param contractAddressHex: The EVM address of the contract defining the bridgeable asset to be onboarded
///
transaction(contractAddressHex: String) {

    let contractAddress: EVM.EVMAddress
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct EVMAddress from hex string (no leading `"0x"`) --- */
        //
        self.contractAddress = EVM.addressFromString(contractAddressHex)

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the EVM contract
        FlowEVMBridge.onboardByEVMAddress(
            self.contractAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/derive_bridged_token_contract_name.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

access(all)
fun main(evmAddressHex: String): String {
    return FlowEVMBridgeUtils.deriveBridgedTokenContractName(
        from: EVM.addressFromString(evmAddressHex)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/gas/set_gas_limit.cdc

```
import "FlowEVMBridgeConfig"

/// Sets the gas limit for all bridge-related operations in EVM.
///
/// @param gasLimit: The new gas limit for all bridge-related operations in EVM.
///
transaction(gasLimit: UInt64) {

    let admin: auth(FlowEVMBridgeConfig.Gas) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeConfig.Gas) &FlowEVMBridgeConfig.Admin>(from: FlowEVMBridgeConfig.adminStoragePath)
            ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        self.admin.setGasLimit(gasLimit)
    }

    post {
        FlowEVMBridgeConfig.gasLimit == gasLimit: "Problem setting gasLimit to: ".concat(gasLimit.toString())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/deploy_bridge_accessor.cdc

```
transaction(name: String, code: String, evmAddress: Address) {
  prepare(signer: auth(AddContract) &Account) {
    signer.contracts.add(name: name, code: code.utf8, publishToEVMAccount: evmAddress)
  }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/example-assets/ExampleToken.cdc

```
import "FungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

access(all) contract ExampleToken: FungibleToken {

    /// The event that is emitted when new tokens are minted
    access(all) event TokensMinted(amount: UFix64, type: String)

    /// Total supply of ExampleTokens in existence
    access(all) var totalSupply: UFix64

    /// Storage and Public Paths
    access(all) let VaultStoragePath: StoragePath
    access(all) let VaultPublicPath: PublicPath
    access(all) let ReceiverPublicPath: PublicPath
    access(all) let AdminStoragePath: StoragePath

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>(),
            Type<FungibleTokenMetadataViews.TotalSupply>()
        ]
    }

    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let medias = MetadataViews.Medias([media])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Example Fungible Token",
                    symbol: "EFT",
                    description: "This fungible token is used as an example to help you develop your next FT #onFlow.",
                    externalURL: MetadataViews.ExternalURL("https://example-ft.onflow.org"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: /storage/exampleTokenVault,
                    receiverPath: /public/exampleTokenReceiver,
                    metadataPath: /public/exampleTokenVault,
                    receiverLinkedType: Type<&ExampleToken.Vault>(),
                    metadataLinkedType: Type<&ExampleToken.Vault>(),
                    createEmptyVaultFunction: (fun(): @{FungibleToken.Vault} {
                        return <-ExampleToken.createEmptyVault(vaultType: Type<@ExampleToken.Vault>())
                    })
                )
            case Type<FungibleTokenMetadataViews.TotalSupply>():
                return FungibleTokenMetadataViews.TotalSupply(
                    totalSupply: ExampleToken.totalSupply
                )
        }
        return nil
    }

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    access(all) resource Vault: FungibleToken.Vault {

        /// The total balance of this vault
        access(all) var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// Called when a fungible token is burned via the `Burner.burn()` method
        access(contract) fun burnCallback() {
            if self.balance > 0.0 {
                ExampleToken.totalSupply = ExampleToken.totalSupply - self.balance
            }
            self.balance = 0.0
        }

        access(all) view fun getViews(): [Type] {
            return ExampleToken.getContractViews(resourceType: nil)
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return ExampleToken.resolveContractView(resourceType: nil, viewType: view)
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[self.getType()] = true
            return supportedTypes
        }

        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Asks if the amount can be withdrawn from this vault
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return amount <= self.balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the tokens that are being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @ExampleToken.Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            let vault <- from as! @ExampleToken.Vault
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        /// createEmptyVault
        ///
        /// Function that creates a new Vault with a balance of zero
        /// and returns it to the calling context. A user must call this function
        /// and store the returned Vault in their storage in order to allow their
        /// account to be able to receive deposits of this token type.
        ///
        access(all) fun createEmptyVault(): @ExampleToken.Vault {
            return <-create Vault(balance: 0.0)
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    access(all) resource Minter {
        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        access(all) fun mintTokens(amount: UFix64): @ExampleToken.Vault {
            ExampleToken.totalSupply = ExampleToken.totalSupply + amount
            emit TokensMinted(amount: amount, type: self.getType().identifier)
            return <-create Vault(balance: amount)
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    access(all) fun createEmptyVault(vaultType: Type): @ExampleToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 1000.0

        self.VaultStoragePath = /storage/exampleTokenVault
        self.VaultPublicPath = /public/exampleTokenVault
        self.ReceiverPublicPath = /public/exampleTokenReceiver
        self.AdminStoragePath = /storage/exampleTokenAdmin 

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)

        // Create a public capability to the stored Vault that exposes
        // the `deposit` method and getAcceptedTypes method through the `Receiver` interface
        // and the `balance` method through the `Balance` interface
        //
        let exampleTokenCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(exampleTokenCap, at: self.VaultPublicPath)
        let receiverCap = self.account.capabilities.storage.issue<&ExampleToken.Vault>(self.VaultStoragePath)
        self.account.capabilities.publish(receiverCap, at: self.ReceiverPublicPath)

        self.account.storage.save(<-vault, to: /storage/exampleTokenVault)

        let admin <- create Minter()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm-integration/claim_accessor_capability_and_save_router.cdc

```
import "EVM"

import "FlowEVMBridgeAccessor"

/// This transaction is intended to be run by the EVM contract account after FlowEVMBridgeAccessor.BridgeAccessor has
/// been configured in the bridge account and its Capability has been published to be claimed by the EVM account. If a
/// BridgeRouter implementation already exists from a previous bridge integration, it will be destroyed and replaced.
///
/// @param name: The name of the BridgeAccessor Capability to claim
/// @param provider: The address of the account that published the BridgeAccessor Capability
///
transaction(name: String, provider: Address) {

    let accessorCap: Capability<auth(EVM.Bridge) &FlowEVMBridgeAccessor.BridgeAccessor>
    let routerRef: auth(EVM.Bridge) &{EVM.BridgeRouter}

    prepare(signer: auth(ClaimInboxCapability, Storage) &Account) {
        let routerStoragePath = /storage/evmBridgeRouter
        
        // Claim the BridgeAccessor Capability
        self.accessorCap = signer.inbox.claim<auth(EVM.Bridge) &FlowEVMBridgeAccessor.BridgeAccessor>(
                name,
                provider: provider
            ) ?? panic("BridgeAccessor Capability not found")

        // Ensure the Capability is valid and nothing is stored where the BridgeRouter should be stored
        assert(self.accessorCap.check() == true, message: "Invalid BridgeAccessor Capability")

        // If a BridgeRouter implementation already exists from previous bridge integration, load and destroy it
        if let existingRouter = signer.storage.borrow<auth(EVM.Bridge) &{EVM.BridgeRouter}>(from: routerStoragePath) {
            destroy <-signer.storage.load<@AnyResource>(from: routerStoragePath)
        }

        // Ensure there is nothing in storage where the new BridgeRouter should be stored
        assert(signer.storage.type(at: routerStoragePath) == nil, message: "Unexpected object found in storage")

        // Create and save the BridgeRouter implementation for the current bridge integration
        let router <-self.accessorCap.borrow()!.createBridgeRouter()
        signer.storage.save(<-router, to: routerStoragePath)

        // Borrow the router from storage and set the BridgeAccessor Capability
        self.routerRef = signer.storage.borrow<auth(EVM.Bridge) &{EVM.BridgeRouter}>(from: routerStoragePath)
            ?? panic("BridgeRouter not found in storage")
    }

    execute {
        self.routerRef.setBridgeAccessor(self.accessorCap)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/calculate_bridge_fee.cdc

```
import "FlowEVMBridgeUtils"

/// Returns the calculated fee based on the number of bytes used to escrow an asset plus the base fee.
///
/// @param bytes: The number of bytes used to escrow an asset.
///
/// @return The calculated fee to be paid in FlowToken
///
access(all)
fun main(bytes used: UInt64): UFix64 {
    return FlowEVMBridgeUtils.calculateBridgeFee(bytes: used)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/utils/ScopedFTProviders.cdc

```
import "FungibleToken"
import "StringUtils"

// Copied from https://github.com/green-goo-dao/flow-utils/blob/crescendo/contracts/ScopedFTProviders.cdc with minor changes
// Special thanks to the Green Goo Dao contributors for creating this contract
//
// ScopedFTProviders
//
// TO AVOID RISK, PLEASE DEPLOY YOUR OWN VERSION OF THIS CONTRACT SO THAT
// MALICIOUS UPDATES ARE NOT POSSIBLE
//
// ScopedProviders are meant to solve the issue of unbounded access FungibleToken vaults
// when a provider is called for.
access(all) contract ScopedFTProviders {
    access(all) struct interface FTFilter {
        access(all) view fun canWithdrawAmount(_ amount: UFix64): Bool
        access(FungibleToken.Withdraw) fun markAmountWithdrawn(_ amount: UFix64)
        access(all) fun getDetails(): {String: AnyStruct}
    }

    access(all) struct AllowanceFilter: FTFilter {
        access(self) let allowance: UFix64
        access(self) var allowanceUsed: UFix64

        init(_ allowance: UFix64) {
            self.allowance = allowance
            self.allowanceUsed = 0.0
        }

        access(all) view fun canWithdrawAmount(_ amount: UFix64): Bool {
            return amount + self.allowanceUsed <= self.allowance
        }

        access(FungibleToken.Withdraw) fun markAmountWithdrawn(_ amount: UFix64) {
            self.allowanceUsed = self.allowanceUsed + amount
        }

        access(all) fun getDetails(): {String: AnyStruct} {
            return {
                "allowance": self.allowance,
                "allowanceUsed": self.allowanceUsed
            }
        }
    }

    // ScopedFTProvider
    //
    // A ScopedFTProvider is a wrapped FungibleTokenProvider with
    // filters that can be defined by anyone using the ScopedFTProvider.
    access(all) resource ScopedFTProvider: FungibleToken.Provider {
        access(self) let provider: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
        access(self) var filters: [{FTFilter}]

        // block timestamp that this provider can no longer be used after
        access(self) let expiration: UFix64?

        access(all) init(provider: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>, filters: [{FTFilter}], expiration: UFix64?) {
            pre {
                provider.check(): "Invalid Provider Capability"
            }
            self.provider = provider
            self.filters = filters
            self.expiration = expiration
        }

        access(all) fun check(): Bool {
            return self.provider.check()
        }

        access(all) view fun isExpired(): Bool {
            if let expiration = self.expiration {
                return getCurrentBlock().timestamp >= expiration
            }
            return false
        }

        access(all) view fun canWithdraw(_ amount: UFix64): Bool {
            if self.isExpired() {
                return false
            }

            for filter in self.filters {
                if !filter.canWithdrawAmount(amount) {
                    return false
                }
            }

            return true
        }

        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return self.canWithdraw(amount)
        }

        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault} {
            pre {
                !self.isExpired(): "provider has expired"
            }

            var i = 0
            while i < self.filters.length {
                if !self.filters[i].canWithdrawAmount(amount) {
                    panic(StringUtils.join(["cannot withdraw tokens. filter of type", self.filters[i].getType().identifier, "failed."], " "))
                }

                self.filters[i].markAmountWithdrawn(amount)
                i = i + 1
            }

            return <-self.provider.borrow()!.withdraw(amount: amount)
        }

        access(all) fun getDetails(): [{String: AnyStruct}] {
            let details: [{String: AnyStruct}] = []
            for filter in self.filters {
                details.append(filter.getDetails())
            }

            return details
        }
    }

    access(all) fun createScopedFTProvider(
        provider: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>,
        filters: [{FTFilter}],
        expiration: UFix64?
    ): @ScopedFTProvider {
        return <- create ScopedFTProvider(provider: provider, filters: filters, expiration: expiration)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeAccessor.cdc

```
import "NonFungibleToken"
import "FungibleToken"
import "FlowToken"

import "EVM"

import "FlowEVMBridgeConfig"
import "FlowEVMBridge"

/// This contract defines a mechanism for routing bridge requests from the EVM contract to the Flow-EVM bridge contract
///
access(all)
contract FlowEVMBridgeAccessor {

    access(all) let StoragePath: StoragePath
    
    /// BridgeAccessor implementation used by the EVM contract to route bridge calls from COA resources
    ///
    access(all)
    resource BridgeAccessor : EVM.BridgeAccessor {

        /// Passes along the bridge request to dedicated bridge contract
        ///
        /// @param nft: The NFT to be bridged to EVM
        /// @param to: The address of the EVM account to receive the bridged NFT
        /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
        ///
        access(EVM.Bridge)
        fun depositNFT(
            nft: @{NonFungibleToken.NFT},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ) {
            FlowEVMBridge.bridgeNFTToEVM(token: <-nft, to: to, feeProvider: feeProvider)
        }

        /// Passes along the bridge request to the dedicated bridge contract, returning the bridged NFT
        ///
        /// @param caller: A reference to the COA which currently owns the NFT in EVM
        /// @param type: The Cadence type of the NFT to be bridged from EVM
        /// @param id: The ID of the NFT to be bridged from EVM
        /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
        ///
        /// @return The bridged NFT
        ///
        access(EVM.Bridge)
        fun withdrawNFT(
            caller: auth(EVM.Call) &EVM.CadenceOwnedAccount,
            type: Type,
            id: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{NonFungibleToken.NFT} {
            // Define a callback function, enabling the bridge to act on the ephemeral COA reference in scope
            var executed = false
            fun callback(): EVM.Result {
                pre {
                    !executed: "Callback can only be executed once"
                }
                post {
                    executed: "Callback must be executed"
                }
                executed = true
                return caller.call(
                    to: FlowEVMBridge.getAssociatedEVMAddress(with: type)
                        ?? panic("No EVM address associated with type"),
                    data: EVM.encodeABIWithSignature(
                        "safeTransferFrom(address,address,uint256)",
                        [caller.address(), FlowEVMBridge.getBridgeCOAEVMAddress(), id]
                    ),
                    gasLimit: FlowEVMBridgeConfig.gasLimit,
                    value: EVM.Balance(attoflow: 0)
                )
            }
            // Execute the bridge request
            return <- FlowEVMBridge.bridgeNFTFromEVM(
                owner: caller.address(),
                type: type,
                id: id,
                feeProvider: feeProvider,
                protectedTransferCall: callback
            )
        }

        /// Passes along the bridge request to dedicated bridge contract
        ///
        /// @param vault: The fungible token vault to be bridged to EVM
        /// @param to: The address of the EVM account to receive the bridged tokens
        /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
        ///
        access(EVM.Bridge)
        fun depositTokens(
            vault: @{FungibleToken.Vault},
            to: EVM.EVMAddress,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ) {
            FlowEVMBridge.bridgeTokensToEVM(vault: <-vault, to: to, feeProvider: feeProvider)
        }

        /// Passes along the bridge request to the dedicated bridge contract, returning the bridged FungibleToken
        ///
        /// @param caller: A reference to the COA which currently owns the tokens in EVM
        /// @param type: The Cadence type of the fungible token vault to be bridged from EVM
        /// @param amount: The amount of tokens to be bridged
        /// @param feeProvider: A reference to a FungibleToken Provider from which the bridging fee is withdrawn in $FLOW
        ///
        /// @return The bridged FungibleToken Vault
        ///
        access(EVM.Bridge)
        fun withdrawTokens(
            caller: auth(EVM.Call) &EVM.CadenceOwnedAccount,
            type: Type,
            amount: UInt256,
            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        ): @{FungibleToken.Vault} {
            // Define a callback function, enabling the bridge to act on the ephemeral COA reference in scope
            var executed = false
            fun callback(): EVM.Result {
                pre {
                    !executed: "Callback can only be executed once"
                }
                post {
                    executed: "Callback must be executed"
                }
                executed = true
                return caller.call(
                    to: FlowEVMBridge.getAssociatedEVMAddress(with: type)
                        ?? panic("No EVM address associated with type"),
                    data: EVM.encodeABIWithSignature(
                        "transfer(address,uint256)",
                        [FlowEVMBridge.getBridgeCOAEVMAddress(), amount]
                    ),
                    gasLimit: FlowEVMBridgeConfig.gasLimit,
                    value: EVM.Balance(attoflow: 0)
                )
            }
            // Execute the bridge request
            return <- FlowEVMBridge.bridgeTokensFromEVM(
                owner: caller.address(),
                type: type,
                amount: amount,
                feeProvider: feeProvider,
                protectedTransferCall: callback
            )
        }

        /// Returns a BridgeRouter resource so a Capability on this BridgeAccessor can be stored in the BridgeRouter
        ///
        access(EVM.Bridge) fun createBridgeRouter(): @BridgeRouter {
            return <-create BridgeRouter()
        }
    }

    /// BridgeRouter implementation used by the EVM contract to capture a BridgeAccessor Capability and route bridge
    /// calls from COA resources to the FlowEVMBridge contract
    ///
    access(all) resource BridgeRouter : EVM.BridgeRouter {
        /// Capability to the BridgeAccessor resource, initialized to nil
        access(self) var bridgeAccessorCap: Capability<auth(EVM.Bridge) &{EVM.BridgeAccessor}>?

        init() {
            self.bridgeAccessorCap = nil
        }

        /// Returns an EVM.Bridge entitled reference to the underlying BridgeAccessor resource
        ///
        access(EVM.Bridge) view fun borrowBridgeAccessor(): auth(EVM.Bridge) &{EVM.BridgeAccessor} {
            let cap = self.bridgeAccessorCap ?? panic("BridgeAccessor Capabaility is not yet set")
            return cap.borrow() ?? panic("Problem retrieving BridgeAccessor reference")
        }

        /// Sets the BridgeAccessor Capability in the BridgeRouter
        access(EVM.Bridge) fun setBridgeAccessor(_ accessorCap: Capability<auth(EVM.Bridge) &{EVM.BridgeAccessor}>) {
            self.bridgeAccessorCap = accessorCap
        }
    }

    init(publishToEVMAccount: Address) {
        self.StoragePath = /storage/flowEVMBridgeAccessor
        self.account.storage.save(
            <-create BridgeAccessor(),
            to: self.StoragePath
        )
        let cap = self.account.capabilities.storage.issue<auth(EVM.Bridge) &BridgeAccessor>(self.StoragePath)
        self.account.inbox.publish(cap, name: "FlowEVMBridgeAccessor", recipient: publishToEVMAccount)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/tokens/get_all_vault_info_from_storage.cdc

```
import "FungibleToken"
import "FlowToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

/// Custom struct to store Fungible Token vault info
access(all)
struct FTVaultInfo {
    /// The name of the Fungible Token
    access(all) let name: String
    /// The symbol of the Fungible Token
    access(all) let symbol: String
    /// The balance of the Fungible Token
    access(all) var balance: UFix64
    /// The address of the Fungible Token contract
    access(all) let tokenContractAddress: Address
    /// The name of the Fungible Token contract
    access(all) let tokenContractName: String
    /// The storage path of the Fungible Token vault
    access(all) let storagePath: StoragePath
    /// The receiver path of the Fungible Token vault
    access(all) let receiverPath: PublicPath

    init(
        name: String,
        symbol: String,
        balance: UFix64,
        tokenContractAddress: Address,
        tokenContractName: String,
        storagePath: StoragePath,
        receiverPath: PublicPath
    ) {
        self.name = name
        self.symbol = symbol
        self.balance = balance
        self.tokenContractAddress = tokenContractAddress
        self.tokenContractName = tokenContractName
        self.storagePath = storagePath
        self.receiverPath = receiverPath
    }

    /// Updates the balance of the Fungible Token vault
    access(all) fun updateBalance(delta: UFix64) {
        self.balance = self.balance + delta
    }
}

/// Returns a FTVaultInfo struct with the provided data
///
/// @param vaultType: The type of the Fungible Token vault
/// @param balance: The balance of the Fungible Token vault
/// @param display: The FTDisplay view of the Fungible Token vault
/// @param data: The FTVaultData view of the Fungible Token vault
///
/// @return FTVaultInfo: The FTVaultInfo struct with the provided data
///
access(all)
fun getVaultInfo(
    vaultType: Type,
    balance: UFix64,
    display: FungibleTokenMetadataViews.FTDisplay,
    data: FungibleTokenMetadataViews.FTVaultData
): FTVaultInfo {
    let identifier = vaultType.identifier
    let addrString = "0x".concat(identifier.split(separator: ".")[1])
    let contractAddress = Address.fromString(addrString) ?? panic("INVALID ADDRESS: ".concat(addrString))
    let contractName = identifier.split(separator: ".")[2]

    return FTVaultInfo(
        name: display.name,
        symbol: display.symbol,
        balance: balance,
        tokenContractAddress: contractAddress,
        tokenContractName: contractName,
        storagePath: data.storagePath,
        receiverPath: data.receiverPath
    )
}

/// Returns a mapping of all Fungible Token vaults stored in the account's storage indexed by their type
///
/// @param address: The address of the account to query
///
/// @return {Type: FTVaultInfo}: A mapping of vault types to their respective info
access(all)
fun main(address: Address): {Type: FTVaultInfo} {
    let acct = getAuthAccount<auth(BorrowValue) &Account>(address)
    let res: {Type: FTVaultInfo} = {}

    // Define target types
    let ftVaultType = Type<@{FungibleToken.Vault}>()
    let displayType = Type<FungibleTokenMetadataViews.FTDisplay>()
    let dataType = Type<FungibleTokenMetadataViews.FTVaultData>()

    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
        if type.isSubtype(of: ftVaultType) {
            // Reference the Vault at the current storage path
            let vault = acct.storage.borrow<&{FungibleToken.Vault}>(from: path)
                ?? panic("Problem borrowing vault from path: ".concat(path.toString()))
            // Get the balance
            var balance = vault.balance
            // Update the balance if the Vault type has already been encountered & return early
            if let info = res[type] {
                info.updateBalance(delta: balance)
                return true
            }

            // Resolve FT metadata views
            let display = vault.resolveView(displayType) as! FungibleTokenMetadataViews.FTDisplay?
            let data = vault.resolveView(dataType) as! FungibleTokenMetadataViews.FTVaultData?
            // Continue if metadata views are not resolved - no relevant info to capture
            if display == nil || data == nil {
                return true
            }
            // Capture the relevant info and insert to our result mapping
            let info = getVaultInfo(vaultType: type, balance: balance, display: display!, data: data!)
            res.insert(key: type, info)
        }
        return true
    })
    return res
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/blocklist/unblock_evm_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Unblocks the given EVM contract address from onboarding to the bridge.
///
/// @param evmContractHex: The EVM contract address to unblock
///
transaction(evmContractHex: String) {

    let evmBlocklist: auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.EVMBlocklist
    let evmAddress: EVM.EVMAddress

    prepare(signer: auth(BorrowValue) &Account) {
        self.evmBlocklist = signer.storage.borrow<auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.EVMBlocklist>(
                from: /storage/evmBlocklist
            ) ?? panic("Could not borrow FlowEVMBridgeConfig EVMBlocklist reference")
        self.evmAddress = EVM.addressFromString(evmContractHex)
    }

    execute {
        self.evmBlocklist.unblock(self.evmAddress)
    }

    post {
        !FlowEVMBridgeConfig.isEVMAddressBlocked(self.evmAddress): "EVM address was not unblocked"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/bridge_nft_to_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges an NFT from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftIdentifier: String, id: UInt64) {
    
    let nft: @{NonFungibleToken.NFT}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")
        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(nftType.identifier))
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                .concat(collectionData.storagePath.toString()))

        // Withdraw the requested NFT & set a cap on the withdrawable bridge fee
        self.nft <- collection.withdraw(withdrawID: id)
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support the requested asset type ".concat(nftIdentifier))
        // Add the onboarding fee if onboarding is necessary
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.nft.getType().identifier == nftIdentifier:
            "Attempting to send invalid nft type - requested: ".concat(nftIdentifier)
            .concat(", sending: ").concat(self.nft.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge
        self.coa.depositNFT(
            nft: <-self.nft,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/tokens/bridge_tokens_from_evm.cdc

```
import "FungibleToken"
import "FungibleTokenMetadataViews"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges fungible tokens from EVM to Cadence assuming it has already been onboarded to the
/// FlowEVMBridge.
///
/// NOTE: The ERC20 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM
///
transaction(vaultIdentifier: String, amount: UInt256) {

    let vaultType: Type
    let receiver: &{FungibleToken.Vault}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        self.vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: self.vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Reference the signer's Vault --- */
        //
        // Borrow a reference to the FungibleToken Vault, configuring if necessary
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract with name"
                .concat(tokenContractName).concat(" and address ")
                .concat(tokenContractAddress.toString()))
        let vaultData = viewResolver.resolveContractView(
                resourceType: self.vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view for Vault type ".concat(self.vaultType.identifier))
        // If the vault does not exist, create it and publish according to the contract's defined configuration
        if signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath) == nil {
            signer.storage.save(<-vaultData.createEmptyVault(), to: vaultData.storagePath)

            signer.capabilities.unpublish(vaultData.receiverPath)
            signer.capabilities.unpublish(vaultData.metadataPath)

            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)
            let metadataCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)

            signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
            signer.capabilities.publish(metadataCap, at: vaultData.metadataPath)
        }
        self.receiver = signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath)
            ?? panic("Could not borrow FungibleToken Vault from storage path ".concat(vaultData.storagePath.toString()))

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge request
        let vault: @{FungibleToken.Vault} <- self.coa.withdrawTokens(
            type: self.vaultType,
            amount: amount,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged vault is the correct type
        assert(
            vault.getType() == self.vaultType,
            message: "Bridged vault type mismatch - requested: ".concat(self.vaultType.identifier)
                .concat(", received: ").concat(vault.getType().identifier)
        )
        // Deposit the bridged token into the signer's vault
        self.receiver.deposit(from: <-vault)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/type_requires_onboarding.cdc

```
import "FlowEVMBridge"

/// Returns whether a type needs to be onboarded to the FlowEVMBridge
///
/// @param type: The Cadence Type in question
///
/// @return Whether the type requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///
access(all) fun main(type: Type): Bool? {
    return FlowEVMBridge.typeRequiresOnboarding(type)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/FlowEVMBridgeTokenEscrow.cdc

```

import "Burner"
import "FungibleToken"
import "NonFungibleToken"
import "MetadataViews"
import "ViewResolver"
import "FlowToken"

import "EVM"

import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"
import "CrossVMToken"

/// This escrow contract handles the locking of fungible tokens that are bridged from Cadence to EVM and retrieval of
/// locked assets in escrow when they are bridged back to Cadence.
///
access(all) contract FlowEVMBridgeTokenEscrow {

    /**********************
            Getters
    ***********************/

    /// Returns whether the Locker has been initialized for the given fungible token type
    ///
    /// @param forType: Type of the locked fungible tokens
    ///
    /// @returns true if the Locker has been initialized for the given fungible token type, otherwise false
    ///
    access(all) view fun isInitialized(forType: Type): Bool {
        return self.borrowLocker(forType: forType) != nil
    }

    /// Returns the balance of locked tokens for the given fungible token type
    ///
    /// @param tokenType: Type of the locked fungible tokens
    ///
    /// @returns The balance of locked tokens for the given fungible token type or nil if the locker doesn't exist
    ///
    access(all) view fun getLockedTokenBalance(tokenType: Type): UFix64? {
        return self.borrowLocker(forType: tokenType)?.getLockedBalance() ?? nil
    }

    /// Returns the type of the locked vault for the given fungible token type
    ///
    /// @param tokenType: Type of the locked fungible tokens
    ///
    /// @returns The type of the locked vault for the given fungible token type or nil if the locker doesn't exist
    ///
    access(all) view fun getViews(tokenType: Type): [Type]? {
        return self.borrowLocker(forType: tokenType)?.getViews() ?? []
    }

    /**********************
        Bridge Methods
    ***********************/

    /// Initializes the Locker for the given fungible token type if it hasn't been initialized yet
    ///
    access(account) fun initializeEscrow(
        with vault: @{FungibleToken.Vault},
        name: String,
        symbol: String,
        decimals: UInt8,
        evmTokenAddress: EVM.EVMAddress
    ) {
        pre {
            vault.balance == 0.0:
            "Vault contains a balance=".concat(vault.balance.toString())
                .concat(" - can only initialize Escrow with an empty vault")
        }
        let lockedType = vault.getType()
        let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: lockedType)
            ?? panic("Problem deriving Locker path for Vault type identifier=".concat(lockedType.identifier))
        if self.account.storage.type(at: lockerPath) != nil {
            panic("Token Locker already stored at storage path=".concat(lockedType.identifier))
        }

        // Create the Locker, lock a new vault of given type and save at the derived path
        let locker <- create Locker(
            name: name,
            symbol: symbol,
            decimals: decimals,
            lockedVault: <-vault,
            evmTokenAddress: evmTokenAddress
        )
        self.account.storage.save(<-locker, to: lockerPath)
    }

    /// Locks the fungible tokens in escrow returning the storage used by locking the Vault
    ///
    access(account) fun lockTokens(_ vault: @{FungibleToken.Vault}): UInt64 {
        let locker = self.borrowLocker(forType: vault.getType())
            ?? panic("Locker doesn't exist for given type=".concat(vault.getType().identifier))

        let preStorageSnapshot = self.account.storage.used
        locker.deposit(from: <-vault)
        let postStorageSnapshot = self.account.storage.used

        // Return the amount of storage used by the locker after storing the NFT
        if postStorageSnapshot < preStorageSnapshot {
            // Due to atree inlining, account storage usage may counterintuitively decrease at times - return 0
            return 0
        } else {
            // Otherwise, return the storage usage delta
            return postStorageSnapshot - preStorageSnapshot
        }
    }

    /// Unlocks the tokens of the given type and amount, reverting if it isn't in escrow
    ///
    access(account) fun unlockTokens(type: Type, amount: UFix64): @{FungibleToken.Vault} {
        let locker = self.borrowLocker(forType: type)
            ?? panic("Locker doesn't exist for given type=".concat(type.identifier))
        return <- locker.withdraw(amount: amount)
            
    }

    /// Retrieves an entitled locker for the given type or nil if it doesn't exist
    ///
    access(self) view fun borrowLocker(forType: Type): auth(FungibleToken.Withdraw) &Locker? {
        if let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: forType) {
            if self.account.storage.type(at: lockerPath) == Type<@Locker>() {
                return self.account.storage.borrow<auth(FungibleToken.Withdraw) &Locker>(from: lockerPath)
            }
        }
        return nil
    }

    /*********************
            Locker
    *********************/

    /// The resource managing the locking & unlocking of FTs via this contract's interface.
    ///
    access(all) resource Locker : CrossVMToken.EVMTokenInfo, FungibleToken.Receiver, FungibleToken.Provider, ViewResolver.Resolver {
        /// Corresponding name assigned in the tokens' corresponding ERC20 contract
        access(all) let name: String
        /// Corresponding symbol assigned in the tokens' corresponding ERC20 contract
        access(all) let symbol: String
        /// Corresponding decimals assigned in the tokens' corresponding ERC20 contract. While Cadence support floating
        /// point numbers, EVM does not, so we need to keep track of the decimals to convert between the two.
        access(all) let decimals: UInt8
        /// Corresponding ERC20 address for the locked tokens
        access(all) let evmTokenAddress: EVM.EVMAddress
        // Vault to hold all locked tokens
        access(self) let lockedVault: @{FungibleToken.Vault}


        init(name: String, symbol: String, decimals: UInt8, lockedVault: @{FungibleToken.Vault}, evmTokenAddress: EVM.EVMAddress) {
            self.decimals = decimals
            self.name = name
            self.symbol = symbol
            self.evmTokenAddress = evmTokenAddress

            self.lockedVault <- lockedVault
            // Locked Vaults must accept their own type as Lockers escrow Vaults on a 1:1 type basis
            assert(
                self.lockedVault.isSupportedVaultType(type: self.lockedVault.getType()),
                message: "Locked Vault does not accept its own type=".concat(self.lockedVault.getType().identifier)
            )
        }

        /// Gets the ERC20 name value
        access(all) view fun getName(): String {
            return self.name
        }
        /// Gets the ERC20 symbol value
        access(all) view fun getSymbol(): String {
            return self.symbol
        }
        /// Gets the ERC20 decimals value
        access(all) view fun getDecimals(): UInt8 {
            return self.decimals
        }
        /// Get the EVM contract address of the locked Vault's corresponding ERC20 contract address
        ///
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return self.evmTokenAddress
        }

        /// Returns the balance of tokens in the locked Vault
        ///
        access(all) view fun getLockedBalance(): UFix64 {
            return self.lockedVault.balance
        }

        /// Returns the type of the locked vault
        ///
        access(all) view fun getLockedType(): Type {
            return self.lockedVault.getType()
        }

        /// Function to ask a provider if a specific amount of tokens is available to be withdrawn from the locked vault
        ///
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {
            return self.lockedVault.isAvailableToWithdraw(amount: amount)
        }

        /// Returns a mapping of vault types that this locker accepts. This Locker will only accept Vaults of the same
        ///
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            return {self.lockedVault.getType(): true}
        }

        /// Returns whether or not the given type is accepted by the Receiver
        ///
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// Returns the views supported by the locked Vault
        ///
        access(all) view fun getViews(): [Type] {
            return self.lockedVault.getViews()
        }

        /// Resolves the requested view type on the locked FT if it supports the requested view type
        ///
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            return self.lockedVault.resolveView(view)
        }

        /// Deposits the given token vault into the contained locked Vault
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            self.lockedVault.deposit(from: <-from)
        }

        /// Withdraws an amount of tokens from this locker, removing it from the vault and returning it
        ///
        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault} {
            return <-self.lockedVault.withdraw(amount: amount)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/templates/FlowEVMBridgedERC20.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ICrossVM} from "../interfaces/ICrossVM.sol";

contract FlowEVMBridgedERC20 is ERC165, ERC20, ERC20Burnable, ERC20Permit, Ownable, ICrossVM {
    string public cadenceTokenAddress;
    string public cadenceTokenIdentifier;
    string public contractMetadata;

    string private _customSymbol;

    constructor(
        address owner,
        string memory name_,
        string memory symbol_,
        string memory _cadenceTokenAddress,
        string memory _cadenceTokenIdentifier,
        string memory _contractMetadata
    ) ERC20(name_, symbol_) Ownable(owner) ERC20Permit(name_) {
        _customSymbol = symbol_;
        cadenceTokenAddress = _cadenceTokenAddress;
        cadenceTokenIdentifier = _cadenceTokenIdentifier;
        contractMetadata = _contractMetadata;
    }

    function getCadenceAddress() external view returns (string memory) {
        return cadenceTokenAddress;
    }

    function getCadenceIdentifier() external view returns (string memory) {
        return cadenceTokenIdentifier;
    }

    function symbol() public view override returns (string memory) {
        return _customSymbol;
    }

    function contractURI() public view returns (string memory) {
        return contractMetadata;
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function setSymbol(string memory newSymbol) public onlyOwner {
        _setSymbol(newSymbol);
    }

    function setContractURI(string memory newContractURI) public onlyOwner {
        contractMetadata = newContractURI;
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC165) returns (bool) {
        return interfaceId == type(IERC20).interfaceId || interfaceId == type(ERC20Burnable).interfaceId
            || interfaceId == type(Ownable).interfaceId || interfaceId == type(ERC20Permit).interfaceId
            || interfaceId == type(ICrossVM).interfaceId || super.supportsInterface(interfaceId);
    }

    function _setSymbol(string memory newSymbol) internal {
        _customSymbol = newSymbol;
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/setup/setup_generic_vault.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "MetadataViews"
import "FungibleTokenMetadataViews"

import "FlowEVMBridgeUtils"

/// Configures a Vault according to the shared FungibleToken standard and the defaults specified by the Vault's
/// defining contract.
///
/// @param vaultIdentifier: The identifier of the Vault to configure.
///
transaction(vaultIdentifier: String) {

    prepare(signer: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {
        // Gather identifying information about the Vault and its defining contract
        let vaultType = CompositeType(vaultIdentifier) ?? panic("Invalid Vault identifier: ".concat(vaultIdentifier))
        let contractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not derive contract address from identifier: ".concat(vaultIdentifier))
        let contractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not derive contract name from identifier: ".concat(vaultIdentifier))
        // Borrow the contract and resolve its Vault data
        let ftContract = getAccount(contractAddress).contracts.borrow<&{FungibleToken}>(name: contractName)
            ?? panic("No such FungibleToken contract found")
        let data = ftContract.resolveContractView(
                resourceType: vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData for Vault type: ".concat(vaultIdentifier))

        // Check for collision, returning if the vault already exists or reverting on unexpected collision
        let storedType = signer.storage.type(at: data.storagePath)
        if storedType == vaultType {
            return
        } else if storedType != nil {
            panic(
                "Another resource of type "
                .concat(storedType!.identifier)
                .concat(" already exists at the storage path: ")
                .concat(data.storagePath.toString())
            )
        }

        // Create a new vault and save it to signer's storage at the vault's default storage path
        signer.storage.save(<-data.createEmptyVault(), to: data.storagePath)

        // Issue a public Vault capability and publish it to the vault's default public path
        signer.capabilities.unpublish(data.receiverPath)
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(data.storagePath)
        signer.capabilities.publish(receiverCap, at: data.receiverPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/get_bridge_coa_address.cdc

```
import "EVM"

import "FlowEVMBridge"

/// Returns the EVM address associated with the FlowEVMBridge
///
/// @return The EVM address associated with the FlowEVMBridge's coordinating CadenceOwnedAccount
///
access(all) fun main(): String {
    return FlowEVMBridge.getBridgeCOAEVMAddress().toString()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/utils/Serialize.cdc

```
import "ViewResolver"
import "MetadataViews"
import "NonFungibleToken"

/// This contract is a utility for serializing primitive types, arrays, and common metadata mapping formats to JSON
/// compatible strings. Also included are interfaces enabling custom serialization for structs and resources.
///
/// Special thanks to @austinkline for the idea and initial implementation & @bjartek + @bluesign for optimizations.
///
access(all)
contract Serialize {

    /// Method that returns a serialized representation of the given value or nil if the value is not serializable
    ///
    access(all)
    fun tryToJSONString(_ value: AnyStruct): String? {
        // Recursively serialize array & return
        if value.getType().isSubtype(of: Type<[AnyStruct]>()) {
            return self.arrayToJSONString(value as! [AnyStruct])
        }
        // Recursively serialize map & return
        if value.getType().isSubtype(of: Type<{String: AnyStruct}>()) {
            return self.dictToJSONString(dict: value as! {String: AnyStruct}, excludedNames: nil)
        }
        // Handle primitive types & optionals
        switch value.getType() {
            case Type<Never?>():
                return "\"nil\""
            case Type<String>():
                return String.join(["\"", value as! String, "\"" ], separator: "")
            case Type<String?>():
                return String.join(["\"", value as? String ?? "nil", "\"" ], separator: "")
            case Type<Character>():
                return String.join(["\"", (value as! Character).toString(), "\"" ], separator: "")
            case Type<Bool>():
                return String.join(["\"", value as! Bool ? "true" : "false", "\"" ], separator: "")
            case Type<Address>():
                return String.join(["\"", (value as! Address).toString(), "\"" ], separator: "")
            case Type<Address?>():
                return String.join(["\"", (value as? Address)?.toString() ?? "nil", "\"" ], separator: "")
            case Type<Int8>():
                return String.join(["\"", (value as! Int8).toString(), "\"" ], separator: "")
            case Type<Int16>():
                return String.join(["\"", (value as! Int16).toString(), "\"" ], separator: "")
            case Type<Int32>():
                return String.join(["\"", (value as! Int32).toString(), "\"" ], separator: "")
            case Type<Int64>():
                return String.join(["\"", (value as! Int64).toString(), "\"" ], separator: "")
            case Type<Int128>():
                return String.join(["\"", (value as! Int128).toString(), "\"" ], separator: "")
            case Type<Int256>():
                return String.join(["\"", (value as! Int256).toString(), "\"" ], separator: "")
            case Type<Int>():
                return String.join(["\"", (value as! Int).toString(), "\"" ], separator: "")
            case Type<UInt8>():
                return String.join(["\"", (value as! UInt8).toString(), "\"" ], separator: "")
            case Type<UInt16>():
                return String.join(["\"", (value as! UInt16).toString(), "\"" ], separator: "")
            case Type<UInt32>():
                return String.join(["\"", (value as! UInt32).toString(), "\"" ], separator: "")
            case Type<UInt64>():
                return String.join(["\"", (value as! UInt64).toString(), "\"" ], separator: "")
            case Type<UInt128>():
                return String.join(["\"", (value as! UInt128).toString(), "\"" ], separator: "")
            case Type<UInt256>():
                return String.join(["\"", (value as! UInt256).toString(), "\"" ], separator: "")
            case Type<UInt>():
                return String.join(["\"", (value as! UInt).toString(), "\"" ], separator: "")
            case Type<Word8>():
                return String.join(["\"", (value as! Word8).toString(), "\"" ], separator: "")
            case Type<Word16>():
                return String.join(["\"", (value as! Word16).toString(), "\"" ], separator: "")
            case Type<Word32>():
                return String.join(["\"", (value as! Word32).toString(), "\"" ], separator: "")
            case Type<Word64>():
                return String.join(["\"", (value as! Word64).toString(), "\"" ], separator: "")
            case Type<Word128>():
                return String.join(["\"", (value as! Word128).toString(), "\"" ], separator: "")
            case Type<Word256>():
                return String.join(["\"", (value as! Word256).toString(), "\"" ], separator: "")
            case Type<UFix64>():
                return String.join(["\"", (value as! UFix64).toString(), "\"" ], separator: "")
            default:
                return nil
        }
    }

    /// Returns a serialized representation of the given array or nil if the value is not serializable
    ///
    access(all)
    fun arrayToJSONString(_ arr: [AnyStruct]): String? {
        let parts: [String]= []
        for element in arr {
            let serializedElement = self.tryToJSONString(element)
            if serializedElement == nil {
                continue
            }
            parts.append(serializedElement!)
        }
        return "[".concat(String.join(parts, separator: ", ")).concat("]")
    }

    /// Returns a serialized representation of the given String-indexed mapping or nil if the value is not serializable.
    /// The interface here is largely the same as as the `MetadataViews.dictToTraits` method, though here
    /// a JSON-compatible String is returned instead of a `Traits` array.
    ///
    access(all)
    fun dictToJSONString(dict: {String: AnyStruct}, excludedNames: [String]?): String? {
        if excludedNames != nil {
            for k in excludedNames! {
                dict.remove(key: k)
            }
        }
        let parts: [String] = []
        for key in dict.keys {
            let serializedValue = self.tryToJSONString(dict[key]!)
            if serializedValue == nil {
                continue
            }
            let serialializedKeyValue = String.join([self.tryToJSONString(key)!, serializedValue!], separator: ": ")
            parts.append(serialializedKeyValue)
        }
        return "{".concat(String.join(parts, separator: ", ")).concat("}")
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/FlowBridgeDeploymentRegistry.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {FlowEVMDeploymentRegistry} from "./interfaces/FlowEVMDeploymentRegistry.sol";

/**
 * @title FlowBridgeDeploymentRegistry
 * @dev A contract to manage the association between bridged Flow EVM contracts and a corresponding Cadence resource type.
 * Deployment of new bridged Flow EVM contracts is handled in `FlowBridgeFactory`.
 */
contract FlowBridgeDeploymentRegistry is FlowEVMDeploymentRegistry, Ownable {
    constructor() Ownable(msg.sender) {
        registrar = msg.sender;
    }

    /**
     * @dev Set the registrar address as the entity that can register new deployments. Only the owner can call this
     * function.
     *
     * @param _registrar The address of the registrar
     */
    function setRegistrar(address _registrar) external onlyOwner {
        _setRegistrar(_registrar);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/blocklist/block_evm_address.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Blocks the given EVM contract address from onboarding.
///
/// @param evmContractHex: The EVM contract address to block from onboarding
///
transaction(evmContractHex: String) {

    let evmBlocklist: auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.EVMBlocklist
    let evmAddress: EVM.EVMAddress

    prepare(signer: auth(BorrowValue) &Account) {
        self.evmBlocklist = signer.storage.borrow<auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.EVMBlocklist>(
                from: /storage/evmBlocklist
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
        self.evmAddress = EVM.addressFromString(evmContractHex)
    }

    execute {
        self.evmBlocklist.block(self.evmAddress)
    }

    post {
        FlowEVMBridgeConfig.isEVMAddressBlocked(self.evmAddress): "EVM address was not blocked"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/tests/transactions/update_contract.cdc

```
transaction(name: String, codeHex: String) {
    prepare(signer: auth(UpdateContract) &Account) {
        signer.contracts.update(name: name, code: codeHex.decodeHex())
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-handled-token/mint_tokens.cdc

```
import "FungibleToken"
import "ExampleHandledToken"
import "FungibleTokenMetadataViews"

import "FlowEVMBridgeHandlerInterfaces"

/// This transaction is what the minter Account uses to mint new ExampleTokens
/// They provide the recipient address and amount to mint, and the tokens
/// are transferred to the address after minting

transaction(recipient: Address, amount: UFix64) {

    /// Reference to the Example Token Minter Resource object
    let tokenMinter: auth(FlowEVMBridgeHandlerInterfaces.Mint) &ExampleHandledToken.Minter

    /// Reference to the Fungible Token Receiver of the recipient
    let tokenReceiver: &{FungibleToken.Receiver}

    /// The total supply of tokens before the burn
    let supplyBefore: UFix64

    prepare(signer: auth(BorrowValue) &Account) {
        self.supplyBefore = ExampleHandledToken.totalSupply

        // Borrow a reference to the admin object
        self.tokenMinter = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Mint) &ExampleHandledToken.Minter>(
                from: ExampleHandledToken.AdminStoragePath
            ) ?? panic("Signer is not the token admin")

        let vaultData = ExampleHandledToken.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get vault data view for the contract")
    
        self.tokenReceiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow receiver reference to the Vault")
    }

    execute {

        // Create mint tokens
        let mintedVault <- self.tokenMinter.mint(amount: amount)

        // Deposit them to the receiever
        self.tokenReceiver.deposit(from: <-mintedVault)
    }

    post {
        ExampleHandledToken.totalSupply == self.supplyBefore + amount: "The total supply must be increased by the amount"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/example-assets/example-nft/mint_nft.cdc

```
/// This script uses the NFTMinter resource to mint a new NFT
/// It must be run with the account that has the minter resource
/// stored in /storage/NFTMinter

import "NonFungibleToken"
import "ExampleNFT"
import "MetadataViews"
import "FungibleToken"

transaction(
    recipient: Address,
    name: String,
    description: String,
    thumbnail: String,
    cuts: [UFix64],
    royaltyDescriptions: [String],
    royaltyBeneficiaries: [Address]
) {

    /// local variable for storing the minter reference
    let minter: &ExampleNFT.NFTMinter

    /// Reference to the receiver's collection
    let recipientCollectionRef: &{NonFungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {

        let collectionData = ExampleNFT.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("ViewResolver does not resolve NFTCollectionData view")
        
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)
            ?? panic("Account does not store an object at the specified path")

        // Borrow the recipient's public NFT collection reference
        self.recipientCollectionRef = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(
                collectionData.publicPath
            ) ?? panic("Could not get receiver reference to the NFT Collection")
    }

    pre {
        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: "Array length should be equal for royalty related details"
    }

    execute {

        // Create the royalty details
        var count = 0
        var royalties: [MetadataViews.Royalty] = []
        log(royaltyBeneficiaries.length)
        while royaltyBeneficiaries.length > count {
            let beneficiary = royaltyBeneficiaries[count]
            let beneficiaryCapability = getAccount(beneficiary).capabilities.get<&{FungibleToken.Receiver}>(
                    MetadataViews.getRoyaltyReceiverPublicPath()
                )
            if !beneficiaryCapability.check() {
                panic("Beneficiary does not have Receiver configured at RoyaltyReceiverPublicPath")
            }

            royalties.append(
                MetadataViews.Royalty(
                    receiver: beneficiaryCapability,
                    cut: cuts[count],
                    description: royaltyDescriptions[count]
                )
            )
            count = count + 1
        }


        // Mint the NFT and deposit it to the recipient's collection
        let mintedNFT <- self.minter.mintNFT(
            name: name,
            description: description,
            thumbnail: thumbnail,
            royalties: royalties
        )
        self.recipientCollectionRef.deposit(token: <-mintedNFT)
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/is_type_paused.cdc

```
import "FlowEVMBridgeConfig"

access(all)
fun main(typeIdentifier: String): Bool? {
    return FlowEVMBridgeConfig.isTypePaused(
        CompositeType(typeIdentifier) ?? panic("Invalid type identifier provided: ".concat(typeIdentifier))
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/pause/update_type_pause_status.cdc

```
import "FlowEVMBridgeConfig"

/// Sets the pause status of the specified asset type as either paused or unpaused.
///
/// @param typeIdentifier: The type identifier of the asset to pause or unpause.
/// @param pause: A boolean indicating whether the FlowEVM Bridge should be paused or unpaused.
///
/// @emits FlowEVMBridgeConfig.TypePauseStatusUpdated(paused: true)
///
transaction(typeIdentifier: String, pause: Bool) {

    let admin: auth(FlowEVMBridgeConfig.Pause) &FlowEVMBridgeConfig.Admin
    let type: Type

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeConfig.Pause) &FlowEVMBridgeConfig.Admin>(from: FlowEVMBridgeConfig.adminStoragePath)
            ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
        self.type = CompositeType(typeIdentifier) ?? panic("Invalid type identifier provided: ".concat(typeIdentifier))
    }

    execute {
        if pause {
            self.admin.pauseType(self.type)
        } else {
            self.admin.unpauseType(self.type)
        }
    }

    post {
        FlowEVMBridgeConfig.isTypePaused(self.type) == pause: "Problem updating pause status for provided type"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/evm/set_delegated_deployer.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Sets the bridge factory contract address as a delegated deployer in the provided deployer contract. This enables the
/// factory contract to deploy new contracts via the deployer contract.
///
/// @param deployerEVMAddressHex The EVM address of the deployer contract as a hex string
///
transaction(deployerEVMAddressHex: String) {

    let targetDeployerEVMAddress: EVM.EVMAddress
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount
    var postDelegatedDeployer: EVM.EVMAddress?

    prepare(signer: auth(BorrowValue) &Account) {
        self.targetDeployerEVMAddress = EVM.addressFromString(deployerEVMAddressHex)
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        self.postDelegatedDeployer = nil
    }

    execute {
        // Execute the call
        let callResult = self.coa.call(
            to: self.targetDeployerEVMAddress,
            data: EVM.encodeABIWithSignature(
                "setDelegatedDeployer(address)",
                [FlowEVMBridgeUtils.getBridgeFactoryEVMAddress()]
            ),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(callResult.status == EVM.Status.successful, message: "Failed to set delegated deployer")

        // Confirm the delegated deployer was set
        let postDelegatedDeployerResult = self.coa.call(
            to: self.targetDeployerEVMAddress,
            data: EVM.encodeABIWithSignature("delegatedDeployer()", []),
            gasLimit: 15_000_000,
            value: EVM.Balance(attoflow: 0)
        )
        assert(postDelegatedDeployerResult.status == EVM.Status.successful, message: "Failed to get delegated deployer")

        let decodedResult = EVM.decodeABI(
                types: [Type<EVM.EVMAddress>()],
                data: postDelegatedDeployerResult.data
            ) as! [AnyStruct]
        assert(decodedResult.length == 1, message: "Invalid response from delegatedDeployer() call")
        self.postDelegatedDeployer = decodedResult[0] as! EVM.EVMAddress
    }

    post {
        self.postDelegatedDeployer!.equals(FlowEVMBridgeUtils.getBridgeFactoryEVMAddress()):
            "FlowBridgeFactory address "
            .concat(FlowEVMBridgeUtils.getBridgeFactoryEVMAddress().toString())
            .concat(" was not set as the delegated deployer in the deployer contract ")
            .concat(deployerEVMAddressHex)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/batch_evm_address_requires_onboarding.cdc

```
import "EVM"

import "FlowEVMBridge"

/// Returns whether a EVM contract needs to be onboarded to the FlowEVMBridge
///
/// @param evmAddresses: Array of hex-encoded address of the EVM contract as a String without 0x prefix to check for
///     onboarding status
///
/// @return Whether the contract requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///     indexed on the hex-encoded address of the EVM contract without 0x prefix
///
access(all) fun main(evmAddresses: [String]): {String: Bool?} {
    let results: {String: Bool?} = {}
    for addressHex in evmAddresses {
        if results[addressHex] != nil {
            continue
        }
        let address = EVM.addressFromString(addressHex)
        let requiresOnboarding = FlowEVMBridge.evmAddressRequiresOnboarding(address)
        results.insert(key: addressHex, requiresOnboarding)
    }
    return results
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/utils/StringUtils.cdc

```
import "ArrayUtils"

// Copied from https://github.com/green-goo-dao/flow-utils/blob/crescendo/contracts/StringUtils.cdc
// Special thanks to the Green Goo Dao contributors for creating this contract
access(all) contract StringUtils {

    access(all) fun format(_ s: String, _ args: {String:String}): String{
        var formatted = s
        for key in args.keys{
            formatted = StringUtils.replaceAll(formatted, "{".concat(key).concat("}"), args[key]!)
        }
        return formatted
    }

    access(all) fun explode(_ s: String): [String]{
        var chars : [String] =  []
        for i in ArrayUtils.range(0, s.length){
            chars.append(s[i].toString())
        }  
        return chars
    }

    access(all) fun trimLeft(_ s: String): String{
        for i in ArrayUtils.range(0, s.length){
            if s[i] != " "{
                return s.slice(from: i, upTo: s.length)
            }
        }
        return ""
    }

    access(all) fun trim(_ s: String): String{
        return self.trimLeft(s)
    }

    access(all) fun replaceAll(_ s: String, _ search: String, _ replace: String): String{
        return s.replaceAll(of: search, with: replace)
    }

    access(all) fun hasPrefix(_ s: String, _ prefix: String) : Bool{
        return s.length >= prefix.length && s.slice(from:0, upTo: prefix.length)==prefix
    }

    access(all) fun hasSuffix(_ s: String, _ suffix: String) : Bool{
        return s.length >= suffix.length && s.slice(from:s.length-suffix.length, upTo: s.length)==suffix
    }

    access(all) fun index(_ s : String, _ substr : String, _ startIndex: Int): Int?{
        for i in ArrayUtils.range(startIndex,s.length-substr.length+1){
            if s[i]==substr[0] && s.slice(from:i, upTo:i+substr.length) == substr{
                return i
            }
        }
        return nil
    }

    access(all) fun count(_ s: String, _ substr: String): Int{
        var pos = [self.index(s, substr, 0)]
        while pos[0]!=nil {
            pos.insert(at:0, self.index(s, substr, pos[0]!+pos.length*substr.length+1))
        }
        return pos.length-1
    }

    access(all) fun contains(_ s: String, _ substr: String): Bool {
        if let index =  self.index(s, substr, 0) {
            return true
        }
        return false
    }

    access(all) fun substringUntil(_ s: String, _ until: String, _ startIndex: Int): String{
        if let index = self.index( s, until, startIndex){
            return s.slice(from:startIndex, upTo: index)
        }
        return s.slice(from:startIndex, upTo:s.length)
    }

    access(all) fun split(_ s: String, _ delimiter: String): [String] {
        return s.split(separator: delimiter)
    }

    access(all) fun join(_ strs: [String], _ separator: String): String {
        return String.join(strs, separator: separator)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/create_cadence_native_token_handler.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeHandlers"

/// Creates a new TokenHandler for a Cadence-native fungible token and configures it in the bridge to handle the target
/// vault type. The minter enabling the handling of tokens as well as the target EVM address must also be set before
// the TokenHandler can be enabled.
///
/// @param vaultIdentifier: The type identifier of the vault to create the TokenHandler for
/// @param minterIdentifier: The type identifier of the TokenMinter implementing resource
///
transaction(vaultIdentifier: String, minterIdentifier: String) {

    let configurator: auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeHandlers.HandlerConfigurator

    prepare(signer: auth(BorrowValue, LoadValue) &Account) {
        self.configurator = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeHandlers.HandlerConfigurator>(
                from: FlowEVMBridgeHandlers.ConfiguratorStoragePath
            ) ?? panic("Missing configurator")
    }

    execute {
        let targetType = CompositeType(vaultIdentifier)
            ?? panic("Invalid vault identifier")
        let minterType = CompositeType(minterIdentifier)
            ?? panic("Invalid minter identifier")
        self.configurator.createTokenHandler(
            handlerType: Type<@FlowEVMBridgeHandlers.CadenceNativeTokenHandler>(),
            targetType: targetType,
            targetEVMAddress: nil,
            expectedMinterType: minterType
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/utils/total_supply.cdc

```
import "EVM"

import "FlowEVMBridgeUtils"

/// Retrieves the total supply of the ERC20 contract at the given EVM contract address. Reverts on EVM call failure.
///
/// @param evmContractAddress: The EVM contract address to retrieve the total supply from
///
/// @return the total supply of the ERC20
///
access(all) fun main(evmContractAddressHex: String): UInt256 {
    return FlowEVMBridgeUtils.totalSupply(
        evmContractAddress: EVM.addressFromString(evmContractAddressHex)
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/templates/mainnet/EVMBridgedNFTTemplate.cdc

```
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61

import EVM from 0xe467b9dd11fa00df

import ICrossVM from 0x1e4aa0b87d10b141
import ICrossVMAsset from 0x1e4aa0b87d10b141
import IEVMBridgeNFTMinter from 0x1e4aa0b87d10b141
import FlowEVMBridgeNFTEscrow from 0x1e4aa0b87d10b141
import FlowEVMBridgeConfig from 0x1e4aa0b87d10b141
import FlowEVMBridgeUtils from 0x1e4aa0b87d10b141
import FlowEVMBridge from 0x1e4aa0b87d10b141
import CrossVMNFT from 0x1e4aa0b87d10b141
import FlowEVMBridgeResolver from 0x1e4aa0b87d10b141

/// This contract is a template used by FlowEVMBridge to define EVM-native NFTs bridged from Flow EVM to Flow.
/// Upon deployment of this contract, the contract name is derived as a function of the asset type (here an ERC721 aka
/// an NFT) and the contract's EVM address. The derived contract name is then joined with this contract's code,
/// prepared as chunks in FlowEVMBridgeTemplates before being deployed to the Flow EVM Bridge account.
///
/// On bridging, the ERC721 is transferred to the bridge's CadenceOwnedAccount EVM address and a new NFT is minted from
/// this contract to the bridging caller. On return to Flow EVM, the reverse process is followed - the token is locked
/// in NFT escrow and the ERC721 is transferred to the defined recipient. In this way, the Cadence token acts as a
/// representation of both the EVM NFT and thus ownership rights to it upon bridging back to Flow EVM.
///
/// To bridge between VMs, a caller can either use the interface exposed on CadenceOwnedAccount or use FlowEVMBridge
/// public contract methods.
///
access(all) contract {{CONTRACT_NAME}} : ICrossVM, ICrossVMAsset, IEVMBridgeNFTMinter, NonFungibleToken {

    /// Pointer to the Factory deployed Solidity contract address defining the bridged asset
    access(all) let evmNFTContractAddress: EVM.EVMAddress
    /// Name of the NFT collection defined in the corresponding ERC721 contract
    access(all) let name: String
    /// Symbol of the NFT collection defined in the corresponding ERC721 contract
    access(all) let symbol: String
    /// URI of the contract, if available as a var in case the bridge enables cross-VM Metadata syncing in the future
    access(all) var contractURI: String?
    /// Retain a Collection to reference when resolving Collection Metadata
    access(self) let collection: @Collection
    /// Mapping of token URIs indexed on their ERC721 ID. This would not normally be retained within a Cadence NFT
    /// contract, but since NFT metadata may be updated in EVM, it's retained here so that the bridge can update
    /// it against the source ERC721 contract which is treated as the NFT's source of truth.
    access(all) let tokenURIs: {UInt256: String}

    /// The NFT resource representing the bridged ERC721 token
    ///
    access(all) resource NFT : ICrossVMAsset.AssetInfo, CrossVMNFT.EVMNFT {
        /// The Cadence ID of the NFT
        access(all) let id: UInt64
        /// The ERC721 ID of the NFT
        access(all) let evmID: UInt256
        /// Additional onchain metadata
        access(all) let metadata: {String: AnyStruct}

        init(
            evmID: UInt256,
            metadata: {String: AnyStruct}
        ) {
            self.id = self.uuid
            self.evmID = evmID
            self.metadata = metadata
        }

        /// Returns the metadata view types supported by this NFT
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.EVMBridgedMetadata>()
            ]
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        access(all) view fun tokenURI(): String {
            return {{CONTRACT_NAME}}.tokenURIs[self.evmID] ?? ""
        }

        /// Resolves a metadata view for this NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let contractRef = {{CONTRACT_NAME}}.borrowThisContract()
                    return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: contractRef, view: Type<MetadataViews.Display>())
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionData>()
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return {{CONTRACT_NAME}}.resolveContractView(
                        resourceType: self.getType(),
                        viewType: Type<MetadataViews.NFTCollectionDisplay>()
                    )
                case Type<MetadataViews.EVMBridgedMetadata>():
                    return MetadataViews.EVMBridgedMetadata(
                        name: self.getName(),
                        symbol: self.getSymbol(),
                        uri: MetadataViews.URI(baseURI: nil, value: self.tokenURI())
                    )
            }
            return nil
        }

        /// public function that anyone can call to create a new empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- {{CONTRACT_NAME}}.createEmptyCollection(nftType: self.getType())
        }

        /* --- CrossVMNFT conformance --- */
        //
        /// Returns the EVM contract address of the NFT
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
            return {{CONTRACT_NAME}}.getEVMContractAddress()
        }
    }

    /// This resource holds associated NFTs, and serves queries about stored NFTs
    access(all) resource Collection : CrossVMNFT.EVMNFTCollection {
        /// dictionary of NFT conforming tokens indexed on their ID
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
        /// Mapping of EVM IDs to Flow NFT IDs
        access(contract) let evmIDToFlowID: {UInt256: UInt64}

        access(all) var storagePath: StoragePath
        access(all) var publicPath: PublicPath

        init () {
            self.ownedNFTs <- {}
            self.evmIDToFlowID = {}
            let collectionData = {{CONTRACT_NAME}}.resolveContractView(
                    resourceType: Type<@{{CONTRACT_NAME}}.NFT>(),
                    viewType: Type<MetadataViews.NFTCollectionData>()
                ) as! MetadataViews.NFTCollectionData?
                ?? panic("Could not resolve the collection data view for the NFT collection")
            self.storagePath = collectionData.storagePath
            self.publicPath = collectionData.publicPath
        }

        access(all) view fun getName(): String {
            return {{CONTRACT_NAME}}.name
        }

        access(all) view fun getSymbol(): String {
            return {{CONTRACT_NAME}}.symbol
        }

        /// Returns a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            return { Type<@{{CONTRACT_NAME}}.NFT>(): true }
        }

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
           return type == Type<@{{CONTRACT_NAME}}.NFT>()
        }

        /// Removes an NFT from the collection and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Could not withdraw an NFT with the provided ID from the collection")

            return <-token
        }

        /// Withdraws an NFT from the collection by its EVM ID
        access(NonFungibleToken.Withdraw) fun withdrawByEVMID(_ id: UInt256): @{NonFungibleToken.NFT} {
            return <- self.withdraw(withdrawID: 
                self.getCadenceID(from: id) ?? panic("Could not withdraw an NFT with the provided EVM ID from the collection")
            )
        }

        /// Ttakes a NFT and adds it to the collections dictionary and adds the ID to the evmIDToFlowID mapping
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @{{CONTRACT_NAME}}.NFT

            // add the new token to the dictionary which removes the old one
            self.evmIDToFlowID[token.evmID] = token.id
            let oldToken <- self.ownedNFTs[token.id] <- token

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Returns an array of the EVM IDs that are in the collection
        access(all) view fun getEVMIDs(): [UInt256] {
            return self.evmIDToFlowID.keys
        }

        /// Returns the Cadence NFT.id for the given EVM NFT ID if it exists in the collection
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64? {
            if self.evmIDToFlowID[evmID] != nil {
                return self.evmIDToFlowID[evmID]
            } else if evmID < UInt256(UInt64.max) && self.borrowNFT(UInt64(evmID)) != nil {
                return UInt64(evmID)
            } else {
                return nil
            }
        }

        /// Returns the EVM NFT ID associated with the Cadence NFT ID. The goal is to retrieve the ERC721 ID value.
        /// As far as the bridge is concerned, an ERC721 defined by the bridge is the NFT's ID at the time of bridging
        /// or the value of the NFT.evmID if it implements the CrossVMNFT.EVMNFT interface when bridged.
        /// Following this pattern, if locked, the NFT is checked for EVMNFT conformance returning .evmID if so,
        /// otherwise the NFT's ID is returned as a UInt256 since that's how the bridge would handle minting in the
        /// corresponding ERC721 contract.
        ///
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256? {
            if let nft = self.borrowNFT(cadenceID) {
                if let evmNFT = CrossVMNFT.getEVMID(from: nft) {
                    return evmNFT
                }
                return UInt256(nft.id)
            }
            return nil
        }

        /// Returns the contractURI for the NFT collection as defined in the source ERC721 contract. If none was
        /// defined at the time of bridging, an empty string is returned.
        access(all) view fun contractURI(): String? {
            return {{CONTRACT_NAME}}.contractURI
        }

        /// Gets the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        /// Retrieves a reference to the NFT stored in the collection by its ID
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Borrow the view resolver for the specified NFT ID
        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            return &self.ownedNFTs[id] as &{ViewResolver.Resolver}? ?? nil
        }

        /// Creates an empty collection
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection}  {
            return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        return <- create Collection()
    }

    /**********************
            Getters
    ***********************/

    /// Returns the name of the asset
    ///
    access(all) view fun getName(): String {
        return self.name
    }

    /// Returns the symbol of the asset
    ///
    access(all) view fun getSymbol(): String {
        return self.symbol
    }

    /// Returns the EVM contract address of the NFT this contract represents
    ///
    access(all) view fun getEVMContractAddress(): EVM.EVMAddress {
        return self.evmNFTContractAddress
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.EVMBridgedMetadata>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let identifier = "{{CONTRACT_NAME}}Collection"
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: StoragePath(identifier: identifier)!,
                    publicPath: PublicPath(identifier: identifier)!,
                    publicCollection: Type<&{{CONTRACT_NAME}}.Collection>(),
                    publicLinkedType: Type<&{{CONTRACT_NAME}}.Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-{{CONTRACT_NAME}}.createEmptyCollection(nftType: Type<@{{CONTRACT_NAME}}.NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let selfRef = self.borrowThisContract()
                return FlowEVMBridgeResolver.resolveBridgedView(bridgedContract: selfRef, view: Type<MetadataViews.NFTCollectionDisplay>())
            case Type<MetadataViews.EVMBridgedMetadata>():
                return MetadataViews.EVMBridgedMetadata(
                    name: self.name,
                    symbol: self.symbol,
                    uri: self.contractURI != nil ? MetadataViews.URI(baseURI: nil, value: self.contractURI!) : MetadataViews.URI(baseURI: nil, value: "")
                )
        }
        return nil
    }

    /**********************
        Internal Methods
    ***********************/

    /// Allows the bridge to mint NFTs from bridge-defined NFT contracts
    ///
    access(account)
    fun mintNFT(id: UInt256, tokenURI: String): @NFT {
        pre {
            self.tokenURIs[id] == nil: "A token with the given ERC721 ID already exists"
        }
        self.tokenURIs[id] = tokenURI
        return <-create NFT(
            evmID: id,
            metadata: {
                "Bridged Block": getCurrentBlock().height,
                "Bridged Timestamp": getCurrentBlock().timestamp
            }
        )
    }

    /// Allows the bridge to update the URI of bridged NFTs. This assumes that the EVM-defining project may contain
    /// logic (onchain or offchain) which updates NFT metadata in the source ERC721 contract. On bridging, the URI can
    /// then be updated in this contract to reflect the source ERC721 contract's metadata.
    ///
    access(account)
    fun updateTokenURI(evmID: UInt256, newURI: String) {
        pre {
            self.tokenURIs[evmID] != nil: "No token with the given ERC721 ID exists"
        }
        if self.tokenURIs[evmID] != newURI {
            self.tokenURIs[evmID] = newURI
        }
    }

    /// Returns a reference to this contract as an ICrossVMAsset contract
    ///
    access(self)
    fun borrowThisContract(): &{ICrossVMAsset} {
        let contractAddress = self.account.address
        return getAccount(contractAddress).contracts.borrow<&{ICrossVMAsset}>(name: "{{CONTRACT_NAME}}")!
    }

    init(name: String, symbol: String, evmContractAddress: EVM.EVMAddress, contractURI: String?) {
        self.evmNFTContractAddress = evmContractAddress
        self.name = name
        self.symbol = symbol
        self.contractURI = contractURI
        self.tokenURIs = {}
        self.collection <- create Collection()

        FlowEVMBridgeConfig.associateType(Type<@{{CONTRACT_NAME}}.NFT>(), with: self.evmNFTContractAddress)
        FlowEVMBridgeNFTEscrow.initializeEscrow(
            forType: Type<@{{CONTRACT_NAME}}.NFT>(),
            name: name,
            symbol: symbol,
            erc721Address: self.evmNFTContractAddress
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/contracts/bridge/interfaces/CrossVMNFT.cdc

```
import "NonFungibleToken"
import "FungibleToken"
import "MetadataViews"

import "EVM"

import "ICrossVMAsset"

/// Contract defining cross-VM NFT-related interfaces
///
access(all) contract CrossVMNFT {


    /// A simple interface for an NFT that is bridged to the EVM. This may be necessary in some cases as there is
    /// discrepancy between Flow NFT standard IDs (UInt64) and EVM NFT standard IDs (UInt256). Discrepancies on IDs
    /// gone unaccounted for have the potential to induce loss of ownership bridging between VMs, so it's critical to
    /// retain identifying token information on bridging.
    ///
    /// See discussion https://github.com/onflow/flow-nft/pull/126#discussion_r1462612559 where @austinkline raised
    /// differentiating IDs in a minimal interface incorporated into the one below
    ///
    access(all) resource interface EVMNFT : ICrossVMAsset.AssetInfo, NonFungibleToken.NFT {
        access(all) let evmID: UInt256

        access(all) view fun getName(): String
        access(all) view fun getSymbol(): String
        access(all) view fun getEVMContractAddress(): EVM.EVMAddress
        access(all) fun tokenURI(): String
    }

    /// A simple interface for a collection of EVMNFTs
    ///
    access(all) resource interface EVMNFTCollection : NonFungibleToken.Collection {
        access(all) view fun getName(): String
        access(all) view fun getSymbol(): String
        access(all) view fun getEVMIDs(): [UInt256]
        access(all) view fun getCadenceID(from evmID: UInt256): UInt64?
        access(all) view fun getEVMID(from cadenceID: UInt64): UInt256?
        access(all) fun contractURI(): String?
    }

    /// Retrieves the EVM ID of an NFT if it implements the EVMNFT interface, returning nil if not
    ///
    access(all) view fun getEVMID(from token: &{NonFungibleToken.NFT}): UInt256? {
        if let evmNFT = token as? &{EVMNFT} {
            return evmNFT.evmID
        }
        return nil
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/CONTRIBUTING.md

# Contributing to the Flow EVM Bridge

The following is a set of guidelines for contributing to the Flow EVM Bridge. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request.

#### Table Of Contents

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Pull Requests](#pull-requests)

[Styleguides](#styleguides)

- [Git Commit Messages](#git-commit-messages)

[Additional Notes](#additional-notes)


## How Can I Contribute?

You are free to contribute however you want! You can submit a bug report in an issue, suggest an enhancment, or even just make a PR for us to review. We just ask that you are clear in your communication and documentation of all your work so we can understand how you are trying to help.

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported. If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible. When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include screenshots and animated GIFs** which show you following the described steps and clearly demonstrate the problem. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

- **What's the name and version of the OS you're using**?
- **What's the name and version of the flow-cli that you are using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**. Include copy/pasteable snippets which you use in those examples, as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Include screenshots and animated GIFs**. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.
- **Explain why this enhancement would be useful** to be included in the standard.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

Before contributing, make sure to examine the project to get familiar with the patterns and style already being used.

### Git Commit Messages

- Use the present tense ("Add feature" not "Added feature")
- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
- Limit the first line to 72 characters or less
- Reference issues and pull requests liberally after the first line


### Additional Notes

Thank you for your interest in contributing to the Flow EVM Bridge!




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/.github/ISSUE_TEMPLATE.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/tokens/bridge_tokens_to_evm.cdc

```
import "FungibleToken"
import "ViewResolver"
import "FungibleTokenMetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// Bridges a Vault from the signer's storage to the signer's COA in EVM.Account.
///
/// NOTE: This transaction also onboards the Vault to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM
///
transaction(vaultIdentifier: String, amount: UFix64) {

    let sentVault: @{FungibleToken.Vault}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract with name"
                .concat(tokenContractName).concat(" and address ")
                .concat(tokenContractAddress.toString()))
        let vaultData = viewResolver.resolveContractView(
                resourceType: vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not resolve FTVaultData view for Vault type ".concat(vaultType.identifier))
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not borrow FungibleToken Vault from storage path ".concat(vaultData.storagePath.toString()))

        // Withdraw the requested balance & set a cap on the withdrawable bridge fee
        self.sentVault <- vault.withdraw(amount: amount)
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Determine if the Vault requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.sentVault.getType())
            ?? panic("Bridge does not support the requested asset type ".concat(vaultIdentifier))
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.sentVault.getType().identifier == vaultIdentifier:
            "Attempting to send invalid vault type - requested: ".concat(vaultIdentifier)
            .concat(", sending: ").concat(self.sentVault.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the Vault to the bridge
            FlowEVMBridge.onboardByType(
                self.sentVault.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge
        self.coa.depositTokens(
            vault: <-self.sentVault,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/blocklist/block_cadence_type.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Blocks the given Cadence Type from onboarding.
///
/// @param typeIdentifier: The Cadence identifier of the type to block
///
transaction(typeIdentifier: String) {

    let cadenceBlocklist: auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.CadenceBlocklist
    let type: Type

    prepare(signer: auth(BorrowValue) &Account) {
        self.cadenceBlocklist = signer.storage.borrow<auth(FlowEVMBridgeConfig.Blocklist) &FlowEVMBridgeConfig.CadenceBlocklist>(
                from: /storage/cadenceBlocklist
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
        self.type = CompositeType(typeIdentifier) ?? panic("Invalid type identifier ".concat(typeIdentifier))
    }

    execute {
        self.cadenceBlocklist.block(self.type)
    }

    post {
        FlowEVMBridgeConfig.isCadenceTypeBlocked(self.type): "Type was not blocked"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/admin/token-handler/enable_token_handler.cdc

```
import "EVM"

import "FlowEVMBridgeHandlerInterfaces"
import "FlowEVMBridgeConfig"

/// Enables the TokenHandler to fulfill bridge requests.
///
/// @param targetTypeIdentifier: The identifier of the handler's target type.
///
transaction(targetTypeIdentifier: String) {

    let admin: auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        self.admin = signer.storage.borrow<auth(FlowEVMBridgeHandlerInterfaces.Admin) &FlowEVMBridgeConfig.Admin>(
                from: FlowEVMBridgeConfig.adminStoragePath
            ) ?? panic("Could not borrow FlowEVMBridgeConfig Admin reference")
    }

    execute {
        let targetType = CompositeType(targetTypeIdentifier)
            ?? panic("Invalid Type identifier provided")
        self.admin.enableHandler(targetType: targetType)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/example-assets/ExampleERC20.sol

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";

contract ExampleERC20 is ERC20, ERC20Burnable, Ownable, ERC20Permit {
    constructor() ERC20("NAME", "SYMBOL") Ownable(msg.sender) ERC20Permit("NAME") {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/config/get_onboard_fee.cdc

```
import "FlowEVMBridgeConfig"

access(all) fun main(): UFix64 {
    return FlowEVMBridgeConfig.onboardFee
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/resolve_locked_vault_metadata.cdc

```
import "NonFungibleToken"
import "MetadataViews"

import "FlowEVMBridgeTokenEscrow"
import "FlowEVMBridgeUtils"

/// Resolves the view for the requested locked Vault or nil if the Vault is not locked in escrow
/// NOTE: This functionality is not available via the escrow contract as `resolveView` is not a `view` method, but the
///     escrow contract does provide the necessary functionality to resolve the view from the context of a script
///
/// @param bridgeAddress: The address of the bridge contract (included as the VM bridge address varies across networks)
/// @param vaultTypeIdentifier: The identifier of the Vault type
/// @param viewIdentifier: The identifier of the view to resolve
///
/// @return The resolved view if the Vault is escrowed & the view is resolved by it or nil if the Vault is not locked
///
access(all) fun main(bridgeAddress: Address, vaultTypeIdentifier: String, viewIdentifier: String): AnyStruct? {
    // Construct runtime types from provided identifiers
    let vaultType: Type = CompositeType(vaultTypeIdentifier) ?? panic("Malformed vault type identifier=".concat(vaultTypeIdentifier))
    let view: Type = CompositeType(viewIdentifier) ?? panic("Malformed view type identifier=".concat(viewIdentifier))

    // Derive the Locker path for the given Vault type
    let lockerPath = FlowEVMBridgeUtils.deriveEscrowStoragePath(fromType: vaultType)
        ?? panic("Problem deriving Locker path for NFT type identifier=".concat(vaultTypeIdentifier))

    // Borrow the locker from the bridge account's storage & return the requested view if the locker exists
    if let locker = getAuthAccount<auth(BorrowValue) &Account>(bridgeAddress).storage.borrow<&FlowEVMBridgeTokenEscrow.Locker>(
        from: lockerPath
    ) {
        return locker.resolveView(view)
    }

    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/bridge/nft/bridge_nft_from_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"

import "ScopedFTProviders"

import "EVM"

import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"

/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftIdentifier: String, id: UInt256) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                    .concat(collectionData.storagePath.toString()))

        /* --- Configure a ScopedFTProvider --- */
        //
        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            )
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged nft is the correct type
        assert(
            nft.getType() == self.nftType,
            message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                .concat(", received: ").concat(nft.getType().identifier)
        )
        // Deposit the bridged NFT into the signer's collection
        self.collection.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/escrow/get_nft_views.cdc

```
import "NonFungibleToken"

import "FlowEVMBridgeNFTEscrow"
import "FlowEVMBridge"

/// Returns the views supported by an escrowed NFT or nil if the NFT is not locked in escrow
///
/// @param nftTypeIdentifier: The type identifier of the NFT
/// @param id: The ID of the NFT
///
/// @return The metadata view types supported by the escrowed NFT or nil if the NFT is not locked in escrow
///
access(all) fun main(nftTypeIdentifier: String, id: UInt64): [Type]? {
    let type = CompositeType(nftTypeIdentifier) ?? panic("Malformed NFT type identifier=".concat(nftTypeIdentifier))
    return FlowEVMBridgeNFTEscrow.getViews(nftType: type, id: id)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/solidity/src/FlowBridgeFactory.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IBridgePermissions} from "./interfaces/IBridgePermissions.sol";
import {IFlowEVMBridgeDeployer} from "./interfaces/IFlowEVMBridgeDeployer.sol";
import {IFlowEVMDeploymentRegistry} from "./interfaces/IFlowEVMDeploymentRegistry.sol";
import {FlowEVMDeploymentRegistry} from "./interfaces/FlowEVMDeploymentRegistry.sol";

/**
 * @title FlowBridgeFactory
 * @dev Factory contract to deploy new FlowEVM bridge contracts, defining Cadence-native assets in EVM. Cadence & EVM
 * contract associations are maintained in a deployment registry. This factory is enabled to deploy contracts via
 * registered deployer implementations, each of which handle the deployment of a single templated contract indexed by
 * a human-readable deployer tag. This setup modularizes each key component of the EVM side of the Flow EVM VM bridge,
 * allowing new asset types to be added by simply adding a new deployer implementation or updated factory contract
 * to be swapped out without affecting the underlying associations between Cadence and EVM contracts.
 */
contract FlowBridgeFactory is Ownable {
    // Address of the deployment registry where deployed contract associations are registered. Note that this is a
    // registry for EVM contracts deployed by the bridge factory and does not include those EVM-native contracts that
    // have been onboarded to the bridge via Cadence contracts. The global source of truth is found in the Cadence
    // side of the bridge, however this registry and publicly accessible methods can serve as a source of truth
    // within EVM. Given some EVM contract, its bridge-supported Cadence type association can be found (and vice-versa)
    // by querying this contract, thus preventing impersonation attacks.
    address private deploymentRegistry;
    // Mapping of deployer tags to their implementation addresses
    mapping(string => address) private deployers;

    /**
     * @dev Emitted when a deployer is added to the factory
     */
    event DeployerAdded(string indexed tag, address deployerAddress);
    /**
     * @dev Emitted when a deployer is updated in the factory
     */
    event DeployerUpdated(string indexed tag, address oldAddress, address newAddress);
    /**
     * @dev Emitted when a deployer is removed from the factory
     */
    event DeployerRemoved(string indexed tag, address oldAddress);
    /**
     * @dev Emitted when the deployment registry is updated
     */
    event DeploymentRegistryUpdated(address indexed oldAddress, address indexed newAddress);

    constructor() Ownable(msg.sender) {}

    /**
     * @dev Deploys a new asset contract via a registered deployer
     *
     * @param deployerTag The tag of the deployer to use as set by the owner
     * @param name The name of the asset
     * @param symbol The symbol of the asset
     * @param cadenceAddress The Flow account address of the Cadence implementation
     * @param cadenceIdentifier The Cadence identifier of the asset type
     * @param contractURI The URI of the contract metadata for the asset
     *
     * @return The address of the newly deployed contract
     */
    function deploy(
        string memory deployerTag,
        string memory name,
        string memory symbol,
        string memory cadenceAddress,
        string memory cadenceIdentifier,
        string memory contractURI
    ) public onlyOwner returns (address) {
        address deployerAddress = deployers[deployerTag];
        _requireIsValidDeployer(deployerAddress);
        IFlowEVMBridgeDeployer deployer = IFlowEVMBridgeDeployer(deployerAddress);

        address newContract = deployer.deploy(name, symbol, cadenceAddress, cadenceIdentifier, contractURI);

        _registerDeployment(cadenceIdentifier, newContract);

        return newContract;
    }

    /**
     * @dev Retrieves the Cadence type identifier associated with the bridge-deployed contract
     *
     * @param contractAddr The address of the deployed contract
     *
     * @return The Cadence identifier of the contract
     */
    function getCadenceIdentifier(address contractAddr) public view returns (string memory) {
        return FlowEVMDeploymentRegistry(deploymentRegistry).getCadenceIdentifier(contractAddr);
    }

    /**
     * @dev Retrieves the address of a bridge-deployed contract by its associated Cadence type identifier
     *
     * @param cadenceIdentifier The Cadence type identifier of the contract
     *
     * @return The address of the deployed contract
     */
    function getContractAddress(string memory cadenceIdentifier) public view returns (address) {
        return FlowEVMDeploymentRegistry(deploymentRegistry).getContractAddress(cadenceIdentifier);
    }

    /**
     * @dev Checks if a contract address is associated with a registered deployment
     *
     * @param contractAddr The address of the deployed contract
     *
     * @return True if the contract is a registered deployment, false otherwise
     */
    function isBridgeDeployed(address contractAddr) public view returns (bool) {
        return FlowEVMDeploymentRegistry(deploymentRegistry).isRegisteredDeployment(contractAddr);
    }

    /**
     * @dev Makes a best guess if the contract address is an ERC20 token by calling the publicly accessible ERC20
     * interface methods on the contract via staticcall to prevent reverts. Note, since ERC20 does not implement
     * ERC165, this is a best guess and may result in false positives.
     *
     * @param contractAddr The address of the contract to check
     *
     * @return True if the contract is an ERC20 token, false otherwise
     */
    function isERC20(address contractAddr) public view returns (bool) {
        (bool success, bytes memory data) = contractAddr.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (!success || data.length == 0) {
            return false;
        }
        (success, data) = contractAddr.staticcall(abi.encodeWithSignature("balanceOf(address)", address(0)));
        if (!success || data.length == 0) {
            return false;
        }
        (success, data) =
            contractAddr.staticcall(abi.encodeWithSignature("allowance(address,address)", address(0), address(0)));
        if (!success || data.length == 0) {
            return false;
        }
        (success, data) = contractAddr.staticcall(abi.encodeWithSignature("name()"));
        if (!success || data.length == 0) {
            return false;
        }
        (success, data) = contractAddr.staticcall(abi.encodeWithSignature("symbol()"));
        if (!success || data.length == 0) {
            return false;
        }
        (success, data) = contractAddr.staticcall(abi.encodeWithSignature("decimals()"));
        if (!success || data.length == 0) {
            return false;
        }
        return true;
    }

    /**
     * @dev Determines if a contract is an ERC721 token by checking if it implements the ERC721 interface via ERC165
     * supportsInterface call.
     *
     * @param contractAddr The address of the contract to check
     *
     * @return True if the contract is an ERC721 token, false otherwise
     */
    function isERC721(address contractAddr) public view returns (bool) {
        try ERC165(contractAddr).supportsInterface(0x80ac58cd) returns (bool support) {
            return support;
        } catch {
            return false;
        }
    }

    /**
     * @dev Determines if a contract is a valid asset by checking if it is either an ERC20 or ERC721 implementation
     *
     * @param contractAddr The address of the contract to check
     *
     * @return True if the contract is a valid asset, false otherwise
     */
    function isValidAsset(address contractAddr) public view returns (bool) {
        return isERC20(contractAddr) != isERC721(contractAddr);
    }

    /**
     * @dev Retrieves the address of the deployment registry
     *
     * @return The address of the deployment registry
     */
    function getRegistry() public view returns (address) {
        return deploymentRegistry;
    }

    /**
     * @dev Retrieves the address of a deployer by its tag
     *
     * @param tag The tag of the deployer
     *
     * @return The address of the deployer
     */
    function getDeployer(string memory tag) public view returns (address) {
        return deployers[tag];
    }

    /**
     * @dev Sets the address of the deployment registry
     *
     * @param _deploymentRegistry The address of the deployment registry
     */
    function setDeploymentRegistry(address _deploymentRegistry) public onlyOwner {
        _requireIsValidRegistry(_deploymentRegistry);

        emit DeploymentRegistryUpdated(deploymentRegistry, _deploymentRegistry);

        deploymentRegistry = _deploymentRegistry;
    }

    /**
     * @dev Adds a new deployer to the factory
     *
     * @param tag The tag of the deployer
     * @param deployerAddress The address of the deployer
     *
     * emits a {DeployerAdded} event
     */
    function addDeployer(string memory tag, address deployerAddress) public onlyOwner {
        _requireIsValidDeployer(deployerAddress);
        require(deployers[tag] == address(0), "FlowBridgeFactory: Deployer already registered");
        deployers[tag] = deployerAddress;

        emit DeployerAdded(tag, deployerAddress);
    }

    /**
     * @dev Adds a deployer to the factory, or updates the address of an existing deployer
     *
     * @param tag The tag of the deployer
     *
     * emits a {DeployerUpdated} event if the deployer already exists otherwise a {DeployerAdded} event
     */
    function upsertDeployer(string memory tag, address deployerAddress) public onlyOwner {
        _requireIsValidDeployer(deployerAddress);

        address oldAddress = deployers[tag];
        if (oldAddress == address(0)) {
            addDeployer(tag, deployerAddress);
            return;
        }

        deployers[tag] = deployerAddress;

        emit DeployerUpdated(tag, oldAddress, deployerAddress);
    }

    /**
     * @dev Removes a deployer from the factory
     *
     * @param tag The tag of the deployer
     *
     * emits a {DeployerRemoved} event
     */
    function removeDeployer(string memory tag) public onlyOwner {
        address oldAddress = deployers[tag];
        require(oldAddress != address(0), "FlowBridgeFactory: Deployer not registered");

        delete deployers[tag];

        emit DeployerRemoved(tag, oldAddress);
    }

    /**
     * @dev Overrides Ownable.renounceOwnership function to prevent ownership renouncement as it is required to retain
     * bridge functionality
     */
    function renounceOwnership() public virtual override onlyOwner {
        revert("FlowBridgeFactory: Ownership cannot be renounced");
    }

    /**
     * @dev Registers a new deployment in the deployment registry
     *
     * @param cadenceIdentifier The Cadence identifier of the deployed contract
     * @param contractAddr The address of the deployed contract
     */
    function _registerDeployment(string memory cadenceIdentifier, address contractAddr) internal {
        FlowEVMDeploymentRegistry registry = FlowEVMDeploymentRegistry(deploymentRegistry);
        registry.registerDeployment(cadenceIdentifier, contractAddr);
    }

    /**
     * @dev Asserts that the registry address is non-zero and implements the IFlowEVMDeploymentRegistry interface
     *
     * @param registryAddr The address of the registry to check
     */
    function _requireIsValidRegistry(address registryAddr) internal view {
        _requireNotZeroAddress(registryAddr);
        require(
            _implementsInterface(registryAddr, type(IFlowEVMDeploymentRegistry).interfaceId),
            "FlowBridgeFactory: Invalid registry"
        );
    }

    /**
     * @dev Asserts that the contract address is non-zero and implements the IFlowEVMBridgeDeployer interface
     *
     * @param contractAddr The address of the contract to check
     */
    function _requireIsValidDeployer(address contractAddr) internal view {
        _requireNotZeroAddress(contractAddr);
        require(
            _implementsInterface(contractAddr, type(IFlowEVMBridgeDeployer).interfaceId),
            "FlowBridgeFactory: Invalid deployer"
        );
    }

    /**
     * @dev Checks if a contract implements a specific interface
     *
     * @param contractAddr The address of the contract to check
     *
     * @return True if the contract implements the interface, false otherwise
     */
    function _implementsInterface(address contractAddr, bytes4 interfaceId) internal view returns (bool) {
        try ERC165(contractAddr).supportsInterface(interfaceId) returns (bool support) {
            return support;
        } catch {
            return false;
        }
    }

    /**
     * @dev Asserts that the address is non-zero
     *
     * @param addr The address to check
     */
    function _requireNotZeroAddress(address addr) internal pure {
        require(addr != address(0), "FlowBridgeFactory: Zero address");
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/transactions/evm/create_new_account_with_coa.cdc

```
import Crypto

import "EVM"

/// Creates a new Flow Address with a single full-weight key and its EVM account, which is
/// a Cadence Owned Account (COA) stored in the account's storage.
///
transaction(
    key: String,  // key to be used for the account
    signatureAlgorithm: UInt8, // signature algorithm to be used for the account
    hashAlgorithm: UInt8, // hash algorithm to be used for the account
) {
    let auth: auth(BorrowValue) &Account

    prepare(signer: auth(BorrowValue) &Account) {
        pre {
            signatureAlgorithm == 1 || signatureAlgorithm == 2:
                "Cannot add Key: Must provide a signature algorithm raw value that corresponds to "
                .concat("one of the available signature algorithms for Flow keys.")
                .concat("You provided ").concat(signatureAlgorithm.toString())
                .concat(" but the options are either 1 (ECDSA_P256), 2 (ECDSA_secp256k1).")
            hashAlgorithm == 1 || hashAlgorithm == 3:
                "Cannot add Key: Must provide a hash algorithm raw value that corresponds to "
                .concat("one of of the available hash algorithms for Flow keys.")
                .concat("You provided ").concat(hashAlgorithm.toString())
                .concat(" but the options are 1 (SHA2_256), 3 (SHA3_256).")
        }

        self.auth = signer
    }

    execute {
        // Create a new public key
        let publicKey = PublicKey(
            publicKey: key.decodeHex(),
            signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!
        )

        // Create a new account
        let account = Account(payer: self.auth)

        // Add the public key to the account
        account.keys.add(
            publicKey: publicKey,
            hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!,
            weight: 1000.0
        )

        // Create a new COA
        let coa <- EVM.createCadenceOwnedAccount()

        // Save the COA to the new account
        let storagePath = StoragePath(identifier: "evm")!
        let publicPath = PublicPath(identifier: "evm")!
        account.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)
        let addressableCap = account.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)
        account.capabilities.unpublish(publicPath)
        account.capabilities.publish(addressableCap, at: publicPath)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-evm-bridge/blob/main/cadence/scripts/bridge/is_evm_address_blocked.cdc

```
import "EVM"

import "FlowEVMBridgeConfig"

/// Returns whether a EVM contract is blocked from onboarded to the FlowEVMBridge
///
/// @param evmAddressHex: The hex-encoded address of the EVM contract as a String
///
/// @return Whether the contract is blocked from onboarding to the FlowEVMBridge
///
access(all) fun main(evmAddressHex: String): Bool {
    let address = EVM.addressFromString(evmAddressHex)
    return FlowEVMBridgeConfig.isEVMAddressBlocked(address)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/purchase_moment.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction is for a user to purchase a moment that another user
// has for sale in their sale collection

// Parameters
//
// sellerAddress: the Flow address of the account issuing the sale of a moment
// tokenID: the ID of the moment being purchased
// purchaseAmount: the amount for which the user is paying for the moment; must not be less than the moment's price

transaction(sellerAddress: Address, tokenID: UInt64, purchaseAmount: UFix64) {
    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the signer's collection
        let collection = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow reference to the Moment Collection")

        // borrow a reference to the signer's fungible token Vault
        let provider = acct.storage.borrow<auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)!
        
        // withdraw tokens from the signer's vault
        let tokens <- provider.withdraw(amount: purchaseAmount) as! @DapperUtilityCoin.Vault

        // get the seller's public account object
        let seller = getAccount(sellerAddress)

        // borrow a public reference to the seller's sale collection
        let topshotSaleCollection = seller.capabilities.borrow<&TopShotMarketV3.SaleCollection>(/public/topshotSalev3Collection)
            ?? panic("Could not borrow public sale reference")
    
        // purchase the moment
        let purchasedToken <- topshotSaleCollection.purchase(tokenID: tokenID, buyTokens: <-tokens)

        // deposit the purchased moment into the signer's collection
        collection.deposit(token: <-purchasedToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/create_play.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction creates a new play struct 
// and stores it in the Top Shot smart contract
// We currently stringify the metadata and insert it into the 
// transaction string, but want to use transaction arguments soon

// Parameters:
//
// metadata: A dictionary of all the play metadata associated

transaction(metadata: {String: String}) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin
    let currPlayID: UInt32

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the admin resource
        self.currPlayID = TopShot.nextPlayID;
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {

        // Create a play with the specified metadata
        self.adminRef.createPlay(metadata: metadata)
    }

    post {
        
        TopShot.getPlayMetaData(playID: self.currPlayID) != nil:
            "playID doesnt exist"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/lock_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction locks a set so that new plays can no longer be added to it

// Parameters:
//
// setID: the ID of the set to be locked

transaction(setID: UInt32) {

    // local variable for the admin resource
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin resource
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {
        // borrow a reference to the Set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // lock the set permanently
        setRef.lock()
    }

    post {
        
        TopShot.isSetLocked(setID: setID)!:
            "Set did not lock"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/script/InitialTestingDeploy.s.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Script} from "forge-std/Script.sol";
import "forge-std/console.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/src/Upgrades.sol";
import {TestNFTContract} from "../src/test-contracts/TestNFTContract.sol";

contract InitialTestingDeployScript is Script {
    function setUp() public {}

    function run() external returns (address, address) {
        // Start broadcast with deployer private key
        vm.startBroadcast(vm.envUint("DEPLOYER_PRIVATE_KEY"));
        console.log("Deployer address:", msg.sender);

        // Set testnet contract initialization parameters
        address owner = msg.sender;
        string memory name = "Test NFT";
        string memory symbol = "TEST";
        string memory baseTokenURI = "https://api.cryptokitties.co/tokenuri/";
        string memory cadenceNFTAddress = "abcdef1234567890";
        string memory cadenceNFTIdentifier = "A.abcdef1234567890.TestNFT.NFT";
        string memory contractURI = 'data:application/json;utf8,{"name": "Name of NFT","description":"Description of NFT"}';
        address underlyingNftContractAddress = address(0x12345);
        address vmBridgeAddress = address(0x67890);

        // Deploy NFT contract using UUPS proxy for upgradeability
        address proxyAddr = Upgrades.deployUUPSProxy(
            "TestNFTContract.sol",
            abi.encodeCall(
                TestNFTContract.initialize,
                (
                    owner,
                    underlyingNftContractAddress,
                    vmBridgeAddress,
                    name,
                    symbol,
                    baseTokenURI,
                    cadenceNFTAddress,
                    cadenceNFTIdentifier,
                    contractURI
                )
            )
        );
        console.log("Proxy contract deployed at address:", proxyAddr);

        // Get implementation contract address
        address implementationAddr = Upgrades.getImplementationAddress(
            proxyAddr
        );
        console.log("Implementation contract deployed at address:", implementationAddr);

        // Stop broadcast and return implementation and proxy addresses
        vm.stopBroadcast();
        return (implementationAddr, proxyAddr);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/scripts/get_sale_set_id.cdc

```
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

access(all) fun main(sellerAddress: Address, momentID: UInt64): UInt32 {
    let saleRef = getAccount(sellerAddress).capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath)
        ?? panic("Could not get public sale reference")

    let token = saleRef.borrowMoment(id: momentID)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return data.setID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/purchase_group_of_moments.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction is for a user to purchase a group of moments from
// one more or more sellers

// Parameters
//
// momentsBySeller: An object consisting of a key of the sellers address,
//  and an array of the moments being purchased from this seller
//
// purchaseAmount: the amount the user is paying for all moments within
//  the group

transaction(momentsBySeller: {Address: [UInt64]}, purchaseAmount: UFix64) {

    // Local variables for the topshot collection object and token provider
    let collectionRef: &TopShot.Collection
    let providerRef: auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault
    
    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the signer's collection
        self.collectionRef = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow reference to the Moment Collection")

        // borrow a reference to the signer's fungible token Vault
        self.providerRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)!
    }

    execute {
        // Obtain a list of seller addresses
        var sellerAddresses = momentsBySeller.keys

        // Initialize the sum price of all moments
        var sumMomentPrices: UFix64 = 0.00

        for sellerAddress in sellerAddresses {
            // Get all moments we are purchasing from this seller
            var sellerMoments = momentsBySeller[sellerAddress]!
            
            for sellerMoment in sellerMoments {
                // Get the seller account
                let seller = getAccount(sellerAddress)
                // Check if we can obtain a reference to the sellers marketV3 collection
                if let marketV3CollectionRef = seller.capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath) {

                    // Check the moments sale price
                    var momentPrice = marketV3CollectionRef.getPrice(tokenID: sellerMoment) ?? panic("Moment not for sale")
                    // Add the sale price to the sum of all moment prices
                    sumMomentPrices = sumMomentPrices + momentPrice
                    // Withdraw fungible tokens for payment
                    let tokens <- self.providerRef.withdraw(amount: momentPrice) as! @DapperUtilityCoin.Vault
                    // Purchase non-fungible token with payment via fungible tokens
                    let purchasedToken <- marketV3CollectionRef.purchase(tokenID: sellerMoment, buyTokens: <-tokens)
                    // Deposit purchased non-fungible token to purchasers collection
                    self.collectionRef.deposit(token: <-purchasedToken)


                // If we could not obtain reference to sellers marketV3 collection, try V1
                } else if let topshotSaleCollection = seller.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection) {

                // Check the moments sale price
                var momentPrice = topshotSaleCollection.getPrice(tokenID: sellerMoment) ?? panic("Moment not for sale")
                // Add the sale price to the sum of all moment prices
                sumMomentPrices = sumMomentPrices + momentPrice
                // Withdraw fungible tokens for payment
                let tokens <- self.providerRef.withdraw(amount: momentPrice) as! @DapperUtilityCoin.Vault
                // Purchase non-fungible token with payment via fungible tokens
                let purchasedToken <- topshotSaleCollection.purchase(tokenID: sellerMoment, buyTokens: <-tokens)
                // Deposit purchased non-fungible token to purchasers collection
                self.collectionRef.deposit(token: <-purchasedToken)

                } else {
                    // Could not borrow a reference to sellers marketV1 or V3 sale collection
                    panic("Could not borrow reference to either Sale collection")
                }

            }
        }
        if sumMomentPrices > purchaseAmount {
            // Revert the transaction if the amount of fungible tokens required 
            // are larger than the users purchaseAmount
            panic("Sum of all moment prices is greater than purchaseAmount!")
        }

    }
}



```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotLocking.cdc

```
import NonFungibleToken from 0xNFTADDRESS

access(all) contract TopShotLocking {

    // -----------------------------------------------------------------------
    // TopShotLocking contract Events
    // -----------------------------------------------------------------------

    // Emitted when a Moment is locked
    access(all) event MomentLocked(id: UInt64, duration: UFix64, expiryTimestamp: UFix64)

    // Emitted when a Moment is unlocked
    access(all) event MomentUnlocked(id: UInt64)

    // Dictionary of locked NFTs
    // TopShot nft resource id is the key
    // locked until timestamp is the value
    access(self) var lockedNFTs: {UInt64: UFix64}

    // Dictionary of NFTs overridden to be unlocked
    access(self) var unlockableNFTs: {UInt64: Bool} // nft resource id is the key

    // isLocked Returns a boolean indicating if an nft exists in the lockedNFTs dictionary
    //
    // Parameters: nftRef: A reference to the NFT resource
    //
    // Returns: true if NFT is locked
    access(all) view fun isLocked(nftRef: &{NonFungibleToken.NFT}): Bool {
        return self.lockedNFTs.containsKey(nftRef.id)
    }

    // getLockExpiry Returns the unix timestamp when an nft is unlockable
    //
    // Parameters: nftRef: A reference to the NFT resource
    //
    // Returns: unix timestamp
    access(all) view fun getLockExpiry(nftRef: &{NonFungibleToken.NFT}): UFix64 {
        if !self.lockedNFTs.containsKey(nftRef.id) {
            panic("NFT is not locked")
        }
        return self.lockedNFTs[nftRef.id]!
    }

    // lockNFT Takes an NFT resource and adds its unique identifier to the lockedNFTs dictionary
    //
    // Parameters: nft: NFT resource
    //             duration: number of seconds the NFT will be locked for
    //
    // Returns: the NFT resource
    access(all) fun lockNFT(nft: @{NonFungibleToken.NFT}, duration: UFix64): @{NonFungibleToken.NFT} {
        let TopShotNFTType: Type = CompositeType("A.TOPSHOTADDRESS.TopShot.NFT")!
        if !nft.isInstance(TopShotNFTType) {
            panic("NFT is not a TopShot NFT")
        }

        if self.lockedNFTs.containsKey(nft.id) {
            // already locked - short circuit and return the nft
            return <- nft
        }

        let expiryTimestamp = getCurrentBlock().timestamp + duration

        self.lockedNFTs[nft.id] = expiryTimestamp

        emit MomentLocked(id: nft.id, duration: duration, expiryTimestamp: expiryTimestamp)

        return <- nft
    }

    // unlockNFT Takes an NFT resource and removes it from the lockedNFTs dictionary
    //
    // Parameters: nft: NFT resource
    //
    // Returns: the NFT resource
    //
    // NFT must be eligible for unlocking by an admin
    access(all) fun unlockNFT(nft: @{NonFungibleToken.NFT}): @{NonFungibleToken.NFT} {
        if !self.lockedNFTs.containsKey(nft.id) {
            // nft is not locked, short circuit and return the nft
            return <- nft
        }

        let lockExpiryTimestamp: UFix64 = self.lockedNFTs[nft.id]!
        let isPastExpiry: Bool = getCurrentBlock().timestamp >= lockExpiryTimestamp

        let isUnlockableOverridden: Bool = self.unlockableNFTs.containsKey(nft.id)

        if !(isPastExpiry || isUnlockableOverridden) {
            panic("NFT is not eligible to be unlocked, expires at ".concat(lockExpiryTimestamp.toString()))
        }

        self.unlockableNFTs.remove(key: nft.id)
        self.lockedNFTs.remove(key: nft.id)

        emit MomentUnlocked(id: nft.id)

        return <- nft
    }

    // getIDs Returns the ids of all locked Top Shot NFT tokens
    //
    // Returns: array of ids
    //
    access(all) view fun getIDs(): [UInt64] {
        return self.lockedNFTs.keys
    }

    // getExpiry Returns the timestamp when a locked token is eligible for unlock
    //
    // Parameters: tokenID: the nft id of the locked token
    //
    // Returns: a unix timestamp in seconds
    //
    access(all) view fun getExpiry(tokenID: UInt64): UFix64? {
        return self.lockedNFTs[tokenID]
    }

    // getLockedNFTsLength Returns the count of locked tokens
    //
    // Returns: an integer containing the number of locked tokens
    //
    access(all) view fun getLockedNFTsLength(): Int {
        return self.lockedNFTs.length
    }

    // The path to the TopShotLocking Admin resource belonging to the Account
    // which the contract is deployed on
    access(all) view fun AdminStoragePath() : StoragePath { return /storage/TopShotLockingAdmin}

    // Admin is a special authorization resource that 
    // allows the owner to override the lock on a moment
    //
    access(all) resource Admin {
        // createNewAdmin creates a new Admin resource
        //
        access(all) fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

        // markNFTUnlockable marks a given nft as being
        // unlockable, overridding the expiry timestamp
        // the nft owner will still need to send an unlock transaction to unlock
        //
        access(all) fun markNFTUnlockable(nftRef: &{NonFungibleToken.NFT}) {
            TopShotLocking.unlockableNFTs[nftRef.id] = true
        }

        access(all) fun unlockByID(id: UInt64) {
            if !TopShotLocking.lockedNFTs.containsKey(id) {
                // nft is not locked, do nothing
                return
            }
            TopShotLocking.lockedNFTs.remove(key: id)
            emit MomentUnlocked(id: id)
        }

        // admin may alter the expiry of a lock on an NFT
        access(all) fun setLockExpiryByID(id: UInt64, expiryTimestamp: UFix64) {
            if expiryTimestamp < getCurrentBlock().timestamp {
                panic("cannot set expiry in the past")
            }

            let duration = expiryTimestamp - getCurrentBlock().timestamp

            TopShotLocking.lockedNFTs[id] = expiryTimestamp

            emit MomentLocked(id: id, duration: duration, expiryTimestamp: expiryTimestamp)
        }

        // unlocks all NFTs
        access(all) fun unlockAll() {
            TopShotLocking.lockedNFTs = {}
            TopShotLocking.unlockableNFTs = {}
        }
    }

    // -----------------------------------------------------------------------
    // TopShotLocking initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        self.lockedNFTs = {}
        self.unlockableNFTs = {}

        // Create a single admin resource
        let admin <- create Admin()

        // Store it in private account storage in `init` so only the admin can use it
        self.account.storage.save(<-admin, to: TopShotLocking.AdminStoragePath())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/.github/ISSUE_TEMPLATE/bug_report.md

---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/unlock_all_moments.cdc

```
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

transaction() {
    let adminRef: &TopShotLocking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // Set TopShotLocking admin ref
        self.adminRef = acct.storage.borrow<&TopShotLocking.Admin>(from: /storage/TopShotLockingAdmin)
            ?? panic("Could not find reference to TopShotLocking Admin resource")
    }

    execute {
        self.adminRef.unlockAll()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/scripts/get_sale_len.cdc

```
import Market from 0xMARKETADDRESS

// This script gets the number of moments an account has for sale

// Parameters:
//
// sellerAddress: The Flow Address of the account whose sale collection needs to be read

// Returns: Int
// Number of moments up for sale in an account

access(all) fun main(sellerAddress: Address): Int {

    let acct = getAccount(sellerAddress)

    let collectionRef = acct.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getIDs().length
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/player/update_submission.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS
import NonFungibleToken from 0xNFTADDRESS

transaction(fastBreakGameID: String, topShotMomentIds: [UInt64]) {

    let gameRef: auth(FastBreakV1.Update) &FastBreakV1.Player

    prepare(acct: auth(BorrowValue) &Account) {

        self.gameRef = acct.storage
            .borrow<auth(FastBreakV1.Update) &FastBreakV1.Player>(from: FastBreakV1.PlayerStoragePath)
            ?? panic("could not borrow a reference to the accounts player")

    }

    execute {
        self.gameRef.updateSubmission(fastBreakGameID: fastBreakGameID, topShots: topShotMomentIds)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/setup_collection.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS

// This transaction sets up an account to use Top Shot
// by storing an empty moment collection and creating
// a public capability for it

transaction {

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // First, check to see if a moment collection already exists
        if acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {
            // create a new TopShot Collection
            let collection <- TopShot.createEmptyCollection(nftType: Type<@TopShot.NFT>()) as! @TopShot.Collection
            // Put the new Collection in storage
            acct.storage.save(<-collection, to: /storage/MomentCollection)
        }

        acct.capabilities.unpublish(/public/MomentCollection)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&TopShot.Collection>(/storage/MomentCollection),
            at: /public/MomentCollection
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/test-contracts/TestNFTContract.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ERC721EnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import {ERC721BurnableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {ERC721WrapperUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721WrapperUpgradeable.sol";

import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import {IERC721Metadata} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import {IERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {IERC2981} from "@openzeppelin/contracts/interfaces/IERC2981.sol";
import {IERC4906} from "@openzeppelin/contracts/interfaces/IERC4906.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import {ICreatorToken, ILegacyCreatorToken} from "../interfaces/ICreatorToken.sol";
import {ITransferValidator721} from "../interfaces/ITransferValidator.sol";
import {ERC721TransferValidator} from "../lib/ERC721TransferValidator.sol";

import {ICrossVM} from "../interfaces/ICrossVM.sol";
import {BridgePermissionsUpgradeable} from "../lib/BridgePermissionsUpgradeable.sol";
import {CrossVMBridgeERC721FulfillmentUpgradeable} from "../lib/CrossVMBridgeERC721FulfillmentUpgradeable.sol";

/**
 * @title ERC-721 TestNFTContract
 * @notice A NFT contract for testing
 * @dev This contract implements the following core features:
 * - ERC721 standard functionality with ownership, enumeration, and burning capabilities
 * - Upgradability via proxy and initializer pattern
 * - Wrapper functionality to handle NFTs from bridge-deployed contract
 * - Fulfillment functionality for Flow -> EVM bridging, once bridge onboarding allowed
 * - Cross-VM compatibility for Flow <-> EVM bridging
 * - Royalty management for secondary sales
 */
contract TestNFTContract is
    Initializable,
    ERC721Upgradeable,
    ERC721BurnableUpgradeable,
    ERC721EnumerableUpgradeable,
    OwnableUpgradeable,
    ERC721WrapperUpgradeable,
    ERC721TransferValidator,
    CrossVMBridgeERC721FulfillmentUpgradeable,
    BridgePermissionsUpgradeable,
    ICrossVM,
    IERC2981,
    IERC4906
{
    // Cadence-specific identifiers for cross-chain bridging
    string public cadenceNFTAddress;
    string public cadenceNFTIdentifier;

    // Metadata-related fields
    string public contractMetadata;
    string private _customSymbol;
    string private _baseTokenURI;

    // Royalty configuration for secondary sales
    RoyaltyInfo private _royaltyInfo;

    // Error declarations
    error InvalidRoyaltyBasisPoints(uint256 basisPoints);
    error RoyaltyAddressCannotBeZeroAddress();
    error InvalidUnderlyingTokenAddress();

    // Event declarations
    event RoyaltyInfoUpdated(address receiver, uint256 bps);
    event ContractURIUpdated();

    /**
     * @notice Stores royalty configuration for secondary sales
     * @dev royaltyBps is in basis points (1/100th of a percent)
     * e.g., 500 = 5%, max value is 10000 = 100%
     */
    struct RoyaltyInfo {
        address royaltyAddress;
        uint96 royaltyBps;
    }

    /**
     * @dev Initializes the contract.
     */
    function initialize(
        address owner,
        address underlyingNftContractAddress,
        address vmBridgeAddress,
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_,
        string memory _cadenceNFTAddress,
        string memory _cadenceNFTIdentifier,
        string memory _contractMetadata
    ) public initializer {
        if (underlyingNftContractAddress == address(0)) {
            revert InvalidUnderlyingTokenAddress();
        }
        __ERC721_init(name_, symbol_);
        __Ownable_init(owner);
        __ERC721Wrapper_init(IERC721(underlyingNftContractAddress));
        __CrossVMBridgeERC721Fulfillment_init(vmBridgeAddress);
        __BridgePermissions_init();
        _customSymbol = symbol_;
        _baseTokenURI = baseTokenURI_;
        cadenceNFTAddress = _cadenceNFTAddress;
        cadenceNFTIdentifier = _cadenceNFTIdentifier;
        contractMetadata = _contractMetadata;
    }

    function getCadenceAddress() external view returns (string memory) {
        return cadenceNFTAddress;
    }

    function getCadenceIdentifier() external view returns (string memory) {
        return cadenceNFTIdentifier;
    }

    function symbol() public view override returns (string memory) {
        return _customSymbol;
    }

    function contractURI() public view returns (string memory) {
        return contractMetadata;
    }

    function setSymbol(string memory newSymbol) public onlyOwner {
        _setSymbol(newSymbol);
    }

    /**
     * @notice Sets the contract URI, whether an offchain metadata URL or a JSON object
     * (i.e. `data:application/json;utf8,{"name":"...","description":"..."}`).
     */
    function setContractURI(string memory newMetadata) external onlyOwner {
        contractMetadata = newMetadata;

        // Indicate that the metadata has been updated (https://docs.opensea.io/docs/contract-level-metadata)
        emit ContractURIUpdated();
    }

    function setBaseTokenURI(string memory newBaseTokenURI) public onlyOwner {
        _baseTokenURI = newBaseTokenURI;

        // Indicate that the metadata has been updated (https://docs.opensea.io/docs/metadata-standards#metadata-updates)
        emit MetadataUpdate(type(uint256).max);
    }

    /**
     * @notice Returns the token URI for a given token ID.
     */
    function tokenURI(uint256 tokenId) public view override(ERC721Upgradeable) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, BridgePermissionsUpgradeable, CrossVMBridgeERC721FulfillmentUpgradeable, IERC165)
        returns (bool)
    {
        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721Metadata).interfaceId
            || interfaceId == type(IERC721Enumerable).interfaceId || interfaceId == type(ERC721BurnableUpgradeable).interfaceId
            || interfaceId == type(OwnableUpgradeable).interfaceId || interfaceId == type(ICrossVM).interfaceId
            || interfaceId == type(ICreatorToken).interfaceId || interfaceId == type(ILegacyCreatorToken).interfaceId
            || interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }

    function _setSymbol(string memory newSymbol) internal {
        _customSymbol = newSymbol;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
        returns (address)
    {
        // Add the beforeTokenTransfer hook
        _beforeTokenTransfer(_ownerOf(tokenId), to, tokenId);

        // Call parent implementation
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {
        super._increaseBalance(account, value);
    }

    function setBridgePermissions(bool permissions) external onlyOwner {
        _setPermissions(permissions);
    }

    function setRoyaltyInfo(RoyaltyInfo calldata newInfo) external onlyOwner {
        // Revert if the new royalty address is the zero address.
        if (newInfo.royaltyAddress == address(0)) {
            revert RoyaltyAddressCannotBeZeroAddress();
        }

        // Revert if the new basis points is greater than 10_000.
        if (newInfo.royaltyBps > 10_000) {
            revert InvalidRoyaltyBasisPoints(newInfo.royaltyBps);
        }

        // Set the new royalty info.
        _royaltyInfo = newInfo;

        // Emit an event with the updated params.
        emit RoyaltyInfoUpdated(newInfo.royaltyAddress, newInfo.royaltyBps);
    }

    function royaltyAddress() external view returns (address) {
        return _royaltyInfo.royaltyAddress;
    }

    function royaltyBasisPoints() external view returns (uint256) {
        return _royaltyInfo.royaltyBps;
    }

    /**
     * @dev Implements the IERC2981 interface.
     */
    function royaltyInfo(
        uint256 /* _tokenId */,
        uint256 _salePrice
    ) external view returns (address receiver, uint256 royaltyAmount) {
        // Put the royalty info on the stack for more efficient access.
        RoyaltyInfo storage info = _royaltyInfo;

        // Set the royalty amount to the sale price times the royalty basis
        // points divided by 10_000.
        royaltyAmount = (_salePrice * info.royaltyBps) / 10_000;

        // Set the receiver of the royalty.
        receiver = info.royaltyAddress;
    }

    function getTransferValidationFunction()
        external
        pure
        returns (bytes4 functionSignature, bool isViewFunction)
    {
        functionSignature = ITransferValidator721.validateTransfer.selector;
        isViewFunction = false;
    }

    function setTransferValidator(address newValidator) external onlyOwner {
        _setTransferValidator(newValidator);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 startTokenId
    ) internal virtual {
        if (from != address(0) && to != address(0)) {
            // Call the transfer validator if one is set.
            address transferValidator = _transferValidator;
            if (transferValidator != address(0)) {
                ITransferValidator721(transferValidator).validateTransfer(
                    msg.sender,
                    from,
                    to,
                    startTokenId
                );
            }
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/utils/wrap_nfts.cdc

```
import "EVM"

/// Wraps NFTs with provided IDs
///
/// @param wrapperERC721Address: EVM address of the wrapper ERC721 NFT
/// @param nftIDs: Array of IDs of the NFTs to wrap
///
transaction(
    wrapperERC721Address: String,
    nftIDs: [UInt256]
) {
    // Cadence-owned account
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue) &Account) {
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("No COA found in signer's account")
    }

    execute {
        // Get contract addresses
        let wrapperAddress = EVM.addressFromString(wrapperERC721Address)
        let underlyingAddress = getUnderlyingERC721Address(self.coa, wrapperAddress)

        // Approve contract to withdraw underlying NFTs from signer's coa
        mustCall(self.coa, underlyingAddress,
            functionSig: "setApprovalForAll(address,bool)",
            args: [wrapperAddress, true]
        )

        // Wrap NFTs with provided IDs
        mustCall(self.coa, wrapperAddress,
            functionSig: "depositFor(address,uint256[])",
            args: [self.coa.address(), nftIDs]
        )

        // Revoke approval for contract to withdraw underlying NFTs from signer's coa
        mustCall(self.coa, underlyingAddress,
            functionSig: "setApprovalForAll(address,bool)",
            args: [wrapperAddress, false]
        )
    }
}

/// Gets the underlying ERC721 address
///
access(all) fun getUnderlyingERC721Address(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ wrapperAddress: EVM.EVMAddress
): EVM.EVMAddress {
    let res = coa.call(
        to: wrapperAddress,
        data: EVM.encodeABIWithSignature("underlying()", []),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful, message: "Call to get underlying ERC721 address failed")
    let decodedResult = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data)
    assert(decodedResult.length == 1, message: "Invalid response length")

    return decodedResult[0] as! EVM.EVMAddress
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/scripts/get_evm_address_string.cdc

```
import "EVM"

/// Returns the hex encoded address of the COA in the given Flow address
///
access(all) fun main(flowAddress: Address): String? {
    return getAuthAccount<auth(BorrowValue) &Account>(flowAddress)
        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)
        ?.address()
        ?.toString()
        ?? nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_setSeries.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the series of the specified set and returns it

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read

// Returns: UInt32
// unique ID of series

access(all) fun main(setID: UInt32): UInt32 {

    let series = TopShot.getSetSeries(setID: setID)
        ?? panic("Could not find the specified set")

    return series
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/create_subedition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction creates a new subedition struct
// and stores it in the Top Shot smart contract

// Parameters:
//
// name:  the name of a new Subedition to be created
// metadata: A dictionary of all the play metadata associated

transaction(name:String, metadata:{String:String}) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin
    let currSubeditionID: UInt32

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the admin resource
        self.currSubeditionID = TopShot.getNextSubeditionID();
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {

        // Create a subedition with the specified metadata
        self.adminRef.createSubedition(name: name, metadata: metadata)
    }

    post {

        TopShot.getSubeditionByID(subeditionID: self.currSubeditionID) != nil:
            "SubedititonID doesnt exist"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_setplays_are_owned.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script checks whether for each SetID/PlayID combo, 
// they own a moment matching that SetPlay.

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// setIDs: A list of unique IDs for the sets whose data needs to be read
// playIDs: A list of unique IDs for the plays whose data needs to be read

// Returns: Bool
// Whether for each SetID/PlayID combo, 
// account owns a moment matching that SetPlay.

access(all) fun main(account: Address, setIDs: [UInt32], playIDs: [UInt32]): Bool {

    assert(
        setIDs.length == playIDs.length,
        message: "set and play ID arrays have mismatched lengths"
    )

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
                ?? panic("Could not get public moment collection reference")

    let momentIDs = collectionRef.getIDs()

    // For each SetID/PlayID combo, loop over each moment in the account
    // to see if they own a moment matching that SetPlay.
    var i = 0

    while i < setIDs.length {
        var hasMatchingMoment = false
        for momentID in momentIDs {
            let token = collectionRef.borrowMoment(id: momentID)
                ?? panic("Could not borrow a reference to the specified moment")

            let momentData = token.data
            if momentData.setID == setIDs[i] && momentData.playID == playIDs[i] {
                hasMatchingMoment = true
                break
            }
        }
        if !hasMatchingMoment {
            return false
        }
        i = i + 1
    }
    
    return true
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/test-contracts/TestContract.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

contract TestContract {
    function testArrayEncoding(uint256[] calldata values) external pure
    returns (uint256[] memory)
    {
        return values;
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/ITransferValidator.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

interface ITransferValidator721 {
    /// @notice Ensure that a transfer has been authorized for a specific tokenId
    function validateTransfer(
        address caller,
        address from,
        address to,
        uint256 tokenId
    ) external view;
}

interface ITransferValidator1155 {
    /// @notice Ensure that a transfer has been authorized for a specific amount of a specific tokenId, and reduce the transferable amount remaining
    function validateTransfer(
        address caller,
        address from,
        address to,
        uint256 tokenId,
        uint256 amount
    ) external;
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/ICrossVMBridgeERC721Fulfillment.sol

```
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

/**
 * @title ICrossVMBridgeERC721Fulfillment
 * @dev Related to https://github.com/onflow/flips/issues/318[FLIP-318] Cross VM NFT implementations
 * on Flow in the context of Cadence-native NFTs. The following interface must be implemented to
 * integrate with the Flow VM bridge connecting Cadence & EVM implementations so that the canonical
 * VM bridge may move the Cadence NFT into EVM in a mint/escrow pattern.
 */
interface ICrossVMBridgeERC721Fulfillment is IERC165 {

    // Encountered when attempting to fulfill a token that has been previously minted and is not
    // escrowed in EVM under the VM bridge
    error FulfillmentFailedTokenNotEscrowed(uint256 id, address escrowAddress);

    // Emitted when an NFT is moved from Cadence into EVM
    event FulfilledToEVM(address indexed recipient, uint256 indexed tokenId);

    /**
     * @dev Returns whether the token is currently escrowed under custody of the designated VM bridge
     * 
     * @param _id the ID of the token in question
     */
    function isEscrowed(uint256 _id) external view returns (bool);

    function exists(uint256 _id) external view returns (bool);

    /**
     * @dev Fulfills the bridge request, minting (if non-existent) or transferring (if escrowed) the
     * token with the given ID to the provided address. For dynamic metadata handling between
     * Cadence & EVM, implementations should override and assign metadata as encoded from Cadence
     * side. If overriding, be sure to preserve the mint/escrow pattern as shown in the default
     * implementation. See `_beforeFulfillment` and `_afterFulfillment` hooks to enable pre-and/or
     * post-processing without the need to override this function.
     * 
     * @param _to address of the token recipient
     * @param _id the id of the token being moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function fulfillToEVM(address _to, uint256 _id, bytes memory _data) external;
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_token_count.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(): UInt64 {

    return FastBreakV1.totalSupply
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/transfer_moment.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS

// This transaction transfers a moment to a recipient

// This transaction is how a topshot user would transfer a moment
// from their account to another account
// The recipient must have a TopShot Collection object stored
// and a public MomentCollectionPublic capability stored at
// `/public/MomentCollection`

// Parameters:
//
// recipient: The Flow address of the account to receive the moment.
// withdrawID: The id of the moment to be transferred

transaction(recipient: Address, withdrawID: UInt64) {

    // local variable for storing the transferred token
    let transferToken: @{NonFungibleToken.NFT}
    
    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the owner's collection
        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow a reference to the stored Moment collection")
        
        // withdraw the NFT
        self.transferToken <- collectionRef.withdraw(withdrawID: withdrawID)
    }

    execute {
        
        // get the recipient's public account object
        let recipient = getAccount(recipient)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

        // deposit the NFT in the receivers collection
        receiverRef.deposit(token: <-self.transferToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/change_receiver.cdc

```
import TopShotMarketV3 from 0xMARKETV3ADDRESS

transaction(receiverPath: PublicPath) {
    prepare(acct: auth(BorrowValue) &Account) {

        let topshotSaleCollection = acct.storage.borrow<auth(TopShotMarketV3.Update) &TopShotMarketV3.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")

        topshotSaleCollection.changeOwnerReceiver(acct.capabilities.get<&{FungibleToken.Receiver}>(receiverPath)!)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/subeditions/get_nextSubeditionID.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the nextSubeditionID from the SubeditionAdmin resource and
// returns that number to the caller

// Returns: UInt32
// the next number in nextSubeditionID from the SubeditionAdmin resource

access(all) fun main(): UInt32 {

    return TopShot.getNextSubeditionID()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/CODE_OF_CONDUCT.md

# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at os@dapperlabs.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/admin/deploy/create_coa.cdc

```
import "Burner"
import "FungibleToken"
import "FlowToken"
import "EVM"

/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM
///
transaction(amount: UFix64) {
    let fundingVault: @FlowToken.Vault?
    let coa: &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability) &Account) {
        /* --- Configure COA --- */
        //
        // Ensure there is not yet a CadenceOwnedAccount in the standard path
        let coaPath = /storage/evm
        if signer.storage.type(at: coaPath) != nil {
            panic(
                "Object already exists in signer's account at path=".concat(coaPath.toString())
                .concat(". Make sure the signing account does not already have a CadenceOwnedAccount.")
            )
        }
        // COA not found in standard path, create and publish a public **unentitled** capability
        signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: coaPath)
        let coaCapability = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(coaPath)
        signer.capabilities.publish(coaCapability, at: /public/evm)

        // Borrow the CadenceOwnedAccount reference
        self.coa = signer.storage.borrow<&EVM.CadenceOwnedAccount>(
                from: coaPath
            ) ?? panic(
                "Could not find CadenceOwnedAccount (COA) in signer's account at path=".concat(coaPath.toString())
                .concat(". Make sure the signing account has initialized a COA at the expected path.")
            )

        /* --- Assign fundingVault --- */
        //
        if amount > 0.0 {
            // Reference the signer's FLOW vault & withdraw the funding amount
            let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
                ?? panic("Could not borrow a reference to the signer's FLOW vault from path=/storage/flowTokenVault")
            self.fundingVault <- vault.withdraw(amount: amount) as! @FlowToken.Vault
        } else {
            // No funding requested, so no need to withdraw from the vault
            self.fundingVault <- nil
        }
    }

    pre {
        self.fundingVault == nil || self.fundingVault?.balance ?? 0.0 == amount:
            "Mismatched funding vault acquired given requested amount=".concat(amount.toString())
    }

    execute {
        // Fund if necessary
        if self.fundingVault != nil || self.fundingVault?.balance ?? 0.0 > 0.0 {
            self.coa.deposit(from: <-self.fundingVault!)
        } else {
            Burner.burn(<-self.fundingVault)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/oracle/create_game.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(
    id: String,
    name: String,
    fastBreakRunID: String,
    submissionDeadline: UInt64,
    numPlayers: UInt64
) {

    let oracleRef: auth(FastBreakV1.Create) &FastBreakV1.FastBreakDaemon

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.oracleRef = acct.storage.borrow<auth(FastBreakV1.Create) &FastBreakV1.FastBreakDaemon>(from: FastBreakV1.OracleStoragePath)
            ?? panic("Could not borrow a reference to the oracle resource")
    }

    execute {

        self.oracleRef.createFastBreakGame(
            id: id,
            name: name,
            fastBreakRunID: fastBreakRunID,
            submissionDeadline: submissionDeadline,
            numPlayers: numPlayers
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/start_sale.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction is for a user to put a new moment up for sale
// They must have TopShot Collection and a TopShotMarketV2 Sale Collection already
// stored in their account

// Parameters
//
// momentId: the ID of the moment to be listed for sale
// price: the sell price of the moment

transaction(momentID: UInt64, price: UFix64) {
    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the topshot Sale Collection
        let topshotSaleCollection = acct.storage.borrow<auth(TopShotMarketV3.Create) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath)
            ?? panic("Could not borrow from sale in storage")

        // List the specified moment for sale
        topshotSaleCollection.listForSale(tokenID: momentID, price: price)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/setup_sharded_locker_room.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS
import NonFungibleToken from 0xNFTADDRESS

/*
    This transaction creates a capability on the minter account
    that links it to the locker room account.

    For example, on testnet:
    minter account = 0x70dff4d1005824db
    locker account = 0xd80d84b4b0a88782
*/


transaction() {

    prepare(minter: auth(Storage, Capabilities) &Account, locker: auth(Storage, Capabilities) &Account) {

        minter.storage.save(
            locker.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &TopShotShardedCollection.ShardedCollection>(/storage/TopShotShardedCollection),
            to: /storage/lockerTSShardedCollection2
        )

        minter.storage.save(
            locker.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(/storage/MomentCollection),
            to: /storage/lockerTSCollection2
        )        
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/setup_up_all_collections.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS
import PackNFT from 0xPACKNFTADDRESS

// This transaction sets up an account to use Top Shot
// by storing an empty moment collection and creating
// a public capability for it

transaction {

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // First, check to see if a moment collection already exists
        if acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {
            // create a new TopShot Collection
            let collection <- TopShot.createEmptyCollection() as! @TopShot.Collection
            // Put the new Collection in storage
            acct.storage.save(<-collection, to: /storage/MomentCollection)
        }

        acct.capabilities.unpublish(/public/MomentCollection)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&TopShot.Collection>(/storage/MomentCollection),
            at: /public/MomentCollection
        )

        // Create a PackNFT collection in the signer account if it doesn't already have one
        if acct.storage.borrow<&PackNFT.Collection>(from: PackNFT.CollectionStoragePath) == nil {
            acct.storage.save(<- PackNFT.createEmptyCollection(), to: PackNFT.CollectionStoragePath);
        }

        // Create collection public capability if it doesn't already exist
        acct.capabilities.unpublish(PackNFT.CollectionPublicPath)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&PackNFT.Collection>(PackNFT.CollectionStoragePath),
            at: PackNFT.CollectionPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/oracle/add_stat_to_game.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(fastBreakGameID: String, name: String, rawType: UInt8, valueNeeded: UInt64) {

    let oracleRef: auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.oracleRef = acct.storage.borrow<auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon>(from: FastBreakV1.OracleStoragePath)
            ?? panic("Could not borrow a reference to the oracle resource")
    }

    execute {

        self.oracleRef.addStatToFastBreakGame(
            fastBreakGameID: fastBreakGameID,
            name: name,
            rawType: rawType,
            valueNeeded: valueNeeded
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/plays/get_all_plays.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns an array of all the plays 
// that have ever been created for Top Shot

// Returns: [TopShot.Play]
// array of all plays created for Topshot

access(all) fun main(): [TopShot.Play] {

    return TopShot.getAllPlays()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/SECURITY.md


# Responsible Disclosure Policy

Flow was built from the ground up with security in mind. Our code, infrastructure, and development methodology helps us keep our users safe.

We really appreciate the community's help. Responsible disclosure of vulnerabilities helps to maintain the security and privacy of everyone.

If you care about making a difference, please follow the guidelines below.

# **Guidelines For Responsible Disclosure**

We ask that all researchers adhere to these guidelines.

## **Rules of Engagement**

- Make every effort to avoid unauthorized access, use, and disclosure of personal information.
- Avoid actions which could impact user experience, disrupt production systems, change, or destroy data during security testing.
- Don’t perform any attack that is intended to cause Denial of Service to the network, hosts, or services on any port or using any protocol.
- Use our provided communication channels to securely report vulnerability information to us.
- Keep information about any bug or vulnerability you discover confidential between us until we publicly disclose it.
- Please don’t use scanners to crawl us and hammer endpoints. They’re noisy and we already do this. If you find anything this way, we have likely already identified it.
- Never attempt non-technical attacks such as social engineering, phishing, or physical attacks against our employees, users, or infrastructure.

## **In Scope URIs**

Be careful that you're looking at domains and systems that belong to us and not someone else. When in doubt, please ask us. Maybe ask us anyway.

Bottom line, we suggest that you limit your testing to infrastructure that is clearly ours.

## **Out of Scope URIs**

The following base URIs are explicitly out of scope:

- None

## **Things Not To Do**

In the interests of your safety, our safety, and for our customers, the following test types are prohibited:

- Physical testing such as office and data-centre access (e.g. open doors, tailgating, card reader attacks, physically destructive testing)
- Social engineering (e.g. phishing, vishing)
- Testing of applications or systems NOT covered by the ‘In Scope’ section, or that are explicitly out of scope.
- Network level Denial of Service (DoS/DDoS) attacks

## **Sensitive Data**

In the interests of protecting privacy, we never want to receive:

- Personally identifiable information (PII)
- Payment card (e.g. credit card) data
- Financial information (e.g. bank records)
- Health or medical information
- Accessed or cracked credentials in cleartext

## **Our Commitment To You**

If you follow these guidelines when researching and reporting an issue to us, we commit to:

- Not send lawyers after you related to your research under this policy;
- Work with you to understand and resolve any issues within a reasonable timeframe, including an initial confirmation of your report within 72 hours of submission; and
- At a minimum, we will recognize your contribution in our Disclosure Acknowledgements if you are the first to report the issue and we make a code or configuration change based on the issue.

## **Disclosure Acknowledgements**

We're happy to acknowledge contributors. Security acknowledgements can be found here.

## Rewards

We run closed bug bounty programs, but beyond that we also pay out rewards, once per eligible bug, to the first responsibly disclosing third party.  Rewards are based on the seriousness of the bug, but the minimum is $100 and we have and are willing to pay $5,000 or more at our sole discretion.

### **Elligibility**

To qualify, the bug must fall within our scope and rules and meet the following criteria:

1. **Previously unknown** - When reported, we must not have already known of the issue, either by internal discovery or separate disclosure.
2. **Material impact** - Demonstrable exploitability where, if exploited, the bug would materially affect the confidentiality, integrity, or availability of our services.
3. **Requires action** - The bug requires some mitigation.  It is both valid and actionable.

## **Reporting Security Findings To Us**

Reports are welcome! Please definitely reach out to us if you have a security concern.

We prefer you to please send us an email: security@onflow.org

Note: If you believe you may have found a security vulnerability in our open source repos, to be on the safe side, do NOT open a public issue.

We encourage you to encrypt the information you send us using our PGP key at [keys.openpgp.org/security@onflow.org](https://keys.openpgp.org/vks/v1/by-fingerprint/AE3264F330AB51F7DBC52C400BB5D3D7516D168C)

Please include the following details with your report:

- A description of the location and potential impact of the finding(s);
- A detailed description of the steps required to reproduce the issue; and
- Any POC scripts, screenshots, and compressed screen captures, where feasible.





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotMarketV2.cdc

```
/*

    TopShotMarketV2.cdc

    Description: Contract definitions for users to sell their moments

    Marketplace is where users can create a sale collection that they
    store in their account storage. In the sale collection, 
    they can put their NFTs up for sale with a price and publish a 
    reference so that others can see the sale.

    If another user sees an NFT that they want to buy,
    they can send fungible tokens that equal or exceed the buy price
    to buy the NFT.  The NFT is transferred to them when
    they make the purchase.

    Each user who wants to sell tokens will have a sale collection 
    instance in their account that contains price information 
    for each node in their collection. The sale holds a capability that 
    links to their main moment collection.

    They can give a reference to this collection to a central contract
    so that it can list the sales in a central place

    When a user creates a sale, they will supply four arguments:
    - A TopShot.Collection capability that allows their sale to withdraw
      a moment when it is purchased.
    - A FungibleToken.Receiver capability as the place where the payment for the token goes.
    - A FungibleToken.Receiver capability specifying a beneficiary, where a cut of the purchase gets sent. 
    - A cut percentage, specifying how much the beneficiary will recieve.
    
    The cut percentage can be set to zero if the user desires and they 
    will receive the entirety of the purchase. TopShot will initialize sales 
    for users with the TopShot admin vault as the vault where cuts get 
    deposited to.
*/

import FungibleToken from 0xFUNGIBLETOKENADDRESS
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS

pub contract TopShotMarketV2 {

    // -----------------------------------------------------------------------
    // TopShot Market contract Event definitions
    // -----------------------------------------------------------------------

    // emitted when a TopShot moment is listed for sale
    pub event MomentListed(id: UInt64, price: UFix64, seller: Address?)
    // emitted when the price of a listed moment has changed
    pub event MomentPriceChanged(id: UInt64, newPrice: UFix64, seller: Address?)
    // emitted when a token is purchased from the market
    pub event MomentPurchased(id: UInt64, price: UFix64, seller: Address?)
    // emitted when a moment has been withdrawn from the sale
    pub event MomentWithdrawn(id: UInt64, owner: Address?)
    // emitted when the cut percentage of the sale has been changed by the owner
    pub event CutPercentageChanged(newPercent: UFix64, seller: Address?)

    pub let marketStoragePath: StoragePath

    pub let marketPublicPath: PublicPath

    // SalePublic 
    //
    // The interface that a user can publish a capability to their sale
    // to allow others to access their sale
    pub resource interface SalePublic {
        pub var cutPercentage: UFix64
        pub fun purchase(tokenID: UInt64, buyTokens: @FungibleToken.Vault): @TopShot.NFT {
            post {
                result.id == tokenID: "The ID of the withdrawn token must be the same as the requested ID"
            }
        }
        pub fun getPrice(tokenID: UInt64): UFix64?
        pub fun getIDs(): [UInt64]
        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id): 
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // SaleCollection
    //
    // This is the main resource that token sellers will store in their account
    // to manage the NFTs that they are selling. The SaleCollection
    // holds a TopShot Collection resource to store the moments that are for sale.
    // The SaleCollection also keeps track of the price of each token.
    // 
    // When a token is purchased, a cut is taken from the tokens
    // and sent to the beneficiary, then the rest are sent to the seller.
    //
    // The seller chooses who the beneficiary is and what percentage
    // of the tokens gets taken from the purchase
    pub resource SaleCollection: SalePublic {

        // A collection of the moments that the user has for sale
        access(self) var ownerCollection: Capability<&TopShot.Collection>

        // Dictionary of the low low prices for each NFT by ID
        access(self) var prices: {UInt64: UFix64}

        // The fungible token vault of the seller
        // so that when someone buys a token, the tokens are deposited
        // to this Vault
        access(self) var ownerCapability: Capability<&{FungibleToken.Receiver}>

        // The capability that is used for depositing 
        // the beneficiary's cut of every sale
        access(self) var beneficiaryCapability: Capability<&{FungibleToken.Receiver}>

        // The percentage that is taken from every purchase for the beneficiary
        // For example, if the percentage is 15%, cutPercentage = 0.15
        pub var cutPercentage: UFix64

        init (ownerCollection: Capability<&TopShot.Collection>, ownerCapability: Capability<&{FungibleToken.Receiver}>, beneficiaryCapability: Capability<&{FungibleToken.Receiver}>, cutPercentage: UFix64) {
            pre {
                // Check that the owner's moment collection capability is correct
                ownerCollection.borrow() != nil: 
                    "Owner's Moment Collection Capability is invalid!"

                // Check that both capabilities are for fungible token Vault receivers
                ownerCapability.borrow() != nil: 
                    "Owner's Receiver Capability is invalid!"
                beneficiaryCapability.borrow() != nil: 
                    "Beneficiary's Receiver Capability is invalid!" 
            }
            
            // create an empty collection to store the moments that are for sale
            self.ownerCollection = ownerCollection
            self.ownerCapability = ownerCapability
            self.beneficiaryCapability = beneficiaryCapability
            // prices are initially empty because there are no moments for sale
            self.prices = {}
            self.cutPercentage = cutPercentage
        }

        // listForSale lists an NFT for sale in this sale collection
        // at the specified price
        //
        // Parameters: tokenID: The id of the NFT to be put up for sale
        //             price: The price of the NFT
        pub fun listForSale(tokenID: UInt64, price: UFix64) {
            pre {
                self.ownerCollection.borrow()!.borrowMoment(id: tokenID) != nil:
                    "Moment does not exist in the owner's collection"
            }

            // Set the token's price
            self.prices[tokenID] = price

            emit MomentListed(id: tokenID, price: price, seller: self.owner?.address)
        }

        // cancelSale cancels a moment sale and clears its price
        //
        // Parameters: tokenID: the ID of the token to withdraw from the sale
        //
        pub fun cancelSale(tokenID: UInt64) {
            pre {
                self.prices[tokenID] != nil: "Token with the specified ID is not already for sale"
            }

            // Remove the price from the prices dictionary
            self.prices.remove(key: tokenID)

            // Set prices to nil for the withdrawn ID
            self.prices[tokenID] = nil
            
            // Emit the event for withdrawing a moment from the Sale
            emit MomentWithdrawn(id: tokenID, owner: self.owner?.address)
        }

        // purchase lets a user send tokens to purchase an NFT that is for sale
        // the purchased NFT is returned to the transaction context that called it
        //
        // Parameters: tokenID: the ID of the NFT to purchase
        //             buyTokens: the fungible tokens that are used to buy the NFT
        //
        // Returns: @TopShot.NFT: the purchased NFT
        pub fun purchase(tokenID: UInt64, buyTokens: @FungibleToken.Vault): @TopShot.NFT {
            pre {
                self.ownerCollection.borrow()!.borrowMoment(id: tokenID) != nil && self.prices[tokenID] != nil:
                    "No token matching this ID for sale!"           
                buyTokens.balance == (self.prices[tokenID] ?? UFix64(0)):
                    "Not enough tokens to buy the NFT!"
            }

            // Read the price for the token
            let price = self.prices[tokenID]!

            // Set the price for the token to nil
            self.prices[tokenID] = nil

            // Take the cut of the tokens that the beneficiary gets from the sent tokens
            let beneficiaryCut <- buyTokens.withdraw(amount: price*self.cutPercentage)

            // Deposit it into the beneficiary's Vault
            self.beneficiaryCapability.borrow()!
                .deposit(from: <-beneficiaryCut)
            
            // Deposit the remaining tokens into the owners vault
            self.ownerCapability.borrow()!
                .deposit(from: <-buyTokens)

            emit MomentPurchased(id: tokenID, price: price, seller: self.owner?.address)

            // Return the purchased token
            let boughtMoment <- self.ownerCollection.borrow()!.withdraw(withdrawID: tokenID) as! @TopShot.NFT

            return <-boughtMoment
        }

        // changePercentage changes the cut percentage of the tokens that are for sale
        //
        // Parameters: newPercent: The new cut percentage for the sale
        pub fun changePercentage(_ newPercent: UFix64) {
            pre {
                newPercent <= 1.0: "Cannot set cut percentage to greater than 100%"
            }
            self.cutPercentage = newPercent

            emit CutPercentageChanged(newPercent: newPercent, seller: self.owner?.address)
        }

        // changeOwnerReceiver updates the capability for the sellers fungible token Vault
        //
        // Parameters: newOwnerCapability: The new fungible token capability for the account 
        //                                 who received tokens for purchases
        pub fun changeOwnerReceiver(_ newOwnerCapability: Capability<&{FungibleToken.Receiver}>) {
            pre {
                newOwnerCapability.borrow() != nil: 
                    "Owner's Receiver Capability is invalid!"
            }
            self.ownerCapability = newOwnerCapability
        }

        // changeBeneficiaryReceiver updates the capability for the beneficiary of the cut of the sale
        //
        // Parameters: newBeneficiaryCapability the new capability for the beneficiary of the cut of the sale
        //
        pub fun changeBeneficiaryReceiver(_ newBeneficiaryCapability: Capability<&{FungibleToken.Receiver}>) {
            pre {
                newBeneficiaryCapability.borrow() != nil: 
                    "Beneficiary's Receiver Capability is invalid!" 
            }
            self.beneficiaryCapability = newBeneficiaryCapability
        }

        // getPrice returns the price of a specific token in the sale
        // 
        // Parameters: tokenID: The ID of the NFT whose price to get
        //
        // Returns: UFix64: The price of the token
        pub fun getPrice(tokenID: UInt64): UFix64? {
            return self.prices[tokenID]
        }

        // getIDs returns an array of token IDs that are for sale
        pub fun getIDs(): [UInt64] {
            return self.prices.keys
        }

        // borrowMoment Returns a borrowed reference to a Moment for sale
        // so that the caller can read data from it
        //
        // Parameters: id: The ID of the moment to borrow a reference to
        //
        // Returns: &TopShot.NFT? Optional reference to a moment for sale 
        //                        so that the caller can read its data
        //
        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {
            if self.prices[id] != nil {
                let ref = self.ownerCollection.borrow()!.borrowMoment(id: id)
                return ref
            } else {
                return nil
            }
        }
    }

    // createCollection returns a new collection resource to the caller
    pub fun createSaleCollection(ownerCollection: Capability<&TopShot.Collection>, ownerCapability: Capability<&{FungibleToken.Receiver}>, beneficiaryCapability: Capability<&{FungibleToken.Receiver}>, cutPercentage: UFix64): @SaleCollection {
        return <- create SaleCollection(ownerCollection: ownerCollection, ownerCapability: ownerCapability, beneficiaryCapability: beneficiaryCapability, cutPercentage: cutPercentage)
    }

    init() {
        self.marketStoragePath = /storage/topshotSalev2Collection
        self.marketPublicPath = /public/topshotSalev2Collection
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/CONTRIBUTING.md

# Contributing to the NBA Topshot smart contracts

The following is a set of guidelines for contributing to the NBA Topshot smart contracts. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request.

#### Table Of Contents

[How Can I Contribute?](#how-can-i-contribute)

- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Pull Requests](#pull-requests)

[Styleguides](#styleguides)

- [Git Commit Messages](#git-commit-messages)

[Additional Notes](#additional-notes)


## How Can I Contribute?

You are free to contribute however you want! You can submit a bug report in an issue, suggest an enhancment, or even just make a PR for us to review. We just ask that you are clear in your communication and documentation of all your work so we can understand how you are trying to help.

### Reporting Bugs

#### Before Submitting A Bug Report

- **Search existing issues** to see if the problem has already been reported. If it has **and the issue is still open**, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Bug Report?

Explain the problem and include additional details to help maintainers reproduce the problem:

- **Use a clear and descriptive title** for the issue to identify the problem.
- **Describe the exact steps which reproduce the problem** in as many details as possible. When listing steps, **don't just say what you did, but explain how you did it**.
- **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
- **Explain which behavior you expected to see instead and why.**
- **Include screenshots and animated GIFs** which show you following the described steps and clearly demonstrate the problem. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.

Provide more context by answering these questions:

- **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

- **What's the name and version of the OS you're using**?
- **What's the name and version of the flow-cli that you are using**?

### Suggesting Enhancements

#### Before Submitting An Enhancement Suggestion

- **Perform a cursory search** to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue and provide the following information:

- **Use a clear and descriptive title** for the issue to identify the suggestion.
- **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
- **Provide specific examples to demonstrate the steps**. Include copy/pasteable snippets which you use in those examples, as [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
- **Include screenshots and animated GIFs**. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux.
- **Explain why this enhancement would be useful** to be included in the standard.

### Pull Requests

The process described here has several goals:

- Maintain code quality
- Fix problems that are important to users

Please follow the [styleguides](#styleguides) to have your contribution considered by the maintainers.
Reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

Before contributing, make sure to examine the project to get familiar with the patterns and style already being used.

### Git Commit Messages

- Use the present tense ("Add feature" not "Added feature")
- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
- Limit the first line to 72 characters or less
- Reference issues and pull requests liberally after the first line


### Additional Notes

Thank you for your interest in contributing to the Flow Token Standards!




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/destroy_moments_v2.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction destroys a number of moments owned by a user

// Parameters
//
// momentIDs: an array of moment IDs of NFTs to be destroyed

transaction(momentIDs: [UInt64]) {

    let collectionRef: auth(NonFungibleToken.Update) &TopShot.Collection
    
    prepare(acct: auth(BorrowValue) &Account) {
        // delist any of the moments that are listed (this delists for both MarketV1 and Marketv3)
        if let topshotSaleV3Collection = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {
            for id in momentIDs {
                if topshotSaleV3Collection.borrowMoment(id: id) != nil{
                    // cancel the moment from the sale, thereby de-listing it
                    topshotSaleV3Collection.cancelSale(tokenID: id)
                }
            }
        }

        self.collectionRef = acct.storage.borrow<auth(NonFungibleToken.Update) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")
    }

    execute {
        self.collectionRef.destroyMoments(ids: momentIDs)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/scripts/get_sale_price.cdc

```
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

access(all) fun main(sellerAddress: Address, momentID: UInt64): UFix64 {

    let acct = getAccount(sellerAddress)
    let collectionRef = acct.capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    let price = collectionRef.getPrice(tokenID: UInt64(momentID))
        ?? panic("Could not find price")

    return price
    
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/add_play_to_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is how a Top Shot admin adds a created play to a set

// Parameters:
//
// setID: the ID of the set to which a created play is added
// playID: the ID of the play being added

transaction(setID: UInt32, playID: UInt32) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("Could not borrow a reference to the Admin resource")
    }

    execute {
        
        // Borrow a reference to the set to be added to
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Add the specified play ID
        setRef.addPlay(playID: playID)
    }

    post {
        TopShot.getPlaysInSet(setID: setID)!.contains(playID): 
            "set does not contain playID"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_nextSetID.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the next Set ID from the TopShot contract and 
// returns that number to the caller

// Returns: UInt32
// Value of nextSetID field in TopShot contract

access(all) fun main(): UInt32 {

    log(TopShot.nextSetID)

    return TopShot.nextSetID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/ICreatorToken.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

interface ICreatorToken {
    event TransferValidatorUpdated(address oldValidator, address newValidator);

    function getTransferValidator() external view returns (address validator);

    function getTransferValidationFunction()
        external
        view
        returns (bytes4 functionSignature, bool isViewFunction);

    function setTransferValidator(address validator) external;
}

interface ILegacyCreatorToken {
    event TransferValidatorUpdated(address oldValidator, address newValidator);

    function getTransferValidator() external view returns (address validator);

    function setTransferValidator(address validator) external;
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/IBridgePermissions.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

interface IBridgePermissions is IERC165 {
    /**
     * @dev Emitted when the permissions for the contract are updated.
     */
    event PermissionsUpdated(bool newPermissions);

    /**
     * @dev Returns true if the contract allows bridging of its assets.
     */
    function allowsBridging() external view returns (bool);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/set_nft_subedition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction links nft to subedititon

// Parameters:
//
// nftID:  the unique ID of nft
// subeditionID: the unique ID of subedition

transaction(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the admin resource
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {
        // Create a subedition with the specified metadata
        self.adminRef.setMomentsSubedition(nftID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/create_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is for the admin to create a new set resource
// and store it in the top shot smart contract

// Parameters:
//
// setName: the name of a new Set to be created

transaction(setName: String) {
    
    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin
    let currSetID: UInt32

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("Could not borrow a reference to the Admin resource")
        self.currSetID = TopShot.nextSetID;
    }

    execute {
        
        // Create a set with the specified name
        self.adminRef.createSet(name: setName)
    }

    post {
        
        TopShot.getSetName(setID: self.currSetID) == setName:
          "Could not find the specified set"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/admin/deploy/deploy_contract.cdc

```
import "FungibleToken"
import "FlowToken"
import "EVM"

/// Deploys a compiled solidity contract from bytecode to the EVM, with the signer's COA as the deployer
///
transaction(bytecode: String, gasLimit: UInt64) {
    let coa: auth(EVM.Deploy) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Deploy) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow reference to the signer's bridged account")
    }

    execute {
        let result = self.coa.deploy(
            code: bytecode.decodeHex(),
            gasLimit: gasLimit,
            value: EVM.Balance(attoflow: 0)
        )
        assert(result.status == EVM.Status.successful && result.deployedContract != nil,
            message: "EVM deployment failed with error code: ".concat(result.errorCode.toString())
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_set_data.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns all the metadata about the specified set

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read

// Returns: TopShot.QuerySetData

access(all) fun main(setID: UInt32): TopShot.QuerySetData {

    let data = TopShot.getSetData(setID: setID)
        ?? panic("Could not get data for the specified set ID")

    return data
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/scripts/get_sale_len.cdc

```
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

access(all) fun main(sellerAddress: Address): Int {
    let acct = getAccount(sellerAddress)
    let collectionRef = acct.capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getIDs().length
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/ICrossVM.sol

```
pragma solidity 0.8.24;

interface ICrossVM {
    function getCadenceAddress() external view returns (string memory);
    function getCadenceIdentifier() external view returns (string memory);
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/lock_fake_nft.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction attempts to send an NFT that is impersonating a TopShot NFT
// to the locking contract, it must fail

// Parameters
//
// id: the Flow ID of the TopShot moment
// duration: number of seconds that the moment will be locked for

transaction(id: UInt64, duration: UFix64) {
    prepare(acct: auth(BorrowValue) &Account) {
        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        let nft <- collectionRef.withdraw(withdrawID: id)

        let lockedNFT <- TopShotLocking.lockNFT(nft: <-nft, duration: duration)

        // destroy here to get rid of loss of resource error - should not actually get here
        destroy <- lockedNFT
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/mint_and_purchase.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS

// This transaction mints DapperUtilityCoin (a Fungible Token) to self,
// then purchases a moment for sale from a seller
// then deposits bought moment to a recipient

// Parameters:
//
// sellerAddress: the Flow address of the account issuing the sale of a moment
// recipient: the Flow address who will receive the moment
// tokenID: the ID of the moment being purchased
// purchaseAmount: the amount for which the user is paying for the moment; must not be less than the moment's price

transaction(sellerAddress: Address, recipient: Address, tokenID: UInt64, purchaseAmount: UFix64) {

    // Local variable for the coin admin
    let ducRef: &DapperUtilityCoin.Minter

    prepare(signer: auth(Storage, Capabilities) &Account) {

        self.ducRef = signer.storage.borrow<&DapperUtilityCoin.Minter>(from: /storage/dapperUtilityCoinAdmin)
            ?? panic("Signer is not the token admin")
    }

    execute {

        let mintedVault <- self.ducRef.mintTokens(amount: purchaseAmount) as! @DapperUtilityCoin.Vault


        let seller = getAccount(sellerAddress)
        
        let topshotSaleCollection = seller.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
            ?? panic("Could not borrow public sale reference")

        let boughtToken <- topshotSaleCollection.purchase(tokenID: tokenID, buyTokens: <-mintedVault)

        // get the recipient's public account object and borrow a reference to their moment receiver
        let recipient = getAccount(recipient).capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)
            ?? panic("Could not borrow a reference to the moment collection")

        // deposit the NFT in the receivers collection
        recipient.deposit(token: <-boughtToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_set_locked.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns a boolean indicating if the specified set is locked
// meaning new plays cannot be added to it

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read

// Returns: Bool
// Whether specified set is locked

access(all) fun main(setID: UInt32): Bool {

    let isLocked = TopShot.isSetLocked(setID: setID)
        ?? panic("Could not find the specified set")

    return isLocked
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/fulfill_pack.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS

// This transaction is what Top Shot uses to send the moments in a "pack" to
// a user's collection

// Parameters:
//
// recipientAddr: the Flow address of the account receiving a pack of moments
// momentsIDs: an array of moment IDs to be withdrawn from the owner's moment collection

transaction(recipientAddr: Address, momentIDs: [UInt64]) {

    prepare(acct: auth(BorrowValue) &Account) {
        
        // get the recipient's public account object
        let recipient = getAccount(recipientAddr)

        // borrow a reference to the recipient's moment collection
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's collection")

        

        // borrow a reference to the owner's moment collection
        if let collection = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShotShardedCollection.ShardedCollection>(from: /storage/ShardedMomentCollection) {
            
            receiverRef.batchDeposit(tokens: <-collection.batchWithdraw(ids: momentIDs))
        } else {

            let collection = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)!

            // Deposit the pack of moments to the recipient's collection
            receiverRef.batchDeposit(tokens: <-collection.batchWithdraw(ids: momentIDs))

        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_serialNum.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the serial number of a moment
// by borrowing a reference to the moment 
// and returning its serial number

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: UInt32
// The serialNumber associated with a moment with a specified ID

access(all) fun main(account: Address, id: UInt64): UInt32 {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return data.serialNumber
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/plays/get_nextPlayID.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the public nextPlayID from the TopShot contract and 
// returns that number to the caller

// Returns: UInt32
// the nextPlayID field in TopShot contract

access(all) fun main(): UInt32 {

    log(TopShot.nextPlayID)

    return TopShot.nextPlayID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/set_nfts_lock_expiry.cdc

```
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

transaction(ids: [UInt64], expiryTimestamp: UFix64) {
    let adminRef: &TopShotLocking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // Set TopShotLocking admin ref
        self.adminRef = acct.storage.borrow<&TopShotLocking.Admin>(from: /storage/TopShotLockingAdmin)
            ?? panic("Could not find reference to TopShotLocking Admin resource")
    }

    execute {
        for id in ids {
            self.adminRef.setLockExpiryByID(id: id, expiryTimestamp: expiryTimestamp)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopshotAdminReceiver.cdc

```
/*

  AdminReceiver.cdc

  This contract defines a function that takes a TopShot Admin
  object and stores it in the storage of the contract account
  so it can be used.

 */

import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS

access(all) contract TopshotAdminReceiver {

    // storeAdmin takes a TopShot Admin resource and 
    // saves it to the account storage of the account
    // where the contract is deployed
    access(all) fun storeAdmin(newAdmin: @TopShot.Admin) {
        self.account.storage.save(<-newAdmin, to: /storage/TopShotAdmin)
    }
    
    init() {
        // Save a copy of the sharded Moment Collection to the account storage
        if self.account.storage.borrow<&TopShotShardedCollection.ShardedCollection>(from: /storage/ShardedMomentCollection) == nil {
            let collection <- TopShotShardedCollection.createEmptyCollection(numBuckets: 32)
            // Put a new Collection in storage
            self.account.storage.save(<-collection, to: /storage/ShardedMomentCollection)
            let cap = self.account.capabilities.storage.issue<&TopShotShardedCollection.ShardedCollection>(/storage/ShardedMomentCollection)
            self.account.capabilities.publish(cap, at: /public/MomentCollection)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotMarketV3.cdc

```
/**

    TopShotMarketV3.cdc

    Description: Contract definitions for users to sell their moments

    Marketplace is where users can create a sale collection that they
    store in their account storage. In the sale collection, 
    they can put their NFTs up for sale with a price and publish a 
    reference so that others can see the sale.

    If another user sees an NFT that they want to buy,
    they can send fungible tokens that equal the buy price
    to buy the NFT.  The NFT is transferred to them when
    they make the purchase.

    Each user who wants to sell tokens will have a sale collection 
    instance in their account that contains price information 
    for each node in their collection. The sale holds a capability that 
    links to their main moment collection.

    They can give a reference to this collection to a central contract
    so that it can list the sales in a central place

    When a user creates a sale, they will supply four arguments:
    - A TopShot.Collection capability that allows their sale to withdraw
      a moment when it is purchased.
    - A FungibleToken.Receiver capability as the place where the payment for the token goes.
    - A FungibleToken.Receiver capability specifying a beneficiary, where a cut of the purchase gets sent. 
    - A cut percentage, specifying how much the beneficiary will recieve.
    
    The cut percentage can be set to zero if the user desires and they 
    will receive the entirety of the purchase. TopShot will initialize sales 
    for users with the TopShot admin vault as the vault where cuts get 
    deposited to.
**/

import FungibleToken from 0xFUNGIBLETOKENADDRESS
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS

access(all) contract TopShotMarketV3 {

    access(all) entitlement Create
    access(all) entitlement Cancel
    access(all) entitlement Update

    // -----------------------------------------------------------------------
    // TopShot Market contract Event definitions
    // -----------------------------------------------------------------------

    /// emitted when a TopShot moment is listed for sale
    access(all) event MomentListed(id: UInt64, price: UFix64, seller: Address?)
    /// emitted when the price of a listed moment has changed
    access(all) event MomentPriceChanged(id: UInt64, newPrice: UFix64, seller: Address?)
    /// emitted when a token is purchased from the market
    access(all) event MomentPurchased(id: UInt64, price: UFix64, seller: Address?, momentName: String, momentDescription: String, momentThumbnailURL: String)
    /// emitted when a moment has been withdrawn from the sale
    access(all) event MomentWithdrawn(id: UInt64, owner: Address?)

    /// Path where the `SaleCollection` is stored
    access(all) let marketStoragePath: StoragePath

    /// Path where the public capability for the `SaleCollection` is
    access(all) let marketPublicPath: PublicPath

    /// SaleCollection
    ///
    /// This is the main resource that token sellers will store in their account
    /// to manage the NFTs that they are selling. The SaleCollection
    /// holds a TopShot Collection resource to store the moments that are for sale.
    /// The SaleCollection also keeps track of the price of each token.
    /// 
    /// When a token is purchased, a cut is taken from the tokens
    /// and sent to the beneficiary, then the rest are sent to the seller.
    ///
    /// The seller chooses who the beneficiary is and what percentage
    /// of the tokens gets taken from the purchase
    access(all) resource SaleCollection: Market.SalePublic {

        /// A collection of the moments that the user has for sale
        access(self) var ownerCollection: Capability<auth(NonFungibleToken.Withdraw, NonFungibleToken.Update) &TopShot.Collection>

        /// Capability to point at the V1 sale collection
        access(self) var marketV1Capability: Capability<auth(Market.Create, NonFungibleToken.Withdraw, Market.Update) &Market.SaleCollection>?

        /// Dictionary of the low low prices for each NFT by ID
        access(self) var prices: {UInt64: UFix64}

        /// The fungible token vault of the seller
        /// so that when someone buys a token, the tokens are deposited
        /// to this Vault
        access(self) var ownerCapability: Capability<&{FungibleToken.Receiver}>

        /// The capability that is used for depositing 
        /// the beneficiary's cut of every sale
        access(self) var beneficiaryCapability: Capability<&{FungibleToken.Receiver}>

        /// The percentage that is taken from every purchase for the beneficiary
        /// For example, if the percentage is 15%, cutPercentage = 0.15
        access(all) var cutPercentage: UFix64

        init (ownerCollection: Capability<auth(NonFungibleToken.Withdraw, NonFungibleToken.Update) &TopShot.Collection>,
              ownerCapability: Capability<&{FungibleToken.Receiver}>,
              beneficiaryCapability: Capability<&{FungibleToken.Receiver}>,
              cutPercentage: UFix64,
              marketV1Capability: Capability<auth(Market.Create, NonFungibleToken.Withdraw, Market.Update) &Market.SaleCollection>?) {
            pre {
                // Check that the owner's moment collection capability is correct
                ownerCollection.check(): 
                    "Owner's Moment Collection Capability is invalid!"

                // Check that both capabilities are for fungible token Vault receivers
                ownerCapability.check(): 
                    "Owner's Receiver Capability is invalid!"
                beneficiaryCapability.check(): 
                    "Beneficiary's Receiver Capability is invalid!" 

                // Make sure the V1 sale collection capability is valid
                marketV1Capability == nil || marketV1Capability!.check():
                    "V1 Market Capability is invalid"
            }
            
            // create an empty collection to store the moments that are for sale
            self.ownerCollection = ownerCollection
            self.ownerCapability = ownerCapability
            self.beneficiaryCapability = beneficiaryCapability
            // prices are initially empty because there are no moments for sale
            self.prices = {}
            self.cutPercentage = cutPercentage
            self.marketV1Capability = marketV1Capability
        }

        /// listForSale lists an NFT for sale in this sale collection
        /// at the specified price
        ///
        /// Parameters: tokenID: The id of the NFT to be put up for sale
        ///             price: The price of the NFT
        access(Create) fun listForSale(tokenID: UInt64, price: UFix64) {
            pre {
                self.ownerCollection.borrow()!.borrowMoment(id: tokenID) != nil:
                    "Moment does not exist in the owner's collection"

                !TopShotLocking.isLocked(nftRef: self.ownerCollection.borrow()!.borrowNFT(tokenID)!):
                    "Moment is locked"
            }

            // Set the token's price
            self.prices[tokenID] = price

            emit MomentListed(id: tokenID, price: price, seller: self.owner?.address)
        }

        /// cancelSale cancels a moment sale and clears its price
        ///
        /// Parameters: tokenID: the ID of the token to withdraw from the sale
        ///
        access(Cancel) fun cancelSale(tokenID: UInt64) {
            
            // First check this version of the sale
            if self.prices[tokenID] != nil {
                // Remove the price from the prices dictionary
                self.prices.remove(key: tokenID)

                // Set prices to nil for the withdrawn ID
                self.prices[tokenID] = nil
                
                // Emit the event for withdrawing a moment from the Sale
                emit MomentWithdrawn(id: tokenID, owner: self.owner?.address)

            // If not found in this SaleCollection, check V1
            } else if let v1Market = self.marketV1Capability {
                let v1MarketRef = v1Market.borrow()!

                if v1MarketRef.getPrice(tokenID: tokenID) != nil {
                    // withdraw the moment from the v1 collection
                    let token <- v1MarketRef.withdraw(tokenID: tokenID)

                    // borrow a reference to the main top shot collection
                    let ownerCollectionRef = self.ownerCollection.borrow()
                        ?? panic("Could not borrow owner collection reference")

                    // deposit the withdrawn moment into the main collection
                    ownerCollectionRef.deposit(token: <-token)
                }
            }
        }

        /// purchase lets a user send tokens to purchase an NFT that is for sale
        /// the purchased NFT is returned to the transaction context that called it
        ///
        /// Parameters: tokenID: the ID of the NFT to purchase
        ///             buyTokens: the fungible tokens that are used to buy the NFT
        ///
        /// Returns: @TopShot.NFT: the purchased NFT
        access(all) fun purchase(tokenID: UInt64, buyTokens: @DapperUtilityCoin.Vault): @TopShot.NFT {

            // First check this sale collection for the NFT
            if self.prices[tokenID] != nil {
                assert(
                    buyTokens.balance == self.prices[tokenID]!,
                    message: "Not enough tokens to buy the NFT!"
                )

                // Read the price for the token
                let price = self.prices[tokenID]!

                // Set the price for the token to nil
                self.prices[tokenID] = nil

                // Take the cut of the tokens that the beneficiary gets from the sent tokens
                let beneficiaryCut <- buyTokens.withdraw(amount: price*self.cutPercentage)

                // Deposit it into the beneficiary's Vault
                self.beneficiaryCapability.borrow()!
                    .deposit(from: <-beneficiaryCut)
                
                // Deposit the remaining tokens into the owners vault
                self.ownerCapability.borrow()!
                    .deposit(from: <-buyTokens)

                // Return the purchased token
                let boughtMoment <- self.ownerCollection.borrow()!.withdraw(withdrawID: tokenID) as! @TopShot.NFT

                let momentDisplay = boughtMoment.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
                emit MomentPurchased(id: tokenID, price: price, seller: self.owner?.address, momentName: momentDisplay.name, momentDescription: momentDisplay.description, momentThumbnailURL: momentDisplay.thumbnail.uri())

                return <-boughtMoment

            // If not found in this SaleCollection, check V1
            } else if let v1Market = self.marketV1Capability {
                let v1MarketRef = v1Market.borrow()!

                return <-v1MarketRef.purchase(tokenID: tokenID, buyTokens: <-buyTokens)
            } 
            
            // Refactored to avoid dead code to resolve
            // https://github.com/dapperlabs/nba-smart-contracts/issues/165
            panic("No token matching this ID for sale!")

        }

        /// changeOwnerReceiver updates the capability for the sellers fungible token Vault
        ///
        /// Parameters: newOwnerCapability: The new fungible token capability for the account 
        ///                                 who received tokens for purchases
        access(Update) fun changeOwnerReceiver(_ newOwnerCapability: Capability<&{FungibleToken.Receiver}>) {
            pre {
                newOwnerCapability.borrow() != nil: 
                    "Owner's Receiver Capability is invalid!"
            }
            self.ownerCapability = newOwnerCapability
        }

        /// changeBeneficiaryReceiver updates the capability for the beneficiary of the cut of the sale
        ///
        /// Parameters: newBeneficiaryCapability the new capability for the beneficiary of the cut of the sale
        ///
        access(Update) fun changeBeneficiaryReceiver(_ newBeneficiaryCapability: Capability<&{FungibleToken.Receiver}>) {
            pre {
                newBeneficiaryCapability.borrow() != nil: 
                    "Beneficiary's Receiver Capability is invalid!" 
            }
            self.beneficiaryCapability = newBeneficiaryCapability
        }

        /// getPrice returns the price of a specific token in the sale
        /// 
        /// Parameters: tokenID: The ID of the NFT whose price to get
        ///
        /// Returns: UFix64: The price of the token
        access(all) view fun getPrice(tokenID: UInt64): UFix64? {
            if let price = self.prices[tokenID] {
                return price
            } else if let marketV1 = self.marketV1Capability {
                return marketV1.borrow()!.getPrice(tokenID: tokenID)
            }
            return nil
        }

        /// getIDs returns an array of token IDs that are for sale
        access(all) view fun getIDs(): [UInt64] {
            let v3Keys = self.prices.keys

            // Add any V1 SaleCollection IDs if they exist
            if let marketV1 = self.marketV1Capability {
                let v1Keys = marketV1.borrow()!.getIDs()
                return v1Keys.concat(v3Keys)
            } else {
                return v3Keys
            }
        }

        /// borrowMoment Returns a borrowed reference to a Moment for sale
        /// so that the caller can read data from it
        ///
        /// Parameters: id: The ID of the moment to borrow a reference to
        ///
        /// Returns: &TopShot.NFT? Optional reference to a moment for sale 
        ///                        so that the caller can read its data
        ///
        access(all) view fun borrowMoment(id: UInt64): &TopShot.NFT? {
            // first check this collection
            if self.prices[id] != nil {
                let ref = self.ownerCollection.borrow()!.borrowMoment(id: id)
                return ref
            } else {
                // If it wasn't found here, check the V1 SaleCollection
                if let marketV1 = self.marketV1Capability {
                    return marketV1.borrow()!.borrowMoment(id: id)
                }
                return nil
            }
        }
    }

    /// createCollection returns a new collection resource to the caller
    access(all) fun createSaleCollection(ownerCollection: Capability<auth(NonFungibleToken.Withdraw, NonFungibleToken.Update) &TopShot.Collection>,
                                 ownerCapability: Capability<&{FungibleToken.Receiver}>,
                                 beneficiaryCapability: Capability<&{FungibleToken.Receiver}>,
                                 cutPercentage: UFix64,
                                 marketV1Capability: Capability<auth(Market.Create, NonFungibleToken.Withdraw, Market.Update) &Market.SaleCollection>?): @SaleCollection {

        return <- create SaleCollection(ownerCollection: ownerCollection,
                                        ownerCapability: ownerCapability,
                                        beneficiaryCapability: beneficiaryCapability,
                                        cutPercentage: cutPercentage,
                                        marketV1Capability: marketV1Capability)
    }

    init() {
        self.marketStoragePath = /storage/topshotSale3Collection
        self.marketPublicPath = /public/topshotSalev3Collection
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/oracle/score_fast_break_submission.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(fastBreakGameID: String, playerAddress: Address, points: UInt64, win: Bool) {

    let oracleRef: auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon
    let playerId: UInt64

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.oracleRef = acct.storage.borrow<auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon>(from: FastBreakV1.OracleStoragePath)
            ?? panic("could not borrow a reference to the oracle resource")

        self.playerId = FastBreakV1.getPlayerIdByAccount(accountAddress: playerAddress)
    }

    execute {

        self.oracleRef.updateFastBreakScore(
            fastBreakGameID: fastBreakGameID,
            playerId: self.playerId,
            points: points,
            win: win
        )
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/interfaces/ICrossVMBridgeCallable.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

/**
 * @title ICrossVMBridgeCallable
 * @dev An interface intended for use by implementations on Flow EVM, allowing a contract to define
 * access to the Cadence X EVM bridge on certain methods.
 */
interface ICrossVMBridgeCallable {

    /// @dev Should encounter when the vmBridgeAddress is initialized to 0x0
    error CrossVMBridgeCallableZeroInitialization();
    /// @dev Should encounter when a VM bridge privileged method is triggered by unauthorized caller
    error CrossVMBridgeCallableUnauthorizedAccount(address account);

    /**
     * @dev Returns the designated VM bridge’s EVM address
     */
    function vmBridgeAddress() external view returns (address);
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/purchase_both_markets.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction purchases a moment from the v3 sale collection
// The v3 sale collection will also check the v1 collection for for sale moments as part of the purchase
// If there is no v3 sale collection, the transaction will just purchase it from v1 anyway

transaction(seller: Address, recipient: Address, momentID: UInt64, purchaseAmount: UFix64) {

    let purchaseTokens: @DapperUtilityCoin.Vault

    prepare(acct: auth(BorrowValue) &Account) {

        // Borrow a provider reference to the buyers vault
        let provider = acct.storage.borrow<auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)
            ?? panic("Could not borrow a reference to the buyers FlowToken Vault")
        
        // withdraw the purchase tokens from the vault
        self.purchaseTokens <- provider.withdraw(amount: purchaseAmount) as! @DapperUtilityCoin.Vault
        
    }

    execute {

        // get the accounts for the seller and recipient
        let seller = getAccount(seller)
        let recipient = getAccount(recipient)

        // Get the reference for the recipient's nft receiver
        let receiverRef = recipient.capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)
            ?? panic("Could not borrow a reference to the moment collection")

        if let marketV3CollectionRef = seller.capabilities.borrow<&TopShotMarketV3.SaleCollection>(/public/topshotSalev3Collection) {

            let purchasedToken <- marketV3CollectionRef.purchase(tokenID: momentID, buyTokens: <-self.purchaseTokens)
            receiverRef.deposit(token: <-purchasedToken)

        } else if let marketV1CollectionRef = seller.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection) {
            // purchase the moment
            let purchasedToken <- marketV1CollectionRef.purchase(tokenID: momentID, buyTokens: <-self.purchaseTokens)

            // deposit the purchased moment into the signer's collection
            receiverRef.deposit(token: <-purchasedToken)

        } else {
            panic("Could not borrow reference to either Sale collection")
        }
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/transfer_flow_to_evm_address.cdc

```
import "FungibleToken"
import "FlowToken"

import "EVM"

/// Transfers $FLOW from the signer's account Cadence Flow balance to the recipient's hex-encoded EVM address.
///
transaction(recipientEVMAddressHex: String, amount: UFix64) {

    var sentVault: @FlowToken.Vault
    let recipientEVMAddress: EVM.EVMAddress
    let recipientPreBalance: UFix64

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        // Borrow a reference to the signer's FlowToken.Vault and withdraw the amount
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")
        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault

        // Get the recipient's EVM address
        self.recipientEVMAddress = EVM.addressFromString(recipientEVMAddressHex)

        // Get the recipient's balance before the transfer to check the amount transferred
        self.recipientPreBalance = self.recipientEVMAddress.balance().inFLOW()
    }

    execute {
        // Deposit the amount to the recipient's EVM address
        self.recipientEVMAddress.deposit(from: <-self.sentVault)
    }

    post {
        self.recipientEVMAddress.balance().inFLOW() == self.recipientPreBalance + amount:
            "Problem transferring value to EVM address"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/unlock_moment.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction unlocks a TopShot NFT removing it from the locked dictionary
// and re-enabling the ability to withdraw, sell, and transfer the moment

// Parameters
//
// id: the Flow ID of the TopShot moment
transaction(id: UInt64) {
    prepare(acct: auth(BorrowValue) &Account) {
        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Update) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        collectionRef.unlock(id: id)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/lib/CrossVMBridgeCallableUpgradeable.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

import {ICrossVMBridgeCallable} from "../interfaces/ICrossVMBridgeCallable.sol";
import {ContextUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import {ERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol";

/**
 * @title CrossVMBridgeCallable
 * @dev A base contract intended for use in implementations on Flow, allowing a contract to define
 * access to the Cadence X EVM bridge on certain methods.
 */
abstract contract CrossVMBridgeCallableUpgradeable is ICrossVMBridgeCallable, ContextUpgradeable, ERC165Upgradeable {

    address private _vmBridgeAddress;

    /**
     * @dev Sets the bridge EVM address such that only the bridge COA can call the privileged methods
     */
    function _init_vm_bridge_address(address vmBridgeAddress_) internal {
        if (vmBridgeAddress_ == address(0)) {
            revert CrossVMBridgeCallableZeroInitialization();
        }
        _vmBridgeAddress = vmBridgeAddress_;
    }

    /**
     * @dev Modifier restricting access to the designated VM bridge EVM address 
     */
    modifier onlyVMBridge() {
        _checkVMBridgeAddress();
        _;
    }

    /**
     * @dev Returns the designated VM bridge’s EVM address
     */
    function vmBridgeAddress() public view virtual returns (address) {
        return _vmBridgeAddress;
    }

    /**
     * @dev Checks that msg.sender is the designated VM bridge address
     */
    function _checkVMBridgeAddress() internal view virtual {
        if (_vmBridgeAddress != _msgSender()) {
            revert CrossVMBridgeCallableUnauthorizedAccount(_msgSender());
        }
    }

    /**
     * @dev Allows a caller to determine the contract conforms to the `ICrossVMFulfillment` interface
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable) returns (bool) {
        return interfaceId == type(ICrossVMBridgeCallable).interfaceId || super.supportsInterface(interfaceId);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/stop_sale.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import NonFungibleToken from 0xNFTADDRESS


// This transaction is for a user to stop a moment sale in their account
// by withdrawing that moment from their sale collection and depositing
// it into their normal moment collection

// Parameters
//
// tokenID: the ID of the moment whose sale is to be delisted

transaction(tokenID: UInt64) {

    let collectionRef: &TopShot.Collection
    let saleCollectionRef: auth(NonFungibleToken.Withdraw) &Market.SaleCollection

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // Borrow a reference to the NFT collection in the signers account
        self.collectionRef = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        // borrow a reference to the owner's sale collection
        self.saleCollectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
    }

    execute {
    
        // withdraw the moment from the sale, thereby de-listing it
        let token <- self.saleCollectionRef.withdraw(tokenID: tokenID)

        // deposit the moment into the owner's collection
        self.collectionRef.deposit(token: <-token)
    }
}   
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/get_topshot_metadata.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS


access(all) fun main(address: Address, id: UInt64): TopShot.TopShotMomentMetadataView {
    let account = getAccount(address)

    let collectionRef = account.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

    let nft = collectionRef.borrowMoment(id: id)!
    
    // Get the Top Shot specific metadata for this NFT
    let view = nft.resolveView(Type<TopShot.TopShotMomentMetadataView>())!

    let metadata = view as! TopShot.TopShotMomentMetadataView
    
    return metadata
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/destroy_moments.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction destroys a number of moments owned by a user

// Parameters
//
// momentIDs: an array of moment IDs of NFTs to be destroyed

transaction(momentIDs: [UInt64]) {

    let collectionRef: auth(NonFungibleToken.Withdraw) &TopShot.Collection
    
    prepare(acct: auth(BorrowValue) &Account) {
        // delist any of the moments that are listed (this delists for both MarketV1 and Marketv3)
        if let topshotSaleV3Collection = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {
            for id in momentIDs {
                if topshotSaleV3Collection.borrowMoment(id: id) != nil{
                    // cancel the moment from the sale, thereby de-listing it
                    topshotSaleV3Collection.cancelSale(tokenID: id)
                }
            }
        }

        self.collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")
    }

    execute {
        let tokens <- self.collectionRef.batchWithdraw(ids: momentIDs)
        // destroy the NFTs
        destroy tokens
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_isLocked.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

// This script determines if a moment is locked

// Parameters:
//
// account: The Flow Address of the account who owns the moment
// id: The unique ID for the moment

// Returns: Bool
// Whether the moment is locked

access(all) fun main(account: Address, id: UInt64): Bool {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    let nftRef = collectionRef.borrowNFT(id)!

    return TopShotLocking.isLocked(nftRef: nftRef)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/scripts/get_sale_price.cdc

```
import Market from 0xMARKETADDRESS

// This script gets the price of a moment in an account's sale collection
// by looking up its unique ID.

// Parameters:
//
// sellerAddress: The Flow Address of the account whose sale collection needs to be read
// momentID: The unique ID for the moment whose data needs to be read

// Returns: UFix64
// The price of moment with specified ID on sale

access(all) fun main(sellerAddress: Address, momentID: UInt64): UFix64 {

    let acct = getAccount(sellerAddress)

    let collectionRef = acct.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getPrice(tokenID: UInt64(momentID))!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/retireAll_plays_from_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is for retiring all plays from a set, which
// makes it so that moments can no longer be minted
// from all the editions with that set

// Parameters:
//
// setID: the ID of the set to be retired entirely

transaction(setID: UInt32) {
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {
        // borrow a reference to the specified set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // retire all the plays
        setRef.retireAll()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/retire_all.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This is a transaction an admin would use to retire all the plays in a set
// which makes it so that no more moments can be minted from the retired plays

// Parameters:
//
// setID: the ID of the set to be retired entirely

transaction(setID: UInt32) {

    // local variable for the admin reference
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the admin resource
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {

        // borrow a reference to the specified set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // retire all the plays permenantely
        setRef.retireAll()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/plays/get_play_metadata_field.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns the value for the specified metadata field
// associated with a play in the TopShot smart contract

// Parameters:
//
// playID: The unique ID for the play whose data needs to be read
// field: The specified metadata field whose data needs to be read

// Returns: String
// Value of specified metadata field associated with specified playID

access(all) fun main(playID: UInt32, field: String): String {

    let field = TopShot.getPlayMetaDataByField(playID: playID, field: field) ?? panic("Play doesn't exist")

    log(field)

    return field
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_player_score.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(id: String, playerAddress: Address): UInt64 {
    let playerId = FastBreakV1.getPlayerIdByAccount(accountAddress: playerAddress)
    let fastBreak = FastBreakV1.getFastBreakGame(id: id)!
    let submission : FastBreakV1.FastBreakSubmission = fastBreak.getFastBreakSubmissionByPlayerId(playerId: playerId)!

    return submission.points
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/create_start_sale.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import Market from 0xMARKETADDRESS
import TopShot from 0xTOPSHOTADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction puts a moment owned by the user up for sale

// Parameters:
//
// tokenReceiverPath: token capability for the account who will receive tokens for purchase
// beneficiaryAccount: the Flow address of the account where a cut of the purchase will be sent
// cutPercentage: how much in percentage the beneficiary will receive from the sale
// momentID: ID of moment to be put on sale
// price: price of moment

transaction(tokenReceiverPath: PublicPath, beneficiaryAccount: Address, cutPercentage: UFix64, momentID: UInt64, price: UFix64) {

    // Local variables for the topshot collection and market sale collection objects
    let collectionRef: auth(NonFungibleToken.Withdraw) &TopShot.Collection
    let marketSaleCollectionRef: auth(Market.Create) &Market.SaleCollection
    
    prepare(acct: auth(Storage, Capabilities) &Account) {

        // check to see if a sale collection already exists
        if acct.storage.borrow<&Market.SaleCollection>(from: /storage/topshotSaleCollection) == nil {

            // get the fungible token capabilities for the owner and beneficiary

            let ownerCapability = acct.capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

            let beneficiaryCapability = getAccount(beneficiaryAccount).capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

            // create a new sale collection
            let topshotSaleCollection <- Market.createSaleCollection(ownerCapability: ownerCapability, beneficiaryCapability: beneficiaryCapability, cutPercentage: cutPercentage)
            
            // save it to storage
            acct.storage.save(<-topshotSaleCollection, to: /storage/topshotSaleCollection)
        
            // create a public link to the sale collection
            acct.capabilities.publish(
                acct.capabilities.storage.issue<&Market.SaleCollection>(/storage/topshotSaleCollection),
                at: /public/topshotSaleCollection
            )
        }
        
        // borrow a reference to the seller's moment collection
        self.collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        // borrow a reference to the sale
        self.marketSaleCollectionRef = acct.storage.borrow<auth(Market.Create) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
    }

    execute {

        // withdraw the moment to put up for sale
        let token <- self.collectionRef.withdraw(withdrawID: momentID) as! @TopShot.NFT
        
        // the the moment for sale
        self.marketSaleCollectionRef.listForSale(token: <-token, price: UFix64(price))
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/bridge_nfts_from_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"
import "ScopedFTProviders"
import "EVM"
import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"
import "CrossVMMetadataViews"

/// Bridges NFTs with provided IDs from EVM to Cadence, unwrapping them first if applicable.
///
/// @param nftIdentifier: The identifier of the NFT to unwrap and bridge (e.g., 'A.0b2a3299cc857e29.TopShot.NFT')
/// @param nftIDs: The IDs of the NFTs to bridge to Cadence from EVM (must be held in the signer's COA before submission)
///
transaction(
    nftIdentifier: String,
    nftIDs: [UInt256]
) {
    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge, EVM.Call) &EVM.CadenceOwnedAccount
    let viewResolver: &{ViewResolver}

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge, EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA signer's account at path /storage/evm")

        // Get NFT type, address, and name from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        // Borrow a reference to the NFT collection, configuring if necessary
        self.viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = self.viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                    .concat(collectionData.storagePath.toString()))

        // Set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(nftIDs.length))
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }

        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Unwrap NFTs if applicable
        unwrapNFTsIfApplicable(self.coa,
            nftIDs: nftIDs,
            nftType: self.nftType,
            viewResolver: self.viewResolver
        )

        // Bridge each NFT from the signer's COA in EVM to the signer's collection in Cadence
        for id in nftIDs {
            // Execute the bridge to Cadence for the current ID
            let nft: @{NonFungibleToken.NFT}  <- self.coa.withdrawNFT(
                type: self.nftType,
                id: id,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )

            // Ensure the bridged nft is the correct type
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )

            // Deposit the bridged NFT into the signer's collection
            self.collection.deposit(token: <-nft)
        }

        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

/// Unwraps NFTs from a project's custom ERC721 wrapper contract to bridged NFTs on EVM, if applicable.
/// Enables projects to use their own ERC721 contract while leveraging the bridge's underlying contract,
/// until direct custom contract support is added to the bridge.
///
/// @param coa: The COA of the signer
/// @param nftIDs: The IDs of the NFTs to wrap
/// @param nftType: The type of the NFTs to wrap
/// @param viewResolver: The ViewResolver of the NFT contract
///
access(all) fun unwrapNFTsIfApplicable(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    nftIDs: [UInt256],
    nftType: Type,
    viewResolver: &{ViewResolver}
) {
    // Get the project-defined ERC721 address if it exists
    if let crossVMPointer = viewResolver.resolveContractView(
            resourceType: nftType,
            viewType: Type<CrossVMMetadataViews.EVMPointer>()
    ) as! CrossVMMetadataViews.EVMPointer? {
        // Get the underlying ERC721 address if it exists
        if let underlyingAddress = getUnderlyingERC721Address(coa, crossVMPointer.evmContractAddress) {
            for id in nftIDs {
                // Unwrap NFT if it is wrapped
                if isNFTWrapped(coa,
                    nftID: id,
                    underlying: underlyingAddress,
                    wrapper: crossVMPointer.evmContractAddress
                ) {
                    let res = mustCall(coa, crossVMPointer.evmContractAddress,
                        functionSig: "withdrawTo(address,uint256[])",
                        args: [coa.address(), [id]]
                    )
                    let decodedRes = EVM.decodeABI(types: [Type<Bool>()], data: res.data)
                    assert(decodedRes.length == 1, message: "Invalid response length")
                    assert(decodedRes[0] as! Bool, message: "Failed to unwrap NFT")
                }
            }
        }
    }
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

/// Gets the underlying ERC721 address if it exists (i.e. if the ERC721 is a wrapper)
///
access(all) fun getUnderlyingERC721Address(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ wrapperAddress: EVM.EVMAddress
): EVM.EVMAddress? {
    let res = coa.call(
        to: wrapperAddress,
        data: EVM.encodeABIWithSignature("underlying()", []),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    // If the call fails, return nil
    if res.status != EVM.Status.successful || res.data.length == 0 {
        return nil
    }

    // Decode and return the underlying ERC721 address
    let decodedResult = EVM.decodeABI(
        types: [Type<EVM.EVMAddress>()],
        data: res.data
    )
    assert(decodedResult.length == 1, message: "Invalid response length")
    return decodedResult[0] as! EVM.EVMAddress
}

/// Checks if the provided NFT is wrapped in the underlying ERC721 contract
///
access(all) fun isNFTWrapped(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    nftID: UInt256,
    underlying: EVM.EVMAddress,
    wrapper: EVM.EVMAddress
): Bool {
    let res = coa.call(
        to: underlying,
        data: EVM.encodeABIWithSignature("ownerOf(uint256)", [nftID]),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    // If the call fails, return false
    if res.status != EVM.Status.successful || res.data.length == 0{
        return false
    }

    // Decode and compare the addresses
    let decodedResult = EVM.decodeABI(
        types: [Type<EVM.EVMAddress>()],
        data: res.data
    )
    assert(decodedResult.length == 1, message: "Invalid response length")
    let owner = decodedResult[0] as! EVM.EVMAddress
    return owner.toString() == wrapper.toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/get_totalSupply.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the current number of moments that have been minted
// from the TopShot contract and returns that number to the caller

// Returns: UInt64
// Number of moments minted from TopShot contract

access(all) fun main(): UInt64 {

    return TopShot.totalSupply
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/retire_play_from_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is for retiring a play from a set, which
// makes it so that moments can no longer be minted from that edition

// Parameters:
// 
// setID: the ID of the set in which a play is to be retired
// playID: the ID of the play to be retired

transaction(setID: UInt32, playID: UInt32) {
    
    // local variable for storing the reference to the admin resource
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
    }

    execute {

        // borrow a reference to the specified set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // retire the play
        setRef.retirePlay(playID: playID)
    }

    post {
        
        self.adminRef.borrowSet(setID: setID).getRetired()[playID]!: 
            "play is not retired"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/shardedCollection/transfer_from_sharded.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS

// This transaction deposits an NFT to a recipient

// Parameters
//
// recipient: the Flow address who will receive the NFT
// momentID: moment ID of NFT that recipient will receive

transaction(recipient: Address, momentID: UInt64) {

    let transferToken: @{NonFungibleToken.NFT}
    
    prepare(acct: auth(BorrowValue) &Account) {

        self.transferToken <- acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShotShardedCollection.ShardedCollection>(from: /storage/ShardedMomentCollection)!.withdraw(withdrawID: momentID)
    }

    execute {
        
        // get the recipient's public account object
        let recipient = getAccount(recipient)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

        // deposit the NFT in the receivers collection
        receiverRef.deposit(token: <-self.transferToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_player_win_count_for_run.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(runId: String, playerAddress: Address): UInt64 {
    let playerId = FastBreakV1.getPlayerIdByAccount(accountAddress: playerAddress)
    let fastBreakRun = FastBreakV1.getFastBreakRun(id: runId)!

    return fastBreakRun.runWinCount[playerId] ?? 0
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/create_sale.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction creates a sale collection and stores it in the signer's account
// It does not put an NFT up for sale

// Parameters
// 
// beneficiaryAccount: the Flow address of the account where a cut of the purchase will be sent
// cutPercentage: how much in percentage the beneficiary will receive from the sale

transaction(tokenReceiverPath: PublicPath, beneficiaryAccount: Address, cutPercentage: UFix64) {
    prepare(acct: auth(Storage, Capabilities) &Account) {
        let ownerCapability = acct.capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

        let beneficiaryCapability = getAccount(beneficiaryAccount).capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

        let ownerCollection = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(/storage/MomentCollection)

        let collection <- TopShotMarketV3.createSaleCollection(ownerCollection: ownerCollection,
                                                               ownerCapability: ownerCapability,
                                                               beneficiaryCapability: beneficiaryCapability,
                                                               cutPercentage: cutPercentage,
                                                               marketV1Capability: nil)
        
        acct.storage.save(<-collection, to: TopShotMarketV3.marketStoragePath)

        acct.capabilities.publish(
            acct.capabilities.storage.issue<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketStoragePath),
            at: TopShotMarketV3.marketPublicPath
        )
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/batch_transfer.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS

// This transaction transfers a number of moments to a recipient

// Parameters
//
// recipientAddress: the Flow address who will receive the NFTs
// momentIDs: an array of moment IDs of NFTs that recipient will receive

transaction(recipientAddress: Address, momentIDs: [UInt64]) {

    let transferTokens: @NonFungibleToken.Collection
    
    prepare(acct: auth(BorrowValue) &Account) {

        self.transferTokens <- acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)!.batchWithdraw(ids: momentIDs)
    }

    execute {
        
        // get the recipient's public account object
        let recipient = getAccount(recipientAddress)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's collection")

        // deposit the NFT in the receivers collection
        receiverRef.batchDeposit(token: <-self.transferTokens)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/lock_moment.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction locks a TopShot NFT rendering it unable to be withdrawn, sold, or transferred

// Parameters
//
// id: the Flow ID of the TopShot moment
// duration: number of seconds that the moment will be locked for

transaction(id: UInt64, duration: UFix64) {
    prepare(acct: auth(BorrowValue) &Account) {
        if let saleRef = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {
            saleRef.cancelSale(tokenID: id)
        }

        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Update) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        collectionRef.lock(id: id, duration: duration)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_setName.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the set name associated with a moment
// in a collection by getting a reference to the moment
// and then looking up its name

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: String
// The set name associated with a moment with a specified ID

access(all) fun main(account: Address, id: UInt64): String {

    // borrow a public reference to the owner's moment collection 
    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    // borrow a reference to the specified moment in the collection
    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return TopShot.getSetName(setID: data.setID)!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/scripts/get_sale_percentage.cdc

```
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

access(all) fun main(sellerAddress: Address): UFix64 {
    let acct = getAccount(sellerAddress)
    let collectionRef = acct.capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.cutPercentage
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc

```
/**

## The Flow Non-Fungible Token standard

## `NonFungibleToken` contract

The interface that all Non-Fungible Token contracts should conform to.
If a user wants to deploy a new NFT contract, their contract should implement
The types defined here

/// Contributors (please add to this list if you contribute!):
/// - Joshua Hannan - https://github.com/joshuahannan
/// - Bastian Müller - https://twitter.com/turbolent
/// - Dete Shirley - https://twitter.com/dete73
/// - Bjarte Karlsen - https://twitter.com/0xBjartek
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Deniz Edincik - https://twitter.com/bluesign
///
/// Repo reference: https://github.com/onflow/flow-nft

## `NFT` resource interface

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource interface

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives developers the ability to define functions
that can use any type that implements these interfaces

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

import "ViewResolver"

/// The main NFT contract interface. Other NFT contracts will import
/// and implement this interface as well the interfaces defined in this interface
///
access(all) contract interface NonFungibleToken: ViewResolver {

    /// An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// An entitlement for allowing updates and update events for an NFT
    access(all) entitlement Update

    /// Event that contracts should emit when the metadata of an NFT is updated
    /// It can only be emitted by calling the `emitNFTUpdated` function
    /// with an `Update` entitled reference to the NFT that was updated
    /// The entitlement prevents spammers from calling this from other users' collections
    /// because only code within a collection or that has special entitled access
    /// to the collections methods will be able to get the entitled reference
    /// 
    /// The event makes it so that third-party indexers can monitor the events
    /// and query the updated metadata from the owners' collections.
    ///
    access(all) event Updated(type: String, id: UInt64, uuid: UInt64, owner: Address?)
    access(all) view fun emitNFTUpdated(_ nftRef: auth(Update) &{NonFungibleToken.NFT})
    {
        emit Updated(type: nftRef.getType().identifier, id: nftRef.id, uuid: nftRef.uuid, owner: nftRef.owner?.address)
    }


    /// Event that is emitted when a token is withdrawn,
    /// indicating the type, id, uuid, the owner of the collection that it was withdrawn from,
    /// and the UUID of the resource it was withdrawn from, usually a collection.
    ///
    /// If the collection is not in an account's storage, `from` will be `nil`.
    ///
    access(all) event Withdrawn(type: String, id: UInt64, uuid: UInt64, from: Address?, providerUUID: UInt64)

    /// Event that emitted when a token is deposited to a collection.
    /// Indicates the type, id, uuid, the owner of the collection that it was deposited to,
    /// and the UUID of the collection it was deposited to
    ///
    /// If the collection is not in an account's storage, `from`, will be `nil`.
    ///
    access(all) event Deposited(type: String, id: UInt64, uuid: UInt64, to: Address?, collectionUUID: UInt64)

    /// Interface that the NFTs must conform to
    ///
    access(all) resource interface NFT: ViewResolver.Resolver {

        /// unique ID for the NFT
        access(all) let id: UInt64

        /// Event that is emitted automatically every time a resource is destroyed
        /// The type information is included in the metadata event so it is not needed as an argument
        access(all) event ResourceDestroyed(id: UInt64 = self.id, uuid: UInt64 = self.uuid)

        /// createEmptyCollection creates an empty Collection that is able to store the NFT
        /// and returns it to the caller so that they can own NFTs
        ///
        /// @return A an empty collection that can store this NFT
        ///
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getLength() == 0: 
                    "NonFungibleToken.NFT.createEmptyCollection: Cannot create an empty collection! "
                    .concat("The created NonFungibleToken Collection has a non-zero length. ")
                    .concat(" A newly created collection must be empty!")
                result.isSupportedNFTType(type: self.getType()): 
                    "NonFungibleToken.NFT.createEmptyCollection: Cannot create an empty collection! "
                    .concat("The created NonFungibleToken Collection does not support NFTs of type <")
                    .concat(self.getType().identifier)
                    .concat(">. The collection must support NFTs of type <")
                    .concat(self.getType().identifier).concat(">.")
            }
        }

        /// Gets all the NFTs that this NFT directly owns
        ///
        /// @return A dictionary of all subNFTS keyed by type
        ///
        access(all) view fun getAvailableSubNFTS(): {Type: [UInt64]} {
            return {}
        }

        /// Get a reference to an NFT that this NFT owns
        /// Both arguments are optional to allow the NFT to choose
        /// how it returns sub NFTs depending on what arguments are provided
        /// For example, if `type` has a value, but `id` doesn't, the NFT 
        /// can choose which NFT of that type to return if there is a "default"
        /// If both are `nil`, then NFTs that only store a single NFT can just return
        /// that. This helps callers who aren't sure what they are looking for 
        ///
        /// @param type: The Type of the desired NFT
        /// @param id: The id of the NFT to borrow
        ///
        /// @return A structure representing the requested view.
        access(all) fun getSubNFT(type: Type, id: UInt64) : &{NonFungibleToken.NFT}? {
            return nil
        }
    }

    /// Interface to mediate withdrawals from a resource, usually a Collection
    ///
    access(all) resource interface Provider {

        // We emit withdraw events from the provider interface because conficting withdraw
        // events aren't as confusing to event listeners as conflicting deposit events

        /// withdraw removes an NFT from the collection and moves it to the caller
        /// It does not specify whether the ID is UUID or not
        ///
        /// @param withdrawID: The id of the NFT to withdraw from the collection
        /// @return @{NFT}: The NFT that was withdrawn
        ///
        access(Withdraw) fun withdraw(withdrawID: UInt64): @{NFT} {
            post {
                result.id == withdrawID: 
                    "NonFungibleToken.Provider.withdraw: Cannot withdraw NFT! "
                    .concat("The ID of the withdrawn NFT (")
                    .concat(result.id.toString())
                    .concat(") must be the same as the requested ID (")
                    .concat(withdrawID.toString())
                    .concat(").")
                emit Withdrawn(type: result.getType().identifier, id: result.id, uuid: result.uuid, from: self.owner?.address, providerUUID: self.uuid)
            }
        }
    }

    /// Interface to mediate deposits to the Collection
    ///
    access(all) resource interface Receiver {

        /// deposit takes an NFT as an argument and adds it to the Collection
        /// @param token: The NFT to deposit
        access(all) fun deposit(token: @{NFT})

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        /// @return A dictionary of types mapped to booleans indicating if this
        ///         reciever supports it
        access(all) view fun getSupportedNFTTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        /// @param type: An NFT type
        /// @return A boolean indicating if this receiver can recieve the desired NFT type
        access(all) view fun isSupportedNFTType(type: Type): Bool
    }

    /// Kept for backwards-compatibility reasons
    access(all) resource interface CollectionPublic {
        access(all) fun deposit(token: @{NFT})
        access(all) view fun getLength(): Int
        access(all) view fun getIDs(): [UInt64]
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void
        access(all) view fun borrowNFT(_ id: UInt64): &{NFT}?
    }

    /// Requirement for the concrete resource type in the implementing contract
    /// to implement this interface. Since this interface inherits from
    /// all the other necessary interfaces, resources that implement it do not 
    /// also need to include the other interfaces in their conformance lists
    ///
    access(all) resource interface Collection: Provider, Receiver, CollectionPublic, ViewResolver.ResolverCollection {

        /// Field that contains all the NFTs that the collection owns
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        /// deposit takes a NFT as an argument and stores it in the collection
        /// @param token: The NFT to deposit into the collection
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            pre {
                // We emit the deposit event in the `Collection` interface
                // because the `Collection` interface is almost always the final destination
                // of tokens and deposit emissions from custom receivers could be confusing
                // and hard to reconcile to event listeners
                emit Deposited(type: token.getType().identifier, id: token.id, uuid: token.uuid, to: self.owner?.address, collectionUUID: self.uuid)
            }
        }

        /// Gets the amount of NFTs stored in the collection
        /// @return An integer indicating the size of the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        /// Allows a given function to iterate through the list
        /// of owned NFT IDs in a collection without first
        /// having to load the entire list into memory
        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void {
            self.ownedNFTs.forEachKey(f)
        }

        /// Borrows a reference to an NFT stored in the collection
        /// If the NFT with the specified ID is not in the collection,
        /// the function should return `nil` and not panic.
        ///
        /// @param id: The desired nft id in the collection to return a referece for.
        /// @return An optional reference to the NFT
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            post {
                (result == nil) || (result?.id == id): 
                    "NonFungibleToken.Collection.borrowNFT: Cannot borrow NFT reference! "
                    .concat("The ID of the returned reference (")
                    .concat(result!.id.toString())
                    .concat(") does not match the ID that was specified (")
                    .concat(id.toString())
                    .concat(")")
            }
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getType() == self.getType(): 
                    "NonFungibleToken.Collection.createEmptyCollection: Cannot create empty collection! "
                    .concat("The created collection type <")
                    .concat(result.getType().identifier)
                    .concat("> does not have the same type as the collection that was used to create it <")
                    .concat(self.getType().identifier)
                    .concat(">.")
                result.getLength() == 0:
                    "NonFungibleToken.Collection.createEmptyCollection: Cannot create empty collection! "
                    .concat("The created collection has a non-zero length.")
                    .concat(" A newly created collection must be empty!")
            }
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    /// @param nftType: The desired nft type to return a collection for.
    /// @return An array of NFT Types that the implementing contract defines.
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        post {
            result.getIDs().length == 0: 
                "NonFungibleToken.createEmptyCollection: Cannot create empty collection! "
                .concat("The created collection has a non-zero length. ")
                .concat("A newly created collection must be empty!")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/mint_moment.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is what an admin would use to mint a single new moment
// and deposit it in a user's collection

// Parameters:
//
// setID: the ID of a set containing the target play
// playID: the ID of a play from which a new moment is minted
// recipientAddr: the Flow address of the account receiving the newly minted moment

transaction(setID: UInt32, playID: UInt32, recipientAddr: Address) {
    // local variable for the admin reference
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)!
    }

    execute {
        // Borrow a reference to the specified set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Mint a new NFT
        let moment1 <- setRef.mintMoment(playID: playID)

        // get the public account object for the recipient
        let recipient = getAccount(recipientAddr)

        // get the Collection reference for the receiver

        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's moment collection")

        // deposit the NFT in the receivers collection
        receiverRef.deposit(token: <-moment1)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_playID.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the playID associated with a moment
// in a collection by getting a reference to the moment
// and then looking up its playID 

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: UInt32
// The playID associated with a moment with a specified ID

access(all) fun main(account: Address, id: UInt64): UInt32 {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return data.playID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/README.md

# NBA Top Shot

## Introduction

This repository contains the smart contracts and transactions that implement
the core functionality of NBA Top Shot.

The smart contracts are written in Cadence, a new resource oriented
smart contract programming language designed for the Flow Blockchain.

### What is NBA Top Shot

NBA Top Shot is the official digital collectibles
game for the National Basketball Association. Players collect and trade
digital collectibles that represent highlights from the best players 
in the world. See more at nbatopshot.com

### What is Flow?

Flow is a new blockchain for open worlds. Read more about it [here](https://www.onflow.org/).

### What is Cadence?

Cadence is a new Resource-oriented programming language 
for developing smart contracts for the Flow Blockchain.
Read more about it [here](https://www.docs.onflow.org)

We recommend that anyone who is reading this should have already
completed the [Cadence Tutorials](https://docs.onflow.org/cadence) 
so they can build a basic understanding of the programming language.

Resource-oriented programming, and by extension Cadence, 
is the perfect programming environment for Non-Fungible Tokens (NFTs), because users are able
to store their NFT objects directly in their accounts and transact
peer-to-peer. Please see the [blog post about resources](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e)
to understand why they are perfect for digital assets like NBA Top Shot Moments.

### Contributing

If you see an issue with the code for the contracts, the transactions, scripts,
documentation, or anything else, please do not hesitate to make an issue or
a pull request with your desired changes. This is an open source project
and we welcome all assistance from the community!

## Top Shot Contract Addresses

`TopShot.cdc`: This is the main Top Shot smart contract that defines
the core functionality of the NFT.

| Network | Contract Address     |
|---------|----------------------|
| Testnet | [`0x877931736ee77cff`](https://contractbrowser.com/A.877931736ee77cff.TopShot) |
| Mainnet | [`0x0b2a3299cc857e29`](https://contractbrowser.com/A.0b2a3299cc857e29.TopShot) |

> **Note**: Bridged Top Shot Moments are available on Flow EVM. See the [EVM Bridging README](evm-bridging/README.md) for contract addresses and details.

`MarketTopShot.cdc`: This is the top shot marketplace contract that allows users
to buy and sell their NFTs.

| Network | Contract Address     |
|---------|----------------------|
| Testnet | [`0x547f177b243b4d80`](https://contractbrowser.com/A.547f177b243b4d80.TopShotMarketV3) |
| Mainnet | [`0xc1e4f4f4c4257510`](https://contractbrowser.com/A.c1e4f4f4c4257510.TopShotMarketV3) |

### Non Fungible Token Standard

The NBA Top Shot contracts utilize the [Flow NFT standard](https://github.com/onflow/flow-nft)
which is equivalent to ERC-721 or ERC-1155 on Ethereum. If you want to build an NFT contract,
please familiarize yourself with the Flow NFT standard before starting and make sure you utilize it 
in your project in order to be interoperable with other tokens and contracts that implement the standard.

### Top Shot Marketplace contract

The top shot marketplace contract was designed in the very early days of Cadence, and therefore
uses some language features that are NOT RECOMMENDED to use by newer projects.
For example, the marketplace contract stores the moments that are for sale in the sale collection.
The correct way to manage this in cadence is to give a collection capability to the market collection
so that the nfts do not have to leave the main collection when going up for sale. The sale collection
would use this capability to withdraw moments from the main collection when they are purchased.

This way, any other smart contracts that need to check a user's account for what they own only need to check
the main collection and not all of the sale collections that could possibly be in their account.

See the [kitty items marketplace contract](https://github.com/onflow/kitty-items/blob/master/cadence/contracts/KittyItemsMarket.cdc) for an example of the current best practices when
it comes to marketplace contracts.

## Directory Structure

The directories here are organized into contracts, scripts, and transactions.

Contracts contain the source code for the Top Shot contracts that are deployed to Flow.

Scripts contain read-only transactions to get information about
the state of someone's Collection or about the state of the TopShot contract.

Transactions contain the transactions that various admins and users can use
to perform actions in the smart contract like creating plays and sets,
minting Moments, and transferring Moments.

 - `contracts/` : Where the Top Shot related smart contracts live.
 - `transactions/` : This directory contains all the transactions and scripts
 that are associated with the Top Shot smart contracts.
 - `transactions/scripts/`  : This contains all the read-only Cadence scripts 
 that are used to read information from the smart contract
 or from a resource in account storage.
 - `lib/` : This directory contains packages for specific programming languages
 to be able to read copies of the Top Shot smart contracts, transaction templates,
 and scripts. Also contains automated tests written in those languages. Currently,
 Go is the only language that is supported, but we are hoping to add javascript
 and other languages soon. See the README in `lib/go/` for more information
 about how to use the Go packages.
 - `evm-bridging/` : This directory contains the smart contracts and transactions
 for the EVM bridging functionality.

## Top Shot Contract Overview

Each Top Shot Moment NFT represents a play from a game in the NBA season.
Plays are grouped into sets which usually have some overarching theme,
like rarity or the type of the play. 

A set can have one or more plays in it and the same play can exist in
multiple sets, but the combination of a play and a set, 
otherwise known as an edition, is unique and is what classifies an individual Moment.

Multiple Moments can be minted from the same edition and each receives a 
serial number that indicates where in the edition it was minted.

Each Moment is a resource object 
with roughly the following structure:

```cadence
pub resource Moment {

    // global unique Moment ID
    pub let id: UInt64
    
    // the ID of the Set that the Moment comes from
    pub let setID: UInt32

    // the ID of the Play that the Moment references
    pub let playID: UInt32

    // the place in the edition that this Moment was minted
    // Otherwise known as the serial number
    pub let serialNumber: UInt32
}
```

The other types that are defined in `TopShot` are as follows:

 - `Play`: A struct type that holds most of the metadata for the Moments.
    All plays in Top Shot will be stored and modified in the main contract.
 - `SetData`: A struct that contains constant information about sets in Top Shot
    like the name, the series, the id, and such.
 - `Set`: A resource that contains variable data for sets 
    and the functionality to modify sets,
    like adding and retiring plays, locking the set, and minting Moments from
    the set.
 - `MomentData`: A struct that contains the metadata associated with a Moment.
    instances of it will be stored in each Moment.
 - `NFT`: A resource type that is the NFT that represents the Moment
    highlight a user owns. It stores its unique ID and other metadata. This
    is the collectible object that the users store in their accounts.
 - `Collection`: Similar to the `NFTCollection` resource from the NFT
    example, this resource is a repository for a user's Moments.  Users can
    withdraw and deposit from this collection and get information about the 
    contained Moments.
 - `Admin`: This is a resource type that can be used by admins to perform
    various actions in the smart contract like starting a new series, 
    creating a new play or set, and getting a reference to an existing set.
 - `QuerySetData`: A struct that contains the metadata associated with a set.
    This is currently the only way to access the metadata of a set.
    Can be accessed by calling the public function in the `TopShot` smart contract called `getSetData(setID)`

Metadata structs associated with plays and sets are stored in the main smart contract
and can be queried by anyone. For example, If a player wanted to find out the 
name of the team that the player represented in their Moment plays for, they
would call a public function in the `TopShot` smart contract 
called `getPlayMetaDataByField`, providing, from their owned Moment,
the play and field that they want to query. 
They can do the same with information about sets by calling `getSetData` with the setID.

The power to create new plays, sets, and Moments rests 
with the owner of the `Admin` resource.

Admins create plays and sets which are stored in the main smart contract,
Admins can add plays to sets to create editions, which Moments can be minted from.

Admins also can restrict the abilities of sets and editions to be further expanded.
A set begins as being unlocked, which means plays can be added to it,
but when an admin locks the set, plays can no longer be added to it. 
This cannot be reversed.

The same applies to editions. Editions start out open, and an admin can mint as
many Moments they want from the edition. When an admin retires the edition, 
Moments can no longer be minted from that edition. This cannot be reversed.

These rules are in place to ensure the scarcity of sets and editions
once they are closed.

Once a user owns a Moment object, that Moment is stored directly 
in their account storage via their `Collection` object. The collection object
contains a dictionary that stores the Moments and gives utility functions
to move them in and out and to read data about the collection and its Moments.

## How to Deploy and Test the Top Shot Contract in VSCode

The first step for using any smart contract is deploying it to the blockchain,
or emulator in our case. Do these commands in vscode. 
See the [vscode extension instructions](https://docs.onflow.org/vscode-extension/) 
to learn how to use it.

 1. Start the emulator with the `Run emulator` vscode command.
 2. Open the `NonFungibleToken.cdc` file from the [flow-nft repo](https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc) and the `TopShot.cdc` file.  Feel free to read as much as you want to familiarize yourself with the contracts.
 3. In `NonFungibleToken.cdc`, click the `deploy contract to account` 
 above the `Dummy` contract at the bottom of the file to deploy it.
 This also deploys the `NonFungbleToken` interface.
 4. In `TopShot.cdc`, make sure it imports `NonFungibleToken` from the account you deployed it to.
 5. Click the `deploy contract to account` button that appears over the 
    `TopShot` contract declaration to deploy it to a new account.

This deploys the contract code. It also runs the contract's
`init` function, which initializes the contract storage variables,
stores the `Collection` and `Admin` resources 
in account storage, and creates links to the `Collection`.

As you can see, whenever we want to call a function, read a field,
or use a type that is defined in a smart contract, we simply import
that contract from the address it is defined in and then use the imported
contract to access those type definitions and fields.

After the contracts have been deployed, you can run the sample transactions
to interact with the contracts. The sample transactions are meant to be used
in an automated context, so they use transaction arguments and string template
fields. These make it easier for a program to use and interact with them.
If you are running these transactions manually in the Flow Playground or
vscode extension, you will need to remove the transaction arguments and
hard code the values that they are used for. 

You also need to replace the `ADDRESS` placeholders with the actual Flow 
addresses that you want to import from.

## How to Run Transactions Against the Top Shot Contract
This repository contains sample transactions that can be executed against the Top Shot contract either via Flow CLI or using VSCode. This section will describe how to create a new Top Shot set on the Flow emulator.

#### Send Transaction with Flow CLI
1. Install the [Flow CLI and emulator](https://docs.onflow.org/flow-cli/install/)
2. Initialize the flow emulator configuration.  
`flow emulator --init`
3. [Configure the contracts & deployment section](https://docs.onflow.org/flow-cli/configuration/) of the initialized flow.json file. 
4. Start the emulator.  
`flow emulator`
5. On TopShot.cdc substitute the placeholder address `import NonFungibleToken from 0xNFTADDRESS` with the address the NonFungibleToken was deployed to. This will be the emulator address found in the accounts object of the initialized flow.json.
6. Deploy the NonFungibleToken & TopShot contracts to the flow emulator.  
`flow project deploy --network=emulator`
7. Use the Flow CLI to execute transactions against the emulator. This transaction creates a new set on the flow emulator called "new set name".   
`flow transactions send ./transactions/admin/create_set.cdc "new set name"`

#### Send Transaction with VSCode
1. [Install and configure](https://docs.onflow.org/vscode-extension/) VSCode extension.
2. Start flow emulator by running the VSCode command.  
`Cadence: Run emulator`
3. On TopShot.cdc substitute the placeholder address `import NonFungibleToken from 0xNFTADDRESS` with the address the NonFungibleToken was deployed to. Typically, this will be the service account address.
4. Above the contract definition `pub contract interface NonFungibleToken` you will see and press text to deploy this contract to the service account.
5. Above the contract definition `pub contract TopShot: NonFungibleToken` you will see and press text to deploy this contract to the service account.
6. Navigate to `transactions/admin/create_set.cdc` Substitute the placeholder address `import TopShot from 0xNFTADDRESS` with the address TopShot.cdc was deployed to.
7. Transactions run in VSCode cannot take arguments. Replace the line `transaction(setName : String)` with `transaction()` and find every instance of setName in the contract and replace with a hard coded value like "new set name".
8. Above the line `transaction()` you will now see and press the text `Send signed by service account`. This will create a set on the flow emulator called "new set name".

## How to run the automated tests for the contracts

See the `lib/go` README for instructions about how to run the automated tests.

## Instructions for creating plays and minting moments

A common order of creating new Moments would be

1. Creating new plays with `transactions/admin/create_play.cdc`.
2. Creating new sets with `transactions/admin/create_set.cdc`.
3. Adding plays to the sets to create editions
   with `transactions/admin/add_plays_to_set.cdc`.
4. Minting Moments from those editions with 
   `transactions/admin/batch_mint_moment.cdc`.

You can also see the scripts in `transactions/scripts` to see how information
can be read from the real Top Shot smart contract deployed on the
Flow Beta Mainnet. 

### Accessing the NBA Top Shot smart contract on Flow Beta Mainnet

The Flow Beta mainnet is still a work in progress and still has
a limited number of accounts that can run nodes and submit transactions.
Anyone can read data from the contract by running any of the scripts in the 
`transactions` directory using one of the public access nodes.

For example, this is how you would query the total supply via the Flow CLI.

`flow scripts execute transactions/scripts/get_totalSupply.cdc --host access.mainnet.nodes.onflow.org:9000`

Make sure that the import address in the script is correct for mainnet.

## NBA Top Shot Events

The smart contract and its various resources will emit certain events
that show when specific actions are taken, like transferring an NFT. This
is a list of events that can be emitted, and what each event means.
You can find definitions for interpreting these events in Go by seeing
the `lib/go/events` package.
    

#### Events for plays
- `pub event PlayCreated(id: UInt32, metadata: {String:String})`
    
    Emitted when a new play has been created and added to the smart contract by an admin.

- `pub event NewSeriesStarted(newCurrentSeries: UInt32)`
    
    Emitted when a new series has been triggered by an admin.

#### Events for set-Related actions

- `pub event SetCreated(setID: UInt32, series: UInt32)`
    
    Emitted when a new set is created.
    
- `pub event PlayAddedToSet(setID: UInt32, playID: UInt32)`
    
    Emitted when a new play is added to a set.
    
- `pub event PlayRetiredFromSet(setID: UInt32, playID: UInt32, numMoments: UInt32)`

    Emitted when a play is retired from a set. Indicates that 
    that play/set combination and cannot be used to mint moments any more.
    
- `pub event SetLocked(setID: UInt32)`

    Emitted when a set is locked, meaning plays cannot be added.
    
- `pub event MomentMinted(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32)`

    Emitted when a Moment is minted from a set. The `momentID` is the global unique identifier that differentiates a Moment from all other Top Shot Moments in existence. The `serialNumber` is the identifier that differentiates the Moment within an Edition. It corresponds to the place in that edition where it was minted. 

#### Events for Collection-related actions
    
- `pub event Withdraw(id: UInt64, from: Address?)`

    Emitted when a Moment is withdrawn from a collection. `id` refers to the global Moment ID. If the collection was in an account's storage when it was withdrawn, `from` will show the address of the account that it was withdrawn from. If the collection was not in storage when the Moment was withdrawn, `from` will be `nil`.

- `pub event Deposit(id: UInt64, to: Address?)`

    Emitted when a Moment is deposited into a collection. `id` refers to the global Moment ID. If the collection was in an account's storage when it was deposited, `to` will show the address of the account that it was deposited to. If the collection was not in storage when the Moment was deposited, `to` will be `nil`.

### Top Shot NFT Metadata

NFT metadata is represented in a flexible and modular way using the [standard proposed in FLIP-0636](https://github.com/onflow/flow/blob/master/flips/20210916-nft-metadata.md). The Top Shot contract implements the [`MetadataViews.Resolver`](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L21) interface, which standardizes the display of Top Shot NFT in accordance with FLIP-0636. The Top Shot contract also defines a custom view of moment play data called TopShotMomentMetadataView.

## NBA Top Shot Packs

NBA Top Shot packs are currently off-chain and not managed by the NBA Top Shot smart contract. Moments in a pack are minted on-chain, and assembled into a pack for purchase off-chain on the NBA Top Shot platform. When a collector purchases a pack, the moments within the pack are transferred directly to this collector on-chain. The NBA Top Shot smart contract has no knowledge of packs.

## NBA Top Shot Marketplace

The `contracts/MarketTopShot.cdc` contract allows users to create a sale object
in their account to sell their Moments.

When a user wants to sell their Moment, they create a sale collection
in their account and specify a beneficiary of a cut of the sale if they wish.

A Top Shot Sale Collection contains a capability to the owner's moment collection
that allows the sale to withdraw the moment when it is purchased.

When another user wants to buy the Moment that is for sale, they simply send 
their fungible tokens to the `purchase` function 
and if they sent the correct amount, they get the Moment back.

#### Events for Market-related actions

- `pub event MomentListed(id: UInt64, price: UFix64, seller: Address?)`
   
   Emitted when a user lists a Moment for sale in their SaleCollection.

- `pub event MomentPriceChanged(id: UInt64, newPrice: UFix64, seller: Address?)`

   Emitted when a user changes the price of their Moment.

- `pub event MomentPurchased(id: UInt64, price: UFix64, seller: Address?)`

   Emitted when a user purchases a Moment that is for sale.

- `pub event MomentWithdrawn(id: UInt64, owner: Address?)`

   Emitted when a seller withdraws their Moment from their SaleCollection.

- `pub event CutPercentageChanged(newPercent: UFix64, seller: Address?)`

   Emitted when a seller changes the percentage cut that is taken
   from their sales and sent to a beneficiary.

### Different Versions of the Market Contract

There are two versions of the Top Shot Market Contract.
`TopShotMarket.cdc` is the original version of the contract that was used
for the first set of sales in the p2p marketplace, but we made improvements
to it which are now in `TopShotMarketV3.cdc`.

There is also a V2 version that was deployed to mainnet, but will never be used.

Both versions define a `SaleCollection` resource that users store in their account.
The resource manages the logic of the sale like listings, de-listing, prices, and 
purchases. The first version actually stores the moments that are for sale, but 
we realized that this causes issues if other contracts need to access a user's
main collection to see what they own. We created the second version to simply
store a capability to the owner's moment collection so that the moments 
that are for sale do not need to be removed from the main collection to be
put up for sale. In this version, when a moment is purchased, the sale collection
uses the capability to withdraw the moment from the main collection and 
returns it to the buyer.

The new version of the market contract is currently NOT DEPLOYED to mainnet,
but it will be deployed and utilized in the near future.

## TopShot contract improvement
Some improvements were made to the Topshot contract to reflect some cadence best practices and fix a bug.
In-depth explanation on the changes and why we made them can be found in our [Blog Post](https://blog.nbatopshot.com/posts/nba-top-shot-smart-contract-improvements) 

## TopShot Locking Contract Overview

Contract Name: `TopShotLocking`

TopShot NFTs can be locked for a duration meaning they are unable to be withdrawn, listed for sale, burned, etc. 
In the NBA TopShot product users are rewarded for locking their moments.

An NFT may be unlocked after the lock duration has passed, or the contract admin has marked it eligible for unlocking.

The moment is locked even if expiry has passed until the owner requests it be unlocked.
The address which owns the locked NFT must make an unlocking transaction once it is eligible.

### Available functions

#### lockNFT
`pub fun lockNFT(nft: @NonFungibleToken.NFT, expiryTimestamp: UFix64): @NonFungibleToken.NFT`  
Takes a TopShot.NFT resource and sets it in the lockedNFTs dictionary, the value of the entry is the expiry timestamp  
Params:  
`nft` - a `NonFungibleToken.NFT` resource, but must conform to `TopShot.NFT` asserted at runtime  
`expiryTimestamp` - the unix timestamp in seconds at which this nft can be unlocked

Example:
```cadence
let collectionRef = acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

let ONE_YEAR_IN_SECONDS: UFix64 = UFix64(31536000)
collectionRef.lock(id: 1, duration: ONE_YEAR_IN_SECONDS)
```

#### unlockNFT
`pub fun unlockNFT(nft: @NonFungibleToken.NFT): @NonFungibleToken.NFT`  
Takes a `NonFungibleToken.NFT` resource and attempts to remove it from the lockedNFTs dictionary.
This function will panic if the nft lock has not expired or been overridden by an admin.
Params:  
`nft` - a `NonFungibleToken.NFT` resource 

Example:
```cadence
let collectionRef = acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

collectionRef.unlock(id: 1)
```

#### isLocked
`pub fun isLocked(nftRef: &NonFungibleToken.NFT): Bool`  
Returns true if the moment is locked

#### getLockExpiry
`pub fun getLockExpiry(nftRef: &NonFungibleToken.NFT): UFix64`  
Returns the unix timestamp when the nft is eligible for unlock

### Admin Functions

#### markNFTUnlockable
`pub fun markNFTUnlockable(nftRef: &NonFungibleToken.NFT)`  
Places the nft id in an unlockableNFTs dictionary. This dictionary is checked in the `unlockNFT` function and bypasses the `expiryTimestamp`
Params:  
`nftRef` - a reference to an `NonFungibleToken.NFT` resource  

Example:
```cadence
let adminRef: &NFTLocking.Admin

prepare(acct: AuthAccount) {
    // Set TopShotLocking admin ref
    self.adminRef = acct.borrow<&NFTLocking.Admin>(from: /storage/TopShotLockingAdmin)!
}

execute {
    // Set Top Shot NFT Owner collection ref
    let owner = getAccount(0x179b6b1cb6755e31)
    let collectionRef = owner.getCapability(/public/MomentCollection).borrow<&{TopShot.MomentCollectionPublic}>()
        ?? panic("Could not reference owner's moment collection")

    let nftRef = collectionRef.borrowNFT(id: 1)
    self.adminRef.markNFTUnlockable(nftRef: nftRef)
}
```
### Contracts Honoring the Lock

- TopShot `withdraw`
- MarketTopShot relies on the NFT being withdrawn first so no additional code is needed
- TopShotMarketV3 `listForSale`

## License 

The works in these folders 
/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc 
/dapperlabs/nba-smart-contracts/blob/master/contracts/MarketTopShot.cdc 
/dapperlabs/nba-smart-contracts/blob/master/contracts/MarketTopShotV3.cdc 
/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotAdminReceiver.cdc 
/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotShardedCollection.cdc 

are under the Unlicense
https://github.com/onflow/flow-NFT/blob/master/LICENSE





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/scripts/get_sale_set_id.cdc

```
import Market from 0xMARKETADDRESS

// This script gets the setID of a moment in an account's sale collection
// by looking up its unique ID

// Parameters:
//
// sellerAddress: The Flow Address of the account whose sale collection needs to be read
// momentID: The unique ID for the moment whose data needs to be read

// Returns: UInt32
// The setID of moment with specified ID

access(all) fun main(sellerAddress: Address, momentID: UInt64): UInt32 {

    let saleRef =  getAccount(sellerAddress).capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
        ?? panic("Could not get public sale reference")

    let token = saleRef.borrowMoment(id: momentID)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return data.setID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/subeditions/get_all_subeditions.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns an array of all the plays
// that have ever been created for Top Shot

// Returns: [TopShot.Play]
// array of all plays created for Topshot

access(all) fun main(): &[TopShot.Subedition] {

    return TopShot.getAllSubeditions()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/setup_switchboard_account.cdc

```
import FungibleTokenSwitchboard from 0xFUNGIBLETOKENSWITCHBOARDADDRESS
import FungibleToken from 0xFUNGIBLETOKENADDRESS

// This transaction is a template for a transaction that could be used by
// anyone to to add a Switchboard resource to their account so that they can
// receive multiple fungible tokens using a single {FungibleToken.Receiver}
transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {

        // Check if the account already has a Switchboard resource, return early if so
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>(from: FungibleTokenSwitchboard.StoragePath) != nil {
            return
        }

        // Create a new Switchboard resource and put it into storage
        signer.storage.save(
            <- FungibleTokenSwitchboard.createSwitchboard(),
            to: FungibleTokenSwitchboard.StoragePath
        )

        // Clear existing Capabilities at canonical paths
        signer.capabilities.unpublish(FungibleTokenSwitchboard.ReceiverPublicPath)
        signer.capabilities.unpublish(FungibleTokenSwitchboard.PublicPath)

        // Create a public capability to the Switchboard exposing the deposit
        // function through the {FungibleToken.Receiver} interface
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)

        // Create a public capability to the Switchboard exposing both the
        // {FungibleTokenSwitchboard.SwitchboardPublic} and the
        // {FungibleToken.Receiver} interfaces
        let switchboardPublicCap = signer.capabilities.storage.issue<&{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(switchboardPublicCap, at: FungibleTokenSwitchboard.PublicPath)

    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShotShardedCollection.cdc

```
/*
    Description: Central Collection for a large number of TopShot
                 NFTs

    authors: Joshua Hannan joshua.hannan@dapperlabs.com
             Bastian Muller bastian@dapperlabs.com

    This resource object looks and acts exactly like a TopShot MomentCollection
    and (in a sense) shouldn’t have to exist! 

    The problem is that Cadence currently has a limitation where 
    storing more than ~100k objects in a single dictionary or array can fail.

    Most MomentCollections are likely to be much, much smaller than this, 
    and that limitation will be removed in a future iteration of Cadence, 
    so most people will never need to worry about it.

    However! The main TopShot administration account DOES need to worry about it
    because it frequently needs to mint >10k Moments for sale, 
    and could easily end up needing to hold more than 100k Moments at one time.
    
    Until Cadence gets an update, that leaves us in a bit of a pickle!

    This contract bundles together a bunch of MomentCollection objects 
    in a dictionary, and then distributes the individual Moments between them 
    while implementing the same public interface 
    as the default MomentCollection implementation. 

    If we assume that Moment IDs are uniformly distributed, 
    a ShardedCollection with 10 inner Collections should be able 
    to store 10x as many Moments (or ~1M).

    When Cadence is updated to allow larger dictionaries, 
    then this contract can be retired.

*/

import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import ViewResolver   from 0xVIEWRESOLVERADDRESS

access(all) contract TopShotShardedCollection {

    // ShardedCollection stores a dictionary of TopShot Collections
    // A Moment is stored in the field that corresponds to its id % numBuckets
    access(all) resource ShardedCollection: TopShot.MomentCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver {
        
        // Dictionary of topshot collections
        access(contract) var collections: @{UInt64: TopShot.Collection}

        // The number of buckets to split Moments into
        // This makes storage more efficient and performant
        access(all) let numBuckets: UInt64

        access(all) fun forEachID(_ f: fun (UInt64): Bool): Void {
            for key in self.collections.keys {
                 let col = &self.collections[key] as &TopShot.Collection?
                 col?.forEachID(f)
            }
        }


        init(numBuckets: UInt64) {
            self.collections <- {}
            self.numBuckets = numBuckets

            // Create a new empty collection for each bucket
            var i: UInt64 = 0
            while i < numBuckets {

                self.collections[i] <-! TopShot.createEmptyCollection(nftType: Type<@TopShot.NFT>()) as! @TopShot.Collection

                i = i + UInt64(1)
            }
        }

        // withdraw removes a Moment from one of the Collections 
        // and moves it to the caller
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            post {
                result.id == withdrawID: "The ID of the withdrawn NFT is incorrect"
            }
            // Find the bucket it should be withdrawn from
            let bucket = withdrawID % self.numBuckets

            // Withdraw the moment
            let token <- self.collections[bucket]?.withdraw(withdrawID: withdrawID)!
            
            return <-token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: ids: an array of the IDs to be withdrawn from the Collection
        //
        // Returns: @NonFungibleToken.Collection a Collection containing the moments
        //          that were withdrawn
        access(NonFungibleToken.Withdraw) fun batchWithdraw(ids: [UInt64]): @{NonFungibleToken.Collection} {
            var batchCollection <- TopShot.createEmptyCollection(nftType: Type<@TopShot.NFT>())
            
            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            return <-batchCollection
        }

        // deposit takes a Moment and adds it to the Collections dictionary
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {

            // Find the bucket this corresponds to
            let bucket = token.id % self.numBuckets

            let collectionRef = (&self.collections[bucket] as &TopShot.Collection?)!

            // Deposit the nft into the bucket
            collectionRef.deposit(token: <-token)
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection}) {
            let keys = tokens.getIDs()

            // Iterate through the keys in the Collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        access(all) view fun getIDs(): [UInt64] {
            var ids: [UInt64] = []
            // Concatenate IDs in all the Collections
            for key in self.collections.keys {
                let collectionIDs = self.collections[key]?.getIDs() ?? []
                ids = ids.concat(collectionIDs)
            }
            return ids
        }

        // borrowNFT Returns a borrowed reference to a Moment in the Collection
        // so that the caller can read data and call methods from it
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {

            // Get the bucket of the nft to be borrowed
            let bucket = id % self.numBuckets

            // Find NFT in the collections and borrow a reference
            return self.collections[bucket]?.borrowNFT(id)!
        }

        // borrowMoment Returns a borrowed reference to a Moment in the Collection
        // so that the caller can read data and call methods from it
        // They can use this to read its setID, playID, serialNumber,
        // or any of the setData or Play Data associated with it by
        // getting the setID or playID and reading those fields from
        // the smart contract
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        access(all) view fun borrowMoment(id: UInt64): &TopShot.NFT? {

            // Get the bucket of the nft to be borrowed
            let bucket = id % self.numBuckets

            return self.collections[bucket]?.borrowMoment(id: id)!
        }

        // Return a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@TopShot.NFT>()] = true
            return supportedTypes
        }

        // Return whether or not the given type is accepted by the collection
        // A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@TopShot.NFT>() {
                return true
            }
            return false
        }

        // Return the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.getIDs().length
        }

    }

    // Creates an empty ShardedCollection and returns it to the caller
    access(all) fun createEmptyCollection(numBuckets: UInt64): @ShardedCollection {
        return <-create ShardedCollection(numBuckets: numBuckets)
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/admin/deploy/create_new_account_with_coa_and_flow_deposit.cdc

```
import Crypto
import "FungibleToken"
import "FlowToken"
import "EVM"

/// Creates a new flow account with single full-weight key, initial FLOW tokens funding, and
/// a COA EVM account in storage.
///
/// @param pubKey: String - public key to be added to the account
/// @param amount: UFix64 - amount of FLOW tokens to be transferred to the new account
///
transaction(pubKey: String, amount: UFix64) {
    let sentVault: @FlowToken.Vault
    let receiverRef: &{FungibleToken.Receiver}

    prepare(signer: auth(BorrowValue) &Account) {
        // Create new account
        let account = Account(payer: signer)

        // Add public key with full weight, SHA2_256, and ECDSA_P256
        account.keys.add(
            publicKey: PublicKey(
                publicKey: pubKey.decodeHex(),
                signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
            ),
            hashAlgorithm: HashAlgorithm.SHA2_256,
            weight: 1000.0
        )

        // Set COA paths
        let storagePath = StoragePath(identifier: "evm")!
        let publicPath = PublicPath(identifier: "evm")!

        // Create and save new COA in new account's storage
        account.storage.save<@EVM.CadenceOwnedAccount>(<- EVM.createCadenceOwnedAccount(), to: storagePath)

        // Issue and publish capability to the COA
        account.capabilities.unpublish(publicPath)
        account.capabilities.publish(account.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath), at: publicPath)

        // Borrow reference to the signer's FLOW token vault and withdraw provided amount
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")
        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault

        // Borrow reference to the new account's FLOW tokens receiver
        self.receiverRef = account.capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            ?? panic("Could not borrow a Receiver reference to the FlowToken Vault in account ")
    }

    execute {
        // Deposit the withdrawn tokens in the new account's receiver
        self.receiverRef.deposit(from: <- self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_metadata.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the metadata associated with a moment
// in a collection by looking up its playID and then searching
// for that play's metadata in the TopShot contract

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: {String: String} 
// A dictionary of all the play metadata associated
// with the specified moment

access(all) fun main(account: Address, id: UInt64): {String: String} {

    // get the public capability for the owner's moment collection
    // and borrow a reference to it
    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    // Borrow a reference to the specified moment
    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    // Get the moment's metadata to access its play and Set IDs
    let data = token.data

    // Use the moment's play ID 
    // to get all the metadata associated with that play
    let metadata = TopShot.getPlayMetaData(playID: data.playID) ?? panic("Play doesn't exist")

    log(metadata)

    return metadata
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/purchase_moment.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS

// This transaction is for a user to purchase a moment that another user
// has for sale in their sale collection

// Parameters
//
// sellerAddress: the Flow address of the account issuing the sale of a moment
// tokenID: the ID of the moment being purchased
// purchaseAmount: the amount for which the user is paying for the moment; must not be less than the moment's price

transaction(sellerAddress: Address, tokenID: UInt64, purchaseAmount: UFix64) {

    // Local variables for the topshot collection object and token provider
    let collectionRef: &TopShot.Collection
    let providerRef: auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault
    
    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the signer's collection
        self.collectionRef = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow reference to the Moment Collection")

        // borrow a reference to the signer's fungible token Vault
        self.providerRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)!
    }

    execute {

        // withdraw tokens from the signer's vault
        let tokens <- self.providerRef.withdraw(amount: purchaseAmount) as! @DapperUtilityCoin.Vault

        // get the seller's public account object
        let seller = getAccount(sellerAddress)

        // borrow a public reference to the seller's sale collection
        let topshotSaleCollection = seller.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
            ?? panic("Could not borrow public sale reference")
    
        // purchase the moment
        let purchasedToken <- topshotSaleCollection.purchase(tokenID: tokenID, buyTokens: <-tokens)

        // deposit the purchased moment into the signer's collection
        self.collectionRef.deposit(token: <-purchasedToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_fast_break.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(id: String): FastBreakV1.FastBreakGame? {

    return FastBreakV1.getFastBreakGame(id: id)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/.github/ISSUE_TEMPLATE/pull_request_template.md

Closes: #???

## Description

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review.
-->

______

For contributor use:

- [ ] Targeted PR against `master` branch
- [ ] Linked to Github issue with discussion and accepted design OR link to spec that describes this work.
- [ ] Code follows the [standards mentioned here](https://github.com/onflow/flow-nft/blob/master/CONTRIBUTING.md#styleguides).
- [ ] Updated relevant documentation 
- [ ] Re-reviewed `Files changed` in the Github PR explorer
- [ ] Added appropriate labels 




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/create_start_sale.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import NonFungibleToken from 0xNFTADDRESS

/// This transaction creates a V3 Sale Collection
/// in a user's account and lists a Moment for Sale in that collection
/// If a user already has a V3 Sale Collection
/// the transaction only lists the moment for sale
///
/// When creating a V3 Sale Collection, if the user already has a V1 Sale Collection,
/// the transaction will create and store a provider capability for that V1 Sale Collection
/// to be used with the V3 Sale Collection

transaction(tokenReceiverPath: PublicPath, beneficiaryAccount: Address, cutPercentage: UFix64, momentID: UInt64, price: UFix64) {

    prepare(acct: auth(Storage, Capabilities) &Account) {
        // check to see if a v3 sale collection already exists
        if acct.storage.borrow<&TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) == nil {
            // If the V3 Sale Collection does not exist, set up a new one

            // get the fungible token capabilities for the owner and beneficiary
            let ownerCapability = acct.capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)
            if !ownerCapability.check() {
                panic("Could not get the owner's FungibleToken.Receiver capability from ".concat(tokenReceiverPath.toString()))
            }
            let beneficiaryCapability = getAccount(beneficiaryAccount).capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)
            if !beneficiaryCapability.check() {
                panic("Could not get the beneficiary's FungibleToken.Receiver capability from ".concat(tokenReceiverPath.toString()))
            }

            // Get the owner's TopShot Collection Provider Capability that
            // allows the V3 sale collection to withdraw when sales are made
            var ownerCollection = acct.storage.copy<Capability<auth(NonFungibleToken.Withdraw, NonFungibleToken.Update) &TopShot.Collection>>(from: /storage/MomentCollectionCap)
            if ownerCollection == nil {
                // If the moment collection capabilitity does not already exist,
                // Issue a new one and store it in the standard private moment collection capability path
                ownerCollection = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw, NonFungibleToken.Update) &TopShot.Collection>(/storage/MomentCollection)
                acct.storage.save(ownerCollection, to: /storage/MomentCollectionCap)
            }

            // get a capability for the v1 collection
            // Only accounts that existed before the V3 Sale Collection contract was deployed
            // will have this
            var v1SaleCollection = acct.storage.copy<Capability<auth(Market.Create, NonFungibleToken.Withdraw, Market.Update) &Market.SaleCollection>>(from: /storage/topshotSaleCollectionCap)
            if v1SaleCollection == nil {
                // If the account doesn't have a V1 Sale Collection capability already,
                // first check if they even have a V1 Sale Collection at all
                if acct.storage.borrow<auth(Market.Create) &Market.SaleCollection>(from: /storage/topshotSaleCollection) != nil {
                    // If they have a V1 Sale Collection, issue a capability for it
                    // and store it in storage
                    v1SaleCollection = acct.capabilities.storage.issue<auth(Market.Create, NonFungibleToken.Withdraw, Market.Update) &Market.SaleCollection>(/storage/topshotSaleCollection)
                    acct.storage.save(v1SaleCollection, to: /storage/topshotSaleCollectionCap)
                }
            }

            // create a new sale collection
            // V1SaleCollection will still be `nil` here if a V1 Sale Collection
            // did not exist in the authorizer's account
            // We can force-unwrap `ownerCollection` because it was already guaranteed to be non-`nil` above
            let topshotV3SaleCollection <- TopShotMarketV3.createSaleCollection(ownerCollection: ownerCollection!,
                                                                             ownerCapability: ownerCapability,
                                                                             beneficiaryCapability: beneficiaryCapability,
                                                                             cutPercentage: cutPercentage,
                                                                             marketV1Capability: v1SaleCollection)
            
            // save it to storage
            acct.storage.save(<-topshotV3SaleCollection, to: TopShotMarketV3.marketStoragePath)
        
            // create a public link to the sale collection
           acct.capabilities.publish(
                acct.capabilities.storage.issue<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketStoragePath),
                at: TopShotMarketV3.marketPublicPath
            )
        }

        // borrow a reference to the sale
        let topshotSaleCollection = acct.storage.borrow<auth(TopShotMarketV3.Create) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath)
            ?? panic("Could not borrow the owner's Top Shot V3 Sale Collection in storage from ".concat(TopShotMarketV3.marketStoragePath.toString()))
        
        // put the moment up for sale
        topshotSaleCollection.listForSale(tokenID: momentID, price: price)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/mint_and_purchase.cdc

```
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

transaction(sellerAddress: Address, recipient: Address, tokenID: UInt64, purchaseAmount: UFix64) {

    prepare(signer: auth(BorrowValue) &Account) {

        let tokenAdmin = signer
            .storage.borrow<&DapperUtilityCoin.Minter>(from: /storage/dapperUtilityCoinAdmin)
            ?? panic("Signer is not the token admin")


        let mintedVault <- tokenAdmin.mintTokens(amount: purchaseAmount) as! @DapperUtilityCoin.Vault


        let seller = getAccount(sellerAddress)
        let topshotSaleCollection = seller.capabilities.borrow<&TopShotMarketV3.SaleCollection>(TopShotMarketV3.marketPublicPath)
            ?? panic("Could not borrow public sale reference")

        let boughtToken <- topshotSaleCollection.purchase(tokenID: tokenID, buyTokens: <-mintedVault)

        // get the recipient's public account object and borrow a reference to their moment receiver
        let recipient = getAccount(recipient).capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)
            ?? panic("Could not borrow a reference to the moment collection")

        // deposit the NFT in the receivers collection
        recipient.deposit(token: <-boughtToken)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_current_player.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(): UInt64 {

    return FastBreakV1.nextPlayerId
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/scripts/get_sale_percentage.cdc

```
import Market from 0xMARKETADDRESS

// This script gets the percentage cut that beneficiary will take
// of moments in an account's sale collection

// Parameters:
//
// sellerAddress: The Flow Address of the account whose sale collection needs to be read

// Returns: UFix64
// The percentage cut of an account's sale collection

access(all) fun main(sellerAddress: Address): UFix64 {

    let acct = getAccount(sellerAddress)

    let collectionRef = acct.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.cutPercentage
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/stop_sale.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction is for a user to stop a moment sale in their account

// Parameters
//
// tokenID: the ID of the moment whose sale is to be delisted

transaction(tokenID: UInt64) {

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the owner's sale collection
        if let topshotSaleV3Collection = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {

            // cancel the moment from the sale, thereby de-listing it
            topshotSaleV3Collection.cancelSale(tokenID: tokenID)
            
        } else if let topshotSaleCollection = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &Market.SaleCollection>(from: /storage/topshotSaleCollection) {
            // Borrow a reference to the NFT collection in the signers account
            let collectionRef = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
                ?? panic("Could not borrow from MomentCollection in storage")
        
            // withdraw the moment from the sale, thereby de-listing it
            let token <- topshotSaleCollection.withdraw(tokenID: tokenID)

            // deposit the moment into the owner's collection
            collectionRef.deposit(token: <-token)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/subeditions/get_subedition_by_id.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns the full Subedition entity from
// the TopShot smart contract

// Parameters:
//
// subeditionID: The unique ID for the subedition whose data needs to be read

// Returns: Subedition
// struct from TopShot contract

access(all) fun main(subeditionID: UInt32): &TopShot.Subedition {

    let subedititon = TopShot.getSubeditionByID(subeditionID: subeditionID)

    return subedititon
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/subeditions/get_nft_subedition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

access(all) fun main(nftID: UInt64): UInt32 {

    let subedition = TopShot.getMomentsSubedition(nftID: nftID)
                ?? panic("Could not find the specified moment")
    return subedition
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc

```
/*
    Description: Central Smart Contract for NBA TopShot

    This smart contract contains the core functionality for
    NBA Top Shot, created by Dapper Labs

    The contract manages the data associated with all the plays and sets
    that are used as templates for the Moment NFTs

    When a new Play wants to be added to the records, an Admin creates
    a new Play struct that is stored in the smart contract.

    Then an Admin can create new Sets. Sets consist of a public struct that
    contains public information about a set, and a private resource used
    to mint new moments based off of plays that have been linked to the Set.

    The admin resource has the power to do all of the important actions
    in the smart contract. When admins want to call functions in a set,
    they call their borrowSet function to get a reference
    to a set in the contract. Then, they can call functions on the set using that reference.

    In this way, the smart contract and its defined resources interact
    with great teamwork, just like the Indiana Pacers, the greatest NBA team
    of all time.

    When moments are minted, they are initialized with a MomentData struct and
    are returned by the minter.

    The contract also defines a Collection resource. This is an object that
    every TopShot NFT owner will store in their account
    to manage their NFT collection.

    The main Top Shot account will also have its own Moment collections
    it can use to hold its own moments that have not yet been sent to a user.

    Note: All state changing functions will panic if an invalid argument is
    provided or one of its pre-conditions or post conditions aren't met.
    Functions that don't modify state will simply return 0 or nil
    and those cases need to be handled by the caller.

    It is also important to remember that
    The Golden State Warriors blew a 3-1 lead in the 2016 NBA finals.

*/

import FungibleToken from 0xFUNGIBLETOKENADDRESS
import NonFungibleToken from 0xNFTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS
import ViewResolver from 0xVIEWRESOLVERADDRESS
import CrossVMMetadataViews from 0xCROSSVMMETADATAVIEWSADDRESS
import EVM from 0xEVMADDRESS

access(all) contract TopShot: NonFungibleToken {
    // -----------------------------------------------------------------------
    // TopShot deployment variables
    // -----------------------------------------------------------------------

    // The network the contract is deployed on
    access(all) view fun Network(): String { return ${NETWORK} }

    // The address to which royalties should be deposited
    access(all) view fun RoyaltyAddress(): Address { return 0xTOPSHOTROYALTYADDRESS }

    // The path to the Subedition Admin resource belonging to the Account
    // which the contract is deployed on
    access(all) view fun SubeditionAdminStoragePath(): StoragePath { return /storage/TopShotSubeditionAdmin}

    // -----------------------------------------------------------------------
    // TopShot contract Events
    // -----------------------------------------------------------------------

    // Emitted when a new Play struct is created
    access(all) event PlayCreated(id: UInt32, metadata: {String: String})
    // Emitted when a new series has been triggered by an admin
    access(all) event NewSeriesStarted(newCurrentSeries: UInt32)

    // Events for Set-Related actions
    //
    // Emitted when a new Set is created
    access(all) event SetCreated(setID: UInt32, series: UInt32)
    // Emitted when a new Play is added to a Set
    access(all) event PlayAddedToSet(setID: UInt32, playID: UInt32)
    // Emitted when a Play is retired from a Set and cannot be used to mint
    access(all) event PlayRetiredFromSet(setID: UInt32, playID: UInt32, numMoments: UInt32)
    // Emitted when a Set is locked, meaning Plays cannot be added
    access(all) event SetLocked(setID: UInt32)
    // Emitted when a Moment is minted from a Set
    access(all) event MomentMinted(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32, subeditionID: UInt32)

    // Events for Collection-related actions
    //
    // Emitted when a moment is withdrawn from a Collection
    access(all) event Withdraw(id: UInt64, from: Address?)
    // Emitted when a moment is deposited into a Collection
    access(all) event Deposit(id: UInt64, to: Address?)

    // Emitted when a Moment is destroyed
    access(all) event MomentDestroyed(id: UInt64)

    // Emitted when a Subedition is created
    access(all) event SubeditionCreated(subeditionID: UInt32, name: String, metadata: {String: String})

    // Emitted when a Subedition is linked to the specific Moment
    access(all) event SubeditionAddedToMoment(momentID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32)

    // -----------------------------------------------------------------------
    // TopShot contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // Series that this Set belongs to.
    // Series is a concept that indicates a group of Sets through time.
    // Many Sets can exist at a time, but only one series.
    access(all) var currentSeries: UInt32

    // Variable size dictionary of Play structs
    access(self) var playDatas: {UInt32: Play}

    // Variable size dictionary of SetData structs
    access(self) var setDatas: {UInt32: SetData}

    // Variable size dictionary of Set resources
    access(self) var sets: @{UInt32: Set}

    // The ID that is used to create Plays.
    // Every time a Play is created, playID is assigned
    // to the new Play's ID and then is incremented by 1.
    access(all) var nextPlayID: UInt32

    // The ID that is used to create Sets. Every time a Set is created
    // setID is assigned to the new set's ID and then is incremented by 1.
    access(all) var nextSetID: UInt32

    // The total number of Top shot Moment NFTs that have been created
    // Because NFTs can be destroyed, it doesn't necessarily mean that this
    // reflects the total number of NFTs in existence, just the number that
    // have been minted to date. Also used as global moment IDs for minting.
    access(all) var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // TopShot contract-level Composite Type definitions
    // -----------------------------------------------------------------------
    // These are just *definitions* for Types that this contract
    // and other accounts can use. These definitions do not contain
    // actual stored values, but an instance (or object) of one of these Types
    // can be created by this contract that contains stored values.
    // -----------------------------------------------------------------------

    // Play is a Struct that holds metadata associated
    // with a specific NBA play, like the legendary moment when
    // Ray Allen hit the 3 to tie the Heat and Spurs in the 2013 finals game 6
    // or when Lance Stephenson blew in the ear of Lebron James.
    //
    // Moment NFTs will all reference a single play as the owner of
    // its metadata. The plays are publicly accessible, so anyone can
    // read the metadata associated with a specific play ID
    //
    access(all) struct Play {
        // The unique ID for the Play
        access(all) let playID: UInt32

        // Stores all the metadata about the play as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        access(all) let metadata: {String: String}

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Play metadata cannot be empty"
            }
            self.playID = TopShot.nextPlayID
            self.metadata = metadata
        }

        /// This function is intended to backfill the Play on blockchain with a more detailed
        /// description of the Play. The benefit of having the description is that anyone would
        /// be able to know the story of the Play directly from Flow
        access(contract) fun updateTagline(tagline: String): UInt32 {
            self.metadata["Tagline"] = tagline

            TopShot.playDatas[self.playID] = self
            return self.playID
        }
    }

    // A Set is a grouping of Plays that have occured in the real world
    // that make up a related group of collectibles, like sets of baseball
    // or Magic cards. A Play can exist in multiple different sets.
    //
    // SetData is a struct that is stored in a field of the contract.
    // Anyone can query the constant information
    // about a set by calling various getters located
    // at the end of the contract. Only the admin has the ability
    // to modify any data in the private Set resource.
    //
    access(all) struct SetData {
        // Unique ID for the Set
        access(all) let setID: UInt32

        // Name of the Set
        // ex. "Times when the Toronto Raptors choked in the playoffs"
        access(all) let name: String

        // Series that this Set belongs to.
        // Series is a concept that indicates a group of Sets through time.
        // Many Sets can exist at a time, but only one series.
        access(all) let series: UInt32

        init(name: String) {
            pre {
                name.length > 0: "New Set name cannot be empty"
            }
            self.setID = TopShot.nextSetID
            self.name = name
            self.series = TopShot.currentSeries
        }
    }

    // Set is a resource type that contains the functions to add and remove
    // Plays from a set and mint Moments.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods.
    //
    // The admin can add Plays to a Set so that the set can mint Moments
    // that reference that playdata.
    // The Moments that are minted by a Set will be listed as belonging to
    // the Set that minted it, as well as the Play it references.
    //
    // Admin can also retire Plays from the Set, meaning that the retired
    // Play can no longer have Moments minted from it.
    //
    // If the admin locks the Set, no more Plays can be added to it, but
    // Moments can still be minted.
    //
    // If retireAll() and lock() are called back-to-back,
    // the Set is closed off forever and nothing more can be done with it.
    access(all) resource Set {
        // Unique ID for the set
        access(all) let setID: UInt32

        // Array of plays that are a part of this set.
        // When a play is added to the set, its ID gets appended here.
        // The ID does not get removed from this array when a Play is retired.
        access(contract) var plays: [UInt32]

        // Map of Play IDs that Indicates if a Play in this Set can be minted.
        // When a Play is added to a Set, it is mapped to false (not retired).
        // When a Play is retired, this is set to true and cannot be changed.
        access(contract) var retired: {UInt32: Bool}

        // Indicates if the Set is currently locked.
        // When a Set is created, it is unlocked
        // and Plays are allowed to be added to it.
        // When a set is locked, Plays cannot be added.
        // A Set can never be changed from locked to unlocked,
        // the decision to lock a Set it is final.
        // If a Set is locked, Plays cannot be added, but
        // Moments can still be minted from Plays
        // that exist in the Set.
        access(all) var locked: Bool

        // Mapping of Play IDs that indicates the number of Moments
        // that have been minted for specific Plays in this Set.
        // When a Moment is minted, this value is stored in the Moment to
        // show its place in the Set, eg. 13 of 60.
        access(contract) var numberMintedPerPlay: {UInt32: UInt32}

        init(name: String) {
            self.setID = TopShot.nextSetID
            self.plays = []
            self.retired = {}
            self.locked = false
            self.numberMintedPerPlay = {}

            // Create a new SetData for this Set and store it in contract storage
            TopShot.setDatas[self.setID] = SetData(name: name)
        }

        // addPlay adds a play to the set
        //
        // Parameters: playID: The ID of the Play that is being added
        //
        // Pre-Conditions:
        // The Play needs to be an existing play
        // The Set needs to be not locked
        // The Play can't have already been added to the Set
        //
        access(all) fun addPlay(playID: UInt32) {
            pre {
                TopShot.playDatas[playID] != nil: "Cannot add the Play to Set: Play doesn't exist."
                !self.locked: "Cannot add the play to the Set after the set has been locked."
                self.numberMintedPerPlay[playID] == nil: "The play has already beed added to the set."
            }

            // Add the Play to the array of Plays
            self.plays.append(playID)

            // Open the Play up for minting
            self.retired[playID] = false

            // Initialize the Moment count to zero
            self.numberMintedPerPlay[playID] = 0

            emit PlayAddedToSet(setID: self.setID, playID: playID)
        }

        // addPlays adds multiple Plays to the Set
        //
        // Parameters: playIDs: The IDs of the Plays that are being added
        //                      as an array
        //
        access(all) fun addPlays(playIDs: [UInt32]) {
            for play in playIDs {
                self.addPlay(playID: play)
            }
        }

        // retirePlay retires a Play from the Set so that it can't mint new Moments
        //
        // Parameters: playID: The ID of the Play that is being retired
        //
        // Pre-Conditions:
        // The Play is part of the Set and not retired (available for minting).
        //
        access(all) fun retirePlay(playID: UInt32) {
            pre {
                self.retired[playID] != nil: "Cannot retire the Play: Play doesn't exist in this set!"
            }

            if !self.retired[playID]! {
                self.retired[playID] = true

                emit PlayRetiredFromSet(setID: self.setID, playID: playID, numMoments: self.numberMintedPerPlay[playID]!)
            }
        }

        // retireAll retires all the plays in the Set
        // Afterwards, none of the retired Plays will be able to mint new Moments
        //
        access(all) fun retireAll() {
            for play in self.plays {
                self.retirePlay(playID: play)
            }
        }

        // lock() locks the Set so that no more Plays can be added to it
        //
        // Pre-Conditions:
        // The Set should not be locked
        access(all) fun lock() {
            if !self.locked {
                self.locked = true
                emit SetLocked(setID: self.setID)
            }
        }

        // mintMoment mints a new Moment and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        access(all) fun mintMoment(playID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this Play
            // to use as this Moment's serial number
            let numInPlay = self.numberMintedPerPlay[playID]!

            // Mint the new moment
            let newMoment: @NFT <- create NFT(
                serialNumber: numInPlay + UInt32(1),
                playID: playID,
                setID: self.setID,
                subeditionID: 0
            )

            // Increment the count of Moments minted for this Play
            self.numberMintedPerPlay[playID] = numInPlay + UInt32(1)

            return <-newMoment
        }

        // batchMintMoment mints an arbitrary quantity of Moments
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
        access(all) fun batchMintMoment(playID: UInt32, quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMoment(playID: playID))
                i = i + UInt64(1)
            }

            return <- newCollection
        }

        // mintMomentWithSubedition mints a new Moment with subedition and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //             subeditionID: The ID of the subedition within Edition that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        access(all) fun mintMomentWithSubedition(playID: UInt32, subeditionID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this subedition
            // to use as this Moment's serial number
            let subeditionRef = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            let numInSubedition = subeditionRef.getNumberMintedPerSubedition(
                setID: self.setID,
                playID: playID,
                subeditionID: subeditionID
            )

            // Mint the new moment
            let newMoment: @NFT <- create NFT(
                serialNumber: numInSubedition + UInt32(1),
                playID: playID,
                setID: self.setID,
                subeditionID: subeditionID
            )

            // Increment the count of Moments minted for this subedition
            subeditionRef.addToNumberMintedPerSubedition(
                setID: self.setID,
                playID: playID,
                subeditionID: subeditionID
            )

            subeditionRef.setMomentsSubedition(nftID: newMoment.id, subeditionID: subeditionID, setID: self.setID, playID: playID)

            self.numberMintedPerPlay[playID] = self.numberMintedPerPlay[playID]! + UInt32(1)

            return <- newMoment
        }

        // batchMintMomentWithSubedition mints an arbitrary quantity of Moments with subedition
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //             subeditionID: The ID of the subedition within Edition that the Moments references
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
        access(all) fun batchMintMomentWithSubedition(playID: UInt32, quantity: UInt64, subeditionID: UInt32): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMomentWithSubedition(playID: playID, subeditionID: subeditionID))
                i = i + UInt64(1)
            }

            return <-newCollection
        }

        access(all) view fun getPlays(): [UInt32] {
            return self.plays
        }

        access(all) view fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        access(all) view fun getNumMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    // Struct that contains all of the important data about a set
    // Can be easily queried by instantiating the `QuerySetData` object
    // with the desired set ID
    // let setData = TopShot.QuerySetData(setID: 12)
    //
    access(all) struct QuerySetData {
        access(all) let setID: UInt32
        access(all) let name: String
        access(all) let series: UInt32
        access(self) var plays: [UInt32]
        access(self) var retired: {UInt32: Bool}
        access(all) var locked: Bool
        access(self) var numberMintedPerPlay: {UInt32: UInt32}

        init(setID: UInt32) {
            pre {
                TopShot.sets[setID] != nil: "The set with the provided ID does not exist"
            }

            let set = (&TopShot.sets[setID] as &Set?)!
            let setData = TopShot.setDatas[setID]!

            self.setID = setID
            self.name = setData.name
            self.series = setData.series
            self.plays = set.getPlays()
            self.retired = set.getRetired()
            self.locked = set.locked
            self.numberMintedPerPlay = set.getNumMintedPerPlay()
        }

        access(all) view fun getPlays(): [UInt32] {
            return self.plays
        }

        access(all) view fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        access(all) view fun getNumberMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    access(all) struct MomentData {
        // The ID of the Set that the Moment comes from
        access(all) let setID: UInt32

        // The ID of the Play that the Moment references
        access(all) let playID: UInt32

        // The place in the edition that this Moment was minted
        // Otherwise know as the serial number
        access(all) let serialNumber: UInt32

        init(setID: UInt32, playID: UInt32, serialNumber: UInt32) {
            self.setID = setID
            self.playID = playID
            self.serialNumber = serialNumber
        }
    }

    // This is an implementation of a custom metadata view for Top Shot.
    // This view contains the play metadata.
    //
    access(all) struct TopShotMomentMetadataView {
        access(all) let fullName: String?
        access(all) let firstName: String?
        access(all) let lastName: String?
        access(all) let birthdate: String?
        access(all) let birthplace: String?
        access(all) let jerseyNumber: String?
        access(all) let draftTeam: String?
        access(all) let draftYear: String?
        access(all) let draftSelection: String?
        access(all) let draftRound: String?
        access(all) let teamAtMomentNBAID: String?
        access(all) let teamAtMoment: String?
        access(all) let primaryPosition: String?
        access(all) let height: String?
        access(all) let weight: String?
        access(all) let totalYearsExperience: String?
        access(all) let nbaSeason: String?
        access(all) let dateOfMoment: String?
        access(all) let playCategory: String?
        access(all) let playType: String?
        access(all) let homeTeamName: String?
        access(all) let awayTeamName: String?
        access(all) let homeTeamScore: String?
        access(all) let awayTeamScore: String?
        access(all) let seriesNumber: UInt32?
        access(all) let setName: String?
        access(all) let serialNumber: UInt32
        access(all) let playID: UInt32
        access(all) let setID: UInt32
        access(all) let numMomentsInEdition: UInt32?

        init(
            fullName: String?,
            firstName: String?,
            lastName: String?,
            birthdate: String?,
            birthplace: String?,
            jerseyNumber: String?,
            draftTeam: String?,
            draftYear: String?,
            draftSelection: String?,
            draftRound: String?,
            teamAtMomentNBAID: String?,
            teamAtMoment: String?,
            primaryPosition: String?,
            height: String?,
            weight: String?,
            totalYearsExperience: String?,
            nbaSeason: String?,
            dateOfMoment: String?,
            playCategory: String?,
            playType: String?,
            homeTeamName: String?,
            awayTeamName: String?,
            homeTeamScore: String?,
            awayTeamScore: String?,
            seriesNumber: UInt32?,
            setName: String?,
            serialNumber: UInt32,
            playID: UInt32,
            setID: UInt32,
            numMomentsInEdition: UInt32?
        ) {
            self.fullName = fullName
            self.firstName = firstName
            self.lastName = lastName
            self.birthdate = birthdate
            self.birthplace = birthplace
            self.jerseyNumber = jerseyNumber
            self.draftTeam = draftTeam
            self.draftYear = draftYear
            self.draftSelection = draftSelection
            self.draftRound = draftRound
            self.teamAtMomentNBAID = teamAtMomentNBAID
            self.teamAtMoment = teamAtMoment
            self.primaryPosition = primaryPosition
            self.height = height
            self.weight = weight
            self.totalYearsExperience = totalYearsExperience
            self.nbaSeason = nbaSeason
            self.dateOfMoment= dateOfMoment
            self.playCategory = playCategory
            self.playType = playType
            self.homeTeamName = homeTeamName
            self.awayTeamName = awayTeamName
            self.homeTeamScore = homeTeamScore
            self.awayTeamScore = awayTeamScore
            self.seriesNumber = seriesNumber
            self.setName = setName
            self.serialNumber = serialNumber
            self.playID = playID
            self.setID = setID
            self.numMomentsInEdition = numMomentsInEdition
        }
    }

    // The resource that represents the Moment NFTs
    //
    access(all) resource NFT: NonFungibleToken.NFT {
        // Global unique moment ID
        access(all) let id: UInt64

        // Struct of Moment metadata
        access(all) let data: MomentData

        init(serialNumber: UInt32, playID: UInt32, setID: UInt32, subeditionID: UInt32) {
            // Increment the global Moment IDs
            TopShot.totalSupply = TopShot.totalSupply + UInt64(1)

            self.id = TopShot.totalSupply

            // Set the metadata struct
            self.data = MomentData(setID: setID, playID: playID, serialNumber: serialNumber)

            emit MomentMinted(
                momentID: self.id,
                playID: playID,
                setID: self.data.setID,
                serialNumber: self.data.serialNumber,
                subeditionID: subeditionID
            )
        }

        // If the Moment is destroyed, emit an event to indicate
        // to outside observers that it has been destroyed
        access(all) event ResourceDestroyed(
            id: UInt64 = self.id,
            serialNumber: UInt32 =  self.data.serialNumber,
            playID: UInt32 =  self.data.playID,
            setID: UInt32 = self.data.setID
        )

        access(all) view fun name(): String {
            let fullName: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName") ?? ""
            let playType: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType") ?? ""
            return fullName
                .concat(" ")
                .concat(playType)
        }

        // The description of the Moment.
        // If the Tagline prop exists, use is as the description; else, build the description using set, series, and serial number.
        access(all) view fun description(): String {
            // Return early if the tagline is non-empty
            if let tagline = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Tagline") {
                return tagline
            }

            // Build the description using set name, series number, and serial number
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let serialNumber: String = self.data.serialNumber.toString()
            let seriesNumber: String = TopShot.getSetSeries(setID: self.data.setID)?.toString() ?? ""
            return "A series "
                .concat(seriesNumber)
                .concat(" ")
                .concat(setName)
                .concat(" moment with serial number ")
                .concat(serialNumber)
        }

        // All supported metadata views for the Moment including the Core NFT Views
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<TopShotMomentMetadataView>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<CrossVMMetadataViews.EVMPointer>(),
                Type<MetadataViews.EVMBridgedMetadata>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Medias>()
            ]
        }

        // resolves the view with the given type for the NFT
        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: MetadataViews.HTTPFile(url: self.thumbnail())
                    )
                // Custom metadata view unique to TopShot Moments
                case Type<TopShotMomentMetadataView>():
                    return TopShotMomentMetadataView(
                        fullName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName"),
                        firstName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FirstName"),
                        lastName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "LastName"),
                        birthdate: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthdate"),
                        birthplace: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthplace"),
                        jerseyNumber: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "JerseyNumber"),
                        draftTeam: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftTeam"),
                        draftYear: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftYear"),
                        draftSelection: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftSelection"),
                        draftRound: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftRound"),
                        teamAtMomentNBAID: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMomentNBAID"),
                        teamAtMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMoment"),
                        primaryPosition: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PrimaryPosition"),
                        height: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Height"),
                        weight: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Weight"),
                        totalYearsExperience: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TotalYearsExperience"),
                        nbaSeason: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "NbaSeason"),
                        dateOfMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DateOfMoment"),
                        playCategory: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayCategory"),
                        playType: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType"),
                        homeTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamName"),
                        awayTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamName"),
                        homeTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamScore"),
                        awayTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamScore"),
                        seriesNumber: TopShot.getSetSeries(setID: self.data.setID),
                        setName: TopShot.getSetName(setID: self.data.setID),
                        serialNumber: self.data.serialNumber,
                        playID: self.data.playID,
                        setID: self.data.setID,
                        numMomentsInEdition: TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID)
                    )
                case Type<MetadataViews.Editions>():
                    let name = self.getEditionName()
                    let max = TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID) ?? 0
                    let editionInfo = MetadataViews.Edition(name: name, number: UInt64(self.data.serialNumber), max: max > 0 ? UInt64(max) : nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        UInt64(self.data.serialNumber)
                    )
                case Type<MetadataViews.Royalties>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.Royalties>())
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(self.getMomentURL())
                case Type<MetadataViews.NFTCollectionData>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<CrossVMMetadataViews.EVMPointer>():
                    return TopShot.resolveContractView(resourceType: nil, viewType: Type<CrossVMMetadataViews.EVMPointer>())
                case Type<MetadataViews.EVMBridgedMetadata>():
                    // Project-defined ERC721 EVM contract stores baseURI, name, and symbol in its own contract storage
                    // Name, symbol, and baseURI below are only used for legacy bridge-deployed ERC721 contract
                    return MetadataViews.EVMBridgedMetadata(
                        name: "NBA Top Shot",
                        symbol: "NBAT",
                        uri: MetadataViews.URI(
                            baseURI: ${EVMBASEURI},
                            value: self.id.toString()
                        )
                    )
                case Type<MetadataViews.Traits>():
                    return self.resolveTraitsView()
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.mediumimage()
                                ),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.video()
                                ),
                                mediaType: "video/mp4"
                            )
                        ]
                    )
            }
            return nil
        }

        // resolves this NFT's Traits view
        access(all) fun resolveTraitsView(): MetadataViews.Traits {
            // sports radar team id
            let excludedNames: [String] = ["TeamAtMomentNBAID"]

            // Get subedition
            let subedition = TopShot.getSubeditionByNFTID(self.id)

            // Create a dictionary of this NFT's traits with default metadata
            var traits: {String: AnyStruct} = {
                "SeriesNumber": TopShot.getSetSeries(setID: self.data.setID),
                "SetName": TopShot.getSetName(setID: self.data.setID),
                "SerialNumber": self.data.serialNumber,
                "Locked": TopShotLocking.isLocked(nftRef: &self as &{NonFungibleToken.NFT}),
                "Subedition": subedition?.name ?? "Standard",
                "SubeditionID": subedition?.subeditionID ?? 0
            }

            // Add play specific data
            traits = self.mapPlayData(dict: traits)

            return MetadataViews.dictToTraits(dict: traits, excludedNames: excludedNames)
        }

        // Functions used for computing MetadataViews

        // mapPlayData helps build our trait map from play metadata
        // Returns: The trait map with all non-empty fields from play data added
        access(all) fun mapPlayData(dict: {String: AnyStruct}) : {String: AnyStruct} {
            let playMetadata = TopShot.getPlayMetaData(playID: self.data.playID) ?? {}
            for name in playMetadata.keys {
                let value = playMetadata[name] ?? ""
                if value != "" {
                    dict.insert(key: name, value)
                }
            }
            return dict
        }

        // getMomentURL
        // Returns: The computed external url of the moment
        access(all) view fun getMomentURL(): String {
            return "https://nbatopshot.com/moment/".concat(self.id.toString())
        }

        // getEditionName Moment's edition name is a combination of the Moment's setName and playID
        // `setName: #playID`
        access(all) view fun getEditionName(): String {
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let editionName = setName.concat(": #").concat(self.data.playID.toString())
            return editionName
        }

        access(all) view fun assetPath(): String {
            return "https://assets.nbatopshot.com/media/".concat(self.id.toString())
        }

        // returns a url to display an medium sized image
        access(all) view fun mediumimage(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("?width=512"), firstDelim: "&")
        }

        // a url to display a thumbnail associated with the moment
        access(all) view fun thumbnail(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("?width=256"), firstDelim: "&")
        }

        // a url to display a video associated with the moment
        access(all) view fun video(): String {
            return self.appendOptionalParams(url: self.assetPath().concat("/video"), firstDelim: "?")
        }

        // appends and optional network param needed to resolve the media
        access(all) view fun appendOptionalParams(url: String, firstDelim: String): String {
            if TopShot.Network() == "testnet" {
                return url.concat(firstDelim).concat("testnet")
            }
            return url
        }

        // Create an empty Collection for TopShot NFTs and return it to the caller
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Plays, Sets, and Moments
    //
    access(all) resource Admin {
        // createPlay creates a new Play struct
        // and stores it in the Plays dictionary in the TopShot smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Player Name": "Kevin Durant", "Height": "7 feet"}
        //                               (because we all know Kevin Durant is not 6'9")
        //
        // Returns: the ID of the new Play object
        //
        access(all) fun createPlay(metadata: {String: String}): UInt32 {
            // Create the new Play
            var newPlay = Play(metadata: metadata)
            let newID = newPlay.playID

            // Increment the ID so that it isn't used again
            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)

            emit PlayCreated(id: newPlay.playID, metadata: metadata)

            // Store it in the contract storage
            TopShot.playDatas[newID] = newPlay

            return newID
        }

        /// Temporarily enabled so the description of the play can be backfilled
        /// Parameters: playID: The ID of the play to update
        ///             tagline: A string to be used as the tagline for the play
        /// Returns: The ID of the play
        access(all) fun updatePlayTagline(playID: UInt32, tagline: String): UInt32 {
            let tmpPlay = TopShot.playDatas[playID]
                ?? panic("playID does not exist")

            // Update the play's tagline
            tmpPlay.updateTagline(tagline: tagline)

            // Return the play's ID
            return playID
        }

        // createSet creates a new Set resource and stores it
        // in the sets mapping in the TopShot contract
        //
        // Parameters: name: The name of the Set
        //
        // Returns: The ID of the created set
        access(all) fun createSet(name: String): UInt32 {
            // Create the new Set
            var newSet <- create Set(name: name)

            // Increment the setID so that it isn't used again
            TopShot.nextSetID = TopShot.nextSetID + UInt32(1)

            let newID = newSet.setID

            emit SetCreated(setID: newSet.setID, series: TopShot.currentSeries)

            // Store it in the sets mapping field
            TopShot.sets[newID] <-! newSet

            return newID
        }

        // borrowSet returns a reference to a set in the TopShot
        // contract so that the admin can call methods on it
        //
        // Parameters: setID: The ID of the Set that you want to
        // get a reference to
        //
        // Returns: A reference to the Set with all of the fields
        // and methods exposed
        //
        access(all) view fun borrowSet(setID: UInt32): &Set {
            pre {
                TopShot.sets[setID] != nil: "Cannot borrow Set: The Set doesn't exist"
            }

            // Get a reference to the Set and return it
            // use `&` to indicate the reference to the object and type
            return (&TopShot.sets[setID] as &Set?)!
        }

        // startNewSeries ends the current series by incrementing
        // the series number, meaning that Moments minted after this
        // will use the new series number
        //
        // Returns: The new series number
        //
        access(all) fun startNewSeries(): UInt32 {
            // End the current series and start a new one
            // by incrementing the TopShot series number
            TopShot.currentSeries = TopShot.currentSeries + UInt32(1)

            emit NewSeriesStarted(newCurrentSeries: TopShot.currentSeries)

            return TopShot.currentSeries
        }

        // createSubeditionResource creates new SubeditionMap resource that
        // will be used to mint Moments with Subeditions
        access(all) fun createSubeditionAdminResource() {
            TopShot.account.storage.save<@SubeditionAdmin>(<- create SubeditionAdmin(), to: TopShot.SubeditionAdminStoragePath())
        }

        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        access(all) fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {
            let subeditionAdmin = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            subeditionAdmin.setMomentsSubedition(nftID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        access(all) fun createSubedition(name: String, metadata: {String: String}): UInt32 {
            let subeditionAdmin = TopShot.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            return subeditionAdmin.createSubedition(name:name, metadata:metadata)
        }

        // createNewAdmin creates a new Admin resource
        //
        access(all) fun createNewAdmin(): @Admin {
            return <- create Admin()
        }
    }

    // This is the interface that users can cast their Moment Collection as
    // to allow others to deposit Moments into their Collection. It also allows for reading
    // the IDs of Moments in the Collection.
    /// Deprecated: This is no longer used for defining access control anymore.
    access(all) resource interface MomentCollectionPublic : NonFungibleToken.CollectionPublic {
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection})
        access(all) fun borrowMoment(id: UInt64): &NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTS
    //
    access(all) resource Collection: MomentCollectionPublic, NonFungibleToken.Collection {
        // Dictionary of Moment conforming tokens
        // NFT is a resource type with a UInt64 ID field
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        init() {
            self.ownedNFTs <- {}
        }

        // Return a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@NFT>()] = true
            return supportedTypes
        }

        // Return whether or not the given type is accepted by the collection
        // A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@NFT>() {
                return true
            }
            return false
        }

        // Return the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        // Create an empty Collection for TopShot NFTs and return it to the caller
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
        }

        // withdraw removes an Moment from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            // Borrow nft and check if locked
            let nft = self.borrowNFT(withdrawID)
                ?? panic("Cannot borrow: empty reference")

            if TopShotLocking.isLocked(nftRef: nft) {
                panic("Cannot withdraw: Moment is locked")
            }

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Moment does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: ids: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn moments
        //
        access(NonFungibleToken.Withdraw) fun batchWithdraw(ids: [UInt64]): @{NonFungibleToken.Collection} {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <- self.withdraw(withdrawID: id))
            }

            // Return the withdrawn tokens
            return <- batchCollection
        }

        // deposit takes a Moment and adds it to the Collections dictionary
        //
        // Paramters: token: the NFT to be deposited in the collection
        //
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            // Cast the deposited token as a TopShot NFT to make sure
            // it is the correct type
            let token <- token as! @NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection}) {
            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <- tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // lock takes a token id and a duration in seconds and locks
        // the moment for that duration
        access(NonFungibleToken.Update) fun lock(id: UInt64, duration: UFix64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            TopShot.emitNFTUpdated(&token as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT})

            // pass the token to the locking contract
            // store it again after it comes back
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.lockNFT(nft: <- token, duration: duration)

            destroy oldToken
        }

        // batchLock takes an array of token ids and a duration in seconds
        // it iterates through the ids and locks each for the specified duration
        access(NonFungibleToken.Update) fun batchLock(ids: [UInt64], duration: UFix64) {
            // Iterate through the ids and lock them
            for id in ids {
                self.lock(id: id, duration: duration)
            }
        }

        // unlock takes a token id and attempts to unlock it
        // TopShotLocking.unlockNFT contains business logic around unlock eligibility
        access(NonFungibleToken.Update) fun unlock(id: UInt64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            TopShot.emitNFTUpdated(&token as auth(NonFungibleToken.Update) &{NonFungibleToken.NFT})

            // Pass the token to the TopShotLocking contract then get it back
            // Store it back to the ownedNFTs dictionary
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.unlockNFT(nft: <- token)

            destroy oldToken
        }

        // batchUnlock takes an array of token ids
        // it iterates through the ids and unlocks each if they are eligible
        access(NonFungibleToken.Update) fun batchUnlock(ids: [UInt64]) {
            // Iterate through the ids and unlocks them
            for id in ids {
                self.unlock(id: id)
            }
        }

        // destroyMoments destroys moments in this collection
        // unlocks the moments if they are locked
        //
        // Parameters: ids: An array of NFT IDs
        // to be destroyed from the Collection
        access(NonFungibleToken.Update) fun destroyMoments(ids: [UInt64]) {
            let topShotLockingAdmin = TopShot.account.storage.borrow<&TopShotLocking.Admin>(from: TopShotLocking.AdminStoragePath())
                ?? panic("No TopShotLocking admin resource in storage")

            for id in ids {
                // Remove the nft from the Collection
                let token <- self.ownedNFTs.remove(key: id)
                    ?? panic("Cannot destroy: Moment does not exist in collection: ".concat(id.toString()))

                // Emit a withdraw event here so that platforms do not have to understand TopShot-specific events to see ownership change
                // A withdraw without a corresponding deposit means the NFT in question has no owner address
                emit Withdraw(id: id, from: self.owner?.address)

                // does nothing if the moment is not locked
                topShotLockingAdmin.unlockByID(id: id)

                destroy token
            }
        }

        // getIDs returns an array of the IDs that are in the Collection
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT Returns a borrowed reference to a Moment in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any topshot specific data. Please use borrowMoment to
        // read Moment data.
        //
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        // borrowMoment returns a borrowed reference to a Moment
        // so that the caller can read data and call methods from it.
        // They can use this to read its setID, playID, serialNumber,
        // or any of the setData or Play data associated with it by
        // getting the setID or playID and reading those fields from
        // the smart contract.
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        access(all) view fun borrowMoment(id: UInt64): &NFT? {
            return self.borrowNFT(id) as! &NFT?
        }

        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }
    }

    // -----------------------------------------------------------------------
    // TopShot contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Moments in transactions.
    //
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        if nftType != Type<@NFT>() {
            panic("NFT type is not supported")
        }
        return <- create TopShot.Collection()
    }

    // getAllPlays returns all the plays in topshot
    //
    // Returns: An array of all the plays that have been created
    access(all) view fun getAllPlays(): [Play] {
        return TopShot.playDatas.values
    }

    // getPlayMetaData returns all the metadata associated with a specific Play
    //
    // Parameters: playID: The id of the Play that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    access(all) view fun getPlayMetaData(playID: UInt32): {String: String}? {
        return self.playDatas[playID]?.metadata
    }

    // getPlayMetaDataByField returns the metadata associated with a
    //                        specific field of the metadata
    //                        Ex: field: "Team" will return something
    //                        like "Memphis Grizzlies"
    //
    // Parameters: playID: The id of the Play that is being searched
    //             field: The field to search for
    //
    // Returns: The metadata field as a String Optional
    access(all) view fun getPlayMetaDataByField(playID: UInt32, field: String): String? {
        // Don't force a revert if the playID or field is invalid
        if let play = TopShot.playDatas[playID] {
            return play.metadata[field]
        }
        return nil
    }

    // getSetData returns the data that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The QuerySetData struct that has all the important information about the set
    access(all) fun getSetData(setID: UInt32): QuerySetData? {
        if TopShot.sets[setID] == nil {
            return nil
        }
        return QuerySetData(setID: setID)
    }

    // getSetName returns the name that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The name of the Set
    access(all) view fun getSetName(setID: UInt32): String? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.name
    }

    // getSetSeries returns the series that the specified Set
    //              is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The series that the Set belongs to
    access(all) view fun getSetSeries(setID: UInt32): UInt32? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.series
    }

    // getSetIDsByName returns the IDs that the specified Set name
    //                 is associated with.
    //
    // Parameters: setName: The name of the Set that is being searched
    //
    // Returns: An array of the IDs of the Set if it exists, or nil if doesn't
    access(all) fun getSetIDsByName(setName: String): [UInt32]? {
        var setIDs: [UInt32] = []

        // Iterate through all the setDatas and search for the name
        for setData in TopShot.setDatas.values {
            if setName == setData.name {
                // If the name is found, return the ID
                setIDs.append(setData.setID)
            }
        }

        // If the name isn't found, return nil
        // Don't force a revert if the setName is invalid
        if setIDs.length == 0 {
            return nil
        }
        return setIDs
    }

    // getPlaysInSet returns the list of Play IDs that are in the Set
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: An array of Play IDs
    access(all) view fun getPlaysInSet(setID: UInt32): [UInt32]? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.plays
    }

    // isEditionRetired returns a boolean that indicates if a Set/Play combo
    //                  (otherwise known as an edition) is retired.
    //                  If an edition is retired, it still remains in the Set,
    //                  but Moments can no longer be minted from it.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: Boolean indicating if the edition is retired or not
    access(all) fun isEditionRetired(setID: UInt32, playID: UInt32): Bool? {
        // Return the retired status for the play in the set if it exists
        if let setdata = self.getSetData(setID: setID) {
            return setdata.getRetired()[playID]
        }
        return nil
    }

    // isSetLocked returns a boolean that indicates if a Set
    //             is locked. If it's locked,
    //             new Plays can no longer be added to it,
    //             but Moments can still be minted from Plays the set contains.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: Boolean indicating if the Set is locked or not
    access(all) view fun isSetLocked(setID: UInt32): Bool? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.locked
    }

    // getNumMomentsInEdition return the number of Moments that have been
    //                        minted from a certain edition.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: The total number of Moments
    //          that have been minted from an edition
    access(all) fun getNumMomentsInEdition(setID: UInt32, playID: UInt32): UInt32? {
        // Return the number of moments minted for the play in the set if it exists
        if let setdata = self.getSetData(setID: setID) {
            return setdata.getNumberMintedPerPlay()[playID]
        }
        return nil
    }

    // getMomentsSubedition returns the Subedition the Moment belongs to
    //
    // Parameters: nftID: The ID of the NFT
    //
    // returns: UInt32? Subedition's ID if exists
    //
    access(all) view fun getMomentsSubedition(nftID: UInt64): UInt32? {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.getMomentsSubedition(nftID: nftID)
    }

    // getAllSubeditions returns all the subeditions in topshot subeditionAdmin resource
    //
    // Returns: An array of all the subeditions that have been created
    access(all) view fun getAllSubeditions(): &[Subedition] {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas.values
    }

    // getSubeditionByID returns the subedition struct entity
    //
    // Parameters: subeditionID: The id of the Subedition that is being searched
    //
    // Returns: The Subedition struct
    access(all) view fun getSubeditionByID(subeditionID: UInt32): &Subedition {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas[subeditionID]!
    }

    // getSubeditionByNFTID returns the subedition struct that the NFT belongs to
    //
    // Parameters: nftID: The id of the NFT that is being searched
    //
    // Returns: The subedition struct that the NFT belongs to
    access(all) view fun getSubeditionByNFTID(_ nftID: UInt64): &Subedition? {
        if let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath()) {
            if let subeditionID = subeditionAdmin.getMomentsSubedition(nftID: nftID) {
                return subeditionAdmin.subeditionDatas[subeditionID]
            }
        }
        return nil
    }

    // This script reads the public nextSubeditionID from the SubeditionAdmin resource and
    // returns that number to the caller
    //
    // Returns: UInt32
    // the next number in nextSubeditionID from the SubeditionAdmin resource
    access(all) view fun getNextSubeditionID(): UInt32 {
        let subeditionAdmin = self.account.storage.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.nextSubeditionID
    }

    // SubeditionAdmin is a resource that allows Set to mint Moments with Subeditions
    //
    access(all) struct Subedition {
        access(all) let subeditionID: UInt32

        access(all) let name: String

        access(all) let metadata: {String: String}

        init(subeditionID: UInt32, name: String, metadata: {String: String}) {
            pre {
                name.length != 0: "New Subedition name cannot be empty"
            }
            self.subeditionID = subeditionID
            self.name = name
            self.metadata = metadata
        }
    }

    access(all) resource SubeditionAdmin {
        // Map of number of already minted Moments using Subedition.
        // When a new Moment with Subedition is minted, 1 is added to the
        // number in this map by the key, formed by concatinating of
        // SetID, PlayID and SubeditionID
        access(contract) let numberMintedPerSubedition: {String: UInt32}

        // Map of Subedition which the Moment belongs to.
        // This map updates after each minting.
        access(contract) let momentsSubedition: {UInt64: UInt32}

        // The ID that is used to create Subeditions.
        // Every time a Subeditions is created, subeditionID is assigned
        // to the new Subedition's ID and then is incremented by 1.
        access(contract) var nextSubeditionID: UInt32

        // Variable size dictionary of Subedition structs
        access(contract) let subeditionDatas: {UInt32: Subedition}

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        access(all) fun createSubedition(name: String, metadata: {String: String}): UInt32 {
            let newID = self.nextSubeditionID

            var newSubedition = Subedition(subeditionID: newID, name: name, metadata: metadata)

            self.nextSubeditionID = self.nextSubeditionID + UInt32(1)

            self.subeditionDatas[newID] = newSubedition

            emit SubeditionCreated(subeditionID: newID, name: name, metadata: metadata)

            return newID
        }

        // getMomentsSubedition function that return's wich Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //
        // returns: UInt32? Subedition's ID if exists
        //
        access(all) view fun getMomentsSubedition(nftID: UInt64): UInt32? {
            return self.momentsSubedition[nftID]
        }

        // getNumberMintedPerSubedition function that return's
        // the number of Moments that have been minted for this subedition
        // to use as this Moment's serial number
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        // returns: UInt32 Number of Moments, already minted for this Subedition
        //
        access(all) fun getNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32): UInt32 {
            let setPlaySubedition = self.getSetPlaySubeditionString(setID, playID, subeditionID)
            if !self.numberMintedPerSubedition.containsKey(setPlaySubedition) {
                self.numberMintedPerSubedition.insert(key: setPlaySubedition, UInt32(0))
                return UInt32(0)
            }
            return self.numberMintedPerSubedition[setPlaySubedition]!
        }

        // addToNumberMintedPerSubedition function that increments 1 to the
        // number of Moments that have been minted for this subedition
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        //
        access(contract) fun addToNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32) {
            let setPlaySubedition = self.getSetPlaySubeditionString(setID, playID, subeditionID)

            // Get number of moments minted for this subedition
            let numberMinted = self.numberMintedPerSubedition[setPlaySubedition]
                ?? panic("Could not find number of moments minted for specified Subedition!")

            // Increment the number of moments minted for this subedition
            self.numberMintedPerSubedition[setPlaySubedition] = numberMinted + UInt32(1)
        }

        // getSetPlaySubeditionString builds a string that is used as a key in the numberMintedPerSubedition map
        access(self) view fun getSetPlaySubeditionString(_ setID: UInt32, _ playID: UInt32, _ subeditionID: UInt32): String {
            return setID.toString().concat(playID.toString()).concat(subeditionID.toString())
        }


        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        access(all) fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {
            pre {
                !self.momentsSubedition.containsKey(nftID) : "Subedition for this moment already exists!"
            }

            self.momentsSubedition.insert(key: nftID, subeditionID)

            emit SubeditionAddedToMoment(momentID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        init() {
            self.momentsSubedition = {}
            self.numberMintedPerSubedition = {}
            self.subeditionDatas = {}
            self.nextSubeditionID = 1
        }
    }

    //------------------------------------------------------------
    // Contract MetadataViews
    //------------------------------------------------------------

    // getContractViews returns the metadata view types available for this contract
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<CrossVMMetadataViews.EVMPointer>(),
            Type<MetadataViews.Royalties>()
        ]
    }

    // resolveContractView resolves this contract's metadata views
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        post {
            result == nil || result!.getType() == viewType: "The returned view must be of the given type or nil"
        }
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: /storage/MomentCollection,
                    publicPath: /public/MomentCollection,
                    publicCollection: Type<&Collection>(),
                    publicLinkedType: Type<&Collection>(),
                    createEmptyCollectionFunction: (fun (): @{NonFungibleToken.Collection} {
                        return <- TopShot.createEmptyCollection(nftType: Type<@NFT>())
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let bannerImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/img/top-shot-logo-horizontal-white.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let squareImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/favicon/favicon.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "NBA Top Shot",
                    description: "NBA Top Shot is your chance to own, sell, and trade official digital collectibles of the NBA and WNBA's greatest plays and players",
                    externalURL: MetadataViews.ExternalURL("https://nbatopshot.com"),
                    squareImage: squareImage,
                    bannerImage: bannerImage,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/nbatopshot"),
                        "discord": MetadataViews.ExternalURL("https://discord.com/invite/nbatopshot"),
                        "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nbatopshot")
                    }
                )
            case Type<MetadataViews.Royalties>():
                let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                    getAccount(TopShot.RoyaltyAddress()).capabilities.get<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())!
                return MetadataViews.Royalties(
                    [
                        MetadataViews.Royalty(
                            receiver: royaltyReceiver,
                            cut: 0.05,
                            description: "NBATopShot marketplace royalty"
                        )
                    ]
                )
            case Type<CrossVMMetadataViews.EVMPointer>():
                return CrossVMMetadataViews.EVMPointer(
                    cadenceType: Type<@TopShot.NFT>(),
                    cadenceContractAddress: self.account.address,
                    evmContractAddress: EVM.addressFromString(${EVMCONTRACTADDRESS}),
                    nativeVM: CrossVMMetadataViews.VM.Cadence
                )
        }
        return nil
    }

    // -----------------------------------------------------------------------
    // TopShot initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.currentSeries = 0
        self.playDatas = {}
        self.setDatas = {}
        self.sets <- {}
        self.nextPlayID = 1
        self.nextSetID = 1
        self.totalSupply = 0

        // Put a new Collection in storage
        self.account.storage.save<@Collection>(<- create Collection(), to: /storage/MomentCollection)

        // Create and publish a capability for the collection
        self.account.capabilities.publish(
            self.account.capabilities.storage.issue<&Collection>(/storage/MomentCollection),
            at: /public/MomentCollection
        )

        // Put the Minter in storage
        self.account.storage.save<@Admin>(<- create Admin(), to: /storage/TopShotAdmin)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/imports/CrossVMMetadataViews.cdc

```
import ViewResolver from 0xVIEWRESOLVERADDRESS
import EVM from 0xEVMADDRESS

/// This contract implements views originally proposed in FLIP-318 supporting NFT collections
/// with project-defined implementations across both Cadence & EVM.
/// The View structs in this contract should be implemented in the same way that views from `MetadataViews` are implemented
///
access(all) contract CrossVMMetadataViews {

    /// An enum denoting a VM. For now, there are only two VMs on Flow, but this enum could be
    /// expanded in the event other VMs are supported on the network.
    ///
    access(all) enum VM : UInt8 {
        access(all) case Cadence
        access(all) case EVM
    }

    /// View resolved at contract & resource level pointing to the associated EVM implementation.
    /// NOTE: This view alone is not sufficient to validate an association across Cadence & EVM!
    /// Both the Cadence Type/contract *and* the EVM contract should point to each other, with the
    /// EVM pointer being facilitated by ICrossVM.sol contract interface methods. For more
    /// information and context, see FLIP-318: https://github.com/onflow/flips/issues/318
    ///
    access(all) struct EVMPointer {
        /// The associated Cadence Type defined in the contract that this view is returned from
        access(all) let cadenceType: Type
        /// The defining Cadence contract address
        access(all) let cadenceContractAddress: Address
        /// The associated EVM contract address that the Cadence contract will bridge to
        access(all) let evmContractAddress: EVM.EVMAddress
        /// Whether the asset is Cadence- or EVM-native. Native here meaning the VM in which the
        /// asset is originally distributed.
        access(all) let nativeVM: VM

        init(
            cadenceType: Type,
            cadenceContractAddress: Address,
            evmContractAddress: EVM.EVMAddress,
            nativeVM: VM
        ) {
            self.cadenceType = cadenceType
            self.cadenceContractAddress = cadenceContractAddress
            self.evmContractAddress = evmContractAddress
            self.nativeVM = nativeVM
        }
    }

    access(all) fun getEVMPointer(_ viewResolver: &{ViewResolver.Resolver}): EVMPointer? {
        if let view = viewResolver.resolveView(Type<EVMPointer>()) {
            if let v = view as? EVMPointer {
                return v
            }
        }
        return nil
    }

    /// View resolved at resource level denoting any metadata to be passed to the associated EVM
    /// contract at the time of bridging. This optional view would allow EVM side metadata to be
    /// updated based on current Cadence state. If the view is not supported, no bytes will be
    /// passed into EVM when bridging.
    ///
    access(all) struct EVMBytesMetadata {
        /// Returns the bytes to be passed to the EVM contract on `fulfillToEVM` call, allowing the
        /// EVM contract to update the metadata associated with the NFT. The corresponding Solidity
        /// `bytes` type allows the implementer greater flexibility by enabling them to pass
        /// arbitrary data between VMs.
        access(all) let bytes: EVM.EVMBytes

        init(bytes: EVM.EVMBytes) {
            self.bytes = bytes
        }
    }

    access(all) fun getEVMBytesMetadata(_ viewResolver: &{ViewResolver.Resolver}): EVMBytesMetadata? {
        if let view = viewResolver.resolveView(Type<EVMBytesMetadata>()) {
            if let v = view as? EVMBytesMetadata {
                return v
            }
        }
        return nil
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_locked_nfts_length.cdc

```
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

// This script determines how many NFTs are locked in the Top Shot Locking contract

// Returns: Int
// The number of locked NFTs

access(all) fun main(): Int {
    return TopShotLocking.getLockedNFTsLength()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/README.md

# <h1 align="center"> NBA Top Shot on Flow EVM </h1>

## Introduction

The `BridgedTopShotMoments` smart contract enables NBA Top Shot moments to exist on Flow EVM as ERC721 tokens. Each ERC721 token is a 1:1 reference to a Cadence-native NBA Top Shot moment, maintaining the same metadata and uniqueness while allowing users to leverage both Flow and EVM ecosystems.

### Deployments

|Testnet|Mainnet|
|---|---|
|[`0x87859e1d295e5065A2c73be242e3abBd56BAa576`](https://evm-testnet.flowscan.io/address/0x87859e1d295e5065A2c73be242e3abBd56BAa576)| [`0x84c6a2e6765E88427c41bB38C82a78b570e24709`](https://evm.flowscan.io/address/0x84c6a2e6765E88427c41bB38C82a78b570e24709) |

### Core Features

1. **ERC721 Implementation**
   - Full ERC721 compliance with enumeration and burning capabilities
   - NFT metadata support with customizable base URI
   - Ownable contract for admin operations
   - Upgradeable via UUPS proxy

2. **Bridge Integration**
   - Wrapper functionality for ERC721s from bridge-deployed contract
   - Cross-VM compatibility for Flow ↔ EVM bridging (after [FLIP-318](https://github.com/onflow/flips/pull/319) implementation allowing custom associations, and after contract is onboarded to the bridge)
     - Fulfillment of ERC721s from Flow to EVM
     - Bridge permissions management
     - Cadence-specific identifiers tracking

3. **Royalty Management**
   - ERC2981 royalty standard implementation
   - Transfer validation for royalty enforcement via ERC721C/Token Creator Standard
   - Configurable royalty rates (in basis points)
   - Updatable royalty receiver address

> **Note**: This contract will be integrated with the Flow EVM bridge once [FLIP-318](https://github.com/onflow/flips/pull/319) is implemented. Currently:
>
> - The contract acts as a wrapper for ERC721s from the bridged-deployed contract
> - Bridging transactions rely on the `CrossVMMetadataViews.EVMPointer` implementation in the Cadence `TopShot` contract and internal logic to determine whether wrapping/unwrapping is necessary
> - After bridge onboarding is complete:
>   - All bridging operations to EVM will use the `BridgedTopShotMoments` contract
>   - Bridging from EVM will support both `BridgedTopShotMoments` and the legacy bridge-deployed contract

## Prerequisites

1. Install Foundry:

```sh
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

2. Install Flow CLI: [Instructions](https://developers.flow.com/tools/flow-cli/install)

## Usage

This section provides commands for interacting with NBA Top Shot Moment ERC721s deployed on Flow EVM using either Cadence operations via `flow` CLI or EVM operations via `cast` CLI.

### Cadence Operations

#### Notes

- Ensure all transaction arguments are populated in the corresponding JSON file template before submission
- If you encounter an `insufficient computation` error, increase the gas limit (i.e., `--gas-limit <new-gas-limit>`)

```sh

# Bridge NFTs to EVM (wraps NFTs if applicable)
flow transactions send ./evm-bridging/cadence/transactions/bridge_nfts_to_evm.cdc --args-json "$(cat ./evm-bridging/cadence/transactions/bridge_nfts_to_evm_args.json)" --network <network> --signer <signer> --gas-limit 8000

# Bridge NFTs from EVM (unwraps NFTs if applicable)
flow transactions send ./evm-bridging/cadence/transactions/bridge_nfts_from_evm.cdc --args-json "$(cat ./evm-bridging/cadence/transactions/bridge_nfts_from_evm_args.json)" --network <network> --signer <signer> --gas-limit 8000

# Transfer erc721 NFTs
flow transactions send ./evm-bridging/cadence/transactions/transfer_erc721s_to_evm_address.cdc --args-json "$(cat ./evm-bridging/cadence/transactions/transfer_erc721s_to_evm_address_args.json)" --network <network> --signer <signer>

# Query ERC721 address
flow scripts execute ./evm-bridging/cadence/scripts/get_evm_address_string.cdc <flow_address> --network testnet

# Set up royalty management (admin only)
flow transactions send ./evm-bridging/cadence/transactions/admin/set_up_royalty_management.cdc --args-json "$(cat ./evm-bridging/cadence/transactions/admin/set_up_royalty_management_args.json)" --network <network> --signer <signer>
```

### EVM Operations

```sh
# Approve operator for a NFT
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key <private-key> --legacy "approve(address,uint256)" <operator-address> <token-id>

# Approve operator for all NFTs
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key <private-key> --legacy "setApprovalForAll(address,bool)" <operator-address> <true>

# Transfer NFT
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key <private-key> --legacy "safeTransferFrom(address,address,uint256)" <from-address> <to-address> <token-id>

# Query balance
cast call $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL "balanceOf(address)(uint256)" $DEPLOYER_ADDRESS

# Query owner
cast call $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL "ownerOf(uint256)(address)" <nft-id>

# Query token URI
cast call $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL "tokenURI(uint256)(string)" <nft-id>

# Set NFT symbol (admin only)
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key $DEPLOYER_PRIVATE_KEY --legacy "setSymbol(string)" <new-nft-symbol>

# Set transfer validator (admin only)
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key $DEPLOYER_PRIVATE_KEY --legacy "setTransferValidator(address)" <validator-address>

# Set royalty info (admin only)
cast send $DEPLOYED_PROXY_CONTRACT_ADDRESS --rpc-url $RPC_URL --private-key $DEPLOYER_PRIVATE_KEY --legacy "setRoyaltyInfo((address,uint96))" "(<royalty-receiver-address>,<royalty-basis-points>)"
```

## Development

### Tests

Compile and test contracts:

```sh
forge test --force -vvv
```

### Deploy Using Flow

```sh
# If deploying on emulator, start emulator
flow emulator --config-path ./cadence/transactions/admin/deploy/flow.json --transaction-fees

# Use go 1.22.3
go install golang.org/dl/go1.22.3@latest
go1.22.3 download

# Deploy both proxy and implementation contracts
go1.22.3 run main.go <script-type> <network-name> # for example: go1.22.3 run main.go setup emulator

# If getting the error below:
# vendor/github.com/onflow/crypto/blst_include.h:5:10: fatal error: 'consts.h' file not found
# #include "consts.h"
#
# Try running the following:
CGO_ENABLED=0 go1.22.3 run -tags=no_cgo main.go <script-type> <network-name>
```

### Deploy Using EVM (Initial Testing)

1. Set up environment:

```sh
cp .env.flowevm.testnet.example .env
# Add your account details to .env and source it
source .env
```

2. Deploy and verify contracts:

```sh
# Deploy both proxy and implementation contracts
forge clean
forge script --rpc-url $RPC_URL --private-key $DEPLOYER_PRIVATE_KEY --legacy script/InitialTestingDeploy.s.sol:InitialTestingDeployScript --broadcast --verify --verifier $VERIFIER_PROVIDER --verifier-url $VERIFIER_URL

# If verification fails, verify individually
forge verify-contract --rpc-url $RPC_URL --verifier $VERIFIER_PROVIDER --verifier-url $VERIFIER_URL <address-of-contract-to-verify>
```

## Useful links

- [Flow Faucet](https://faucet.flow.com/fund-account)
- [Flow Developers Doc - Using Foundry with Flow](https://developers.flow.com/evm/guides/foundry)
- [Flow Developers Doc - Interacting with COAs from Cadence](https://developers.flow.com/evm/cadence/interacting-with-coa)
- [EVM Testnet Flowscan](https://evm-testnet.flowscan.io) / [EVM Flowscan](https://evm.flowscan.io)
- [Foundry references](https://book.getfoundry.sh/reference)
- [OpenZeppelin Doc - Foundry Upgrades](https://docs.openzeppelin.com/upgrades-plugins/foundry-upgrades)
- [OpenZeppelin Doc - ERC721 Contracts v5](https://docs.openzeppelin.com/contracts/5.x/api/token/erc721)
- [GitHub - OpenZeppelin Upgradeable Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable)
- [GitHub - LimitBreak Creator Token Standards](https://github.com/limitbreakinc/creator-token-standards)
- [OpenSea Doc - Creator Fee Enforcement](https://docs.opensea.io/docs/creator-fee-enforcement)





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/.github/ISSUE_TEMPLATE/feature-request.md

---
name: Requesting a Feature or Improvement
about: "For feature requests. Please search for existing issues first. Also see CONTRIBUTING."
title: ''
labels: Feedback, Feature
assignees: ''

---

## Instructions

Please fill out the template below to the best of your ability and include a label indicating which tool/service you were working with when you encountered the problem.

### Issue To Be Solved
(Replace This Text: Please present a concise description of the problem to be addressed by this feature request. Please be clear what parts of the problem are considered to be in-scope and out-of-scope.)

### (Optional): Suggest A Solution
(Replace This Text: A concise description of your preferred solution. Things to address include:
* Details of the technical implementation
* Tradeoffs made in design decisions
* Caveats and considerations for the future

If there are multiple solutions, please present each one separately. Save comparisons for the very end.)
  
### (Optional): Context

<what are you currently working on that this is blocking?>




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-0636.
///
/// Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata, such as a creator biography
/// or a JPEG image file.
///
access(all) contract MetadataViews {

    /// Display is a basic view that includes the name, description and
    /// thumbnail for an object. Most objects should implement this view.
    ///
    access(all) struct Display {

        /// The name of the object.
        ///
        /// This field will be displayed in lists and therefore should
        /// be short an concise.
        ///
        access(all) let name: String

        /// A written description of the object.
        ///
        /// This field will be displayed in a detailed view of the object,
        /// so can be more verbose (e.g. a paragraph instead of a single line).
        ///
        access(all) let description: String

        /// A small thumbnail representation of the object.
        ///
        /// This field should be a web-friendly file (i.e JPEG, PNG)
        /// that can be displayed in lists, link previews, etc.
        ///
        access(all) let thumbnail: {File}

        view init(
            name: String,
            description: String,
            thumbnail: {File}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }
    }

    /// Helper to get Display in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Display struct
    ///
    access(all) fun getDisplay(_ viewResolver: &{ViewResolver.Resolver}) : Display? {
        if let view = viewResolver.resolveView(Type<Display>()) {
            if let v = view as? Display {
                return v
            }
        }
        return nil
    }

    /// Generic interface that represents a file stored on or off chain. Files
    /// can be used to references images, videos and other media.
    ///
    access(all) struct interface File {
        access(all) view fun uri(): String
    }

    /// View to expose a file that is accessible at an HTTP (or HTTPS) URL.
    ///
    access(all) struct HTTPFile: File {
        access(all) let url: String

        view init(url: String) {
            self.url = url
        }

        access(all) view fun uri(): String {
            return self.url
        }
    }

    /// View to expose a file stored on IPFS.
    /// IPFS images are referenced by their content identifier (CID)
    /// rather than a direct URI. A client application can use this CID
    /// to find and load the image via an IPFS gateway.
    ///
    access(all) struct IPFSFile: File {

        /// CID is the content identifier for this IPFS file.
        ///
        /// Ref: https://docs.ipfs.io/concepts/content-addressing/
        ///
        access(all) let cid: String

        /// Path is an optional path to the file resource in an IPFS directory.
        ///
        /// This field is only needed if the file is inside a directory.
        ///
        /// Ref: https://docs.ipfs.io/concepts/file-systems/
        ///
        access(all) let path: String?

        view init(cid: String, path: String?) {
            self.cid = cid
            self.path = path
        }

        /// This function returns the IPFS native URL for this file.
        /// Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls
        ///
        /// @return The string containing the file uri
        ///
        access(all) view fun uri(): String {
            if let path = self.path {
                return "ipfs://".concat(self.cid).concat("/").concat(path)
            }

            return "ipfs://".concat(self.cid)
        }
    }

    /// A struct to represent a generic URI. May be used to represent the URI of
    /// the NFT where the type of URI is not able to be determined (i.e. HTTP,
    /// IPFS, etc.)
    ///
    access(all) struct URI: File {
        /// The base URI prefix, if any. Not needed for all URIs, but helpful
        /// for some use cases For example, updating a whole NFT collection's
        /// image host easily
        ///
        access(all) let baseURI: String?
        /// The URI string value
        /// NOTE: this is set on init as a concatenation of the baseURI and the
        /// value if baseURI != nil
        ///
        access(self) let value: String

        access(all) view fun uri(): String {
            return self.value
        }

        init(baseURI: String?, value: String) {
            self.baseURI = baseURI
            self.value = baseURI != nil ? baseURI!.concat(value) : value
        }
    }

    access(all) struct Media {

        /// File for the media
        ///
        access(all) let file: {File}

        /// media-type comes on the form of type/subtype as described here 
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
        ///
        access(all) let mediaType: String

        view init(file: {File}, mediaType: String) {
          self.file=file
          self.mediaType=mediaType
        }
    }

    /// Wrapper view for multiple media views
    ///
    access(all) struct Medias {

        /// An arbitrary-sized list for any number of Media items
        access(all) let items: [Media]

        view init(_ items: [Media]) {
            self.items = items
        }
    }

    /// Helper to get Medias in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Medias struct
    ///
    access(all) fun getMedias(_ viewResolver: &{ViewResolver.Resolver}) : Medias? {
        if let view = viewResolver.resolveView(Type<Medias>()) {
            if let v = view as? Medias {
                return v
            }
        }
        return nil
    }

    /// View to represent a license according to https://spdx.org/licenses/
    /// This view can be used if the content of an NFT is licensed.
    ///
    access(all) struct License {
        access(all) let spdxIdentifier: String

        view init(_ identifier: String) {
            self.spdxIdentifier = identifier
        }
    }

    /// Helper to get License in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional License struct
    ///
    access(all) fun getLicense(_ viewResolver: &{ViewResolver.Resolver}) : License? {
        if let view = viewResolver.resolveView(Type<License>()) {
            if let v = view as? License {
                return v
            }
        }
        return nil
    }

    /// View to expose a URL to this item on an external site.
    /// This can be used by applications like .find and Blocto to direct users 
    /// to the original link for an NFT or a project page that describes the NFT collection.
    /// eg https://www.my-nft-project.com/overview-of-nft-collection
    ///
    access(all) struct ExternalURL {
        access(all) let url: String

        view init(_ url: String) {
            self.url=url
        }
    }

    /// Helper to get ExternalURL in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional ExternalURL struct
    ///
    access(all) fun getExternalURL(_ viewResolver: &{ViewResolver.Resolver}) : ExternalURL? {
        if let view = viewResolver.resolveView(Type<ExternalURL>()) {
            if let v = view as? ExternalURL {
                return v
            }
        }
        return nil
    }

    /// View that defines the composable royalty standard that gives marketplaces a 
    /// unified interface to support NFT royalties.
    ///
    access(all) struct Royalty {

        /// Generic FungibleToken Receiver for the beneficiary of the royalty
        /// Can get the concrete type of the receiver with receiver.getType()
        /// Recommendation - Users should create a new link for a FlowToken 
        /// receiver for this using `getRoyaltyReceiverPublicPath()`, and not 
        /// use the default FlowToken receiver. This will allow users to update 
        /// the capability in the future to use a more generic capability
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// Multiplier used to calculate the amount of sale value transferred to 
        /// royalty receiver. Note - It should be between 0.0 and 1.0 
        /// Ex - If the sale value is x and multiplier is 0.56 then the royalty 
        /// value would be 0.56 * x.
        /// Generally percentage get represented in terms of basis points
        /// in solidity based smart contracts while cadence offers `UFix64` 
        /// that already supports the basis points use case because its 
        /// operations are entirely deterministic integer operations and support 
        /// up to 8 points of precision.
        access(all) let cut: UFix64

        /// Optional description: This can be the cause of paying the royalty,
        /// the relationship between the `wallet` and the NFT, or anything else
        /// that the owner might want to specify.
        access(all) let description: String

        view init(receiver: Capability<&{FungibleToken.Receiver}>, cut: UFix64, description: String) {
            pre {
                cut >= 0.0 && cut <= 1.0 :
                    "MetadataViews.Royalty.init: Cannot initialize the Royalty Metadata View! "
                    .concat("The provided royalty cut value of ").concat(cut.toString())
                    .concat(" is invalid. ")
                    .concat("It should be within the valid range between 0 and 1. i.e [0,1]")
            }
            self.receiver = receiver
            self.cut = cut
            self.description = description
        }
    }

    /// Wrapper view for multiple Royalty views.
    /// Marketplaces can query this `Royalties` struct from NFTs 
    /// and are expected to pay royalties based on these specifications.
    ///
    access(all) struct Royalties {

        /// Array that tracks the individual royalties
        access(self) let cutInfos: [Royalty]

        access(all) view init(_ cutInfos: [Royalty]) {
            // Validate that sum of all cut multipliers should not be greater than 1.0
            var totalCut = 0.0
            for royalty in cutInfos {
                totalCut = totalCut + royalty.cut
            }
            assert(
                totalCut <= 1.0,
                message:
                    "MetadataViews.Royalties.init: Cannot initialize Royalties Metadata View! "
                    .concat(" The sum of cutInfos multipliers is ")
                    .concat(totalCut.toString())
                    .concat(" but it should not be greater than 1.0")
            )
            // Assign the cutInfos
            self.cutInfos = cutInfos
        }

        /// Return the cutInfos list
        ///
        /// @return An array containing all the royalties structs
        ///
        access(all) view fun getRoyalties(): [Royalty] {
            return self.cutInfos
        }
    }

    /// Helper to get Royalties in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Royalties struct
    ///
    access(all) fun getRoyalties(_ viewResolver: &{ViewResolver.Resolver}) : Royalties? {
        if let view = viewResolver.resolveView(Type<Royalties>()) {
            if let v = view as? Royalties {
                return v
            }
        }
        return nil
    }

    /// Get the path that should be used for receiving royalties
    /// This is a path that will eventually be used for a generic switchboard receiver,
    /// hence the name but will only be used for royalties for now.
    ///
    /// @return The PublicPath for the generic FT receiver
    ///
    access(all) view fun getRoyaltyReceiverPublicPath(): PublicPath {
        return /public/GenericFTReceiver
    }

    /// View to represent a single field of metadata on an NFT.
    /// This is used to get traits of individual key/value pairs along with some
    /// contextualized data about the trait
    ///
    access(all) struct Trait {
        // The name of the trait. Like Background, Eyes, Hair, etc.
        access(all) let name: String

        // The underlying value of the trait, the rest of the fields of a trait provide context to the value.
        access(all) let value: AnyStruct

        // displayType is used to show some context about what this name and value represent
        // for instance, you could set value to a unix timestamp, and specify displayType as "Date" to tell
        // platforms to consume this trait as a date and not a number
        access(all) let displayType: String?

        // Rarity can also be used directly on an attribute.
        //
        // This is optional because not all attributes need to contribute to the NFT's rarity.
        access(all) let rarity: Rarity?

        view init(name: String, value: AnyStruct, displayType: String?, rarity: Rarity?) {
            self.name = name
            self.value = value
            self.displayType = displayType
            self.rarity = rarity
        }
    }

    /// Wrapper view to return all the traits on an NFT.
    /// This is used to return traits as individual key/value pairs along with
    /// some contextualized data about each trait.
    access(all) struct Traits {
        access(all) let traits: [Trait]

        view init(_ traits: [Trait]) {
            self.traits = traits
        }
            
        /// Adds a single Trait to the Traits view
        /// 
        /// @param Trait: The trait struct to be added
        ///
        access(all) fun addTrait(_ t: Trait) {
            self.traits.append(t)
        }
    }

    /// Helper to get Traits view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Traits struct
    ///
    access(all) fun getTraits(_ viewResolver: &{ViewResolver.Resolver}) : Traits? {
        if let view = viewResolver.resolveView(Type<Traits>()) {
            if let v = view as? Traits {
                return v
            }
        }
        return nil
    }

    /// Helper function to easily convert a dictionary to traits. For NFT 
    /// collections that do not need either of the optional values of a Trait, 
    /// this method should suffice to give them an array of valid traits.
    ///
    /// @param dict: The dictionary to be converted to Traits
    /// @param excludedNames: An optional String array specifying the `dict`
    ///         keys that are not wanted to become `Traits`
    /// @return The generated Traits view
    ///
    access(all) fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits {
        // Collection owners might not want all the fields in their metadata included.
        // They might want to handle some specially, or they might just not want them included at all.
        if excludedNames != nil {
            for k in excludedNames! {
                dict.remove(key: k)
            }
        }

        let traits: [Trait] = []
        for k in dict.keys {
            let trait = Trait(name: k, value: dict[k]!, displayType: nil, rarity: nil)
            traits.append(trait)
        }

        return Traits(traits)
    }

    /// Optional view for collections that issue multiple objects
    /// with the same or similar metadata, for example an X of 100 set. This
    /// information is useful for wallets and marketplaces.
    /// An NFT might be part of multiple editions, which is why the edition
    /// information is returned as an arbitrary sized array
    ///
    access(all) struct Edition {

        /// The name of the edition
        /// For example, this could be Set, Play, Series,
        /// or any other way a project could classify its editions
        access(all) let name: String?

        /// The edition number of the object.
        /// For an "24 of 100 (#24/100)" item, the number is 24.
        access(all) let number: UInt64

        /// The max edition number of this type of objects.
        /// This field should only be provided for limited-editioned objects.
        /// For an "24 of 100 (#24/100)" item, max is 100.
        /// For an item with unlimited edition, max should be set to nil.
        ///
        access(all) let max: UInt64?

        view init(name: String?, number: UInt64, max: UInt64?) {
            if max != nil {
                assert(
                    number <= max!,
                    message:
                        "MetadataViews.Edition.init: Cannot intialize the Edition Metadata View! "
                        .concat("The provided edition number of ")
                        .concat(number.toString())
                        .concat(" cannot be greater than the max edition number of ")
                        .concat(max!.toString())
                        .concat(".")
                )
            }
            self.name = name
            self.number = number
            self.max = max
        }
    }

    /// Wrapper view for multiple Edition views
    ///
    access(all) struct Editions {

        /// An arbitrary-sized list for any number of editions
        /// that the NFT might be a part of
        access(all) let infoList: [Edition]

        view init(_ infoList: [Edition]) {
            self.infoList = infoList
        }
    }

    /// Helper to get Editions in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Editions struct
    ///
    access(all) fun getEditions(_ viewResolver: &{ViewResolver.Resolver}) : Editions? {
        if let view = viewResolver.resolveView(Type<Editions>()) {
            if let v = view as? Editions {
                return v
            }
        }
        return nil
    }

    /// View representing a project-defined serial number for a specific NFT
    /// Projects have different definitions for what a serial number should be
    /// Some may use the NFTs regular ID and some may use a different
    /// classification system. The serial number is expected to be unique among
    /// other NFTs within that project
    ///
    access(all) struct Serial {
        access(all) let number: UInt64

        view init(_ number: UInt64) {
            self.number = number
        }
    }

    /// Helper to get Serial in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Serial struct
    ///
    access(all) fun getSerial(_ viewResolver: &{ViewResolver.Resolver}) : Serial? {
        if let view = viewResolver.resolveView(Type<Serial>()) {
            if let v = view as? Serial {
                return v
            }
        }
        return nil
    }

    /// View to expose rarity information for a single rarity
    /// Note that a rarity needs to have either score or description but it can 
    /// have both
    ///
    access(all) struct Rarity {
        /// The score of the rarity as a number
        access(all) let score: UFix64?

        /// The maximum value of score
        access(all) let max: UFix64?

        /// The description of the rarity as a string.
        ///
        /// This could be Legendary, Epic, Rare, Uncommon, Common or any other string value
        access(all) let description: String?

        view init(score: UFix64?, max: UFix64?, description: String?) {
            if score == nil && description == nil {
                panic("MetadataViews.Rarity.init: Cannot initialize the Rarity Metadata View! "
                      .concat("The provided score and description are both `nil`. ")
                      .concat(" A Rarity needs to set score, description, or both"))
            }

            self.score = score
            self.max = max
            self.description = description
        }
    }

    /// Helper to get Rarity view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Rarity struct
    ///
    access(all) fun getRarity(_ viewResolver: &{ViewResolver.Resolver}) : Rarity? {
        if let view = viewResolver.resolveView(Type<Rarity>()) {
            if let v = view as? Rarity {
                return v
            }
        }
        return nil
    }

    /// NFTView wraps all Core views along `id` and `uuid` fields, and is used 
    /// to give a complete picture of an NFT. Most NFTs should implement this 
    /// view.
    ///
    access(all) struct NFTView {
        access(all) let id: UInt64
        access(all) let uuid: UInt64
        access(all) let display: MetadataViews.Display?
        access(all) let externalURL: MetadataViews.ExternalURL?
        access(all) let collectionData: NFTCollectionData?
        access(all) let collectionDisplay: NFTCollectionDisplay?
        access(all) let royalties: Royalties?
        access(all) let traits: Traits?

        view init(
            id : UInt64,
            uuid : UInt64,
            display : MetadataViews.Display?,
            externalURL : MetadataViews.ExternalURL?,
            collectionData : NFTCollectionData?,
            collectionDisplay : NFTCollectionDisplay?,
            royalties : Royalties?,
            traits: Traits?
        ) {
            self.id = id
            self.uuid = uuid
            self.display = display
            self.externalURL = externalURL
            self.collectionData = collectionData
            self.collectionDisplay = collectionDisplay
            self.royalties = royalties
            self.traits = traits
        }
    }

    /// Helper to get an NFT view 
    ///
    /// @param id: The NFT id
    /// @param viewResolver: A reference to the resolver resource
    /// @return A NFTView struct
    ///
    access(all) fun getNFTView(id: UInt64, viewResolver: &{ViewResolver.Resolver}) : NFTView {
        let nftView = viewResolver.resolveView(Type<NFTView>())
        if nftView != nil {
            return nftView! as! NFTView
        }

        return NFTView(
            id : id,
            uuid: viewResolver.uuid,
            display: MetadataViews.getDisplay(viewResolver),
            externalURL : MetadataViews.getExternalURL(viewResolver),
            collectionData : self.getNFTCollectionData(viewResolver),
            collectionDisplay : self.getNFTCollectionDisplay(viewResolver),
            royalties : self.getRoyalties(viewResolver),
            traits : self.getTraits(viewResolver)
        )
    }

    /// View to expose the information needed store and retrieve an NFT.
    /// This can be used by applications to setup a NFT collection with proper 
    /// storage and public capabilities.
    ///
    access(all) struct NFTCollectionData {
        /// Path in storage where this NFT is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose public capabilities of this NFT
        /// including standard NFT interfaces and metadataviews interfaces
        access(all) let publicPath: PublicPath

        /// The concrete type of the collection that is exposed to the public
        /// now that entitlements exist, it no longer needs to be restricted to a specific interface
        access(all) let publicCollection: Type

        /// Type that should be linked at the aforementioned public path
        access(all) let publicLinkedType: Type

        /// Function that allows creation of an empty NFT collection that is intended to store
        /// this NFT.
        access(all) let createEmptyCollection: fun(): @{NonFungibleToken.Collection}

        view init(
            storagePath: StoragePath,
            publicPath: PublicPath,
            publicCollection: Type,
            publicLinkedType: Type,
            createEmptyCollectionFunction: fun(): @{NonFungibleToken.Collection}
        ) {
            pre {
                publicLinkedType.isSubtype(of: Type<&{NonFungibleToken.Collection}>()):
                    "MetadataViews.NFTCollectionData.init: Cannot initialize the NFTCollectionData Metadata View! "
                    .concat("The Public linked type <")
                    .concat(publicLinkedType.identifier)
                    .concat("> is incorrect. It must be a subtype of the NonFungibleToken.Collection interface.")
            }
            self.storagePath=storagePath
            self.publicPath=publicPath
            self.publicCollection=publicCollection
            self.publicLinkedType=publicLinkedType
            self.createEmptyCollection=createEmptyCollectionFunction
        }
    }

    /// Helper to get NFTCollectionData in a way that will return an typed Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollectionData struct
    ///
    access(all) fun getNFTCollectionData(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionData? {
        if let view = viewResolver.resolveView(Type<NFTCollectionData>()) {
            if let v = view as? NFTCollectionData {
                return v
            }
        }
        return nil
    }

    /// View to expose the information needed to showcase this NFT's
    /// collection. This can be used by applications to give an overview and 
    /// graphics of the NFT collection this NFT belongs to.
    ///
    access(all) struct NFTCollectionDisplay {
        // Name that should be used when displaying this NFT collection.
        access(all) let name: String

        // Description that should be used to give an overview of this collection.
        access(all) let description: String

        // External link to a URL to view more information about this collection.
        access(all) let externalURL: MetadataViews.ExternalURL

        // Square-sized image to represent this collection.
        access(all) let squareImage: MetadataViews.Media

        // Banner-sized image for this collection, recommended to have a size near 1400x350.
        access(all) let bannerImage: MetadataViews.Media

        // Social links to reach this collection's social homepages.
        // Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            squareImage: MetadataViews.Media,
            bannerImage: MetadataViews.Media,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.description = description
            self.externalURL = externalURL
            self.squareImage = squareImage
            self.bannerImage = bannerImage
            self.socials = socials
        }
    }

    /// Helper to get NFTCollectionDisplay in a way that will return a typed 
    /// Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollection struct
    ///
    access(all) fun getNFTCollectionDisplay(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionDisplay? {
        if let view = viewResolver.resolveView(Type<NFTCollectionDisplay>()) {
            if let v = view as? NFTCollectionDisplay {
                return v
            }
        }
        return nil
    }
    /// This view may be used by Cadence-native projects to define their
    /// contract- and token-level metadata according to EVM-compatible formats.
    /// Several ERC standards (e.g. ERC20, ERC721, etc.) expose name and symbol
    /// values to define assets as well as contract- & token-level metadata view
    /// `tokenURI(uint256)` and `contractURI()` methods. This view enables
    /// Cadence projects to define in their own contracts how they would like
    /// their metadata to be defined when bridged to EVM.
    ///
    access(all) struct EVMBridgedMetadata {

        /// The name of the asset
        ///
        access(all) let name: String

        /// The symbol of the asset
        ///
        access(all) let symbol: String

        /// The URI of the asset - this can either be contract-level or
        /// token-level URI depending on where the metadata is resolved. It
        /// is recommended to reference EVM metadata standards for how to best
        /// prepare your view's formatted value.
        ///
        /// For example, while you may choose to take advantage of onchain
        /// metadata, as is the case for most Cadence NFTs, you may also choose
        /// to represent your asset's metadata in IPFS and assign this value as
        /// an IPFSFile struct pointing to that IPFS file. Alternatively, you
        /// may serialize your NFT's metadata and assign it as a JSON string
        /// data URL representating the NFT's onchain metadata at the time this
        /// view is resolved.
        ///
        access(all) let uri: {File}

        init(name: String, symbol: String, uri: {File}) {
            self.name = name
            self.symbol = symbol
            self.uri = uri
        }
    }

    access(all) fun getEVMBridgedMetadata(_ viewResolver: &{ViewResolver.Resolver}) : EVMBridgedMetadata? {
        if let view = viewResolver.resolveView(Type<EVMBridgedMetadata>()) {
            if let v = view as? EVMBridgedMetadata {
                return v
            }
        }
        return nil
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/lib/ERC721TransferValidator.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { ICreatorToken } from "../interfaces/ICreatorToken.sol";

/**
 * @title  ERC721TransferValidator
 * @notice Functionality to use a transfer validator.
 */
abstract contract ERC721TransferValidator is ICreatorToken {
    /// @dev Store the transfer validator. The null address means no transfer validator is set.
    address internal _transferValidator;

    /// @notice Revert with an error if the transfer validator is being set to the same address.
    error SameTransferValidator();

    /// @notice Returns the currently active transfer validator.
    ///         The null address means no transfer validator is set.
    function getTransferValidator() external view returns (address) {
        return _transferValidator;
    }

    /// @notice Set the transfer validator.
    ///         The external method that uses this must include access control.
    function _setTransferValidator(address newValidator) internal {
        address oldValidator = _transferValidator;
        if (oldValidator == newValidator) {
            revert SameTransferValidator();
        }
        _transferValidator = newValidator;
        emit TransferValidatorUpdated(oldValidator, newValidator);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_id_in_Collection.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns true if a moment with the specified ID
// exists in a user's collection

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: Bool
// Whether a moment with specified ID exists in user's collection

access(all) fun main(account: Address, id: UInt64): Bool {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    return collectionRef.borrowNFT(id) != nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/grant_topshot_locking_admin.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

// this transaction takes a TopShot Locking Admin resource and
// saves it to the account storage of the account second authorizer

transaction {
    prepare(acct: auth(BorrowValue) &Account, acct2: auth(SaveValue) &Account) {
        let topShotLockingAdmin = acct.storage.borrow<&TopShotLocking.Admin>(from: TopShotLocking.AdminStoragePath())
          ?? panic("could not borrow admin reference")

        acct2.storage.save(<- topShotLockingAdmin.createNewAdmin(), to: TopShotLocking.AdminStoragePath())
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/mint_moment_with_subedition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is what an admin would use to mint a single new moment
// and deposit it in a user's collection

// Parameters:
//
// setID: the ID of a set containing the target play
// playID: the ID of a play from which a new moment is minted
// subeditionID: the ID of play's subedition
// recipientAddr: the Flow address of the account receiving the newly minted moment

transaction(setID: UInt32, playID: UInt32, subeditionID: UInt32, recipientAddr: Address) {
    // local variable for the admin reference
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)!
    }

    execute {
        // Borrow a reference to the specified set
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Mint a new NFT with Subedition
        let moment1 <- setRef.mintMomentWithSubedition(playID: playID, subeditionID: subeditionID)

        // get the public account object for the recipient
        let recipient = getAccount(recipientAddr)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's moment collection")

        // deposit the NFT in the receivers collection
        receiverRef.deposit(token: <-moment1)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/create_sale.cdc

```
import Market from 0xMARKETADDRESS
import FungibleToken from 0xFUNGIBLETOKENADDRESS

// This transaction creates a public sale collection capability that any user can interact with

// Parameters:
//
// tokenReceiverPath: token capability for the account who will receive tokens for purchase
// beneficiaryAccount: the Flow address of the account where a cut of the purchase will be sent
// cutPercentage: how much in percentage the beneficiary will receive from the sale

transaction(tokenReceiverPath: PublicPath, beneficiaryAccount: Address, cutPercentage: UFix64) {

    prepare(acct: auth(Storage, Capabilities) &Account) {
        
        let ownerCapability = acct.capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

        let beneficiaryCapability = getAccount(beneficiaryAccount).capabilities.get<&{FungibleToken.Receiver}>(tokenReceiverPath)!

        let collection <- Market.createSaleCollection(ownerCapability: ownerCapability, beneficiaryCapability: beneficiaryCapability, cutPercentage: cutPercentage)
        
        acct.storage.save(<-collection, to: /storage/topshotSaleCollection)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&Market.SaleCollection>(/storage/topshotSaleCollection),
            at: /public/topshotSaleCollection
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/transfer_erc721s_to_evm_address.cdc

```
import "Burner"
import "FungibleToken"
import "FlowToken"
import "EVM"

/// Transfers ERC721s from the signer's COA to an EVM address. All tokens must be defined in the same
/// contract and will be sent to the defined recipient.
///
/// @param erc721Address - The EVM address of the ERC721 contract
/// @param toEVMAddress - The EVM address to transfer the NFT to
/// @param nftIDs - The IDs of the NFTs to transfer
///
transaction(
    erc721Address: String,
    toEVMAddress: String,
    nftIDs: [UInt256]
) {
    prepare(signer: auth(BorrowValue) &Account) {
        // Borrow COA from signer's account storage
        let coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not find coa in signer's account.")

        // Transfer NFTs from signer's COA to provided EVM address
        mustTransferNFTs(coa, EVM.addressFromString(erc721Address),
            nftIDs: nftIDs,
            to: EVM.addressFromString(toEVMAddress),
        )
    }
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

/// Transfers NFTs from the provided COA to the provided EVM address
///
access(all) fun mustTransferNFTs(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ erc721Address: EVM.EVMAddress,
    nftIDs: [UInt256],
    to: EVM.EVMAddress
) {
    for id in nftIDs {
        assert(isOwner(coa, erc721Address, id, coa.address()), message: "NFT not owned by signer's COA")
        mustCall(coa, erc721Address,
            functionSig: "safeTransferFrom(address,address,uint256)",
            args: [coa.address(), to, id]
        )
        assert(isOwner(coa, erc721Address, id, to), message: "NFT not transferred to recipient")
    }
}

/// Checks if the provided NFT is owned by the provided EVM address
///
access(all) fun isOwner(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ erc721Address: EVM.EVMAddress,
    _ nftID: UInt256,
    _ ownerToCheck: EVM.EVMAddress
): Bool {
    let res = coa.call(
        to: erc721Address,
        data: EVM.encodeABIWithSignature("ownerOf(uint256)", [nftID]),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )
    assert(res.status == EVM.Status.successful, message: "Call to ERC721.ownerOf(uint256) failed")
    let decodedRes = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data)
    if decodedRes.length == 1 {
        let actualOwner = decodedRes[0] as! EVM.EVMAddress
        return actualOwner.equals(ownerToCheck)
    }
    return false
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/batch_lock_moments.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction locks a list of TopShot NFTs rendering them unable to be withdrawn, sold, or transferred

// Parameters
//
// ids: array of TopShot moment Flow IDs
// duration: number of seconds that the moment will be locked for

transaction(ids: [UInt64], duration: UFix64) {
    prepare(acct: auth(BorrowValue) &Account) {
        if let saleRef = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {
            for id in ids {
                saleRef.cancelSale(tokenID: id)
            }
        }

        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Update) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        collectionRef.batchLock(ids: ids, duration: duration)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/get_nft_metadata.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS

access(all) struct NFT {
    access(all) let name: String
    access(all) let description: String
    access(all) let thumbnail: String
    access(all) let owner: Address
    access(all) let type: String
    access(all) let externalURL: String
    access(all) let storagePath: String
    access(all) let publicPath: String
    access(all) let collectionName: String
    access(all) let collectionDescription: String
    access(all) let collectionSquareImage: String
    access(all) let collectionBannerImage: String
    access(all) let royaltyReceiversCount: UInt32
    access(all) let traitsCount: UInt32
    access(all) let videoURL: String

    init(
            name: String,
            description: String,
            thumbnail: String,
            owner: Address,
            type: String,
            externalURL: String,
            storagePath: String,
            publicPath: String,
            collectionName: String,
            collectionDescription: String,
            collectionSquareImage: String,
            collectionBannerImage: String,
            royaltyReceiversCount: UInt32,
            traitsCount: UInt32,
            videoURL: String
    ) {
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.owner = owner
        self.type = type
        self.externalURL = externalURL
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.royaltyReceiversCount = royaltyReceiversCount
        self.traitsCount = traitsCount
        self.videoURL = videoURL
    }
}

access(all) fun main(address: Address, id: UInt64): NFT {
    let account = getAccount(address)

    let collectionRef = account.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

    let nft = collectionRef.borrowMoment(id: id)!
    
    // Get all core views for this TopShot NFT
    let displayView = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
    let collectionDisplayView = nft.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay
    let collectionDataView = nft.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData
    let royaltiesView = nft.resolveView(Type<MetadataViews.Royalties>())! as! MetadataViews.Royalties
    let externalURLView = nft.resolveView(Type<MetadataViews.ExternalURL>())! as! MetadataViews.ExternalURL
    let traitsView = nft.resolveView(Type<MetadataViews.Traits>())! as! MetadataViews.Traits
    let mediasView = nft.resolveView(Type<MetadataViews.Medias>())! as! MetadataViews.Medias

    let owner: Address = nft.owner!.address!
    let nftType = nft.getType()

    return NFT(
        name: displayView.name,
        description: displayView.description,
        thumbnail: displayView.thumbnail.uri(),
        owner: owner,
        type: nftType.identifier,
        externalURL: externalURLView.url,
        storagePath: collectionDataView.storagePath.toString(),
        publicPath: collectionDataView.publicPath.toString(),
        collectionName: collectionDisplayView.name,
        collectionDescription: collectionDisplayView.description,
        collectionSquareImage: collectionDisplayView.squareImage.file.uri(),
        collectionBannerImage: collectionDisplayView.bannerImage.file.uri(),
        royaltyReceiversCount: UInt32(royaltiesView.getRoyalties().length),
        traitsCount: UInt32(traitsView.traits.length),
        videoURL: mediasView.items[1].file.uri()
    )
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/scripts/is_erc721_wrapped.cdc

```
import "EVM"

/// Returns true if the NFT is wrapped in the underlying ERC721 contract
///
/// @param flowAccountWithCoa - A Flow account with a COA
/// @param nftID - The ID of the NFT
/// @param underlying - The address of the underlying ERC721 contract
/// @param wrapper - The address of the wrapper ERC721 contract
///
access(all) fun main(flowAccountWithCoa: Address, nftID: UInt64, underlying: String, wrapper: String): Bool {
    let coa = getAuthAccount<auth(BorrowValue) &Account>(flowAccountWithCoa)
        .storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("No COA found in signer's account")

    return isNFTWrapped(coa, nftID: nftID, underlying: EVM.addressFromString(underlying), wrapper: EVM.addressFromString(wrapper))
}

/// Checks if the provided NFT is wrapped in the underlying ERC721 contract
///
access(all) fun isNFTWrapped(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    nftID: UInt64,
    underlying: EVM.EVMAddress,
    wrapper: EVM.EVMAddress
): Bool {
    let res = coa.call(
        to: underlying,
        data: EVM.encodeABIWithSignature("ownerOf(uint256)", [nftID]),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    // If the call fails, return false
    if res.status != EVM.Status.successful {
        return false
    }

    // Decode and compare the addresses
    let decodedResult = EVM.decodeABI(
        types: [Type<EVM.EVMAddress>()],
        data: res.data
    )
    assert(decodedResult.length == 1, message: "Invalid response length")
    let owner = decodedResult[0] as! EVM.EVMAddress
    return owner.toString() == wrapper.toString()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/change_price.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction changes the price of a moment that a user has for sale

// Parameters:
//
// tokenID: the ID of the moment whose price is being changed
// newPrice: the new price of the moment

transaction(tokenID: UInt64, newPrice: UFix64) {
    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the owner's sale collection
        let topshotSaleCollection = acct.storage.borrow<auth(TopShotMarketV3.Create) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath)
            ?? panic("Could not borrow from sale in storage")

        // Change the price of the moment
        topshotSaleCollection.listForSale(tokenID: tokenID, price: newPrice)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/change_percentage.cdc

```
import Market from 0xMARKETADDRESS

// This transaction changes the percentage cut of a moment's sale given to beneficiary

// Parameters:
//
// newPercentage: new percentage of tokens the beneficiary will receive from the sale

transaction(newPercentage: UFix64) {

    // Local variable for the account's topshot sale collection
    let topshotSaleCollectionRef: auth(Market.Update) &Market.SaleCollection

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the owner's sale collection
        self.topshotSaleCollectionRef = acct.storage.borrow<auth(Market.Update) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
    }

    execute {

        // Change the percentage of the moment
        self.topshotSaleCollectionRef.changePercentage(newPercentage)
    }

    post {

        self.topshotSaleCollectionRef.cutPercentage! == newPercentage: 
            "cutPercentage not changed"
    }
    
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/marketV3/upgrade_sale.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction is for a user to change a moment sale from
// the first version of the market contract to the third version

// Parameters
//
// tokenID: the ID of the moment whose sale is to be upgraded

transaction(tokenID: UInt64, price: UFix64) {

    prepare(acct: auth(BorrowValue) &Account) {

        // Borrow a reference to the NFT collection in the signers account	
        let nftCollection = acct.storage.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")	

        // borrow a reference to the owner's sale collection
        let topshotSaleCollection = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")

        let topshotSaleV3Collection = acct.storage.borrow<auth(TopShotMarketV3.Create) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath)
            ?? panic("Could not borrow reference to sale V2 in storage")

        // withdraw the moment from the sale, thereby de-listing it
        let token <- topshotSaleCollection.withdraw(tokenID: tokenID)

        // deposit the moment into the owner's collection	
        nftCollection.deposit(token: <-token)

        // List the specified moment for sale
        topshotSaleV3Collection.listForSale(tokenID: tokenID, price: price)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_collection_ids.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This is the script to get a list of all the moments' ids an account owns
// Just change the argument to `getAccount` to whatever account you want
// and as long as they have a published Collection receiver, you can see
// the moments they own.

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read

// Returns: [UInt64]
// list of all moments' ids an account owns

access(all) fun main(account: Address): [UInt64] {

    let acct = getAccount(account)

    let collectionRef = acct.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

    log(collectionRef.getIDs())

    return collectionRef.getIDs()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/Market.cdc

```
/*

    MarketTopShot.cdc

    Description: Contract definitions for users to sell their moments

    Authors: Joshua Hannan joshua.hannan@dapperlabs.com
             Dieter Shirley dete@axiomzen.com

    Marketplace is where users can create a sale collectio that they
    store in their account storage. In the sale collection,
    they can put their NFTs up for sale with a price and publish a
    reference so that others can see the sale.

    If another user sees an NFT that they want to buy,
    they can send fungible tokens that equal or exceed the buy price
    to buy the NFT.  The NFT is transferred to them when
    they make the purchase.

    Each user who wants to sell tokens will have a sale collection
    instance in their account that holds the tokens that they are putting up for sale

    They can give a reference to this collection to a central contract
    so that it can list the sales in a central place

    When a user creates a sale, they will specify a fungible token capability
    as the place where the payment for the token goes, and they also give
    another fungible token capability for where a cut of the purchase
    gets sent. The cut can be set to zero if the user desires and they
    will receive the entirety of the purchase. Topshot will initialize sales
    for users with the topshot admin vault as the vault where cuts get
    deposited to.
*/

import FungibleToken from 0xFUNGIBLETOKENADDRESS
import DapperUtilityCoin from 0xDUCADDRESS
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS

access(all) contract Market {

    access(all) entitlement Create
    access(all) entitlement Update

    // -----------------------------------------------------------------------
    // TopShot Market contract Event definitions
    // -----------------------------------------------------------------------

    // emitted when a TopShot moment is listed for sale
    access(all) event MomentListed(id: UInt64, price: UFix64, seller: Address?)
    // emitted when the price of a listed moment has changed
    access(all) event MomentPriceChanged(id: UInt64, newPrice: UFix64, seller: Address?)
    // emitted when a token is purchased from the market
    access(all) event MomentPurchased(id: UInt64, price: UFix64, seller: Address?)
    // emitted when a moment has been withdrawn from the sale
    access(all) event MomentWithdrawn(id: UInt64, owner: Address?)
    // emitted when the cut percentage of the sale has been changed by the owner
    access(all) event CutPercentageChanged(newPercent: UFix64, seller: Address?)

    // SalePublic
    //
    // The interface that a user can publish their sale as
    // to allow others to access their sale
    access(all) resource interface SalePublic {
        access(all) var cutPercentage: UFix64
        access(all) fun purchase(tokenID: UInt64, buyTokens: @DapperUtilityCoin.Vault): @TopShot.NFT {
            post {
                result.id == tokenID: "The ID of the withdrawn token must be the same as the requested ID"
            }
        }
        access(all) fun getPrice(tokenID: UInt64): UFix64?
        access(all) fun getIDs(): [UInt64]
        access(all) fun borrowMoment(id: UInt64): &TopShot.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // SaleCollection
    //
    // This is the main resource that token sellers will store in their account
    // to manage the NFTs that they are selling. The SaleCollection
    // holds a TopShot Collection resource to store the moments that are for sale
    // The SaleCollection also keeps track of the price of each token.
    //
    // When a token is purchased, a cut is taken from the tokens that are used to
    // purchase and sent to the beneficiary, then the rest are sent to the seller
    access(all) resource SaleCollection: SalePublic {

        // A collection of the moments that the user has for sale
        access(self) var forSale: @TopShot.Collection

        // Dictionary of the prices for each NFT by ID
        access(self) var prices: {UInt64: UFix64}

        // The fungible token vault of the seller
        // so that when someone buys a token, the tokens are deposited
        // to this Vault
        access(self) var ownerCapability: Capability

        // The capability that is used for depositing
        // the beneficiary's cut of every sale
        access(self) var beneficiaryCapability: Capability

        // the percentage that is taken from every purchase for the beneficiary
        // This is a literal percentage
        // For example, if the percentage is 15%, cutPercentage = 0.15
        access(all) var cutPercentage: UFix64

        init (ownerCapability: Capability, beneficiaryCapability: Capability, cutPercentage: UFix64) {
            pre {
                // Check that both capabilities are for fungible token Vault receivers
                // for dapper utility coin
                ownerCapability.borrow<&{FungibleToken.Receiver}>() != nil:
                    "Owner's Receiver Capability is invalid!"
                beneficiaryCapability.borrow<&{FungibleToken.Receiver}>() != nil:
                    "Beneficiary's Receiver Capability is invalid!"
            }

            self.forSale <- TopShot.createEmptyCollection(nftType: Type<@TopShot.NFT>()) as! @TopShot.Collection
            self.ownerCapability = ownerCapability
            self.beneficiaryCapability = beneficiaryCapability
            self.prices = {}
            self.cutPercentage = cutPercentage
        }

        // listForSale lists an NFT for sale in this sale collection
        // at the specified price
        access(Create) fun listForSale(token: @TopShot.NFT, price: UFix64) {

            // get the ID of the token
            let id = token.id

            // Set the token's price
            self.prices[token.id] = price

            // Deposit the token into the collection
            self.forSale.deposit(token: <-token)

            emit MomentListed(id: id, price: price, seller: self.owner?.address)
        }

        // Withdraw removes a moment that was listed for sale
        access(NonFungibleToken.Withdraw) fun withdraw(tokenID: UInt64): @TopShot.NFT {

            // remove and return the token
            // will revert if the token doesn't exist
            let token <- self.forSale.withdraw(withdrawID: tokenID) as! @TopShot.NFT

            // Remove the price from the prices dictionary
            self.prices.remove(key: tokenID)

            // set prices to nil for the withdrawn ID
            self.prices[tokenID] = nil

            // Emit the event for withdrawing a moment from the Sale
            emit MomentWithdrawn(id: token.id, owner: self.owner?.address)

            // Return the withdrawn token
            return <-token
        }

        // purchase lets a user send tokens to purchase an NFT that is for sale
        // the purchased NFT is returned to the transaction context that called it
        access(all) fun purchase(tokenID: UInt64, buyTokens: @DapperUtilityCoin.Vault): @TopShot.NFT {
            pre {
                self.forSale.borrowNFT(tokenID) != nil && self.prices[tokenID] != nil:
                    "No token matching this ID for sale!"
                buyTokens.balance == (self.prices[tokenID] ?? UFix64(0)):
                    "Not enough tokens to buy the NFT!"
            }

            // Read the price for the token
            let price = self.prices[tokenID]!

            // Set the price for the token to nil
            self.prices[tokenID] = nil

            // take the cut of the tokens that the beneficiary gets from the sent tokens
            let beneficiaryCut <- buyTokens.withdraw(amount: price*self.cutPercentage)

            // deposit it into the beneficiary's Vault
            self.beneficiaryCapability.borrow<&{FungibleToken.Receiver}>()!
                .deposit(from: <-beneficiaryCut)

            // deposit the remaining tokens into the owners vault
            self.ownerCapability.borrow<&{FungibleToken.Receiver}>()!
                .deposit(from: <-buyTokens)

            emit MomentPurchased(id: tokenID, price: price, seller: self.owner?.address)

            // return the purchased token
            return <-self.withdraw(tokenID: tokenID)
        }

        // changePrice changes the price of a token that is currently for sale
        access(Update) fun changePrice(tokenID: UInt64, newPrice: UFix64) {
            pre {
                self.prices[tokenID] != nil: "Cannot change the price for a token that is not for sale"
            }
            // set the new price
            self.prices[tokenID] = newPrice

            emit MomentPriceChanged(id: tokenID, newPrice: newPrice, seller: self.owner?.address)
        }

        // changePercentage changes the cut percentage of the tokens that are for sale
        access(Update) fun changePercentage(_ newPercent: UFix64) {
            self.cutPercentage = newPercent

            emit CutPercentageChanged(newPercent: newPercent, seller: self.owner?.address)
        }

        // changeOwnerReceiver updates the capability for the sellers fungible token Vault
        access(Update) fun changeOwnerReceiver(_ newOwnerCapability: Capability) {
            pre {
                newOwnerCapability.borrow<&{FungibleToken.Receiver}>() != nil:
                    "Owner's Receiver Capability is invalid!"
            }
            self.ownerCapability = newOwnerCapability
        }

        // changeBeneficiaryReceiver updates the capability for the beneficiary of the cut of the sale
        access(Update) fun changeBeneficiaryReceiver(_ newBeneficiaryCapability: Capability) {
            pre {
                newBeneficiaryCapability.borrow<&DapperUtilityCoin.Vault>() != nil:
                    "Beneficiary's Receiver Capability is invalid!"
            }
            self.beneficiaryCapability = newBeneficiaryCapability
        }

        // getPrice returns the price of a specific token in the sale
        access(all) view fun getPrice(tokenID: UInt64): UFix64? {
            return self.prices[tokenID]
        }

        // getIDs returns an array of token IDs that are for sale
        access(all) view fun getIDs(): [UInt64] {
            return self.forSale.getIDs()
        }

        // borrowMoment Returns a borrowed reference to a Moment in the collection
        // so that the caller can read data from it
        access(all) view fun borrowMoment(id: UInt64): &TopShot.NFT? {
            let ref = self.forSale.borrowMoment(id: id)
            return ref
        }
    }

    // createCollection returns a new collection resource to the caller
    access(all) fun createSaleCollection(ownerCapability: Capability, beneficiaryCapability: Capability, cutPercentage: UFix64): @SaleCollection {
        return <- create SaleCollection(ownerCapability: ownerCapability, beneficiaryCapability: beneficiaryCapability, cutPercentage: cutPercentage)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/bridge_nfts_to_evm.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"
import "MetadataViews"
import "FlowToken"
import "ScopedFTProviders"
import "EVM"
import "FlowEVMBridge"
import "FlowEVMBridgeConfig"
import "FlowEVMBridgeUtils"
import "CrossVMMetadataViews"

/// Bridges NFTs with provided IDs from Cadence to EVM, wrapping them in a wrapper ERC721 if applicable.
///
/// @param nftIdentifier: The identifier of the NFT to wrap and bridge (e.g., 'A.0b2a3299cc857e29.TopShot.NFT')
/// @param nftIDs: The IDs of the NFTs to bridge to EVM from Cadence
/// @param recipientEvmAddressIfnotCoa: The EVM address to transfer the NFTs to, nil if the NFTs should stay in signer's COA
///
transaction(
    nftIdentifier: String,
    nftIDs: [UInt64],
    recipientEvmAddressIfnotCoa: String?
) {
    let nftType: Type
    let collection: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}
    let coa: auth(EVM.Bridge, EVM.Call) &EVM.CadenceOwnedAccount
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let viewResolver: &{ViewResolver}

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        // Retrieve or create COA in signer's account
        if let coa = signer.storage.borrow<auth(EVM.Call, EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm) {
            self.coa = coa
        } else {
            signer.storage.save<@EVM.CadenceOwnedAccount>(<- EVM.createCadenceOwnedAccount(), to: /storage/evm)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(/storage/evm),
                at: /public/evm
            )
            self.coa = signer.storage.borrow<auth(EVM.Call, EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)!
        }

        // Get NFT type, address, and name from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        // Borrow a reference to the NFT collection, configuring if necessary
        self.viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract with name "
                .concat(nftContractName).concat(" and address ")
                .concat(nftContractAddress.toString()))
        let collectionData = self.viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData?
            ?? panic("Could not resolve NFTCollectionData view for NFT type ".concat(self.nftType.identifier))
        self.collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not borrow a NonFungibleToken Collection from the signer's storage path "
                .concat(collectionData.storagePath.toString()))

        // Withdraw the requested NFT & set a cap on the withdrawable bridge fee
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000 // 400 kB as upper bound on movable storage used in a single transaction
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(nftIDs.length))

        // Check that the NFT is onboarded
        let requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nftType)
            ?? panic("Bridge does not support the requested asset type ".concat(nftIdentifier))
        assert(!requiresOnboarding, message: "NFT must be onboarded before bridging and wrapping")

        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }

        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
            from: FlowEVMBridgeConfig.providerCapabilityStoragePath)
                ?? panic("Invalid FungibleToken Provider Capability found in storage at path "
                    .concat(FlowEVMBridgeConfig.providerCapabilityStoragePath.toString()))
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
            provider: providerCapCopy,
            filters: [ providerFilter ],
            expiration: getCurrentBlock().timestamp + 1.0
        )
    }

    execute {
        // Bridge each NFT from the signer's collection in Cadence to the signer's COA in EVM
        for id in nftIDs {
            // Withdraw the NFT & ensure it's the correct type
            let nft <- self.collection.withdraw(withdrawID: id)
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requested: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Execute the bridge to EVM for the current ID
            self.coa.depositNFT(
                nft: <- nft,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }

        // Destroy the ScopedFTProvider
        destroy self.scopedProvider

        // Wrap NFTs and transfer to recipient if applicable
        wrapAndTransferNFTsIfApplicable(self.coa,
            nftIDs: nftIDs,
            nftType: self.nftType,
            viewResolver: self.viewResolver,
            recipientIfNotCoa: recipientEvmAddressIfnotCoa != nil ? EVM.addressFromString(recipientEvmAddressIfnotCoa!) : nil
        )
    }
}

/// Wraps and transfers bridged NFTs into a project's custom ERC721 wrapper contract on EVM, if applicable.
/// Enables projects to use their own ERC721 contract while leveraging the bridge's underlying contract,
/// until direct custom contract support is added to the bridge.
///
/// @param coa: The COA of the signer
/// @param nftIDs: The IDs of the NFTs to wrap
/// @param nftType: The type of the NFTs to wrap
/// @param viewResolver: The ViewResolver of the NFT contract
/// @param recipientIfNotCoa: The EVM address to transfer the wrapped NFTs to, nil if the NFTs should stay in signer's COA
///
access(all) fun wrapAndTransferNFTsIfApplicable(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    nftIDs: [UInt64],
    nftType: Type,
    viewResolver: &{ViewResolver},
    recipientIfNotCoa: EVM.EVMAddress?
) {
    // Get the project-defined ERC721 address if it exists
    if let crossVMPointer = viewResolver.resolveContractView(
            resourceType: nftType,
            viewType: Type<CrossVMMetadataViews.EVMPointer>()
    ) as! CrossVMMetadataViews.EVMPointer? {
        // Get the underlying ERC721 address if it exists
        if let underlyingAddress = getUnderlyingERC721Address(coa, crossVMPointer.evmContractAddress) {
            // Wrap NFTs if underlying ERC721 address matches bridge's associated address for NFT type
            if underlyingAddress.equals(FlowEVMBridgeConfig.getEVMAddressAssociated(with: nftType)!) {
                // Approve contract to withdraw underlying NFTs from signer's coa
                mustCall(coa, underlyingAddress,
                    functionSig: "setApprovalForAll(address,bool)",
                    args: [crossVMPointer.evmContractAddress, true]
                )

                // Wrap NFTs with provided IDs, and check if the call was successful
                let res = mustCall(coa, crossVMPointer.evmContractAddress,
                    functionSig: "depositFor(address,uint256[])",
                    args: [coa.address(), nftIDs]
                )
                let decodedRes = EVM.decodeABI(types: [Type<Bool>()], data: res.data)
                assert(decodedRes.length == 1, message: "Invalid response length")
                assert(decodedRes[0] as! Bool, message: "Failed to wrap NFTs")

                // Transfer NFTs to recipient if provided
                if let to = recipientIfNotCoa {
                    mustTransferNFTs(coa, crossVMPointer.evmContractAddress, nftIDs: nftIDs, to: to)
                }

                // Revoke approval for contract to withdraw underlying NFTs from signer's coa
                mustCall(coa, underlyingAddress,
                    functionSig: "setApprovalForAll(address,bool)",
                    args: [crossVMPointer.evmContractAddress, false]
                )
            }
        }
    }
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

/// Transfers NFTs from the provided COA to the provided EVM address
///
access(all) fun mustTransferNFTs(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ erc721Address: EVM.EVMAddress,
    nftIDs: [UInt64],
    to: EVM.EVMAddress
) {
    for id in nftIDs {
        assert(isOwner(coa, erc721Address, id, coa.address()), message: "NFT not owned by signer's COA")
        mustCall(coa, erc721Address,
            functionSig: "safeTransferFrom(address,address,uint256)",
            args: [coa.address(), to, id]
        )
        assert(isOwner(coa, erc721Address, id, to), message: "NFT not transferred to recipient")
    }
}

/// Checks if the provided NFT is owned by the provided EVM address
///
access(all) fun isOwner(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ erc721Address: EVM.EVMAddress,
    _ nftID: UInt64,
    _ ownerToCheck: EVM.EVMAddress
): Bool {
    let res = coa.call(
        to: erc721Address,
        data: EVM.encodeABIWithSignature("ownerOf(uint256)", [nftID]),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )
    assert(res.status == EVM.Status.successful, message: "Call to ERC721.ownerOf(uint256) failed")
    let decodedRes = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data)
    if decodedRes.length == 1 {
        let actualOwner = decodedRes[0] as! EVM.EVMAddress
        return actualOwner.equals(ownerToCheck)
    }
    return false
}

/// Gets the underlying ERC721 address if it exists (i.e. if the ERC721 is a wrapper)
///
access(all) fun getUnderlyingERC721Address(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ wrapperAddress: EVM.EVMAddress
): EVM.EVMAddress? {
    let res = coa.call(
        to: wrapperAddress,
        data: EVM.encodeABIWithSignature("underlying()", []),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    // If the call fails, return nil
    if res.status != EVM.Status.successful || res.data.length == 0 {
        return nil
    }

    // Decode and return the underlying ERC721 address
    let decodedResult = EVM.decodeABI(
        types: [Type<EVM.EVMAddress>()],
        data: res.data
    )
    assert(decodedResult.length == 1, message: "Invalid response length")
    return decodedResult[0] as! EVM.EVMAddress
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/BridgedTopShotMoments.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ERC721EnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import {ERC721BurnableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {ERC721WrapperUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721WrapperUpgradeable.sol";

import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import {IERC721Metadata} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import {IERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {IERC2981} from "@openzeppelin/contracts/interfaces/IERC2981.sol";
import {IERC4906} from "@openzeppelin/contracts/interfaces/IERC4906.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import {ICreatorToken, ILegacyCreatorToken} from "./interfaces/ICreatorToken.sol";
import {ITransferValidator721} from "./interfaces/ITransferValidator.sol";
import {ERC721TransferValidator} from "./lib/ERC721TransferValidator.sol";

import {ICrossVM} from "./interfaces/ICrossVM.sol";
import {BridgePermissionsUpgradeable} from "./lib/BridgePermissionsUpgradeable.sol";
import {CrossVMBridgeERC721FulfillmentUpgradeable} from "./lib/CrossVMBridgeERC721FulfillmentUpgradeable.sol";

/**
 * @title ERC-721 BridgedTopShotMoments
 * @notice A NFT contract for bridged NBA Top Shot Moments
 * @dev This contract implements the following core features:
 * - ERC721 standard functionality with ownership, enumeration, and burning capabilities
 * - Upgradability via proxy and initializer pattern
 * - Wrapper functionality to handle NFTs from bridge-deployed contract
 * - Fulfillment functionality for Flow -> EVM bridging, once bridge onboarding allowed
 * - Cross-VM compatibility for Flow <-> EVM bridging
 * - Royalty management for secondary sales
 */
contract BridgedTopShotMoments is
    Initializable,
    ERC721Upgradeable,
    ERC721BurnableUpgradeable,
    ERC721EnumerableUpgradeable,
    OwnableUpgradeable,
    ERC721WrapperUpgradeable,
    ERC721TransferValidator,
    CrossVMBridgeERC721FulfillmentUpgradeable,
    BridgePermissionsUpgradeable,
    ICrossVM,
    IERC2981,
    IERC4906
{
    // Cadence-specific identifiers for cross-chain bridging
    string public cadenceNFTAddress;
    string public cadenceNFTIdentifier;

    // Metadata-related fields
    string public contractMetadata;
    string private _customSymbol;
    string private _baseTokenURI;

    // Royalty configuration for secondary sales
    RoyaltyInfo private _royaltyInfo;

    // Error declarations
    error InvalidRoyaltyBasisPoints(uint256 basisPoints);
    error RoyaltyAddressCannotBeZeroAddress();
    error InvalidUnderlyingTokenAddress();

    // Event declarations
    event RoyaltyInfoUpdated(address receiver, uint256 bps);
    event ContractURIUpdated();

    /**
     * @notice Stores royalty configuration for secondary sales
     * @dev royaltyBps is in basis points (1/100th of a percent)
     * e.g., 500 = 5%, max value is 10000 = 100%
     */
    struct RoyaltyInfo {
        address royaltyAddress;
        uint96 royaltyBps;
    }

    /**
     * @dev Initializes the contract.
     */
    function initialize(
        address owner,
        address underlyingNftContractAddress,
        address vmBridgeAddress,
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_,
        string memory _cadenceNFTAddress,
        string memory _cadenceNFTIdentifier,
        string memory _contractMetadata
    ) public initializer {
        if (underlyingNftContractAddress == address(0)) {
            revert InvalidUnderlyingTokenAddress();
        }
        __ERC721_init(name_, symbol_);
        __Ownable_init(owner);
        __ERC721Wrapper_init(IERC721(underlyingNftContractAddress));
        __CrossVMBridgeERC721Fulfillment_init(vmBridgeAddress);
        __BridgePermissions_init();
        _customSymbol = symbol_;
        _baseTokenURI = baseTokenURI_;
        cadenceNFTAddress = _cadenceNFTAddress;
        cadenceNFTIdentifier = _cadenceNFTIdentifier;
        contractMetadata = _contractMetadata;
    }

    function getCadenceAddress() external view returns (string memory) {
        return cadenceNFTAddress;
    }

    function getCadenceIdentifier() external view returns (string memory) {
        return cadenceNFTIdentifier;
    }

    function symbol() public view override returns (string memory) {
        return _customSymbol;
    }

    function contractURI() public view returns (string memory) {
        return contractMetadata;
    }

    function setSymbol(string memory newSymbol) public onlyOwner {
        _setSymbol(newSymbol);
    }

    /**
     * @notice Sets the contract URI, whether an offchain metadata URL or a JSON object
     * (i.e. `data:application/json;utf8,{"name":"...","description":"..."}`).
     */
    function setContractURI(string memory newMetadata) external onlyOwner {
        contractMetadata = newMetadata;

        // Indicate that the metadata has been updated (https://docs.opensea.io/docs/contract-level-metadata)
        emit ContractURIUpdated();
    }

    function setBaseTokenURI(string memory newBaseTokenURI) public onlyOwner {
        _baseTokenURI = newBaseTokenURI;

        // Indicate that the metadata has been updated (https://docs.opensea.io/docs/metadata-standards#metadata-updates)
        emit MetadataUpdate(type(uint256).max);
    }

    /**
     * @notice Returns the token URI for a given token ID.
     */
    function tokenURI(uint256 tokenId) public view override(ERC721Upgradeable) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, BridgePermissionsUpgradeable, CrossVMBridgeERC721FulfillmentUpgradeable, IERC165)
        returns (bool)
    {
        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721Metadata).interfaceId
            || interfaceId == type(IERC721Enumerable).interfaceId || interfaceId == type(ERC721BurnableUpgradeable).interfaceId
            || interfaceId == type(OwnableUpgradeable).interfaceId || interfaceId == type(ICrossVM).interfaceId
            || interfaceId == type(ICreatorToken).interfaceId || interfaceId == type(ILegacyCreatorToken).interfaceId
            || interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }

    function _setSymbol(string memory newSymbol) internal {
        _customSymbol = newSymbol;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
        returns (address)
    {
        // Add the beforeTokenTransfer hook
        _beforeTokenTransfer(_ownerOf(tokenId), to, tokenId);

        // Call parent implementation
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {
        super._increaseBalance(account, value);
    }

    function setBridgePermissions(bool permissions) external onlyOwner {
        _setPermissions(permissions);
    }

    function setRoyaltyInfo(RoyaltyInfo calldata newInfo) external onlyOwner {
        // Revert if the new royalty address is the zero address.
        if (newInfo.royaltyAddress == address(0)) {
            revert RoyaltyAddressCannotBeZeroAddress();
        }

        // Revert if the new basis points is greater than 10_000.
        if (newInfo.royaltyBps > 10_000) {
            revert InvalidRoyaltyBasisPoints(newInfo.royaltyBps);
        }

        // Set the new royalty info.
        _royaltyInfo = newInfo;

        // Emit an event with the updated params.
        emit RoyaltyInfoUpdated(newInfo.royaltyAddress, newInfo.royaltyBps);
    }

    function royaltyAddress() external view returns (address) {
        return _royaltyInfo.royaltyAddress;
    }

    function royaltyBasisPoints() external view returns (uint256) {
        return _royaltyInfo.royaltyBps;
    }

    /**
     * @dev Implements the IERC2981 interface.
     */
    function royaltyInfo(
        uint256 /* _tokenId */,
        uint256 _salePrice
    ) external view returns (address receiver, uint256 royaltyAmount) {
        // Put the royalty info on the stack for more efficient access.
        RoyaltyInfo storage info = _royaltyInfo;

        // Set the royalty amount to the sale price times the royalty basis
        // points divided by 10_000.
        royaltyAmount = (_salePrice * info.royaltyBps) / 10_000;

        // Set the receiver of the royalty.
        receiver = info.royaltyAddress;
    }

    function getTransferValidationFunction()
        external
        pure
        returns (bytes4 functionSignature, bool isViewFunction)
    {
        functionSignature = ITransferValidator721.validateTransfer.selector;
        isViewFunction = false;
    }

    function setTransferValidator(address newValidator) external onlyOwner {
        _setTransferValidator(newValidator);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 startTokenId
    ) internal virtual {
        if (from != address(0) && to != address(0)) {
            // Call the transfer validator if one is set.
            address transferValidator = _transferValidator;
            if (transferValidator != address(0)) {
                ITransferValidator721(transferValidator).validateTransfer(
                    msg.sender,
                    from,
                    to,
                    startTokenId
                );
            }
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_plays_in_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns an array of the play IDs that are
// in the specified set

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read

// Returns: [UInt32]
// Array of play IDs in specified set

access(all) fun main(setID: UInt32): [UInt32] {

    let plays = TopShot.getPlaysInSet(setID: setID)!

    return plays
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/batch_unlock_moments.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction unlocks a list of TopShot NFTs

// Parameters
//
// ids: array of TopShot moment Flow IDs

transaction(ids: [UInt64]) {
    prepare(acct: auth(BorrowValue) &Account) {
        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Update) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        collectionRef.batchUnlock(ids: ids)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_metadata_field.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the metadata associated with a moment
// in a collection by looking up its playID and then searching
// for that play's metadata in the TopShot contract. It returns
// the value for the specified metadata field

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// momentID: The unique ID for the moment whose data needs to be read
// fieldToSearch: The specified metadata field whose data needs to be read

// Returns: String
// Value of specified metadata field

access(all) fun main(account: Address, momentID: UInt64, fieldToSearch: String): String {

    // borrow a public reference to the owner's moment collection 
    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    // borrow a reference to the specified moment in the collection
    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    // Get the tokens data
    let data = token.data

    // Get the metadata field associated with the specific play
    let field = TopShot.getPlayMetaDataByField(playID: data.playID, field: fieldToSearch) ?? panic("Play doesn't exist")

    log(field)

    return field
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/plays/get_play_metadata.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns the full metadata associated with a play
// in the TopShot smart contract

// Parameters:
//
// playID: The unique ID for the play whose data needs to be read

// Returns: {String:String}
// A dictionary of all the play metadata associated
// with the specified playID

access(all) fun main(playID: UInt32): {String:String} {

    let metadata = TopShot.getPlayMetaData(playID: playID) ?? panic("Play doesn't exist")

    log(metadata)

    return metadata
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/update_tagline.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction updates multiple existing plays' taglines
// and stores them in the Top Shot smart contract

// Parameters:
//
// plays: A dictionary of {playID: tagline} pairs

transaction(plays: {UInt32: String}) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin
    let firstKey: UInt32
    let lastKey: UInt32

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the admin resource
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")
        self.firstKey = plays.keys[0]
        self.lastKey = plays.keys[plays.keys.length - 1]
    }

    execute {
        // update multiple plays with the specified metadata
        for key in plays.keys {
            self.adminRef.updatePlayTagline(playID: key, tagline: plays[key] ?? panic("No tagline for play"))
        }
    }

    post {
        TopShot.getPlayMetaDataByField(playID: self.firstKey, field: "Tagline") != nil:
            "First play's tagline does not exist"
        TopShot.getPlayMetaDataByField(playID: self.lastKey, field: "Tagline") != nil:
            "Last play's tagline does not exist"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/player/play.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(
    fastBreakGameID: String,
    topShots: [UInt64]
) {

    let gameRef: auth(FastBreakV1.Play) &FastBreakV1.Player
    let recipient: &{FastBreakV1.FastBreakNFTCollectionPublic}

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.gameRef = acct.storage
            .borrow<auth(FastBreakV1.Play) &FastBreakV1.Player>(from: FastBreakV1.PlayerStoragePath)
            ?? panic("could not borrow a reference to the accounts player")

        self.recipient = acct.capabilities.borrow<&FastBreakV1.Collection>(FastBreakV1.CollectionPublicPath)
            ?? panic("could not borrow a reference to the collection receiver")

    }

    execute {

        let nft <- self.gameRef.play(
            fastBreakGameID: fastBreakGameID,
            topShots: topShots
        )
        self.recipient.deposit(token: <- (nft as @{NonFungibleToken.NFT}))
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/start_sale.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction is for a user to put a new moment up for sale
// They must have TopShot Collection and a Market Sale Collection
// stored in their account

// Parameters
//
// momentId: the ID of the moment to be listed for sale
// price: the sell price of the moment

transaction(momentID: UInt64, price: UFix64) {

    let collectionRef: auth(NonFungibleToken.Withdraw) &TopShot.Collection
    let saleCollectionRef: auth(Market.Create) &Market.SaleCollection

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the Top Shot Collection
        self.collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow from MomentCollection in storage")

        // borrow a reference to the topshot Sale Collection
        self.saleCollectionRef = acct.storage.borrow<auth(Market.Create) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
    }

    execute {

        // withdraw the specified token from the collection
        let token <- self.collectionRef.withdraw(withdrawID: momentID) as! @TopShot.NFT

        // List the specified moment for sale
        self.saleCollectionRef.listForSale(token: <-token, price: price)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_numMoments_in_edition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns the number of specified moments that have been
// minted for the specified edition

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read
// playID: The unique ID for the play whose data needs to be read

// Returns: UInt32
// number of moments with specified playID minted for a set with specified setID

access(all) fun main(setID: UInt32, playID: UInt32): UInt32 {

    let numMoments = TopShot.getNumMomentsInEdition(setID: setID, playID: playID)
        ?? panic("Could not find the specified edition")

    return numMoments
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/transfer_admin.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopshotAdminReceiver from 0xADMINRECEIVERADDRESS

// this transaction takes a TopShot Admin resource and 
// saves it to the account storage of the account
// where the contract is deployed

transaction {

    // Local variable for the topshot Admin object
    let adminRef: @TopShot.Admin

    prepare(acct: auth(LoadValue) &Account) {

        self.adminRef <- acct.storage.load<@TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No topshot admin in storage")
    }

    execute {

        TopshotAdminReceiver.storeAdmin(newAdmin: <-self.adminRef)
        
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/create_set_and_play_struct.cdc

```
import TopShot from 0xTOPSHOTADDRESS

transaction() {
    
    prepare(acct: auth(BorrowValue) &Account) {

        let metadata: {String: String} = {"PlayType": "Shoe becomes untied"}

        let newPlay = TopShot.Play(metadata: metadata)

        let newSet = TopShot.SetData(name: "Sneaky Sneakers")
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/admin/set_up_royalty_management.cdc

```
import "EVM"

/// Sets up royalty management for an ERC721 contract
///
/// @param erc721C - The EVM address of the ERC721 contract
/// @param validator - The EVM address of the validator contract
/// @param royaltyRecipient - The EVM address of the royalty recipient
/// @param royaltyBasisPoints - The royalty basis points (0-10000)
transaction(
    erc721C: String,
    validator: String,
    royaltyRecipient: String,
    royaltyBasisPoints: UInt128,
) {
    prepare(signer: auth(BorrowValue) &Account) {
        // Borrow COA from signer's account storage
        let coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not find coa in signer's account.")

        // Set validator contract
        mustCall(coa, EVM.addressFromString(erc721C),
            functionSig: "setTransferValidator(address)",
            args: [EVM.addressFromString(validator)]
        )

        // Set royalty info
        mustCall(coa, EVM.addressFromString(erc721C),
            functionSig: "setRoyaltyInfo((address,uint96))",
            args: [EVM.addressFromString(royaltyRecipient), royaltyBasisPoints]
        )
    }
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/lib/BridgePermissionsUpgradeable.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol";
import {IBridgePermissions} from "../interfaces/IBridgePermissions.sol";

/**
 * @dev Contract for which implementation is checked by the Flow VM bridge as an opt-out mechanism
 * for non-standard asset contracts that wish to opt-out of bridging between Cadence & EVM. By
 * default, the VM bridge operates on a permissionless basis, meaning anyone can request an asset
 * be onboarded. However, some small subset of non-standard projects may wish to opt-out of this
 * and this contract provides a way to do so while also enabling future opt-in.
 *
 * Note: The Flow VM bridge checks for permissions at asset onboarding. If your asset has already
 * been onboarded, setting `permissions` to `false` will not affect movement between VMs.
 */
abstract contract BridgePermissionsUpgradeable is Initializable, ERC165Upgradeable, IBridgePermissions {
    // The permissions for the contract to allow or disallow bridging of its assets.
    bool private _permissions;

    function __BridgePermissions_init() internal onlyInitializing {
        _permissions = false;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {
        return interfaceId == type(IBridgePermissions).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns true if the contract allows bridging of its assets. Checked by the Flow VM
     *     bridge at asset onboarding to enable non-standard asset contracts to opt-out of bridging
     *     between Cadence & EVM. Implementing this contract opts out by default but can be
     *     overridden to opt-in or used in conjunction with a switch to enable opting in.
     */
    function allowsBridging() external view virtual returns (bool) {
        return _permissions;
    }

    /**
     * @dev Set the permissions for the contract to allow or disallow bridging of its assets.
     *
     * Emits a {PermissionsUpdated} event.
     */
    function _setPermissions(bool permissions) internal {
        if (_permissions != permissions) {
            _permissions = permissions;
            emit PermissionsUpdated(permissions);
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/change_price.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import Market from 0xMARKETADDRESS

// This transaction changes the price of a moment that a user has for sale

// Parameters:
//
// tokenID: the ID of the moment whose price is being changed
// newPrice: the new price of the moment

transaction(tokenID: UInt64, newPrice: UFix64) {

    // Local variable for the account's topshot sale collection
    let topshotSaleCollectionRef: auth(Market.Update) &Market.SaleCollection

    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the owner's sale collection
        self.topshotSaleCollectionRef = acct.storage.borrow<auth(Market.Update) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
    }

    execute {

        // Change the price of the moment
        self.topshotSaleCollectionRef.changePrice(tokenID: tokenID, newPrice: newPrice)
    }

    
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/add_plays_to_set.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction adds multiple plays to a set
		
// Parameters:
//
// setID: the ID of the set to which multiple plays are added
// plays: an array of play IDs being added to the set

transaction(setID: UInt32, plays: [UInt32]) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)!
    }

    execute {

        // borrow a reference to the set to be added to
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Add the specified play IDs
        setRef.addPlays(playIDs: plays)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/users/is_account_all_set_up.cdc

```
import NonFungibleToken from "NonFungibleToken"
import PackNFT from "PackNFT"
import TopShot from "TopShot"

/// Check if an account has been set up to hold Pinnacle NFTs.
///
access(all) fun main(address: Address): Bool {
    let account = getAccount(address)
    return account.capabilities.borrow<
        &TopShot.Collection>(/public/MomentCollection) != nil &&
        account.capabilities.borrow<
        &PackNFT.Collection>(PackNFT.CollectionPublicPath) != nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/shardedCollection/setup_sharded_collection.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS
import NonFungibleToken from 0xNFTADDRESS

// This transaction creates and stores an empty moment collection 
// and creates a public capability for it.
// Moments are split into a number of buckets
// This makes storage more efficient and performant

// Parameters
//
// numBuckets: The number of buckets to split Moments into

transaction(numBuckets: UInt64) {

    prepare(acct: auth(Storage, Capabilities) &Account) {

        if acct.storage.borrow<&TopShotShardedCollection.ShardedCollection>(from: /storage/ShardedMomentCollection) == nil {

            let collection <- TopShotShardedCollection.createEmptyCollection(numBuckets: numBuckets)
            // Put a new Collection in storage
            acct.storage.save(<-collection, to: /storage/ShardedMomentCollection)

            acct.capabilities.unpublish(/public/MomentCollection)
            acct.capabilities.publish(
                acct.capabilities.storage.issue<&TopShotShardedCollection.ShardedCollection>(/storage/ShardedMomentCollection),
                at: /public/MomentCollection
            )
        } else {

            panic("Sharded Collection already exists!")
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/get_currentSeries.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script reads the current series from the TopShot contract and 
// returns that number to the caller

// Returns: UInt32
// currentSeries field in TopShot contract

access(all) fun main(): UInt32 {

    return TopShot.currentSeries
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_setName.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the setName of a set with specified setID

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read

// Returns: String
// Name of set with specified setID

access(all) fun main(setID: UInt32): String {

    let name = TopShot.getSetName(setID: setID)
        ?? panic("Could not find the specified set")
        
    return name
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_edition_retired.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction reads if a specified edition is retired

// Parameters:
//
// setID: The unique ID for the set whose data needs to be read
// playID: The unique ID for the play whose data needs to be read

// Returns: Bool
// Whether specified set is retired

access(all) fun main(setID: UInt32, playID: UInt32): Bool {

    let isRetired = TopShot.isEditionRetired(setID: setID, playID: playID)
        ?? panic("Could not find the specified edition")
    
    return isRetired
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/mark_moment_unlockable.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

transaction(ownerAddress: Address, id: UInt64) {
    let adminRef: &TopShotLocking.Admin

    prepare(acct: auth(BorrowValue) &Account) {
        // Set TopShotLocking admin ref
        self.adminRef = acct.storage.borrow<&TopShotLocking.Admin>(from: /storage/TopShotLockingAdmin)
            ?? panic("Could not find reference to TopShotLocking Admin resource")
    }

    execute {
        // Set Top Shot NFT Owner collection ref
        let owner = getAccount(ownerAddress)

        let collectionRef = owner.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Could not reference owner's moment collection")

        // borrow the nft reference
        let nftRef = collectionRef.borrowNFT(id)!

        // mark the nft as unlockable
        self.adminRef.markNFTUnlockable(nftRef: nftRef)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/utils/unwrap_nfts.cdc

```
import "EVM"

/// Unwraps NFTs with provided IDs
///
/// @param wrapperERC721Address: EVM address of the wrapper ERC721 NFT
/// @param nftIDs: Array of IDs of the NFTs to unwrap
///
transaction(
    wrapperERC721Address: String,
    nftIDs: [UInt256]
) {
    // Cadence-owned account
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue) &Account) {
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("No COA found in signer's account")
    }

    execute {
        // Unwrap NFTs with provided IDs
        mustCall(self.coa, EVM.addressFromString(wrapperERC721Address),
            functionSig: "withdrawTo(address,uint256[])",
            args: [self.coa.address(), nftIDs]
        )
    }
}

/// Gets the underlying ERC721 address
///
access(all) fun getUnderlyingERC721Address(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ wrapperAddress: EVM.EVMAddress
): EVM.EVMAddress {
    let res = coa.call(
        to: wrapperAddress,
        data: EVM.encodeABIWithSignature("underlying()", []),
        gasLimit: 100_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful, message: "Call to get underlying ERC721 address failed")
    let decodedResult = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: res.data)
    assert(decodedResult.length == 1, message: "Invalid response length")

    return decodedResult[0] as! EVM.EVMAddress
}

/// Calls a function on an EVM contract from provided coa
///
access(all) fun mustCall(
    _ coa: auth(EVM.Call) &EVM.CadenceOwnedAccount,
    _ contractAddr: EVM.EVMAddress,
    functionSig: String,
    args: [AnyStruct]
): EVM.Result {
    let res = coa.call(
        to: contractAddr,
        data: EVM.encodeABIWithSignature(functionSig, args),
        gasLimit: 4_000_000,
        value: EVM.Balance(attoflow: 0)
    )

    assert(res.status == EVM.Status.successful,
        message: "Failed to call '".concat(functionSig)
            .concat("\n\t error code: ").concat(res.errorCode.toString())
            .concat("\n\t error message: ").concat(res.errorMessage)
            .concat("\n\t gas used: ").concat(res.gasUsed.toString())
            .concat("\n\t args count: ").concat(args.length.toString())
            .concat("\n\t caller address: 0x").concat(coa.address().toString())
            .concat("\n\t contract address: 0x").concat(contractAddr.toString())
    )

    return res
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/cadence/transactions/tests/test_uint_array_encoding.cdc

```
import "EVM"

transaction(evmContractAddress: String) {
    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount

    prepare(signer: auth(SaveValue, BorrowValue, Capabilities) &Account) {
        // Retrieve or create COA
        if let coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm) {
            self.coa = coa
        } else {
            signer.storage.save<@EVM.CadenceOwnedAccount>(<- EVM.createCadenceOwnedAccount(), to: /storage/evm)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(/storage/evm),
                at: /public/evm
            )
            self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)!
        }
    }

    execute {
        // Test array with various values including edge cases (min and max uint64 values)
        let testArray: [UInt64] = [0, 1, 999999, 18446744073709551615]

        // Encode and call
        let res = self.coa.call(
            to: EVM.addressFromString(evmContractAddress),
            data: EVM.encodeABIWithSignature(
                "testArrayEncoding(uint256[])",
                [testArray]
            ),
            gasLimit: 100_000,
            value: EVM.Balance(attoflow: 0)
        )

        assert(res.status == EVM.Status.successful, message: "Call failed")

        // Decode and verify
        let decoded = EVM.decodeABI(types: [Type<[UInt64]>()], data: res.data)
        let returnedArray = decoded[0] as! [UInt64]

        // Compare arrays
        assert(testArray.length == returnedArray.length, message: "Array length mismatch")
        for i, value in testArray {
            assert(value == returnedArray[i],
                message: "Mismatch at index ".concat(i.toString())
                    .concat(": expected ").concat(value.toString())
                    .concat(", got ").concat(returnedArray[i].toString())
            )
        }

        log("Array encoding test passed!")
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/user/transfer_moment_v3_sale.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotMarketV3 from 0xMARKETV3ADDRESS

// This transaction transfers a moment to a recipient
// and cancels the sale in the V3 collection if it exists

// Parameters:
//
// recipient: The Flow address of the account to receive the moment.
// withdrawID: The id of the moment to be transferred

transaction(recipient: Address, withdrawID: UInt64) {

    // local variable for storing the transferred token
    let transferToken: @{NonFungibleToken.NFT}
    
    prepare(acct: auth(Storage, Capabilities) &Account) {

        // borrow a reference to the owner's collection
        let collectionRef = acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShot.Collection>(from: /storage/MomentCollection)
            ?? panic("Could not borrow a reference to the stored Moment collection")
        
        // withdraw the NFT
        self.transferToken <- collectionRef.withdraw(withdrawID: withdrawID)

        if let saleRef = acct.storage.borrow<auth(TopShotMarketV3.Cancel) &TopShotMarketV3.SaleCollection>(from: TopShotMarketV3.marketStoragePath) {
            saleRef.cancelSale(tokenID: withdrawID)
        }
    }

    execute {
        
        // get the recipient's public account object
        let recipient = getAccount(recipient)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

        // deposit the NFT in the receivers collection
        receiverRef.deposit(token: <-self.transferToken)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_setID.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the setID associated with a moment
// in a collection by getting a reference to the moment
// and then looking up its setID 

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: UInt32
// The setID associated with a moment with a specified ID

access(all) fun main(account: Address, id: UInt64): UInt32 {

    // borrow a public reference to the owner's moment collection 
    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    // borrow a reference to the specified moment in the collection
    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return data.setID
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/sets/get_setIDs_by_name.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script returns an array of the setIDs
// that have the specified name

// Parameters:
//
// setName: The name of the set whose data needs to be read

// Returns: [UInt32]
// Array of setIDs that have specified set name

access(all) fun main(setName: String): [UInt32] {

    let ids = TopShot.getSetIDsByName(setName: setName)
        ?? panic("Could not find the specified set name")

    return ids
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_lockExpiry.cdc

```
import TopShot from 0xTOPSHOTADDRESS
import TopShotLocking from 0xTOPSHOTLOCKINGADDRESS

// This script gets the time at which a moment will be eligible for unlocking

// Parameters:
//
// account: The Flow Address of the account who owns the moment
// id: The unique ID for the moment

// Returns: UFix64
// The unix timestamp when the moment is unlockable

access(all) fun main(account: Address, id: UInt64): UFix64 {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    let nftRef = collectionRef.borrowNFT(id)!

    return TopShotLocking.getLockExpiry(nftRef: nftRef)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/test/BridgedTopShotMoments.t.sol

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Test} from "forge-std/Test.sol";
import "forge-std/console.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/src/Upgrades.sol";
import {BridgedTopShotMoments} from "../src/BridgedTopShotMoments.sol";
import {ERC721} from "openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";
import {IERC721Errors} from "openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {Ownable} from "openzeppelin-contracts/contracts/access/Ownable.sol";
import {Strings} from "openzeppelin-contracts/contracts/utils/Strings.sol";
import {CrossVMBridgeERC721FulfillmentUpgradeable} from "../src/lib/CrossVMBridgeERC721FulfillmentUpgradeable.sol";
import {CrossVMBridgeCallableUpgradeable} from "../src/lib/CrossVMBridgeCallableUpgradeable.sol";

import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {IERC721Metadata} from "@openzeppelin/contracts/interfaces/IERC721Metadata.sol";
import {IERC721Enumerable} from "@openzeppelin/contracts/interfaces/IERC721Enumerable.sol";
import {ICrossVMBridgeERC721Fulfillment} from "../src/interfaces/ICrossVMBridgeERC721Fulfillment.sol";
import {ICrossVMBridgeCallable} from "../src/interfaces/ICrossVMBridgeCallable.sol";
import {ICrossVM} from "../src/interfaces/ICrossVM.sol";
import {ICreatorToken, ILegacyCreatorToken} from "../src/interfaces/ICreatorToken.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {IERC2981} from "@openzeppelin/contracts/interfaces/IERC2981.sol";
import {IBridgePermissions} from "../src/interfaces/IBridgePermissions.sol";

// Add this minimal ERC721 implementation for testing
contract UnderlyingERC721 is ERC721, Ownable {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) {}

    function safeMint(address to, uint256 tokenId) public onlyOwner {
        _safeMint(to, tokenId);
    }
}

contract BridgedTopShotMomentsTest is Test {
    address owner;
    address underlyingNftContractOwner;
    address underlyingNftContractAddress;
    address vmBridgeAddress;

    string name;
    string symbol;
    string baseTokenURI;
    string cadenceNFTAddress;
    string cadenceNFTIdentifier;
    string contractURI;
    BridgedTopShotMoments private nftContract;
    UnderlyingERC721 private underlyingNftContract;
    uint256[] nftIDs;

    // Runs before each test
    function setUp() public {
        // Set owner
        owner = msg.sender;

        // Deploy underlying NFT contract and mint underlying NFTs to owner
        underlyingNftContractOwner = address(0x1111);
        nftIDs = [101, 102, 103];
        vm.startPrank(underlyingNftContractOwner);
        underlyingNftContract = new UnderlyingERC721("Underlying NFT", "UNFT");
        for (uint256 i = 0; i < nftIDs.length; i++) {
            underlyingNftContract.safeMint(owner, nftIDs[i]);
        }
        vm.stopPrank();
        assertEq(underlyingNftContract.balanceOf(owner), nftIDs.length);

        // Set NFT contract initialization parameters
        underlyingNftContractAddress = address(underlyingNftContract);
        vmBridgeAddress = address(0x67890);
        name = "name";
        symbol = "symbol";
        baseTokenURI = "https://example.com/";
        cadenceNFTAddress = "cadenceNFTAddress";
        cadenceNFTIdentifier = "cadenceNFTIdentifier";
        contractURI = 'data:application/json;utf8,{"name": "Name of NFT","description":"Description of NFT"}';

        // Deploy NFT contract using UUPS proxy for upgradeability
        address proxyAddr = Upgrades.deployUUPSProxy(
            "BridgedTopShotMoments.sol",
            abi.encodeCall(
                BridgedTopShotMoments.initialize,
                (
                    owner,
                    underlyingNftContractAddress,
                    vmBridgeAddress,
                    name,
                    symbol,
                    baseTokenURI,
                    cadenceNFTAddress,
                    cadenceNFTIdentifier,
                    contractURI
                )
            )
        );

        // Set contract instance
        nftContract = BridgedTopShotMoments(proxyAddr);
    }

    /* Test interface implementations */

    function test_SupportsInterface() public view {
        assertEq(nftContract.supportsInterface(type(IERC165).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(IERC721).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(IERC721Metadata).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(IERC721Enumerable).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(ICrossVM).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(ICreatorToken).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(ILegacyCreatorToken).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(IERC2981).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(ICrossVMBridgeERC721Fulfillment).interfaceId), true);
        assertEq(nftContract.supportsInterface(type(IBridgePermissions).interfaceId), true);
    }

    /* Test contract initialization */

    function test_GetContractInfo() public view {
        assertEq(nftContract.owner(), owner);
        assertEq(nftContract.name(), name);
        assertEq(nftContract.symbol(), symbol);
        assertEq(nftContract.getCadenceAddress(), cadenceNFTAddress);
        assertEq(nftContract.getCadenceIdentifier(), cadenceNFTIdentifier);
        assertEq(nftContract.contractURI(), contractURI);
        assertEq(address(nftContract.underlying()), underlyingNftContractAddress);
        assertEq(nftContract.vmBridgeAddress(), vmBridgeAddress);
        assertEq(nftContract.getTransferValidator(), address(0));
        assertEq(nftContract.royaltyAddress(), address(0));
        assertEq(nftContract.royaltyBasisPoints(), 0);
    }


    /* Test wrapping operations */

    function test_WrapNFTs() public {
        // Approve and wrap NFTs
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();
        assertEq(nftContract.balanceOf(owner), nftIDs.length);
        assertEq(underlyingNftContract.balanceOf(owner), 0);
        for (uint256 i = 0; i < nftIDs.length; i++) {
            assertEq(nftContract.ownerOf(nftIDs[i]), owner);
        }
    }

    function test_RevertWrapNFTsNotApproved() public {
        vm.startPrank(owner);
        vm.expectRevert();
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();
    }

    function test_RevertWrapNFTsZeroAddress() public {
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        vm.expectRevert();
        nftContract.depositFor(address(0), nftIDs);
        vm.stopPrank();
    }

    function test_UnwrapNFTs() public {
        // Approve and wrap NFTs
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();

        // Unwrap NFTs
        vm.startPrank(owner);
        nftContract.withdrawTo(owner, nftIDs);
        vm.stopPrank();
        assertEq(underlyingNftContract.balanceOf(owner), nftIDs.length);
        assertEq(underlyingNftContract.balanceOf(address(nftContract)), 0);
        for (uint256 i = 0; i < nftIDs.length; i++) {
            assertEq(underlyingNftContract.ownerOf(nftIDs[i]), owner);
        }
    }

    /* Test bridge fulfillment */

    function test_FulfillToEVM() public {
        uint256 nftID = 104;
        vm.startPrank(vmBridgeAddress);
        nftContract.fulfillToEVM(owner, nftID, "");
        vm.stopPrank();
        assertEq(nftContract.ownerOf(nftID), owner);
    }

    function test_RevertFulfillToEVMNotEscrowed() public {
        uint256 nftID = 104;
        vm.startPrank(vmBridgeAddress);
        nftContract.fulfillToEVM(owner, nftID, "");
        vm.stopPrank();

        // Fail to fulfill NFT to EVM
        vm.startPrank(vmBridgeAddress);
        vm.expectRevert(abi.encodeWithSelector(ICrossVMBridgeERC721Fulfillment.FulfillmentFailedTokenNotEscrowed.selector, nftID, vmBridgeAddress));
        nftContract.fulfillToEVM(owner, nftID, "");
        vm.stopPrank();
    }

    function test_RevertFulfillToEVMNotBridge() public {
        uint256 nftID = 104;
        vm.startPrank(owner);
        vm.expectRevert(abi.encodeWithSelector(ICrossVMBridgeCallable.CrossVMBridgeCallableUnauthorizedAccount.selector, owner));
        nftContract.fulfillToEVM(owner, nftID, "");
        vm.stopPrank();
    }

    /* Test core ERC721 operations */

    function test_TransferNFT() public {
        address recipient = address(27);

        // Approve and wrap NFT
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();

        // Transfer NFT from account1 to account2 and check balances
        vm.startPrank(owner);
        nftContract.safeTransferFrom(owner, recipient, nftIDs[0]);
        vm.stopPrank();
        assertEq(nftContract.balanceOf(owner), nftIDs.length - 1);
        assertEq(nftContract.balanceOf(recipient), 1);
        assertEq(nftContract.ownerOf(nftIDs[0]), recipient);
    }

    function test_ApproveNFT() public {
        address operator = address(28);

        // Approve and wrap NFT
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();

        // Approve operator for NFT and check approval
        vm.startPrank(owner);
        nftContract.approve(operator, nftIDs[0]);
        vm.stopPrank();
        assertEq(nftContract.getApproved(nftIDs[0]), operator);
    }

    function test_BurnNFT() public {
        // Approve and wrap NFT
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();

        // Burn NFT and check balance
        vm.startPrank(owner);
        nftContract.burn(nftIDs[0]);
        vm.stopPrank();
        assertFalse(nftContract.exists(nftIDs[0]));
        assertEq(nftContract.balanceOf(owner), nftIDs.length - 1);
    }

    /* Test admin operations */

    function test_SetBaseTokenURI() public {
        string memory newBaseTokenURI = "NEW_BASE_URI";

        // Approve and wrap NFT
        vm.startPrank(owner);
        underlyingNftContract.setApprovalForAll(address(nftContract), true);
        nftContract.depositFor(owner, nftIDs);
        vm.stopPrank();
        assertEq(nftContract.tokenURI(nftIDs[0]), string(abi.encodePacked(baseTokenURI, Strings.toString(nftIDs[0]))));

        // Update tokenURI and check newURI
        vm.startPrank(owner);
        nftContract.setBaseTokenURI(newBaseTokenURI);
        vm.stopPrank();
        assertEq(nftContract.tokenURI(nftIDs[0]), string(abi.encodePacked(newBaseTokenURI, Strings.toString(nftIDs[0]))));
    }

    function test_SetERC721Symbol() public {
        // Check initial symbol
        string memory initialSymbol = nftContract.symbol();
        assertEq(initialSymbol, symbol);

        // Update symbol and check new symbol
        string memory newSymbol = "NEW_SYMBOL";
        vm.startPrank(owner);
        nftContract.setSymbol(newSymbol);
        vm.stopPrank();
        assertEq(nftContract.symbol(), newSymbol);
    }

    function test_TransferContractOwnership() public {
        address newOwner = address(27);
        vm.startPrank(owner);
        nftContract.transferOwnership(newOwner);
        vm.stopPrank();
        assertEq(nftContract.owner(), newOwner);
    }

    function test_RevertTransferContractOwnershipToZeroAddress() public {
        address newOwner = address(0);
        vm.startPrank(owner);
        vm.expectRevert();
        nftContract.transferOwnership(newOwner);
        vm.stopPrank();
    }

    /* Test Creator Token operations */

    function test_SetTransferValidator() public {
        // Check initial transfer validator
        assertEq(nftContract.getTransferValidator(), address(0));

        // Set transfer validator and check new validator
        address transferValidator = address(27);
        vm.startPrank(owner);
        nftContract.setTransferValidator(transferValidator);
        vm.stopPrank();
        assertEq(nftContract.getTransferValidator(), transferValidator);
    }

    function test_SetRoyaltyInfo() public {
        // Check initial royalty info
        assertEq(nftContract.royaltyAddress(), address(0));

        // Set royalty info and check new info
        uint96 royaltyBps = 500;
        vm.startPrank(owner);
        nftContract.setRoyaltyInfo(
            BridgedTopShotMoments.RoyaltyInfo({
                royaltyAddress: owner,
                royaltyBps: royaltyBps
            })
        );
        vm.stopPrank();
        assertEq(nftContract.royaltyAddress(), owner);
        assertEq(nftContract.royaltyBasisPoints(), royaltyBps);

        address newRoyaltyAddress = address(28);
        uint96 newRoyaltyBps = 1000;
        // Set royalty info again and check new info
        vm.startPrank(owner);
        nftContract.setRoyaltyInfo(
            BridgedTopShotMoments.RoyaltyInfo({
                royaltyAddress: newRoyaltyAddress,
                royaltyBps: newRoyaltyBps
            })
        );
        vm.stopPrank();
        assertEq(nftContract.royaltyAddress(), newRoyaltyAddress);
        assertEq(nftContract.royaltyBasisPoints(), newRoyaltyBps);
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/shardedCollection/batch_from_sharded.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import TopShotShardedCollection from 0xSHARDEDADDRESS

// This transaction deposits a number of NFTs to a recipient

// Parameters
//
// recipient: the Flow address who will receive the NFTs
// momentIDs: an array of moment IDs of NFTs that recipient will receive

transaction(recipient: Address, momentIDs: [UInt64]) {

    let transferTokens: @{NonFungibleToken.Collection}
    
    prepare(acct: auth(BorrowValue) &Account) {
        
        self.transferTokens <- acct.storage.borrow<auth(NonFungibleToken.Withdraw) &TopShotShardedCollection.ShardedCollection>(from: /storage/ShardedMomentCollection)!.batchWithdraw(ids: momentIDs)
    }

    execute {

        // get the recipient's public account object
        let recipient = getAccount(recipient)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)!

        // deposit the NFT in the receivers collection
        receiverRef.batchDeposit(tokens: <-self.transferTokens)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/borrow_nft_safe.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This is a script to get a boolean value safely to see if a moment exists in a collection
// We expect this will not panic if the NFT is not in the collection
// Change the `account` to whatever account you want
// and as long as they have a published Collection receiver, you can 
// get reference to the NFTs they own.

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// nftID: The ID of the NFT to return

// Returns: Boolean value indicating if the NFT is in the collection

access(all) fun main(account: Address, nftID: UInt64 ): Bool {

    let acct = getAccount(account)

    let collectionRef = acct.capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)!

    let optionalNFT = collectionRef.borrowNFT(nftID)

    // optional binding
    if let nft = optionalNFT {
        return true
    } else {
        return false
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/batch_mint_moment.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction mints multiple moments 
// from a single set/play combination (otherwise known as edition)

// Parameters:
//
// setID: the ID of the set to be minted from
// playID: the ID of the Play from which the Moments are minted 
// quantity: the quantity of Moments to be minted
// recipientAddr: the Flow address of the account receiving the collection of minted moments

transaction(setID: UInt32, playID: UInt32, quantity: UInt64, recipientAddr: Address) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)!
    }

    execute {

        // borrow a reference to the set to be minted from
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Mint all the new NFTs
        let collection <- setRef.batchMintMoment(playID: playID, quantity: quantity)

        // Get the account object for the recipient of the minted tokens
        let recipient = getAccount(recipientAddr)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's collection")

        // deposit the NFT in the receivers collection
        receiverRef.batchDeposit(tokens: <-collection)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/player/create_player.cdc

```
import NonFungibleToken from 0xNFTADDRESS
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(playerName: String) {

    prepare(signer: auth(Storage, Capabilities) &Account) {
        if signer.storage.borrow<&FastBreakV1.Collection>(from: FastBreakV1.CollectionStoragePath) == nil {

            let collection <- FastBreakV1.createEmptyCollection(nftType: Type<@FastBreakV1.NFT>())
            signer.storage.save(<-collection, to: FastBreakV1.CollectionStoragePath)
            signer.capabilities.unpublish(FastBreakV1.CollectionPublicPath)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&FastBreakV1.Collection>(FastBreakV1.CollectionStoragePath),
                at: FastBreakV1.CollectionPublicPath
            )

        }

        if signer.storage.borrow<&FastBreakV1.Player>(from: FastBreakV1.PlayerStoragePath) == nil {

            let player <- FastBreakV1.createPlayer(playerName: playerName)
            signer.storage.save(<-player, to: FastBreakV1.PlayerStoragePath)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/lib/go/README.md

# NBA Top Shot Go Packages

This directory conains packages for interacting with the NBA Top Shot
smart contracts from a Go programming environment.

# Package Guides

- `contracts`: Contains functions to generate the text of the contract code
for the contracts in the `/nba-smart-contracts/contracts` directory.
To generate the contracts:
1. Fetch the `contracts` package: `go get github.com/dapperlabs/nba-smart-contracts/contracts@v0.1.9`
2. Import the package at the top of your Go File: `import "github.com/dapperlabs/nba-smart-contracts/lib/go/contracts"`
3. Call the `GenerateTopShotContract` and others to generate the full text of the contracts.
- `events`: Contains go definitions for the events that are emitted by
the Top Shot contracts so that these events can be monitored by applications.
- `templates`: Contains functions to return transaction templates
for common transactions and scripts for interacting with the Top Shot
smart contracts.
If you want to import the transactions in your Go programs
so you can submit them to interact with the NBA Top Shot smart contracts, 
you can do so with the `templates` package:
1. Fetch the `templates` package: `go get github.com/dapperlabs/nba-smart-contracts/templates@v0.1.10`
2. Import the package at the top of your Go File: `import "github.com/dapperlabs/nba-smart-contracts/lib/go/templates"`
3. Call the various functions in the `templates` package like `templates.GenerateTransferMomentScript()` and others to generate the full text of the templates that you can fill in with your arguments.
- `templates/data`: Contains go constructs for representing play metadata
for Top Shot plays on chain.
- `test`: Contains automated go tests for testing the functionality
of the Top Shot smart contracts.




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/start_new_series.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is for an Admin to start a new Top Shot series

transaction {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin
    let currentSeries: UInt32

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("No admin resource in storage")

        self.currentSeries = TopShot.currentSeries
    }

    execute {
        
        // Increment the series number
        self.adminRef.startNewSeries()
    }

    post {
    
        TopShot.currentSeries == self.currentSeries + 1 as UInt32:
            "new series not started"
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/batch_mint_moment_with_subedition.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction mints multiple moments
// from a single set/play/subedition combination

// Parameters:
//
// setID: the ID of the set to be minted from
// playID: the ID of the Play from which the Moments are minted
// subeditionID: the ID of play's subedition
// quantity: the quantity of Moments to be minted
// recipientAddr: the Flow address of the account receiving the collection of minted moments

transaction(setID: UInt32, playID: UInt32, quantity: UInt64, subeditionID: UInt32, recipientAddr: Address) {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)!
    }

    execute {

        // borrow a reference to the set to be minted from
        let setRef = self.adminRef.borrowSet(setID: setID)

        // Mint all the new NFTs with Subeditions
        let collection <- setRef.batchMintMomentWithSubedition(playID: playID, quantity: quantity, subeditionID: subeditionID)

        // Get the account object for the recipient of the minted tokens
        let recipient = getAccount(recipientAddr)

        // get the Collection reference for the receiver
        let receiverRef = recipient.capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
            ?? panic("Cannot borrow a reference to the recipient's collection")

        // deposit the NFT in the receivers collection
        receiverRef.batchDeposit(tokens: <-collection)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/admin/create_new_subedition_admin_resource.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This transaction is for the admin to create a new subedition admin resource
// and store it in the top shot smart contract

transaction() {

    // Local variable for the topshot Admin object
    let adminRef: &TopShot.Admin

    prepare(acct: auth(BorrowValue) &Account) {

        // borrow a reference to the Admin resource in storage
        self.adminRef = acct.storage.borrow<&TopShot.Admin>(from: /storage/TopShotAdmin)
            ?? panic("Could not borrow a reference to the Admin resource")
    }

    execute {
        self.adminRef.createSubeditionAdminResource()
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/market/change_receiver.cdc

```
import Market from 0xMARKETADDRESS
import FungibleToken from 0xFUNGIBLETOKENADDRESS

// This transaction changes the path which receives tokens for purchases of an account

// Parameters:
//
// receiverPath: The new fungible token capability for the account who receives tokens for purchases

transaction(receiverPath: PublicPath) {

    // Local variables for the sale collection object and receiver
    let saleCollectionRef: auth(Market.Update) &Market.SaleCollection
    let receiverPathRef: Capability<&{FungibleToken.Receiver}>

    prepare(acct: auth(BorrowValue) &Account) {

        self.saleCollectionRef = acct.storage.borrow<auth(Market.Update) &Market.SaleCollection>(from: /storage/topshotSaleCollection)
            ?? panic("Could not borrow from sale in storage")
        self.receiverPathRef = acct.capabilities.get<&{FungibleToken.Receiver}>(receiverPath)!
    }

    execute {

        self.saleCollectionRef.changeOwnerReceiver(self.receiverPathRef)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/FastBreakV1.cdc

```
/*
      _____                 __    ___.                         __
    _/ ____\____    _______/  |_  \_ |_________   ____ _____  |  | __
    \   __\\__  \  /  ___/\   __\  | __ \_  __ \_/ __ \\__  \ |  |/ /
     |  |   / __ \_\___ \  |  |    | \_\ \  | \/\  ___/ / __ \|    <
     |__|  (____  /____  > |__|    |___  /__|    \___  >____  /__|_ \
                \/     \/              \/            \/     \/     \/

    fast break game contract & oracle

*/

import NonFungibleToken from 0xNFTADDRESS
import TopShot from 0xTOPSHOTADDRESS
import MetadataViews from 0xMETADATAVIEWSADDRESS
import TopShotMarketV3, Market from 0xMARKETV3ADDRESS

/// Game & Oracle Contract for Fast Break V1
///
access(all) contract FastBreakV1: NonFungibleToken {

    access(all) entitlement Play
    access(all) entitlement Create
    access(all) entitlement Update

    /// Contract events
    ///

    access(all) event FastBreakPlayerCreated(
        id: UInt64,
        playerName: String
    )

    access(all) event FastBreakRunCreated(
        id: String,
        name: String,
        runStart: UInt64,
        runEnd: UInt64,
        fatigueModeOn: Bool
    )

    access(all) event FastBreakRunStatusChange(id: String, newRawStatus: UInt8)

    access(all) event FastBreakGameCreated(
        id: String,
        name: String,
        fastBreakRunID: String,
        submissionDeadline: UInt64,
        numPlayers: UInt64
    )

    access(all) event FastBreakGameStatusChange(id: String, newRawStatus: UInt8)

    access(all) event FastBreakNFTBurned(id: UInt64, serialNumber: UInt64)

    access(all) event FastBreakGameTokenMinted(
        id: UInt64,
        fastBreakGameID: String,
        serialNumber: UInt64,
        mintingDate: UInt64,
        topShots: [UInt64],
        mintedTo: UInt64
    )

    access(all) event FastBreakGameSubmissionUpdated(
        playerId: UInt64,
        fastBreakGameID: String,
        topShots: [UInt64],
    )

    access(all) event FastBreakGameWinner(
        playerId: UInt64,
        submittedAt: UInt64,
        fastBreakGameID: String,
        topShots: &[UInt64]
    )

    access(all) event FastBreakGameStatAdded(
        fastBreakGameID: String,
        name: String,
        type: UInt8,
        valueNeeded: UInt64
    )

    /// Named Paths
    ///
    access(all) let CollectionStoragePath:      StoragePath
    access(all) let CollectionPublicPath:       PublicPath
    access(all) let OracleStoragePath:          StoragePath
    access(all) let PlayerStoragePath:          StoragePath

    /// Contract variables
    ///
    access(all) var totalSupply:        UInt64
    access(all) var nextPlayerId:        UInt64

    /// Game Enums
    ///

    /// A game of Fast Break has the following status transitions
    ///
    access(all) enum GameStatus: UInt8 {
        access(all) case SCHEDULED /// Game is schedules but closed for submission
        access(all) case OPEN /// Game is open for submission
        access(all) case STARTED /// Game has started
        access(all) case CLOSED /// Game is over and rewards are being distributed
    }

    /// A Fast Break Run has the following status transitions
    ///
    access(all) enum RunStatus: UInt8 {
        access(all) case SCHEDULED
        access(all) case RUNNING /// The first Fast Break game of the run has started
        access(all) case CLOSED /// The last Fast Break game of the run has ended
    }

    /// A Fast Break Statistic can be met by an individual or group of top shots
    ///
    access(all) enum StatisticType: UInt8 {
        access(all) case INDIVIDUAL /// Each top shot must meet or exceed this statistical value
        access(all) case CUMMULATIVE /// All top shots in the submission must meet or exceed this statistical value
    }

    /// Metadata Dictionaries
    ///
    access(self) let fastBreakRunByID:      {String: FastBreakRun}
    access(self) let fastBreakGameByID:     {String: FastBreakGame}
    access(self) let fastBreakPlayerByID:   {UInt64: PlayerData}
    access(self) let playerAccountMapping:  {UInt64: Address}
    access(self) let accountPlayerMapping:  {Address: UInt64}

    /// A top-level Fast Break Run, the container for Fast Break Games
    /// A Fast Break Run contains many Fast Break games & is a mini-season.
    /// Fatigue mode applies submission limitations for the off-chain version of the game
    /// Fatigue mode limits top shot usage by tier. 4 uses legendary. 2 uses rare. 1 use other.
    ///
    access(all) struct FastBreakRun {
        access(all) let id: String /// The off-chain uuid of the Fast Break Run
        access(all) let name: String /// The name of the Run (R0, R1, etc)
        access(all) var status: FastBreakV1.RunStatus /// The status of the run
        access(all) let runStart: UInt64 /// The block timestamp starting the run
        access(all) let runEnd: UInt64 /// The block timestamp ending the run
        access(all) let runWinCount: {UInt64: UInt64} /// win count by playerId
        access(all) let fatigueModeOn: Bool /// Fatigue mode is a game rule limiting usage of top shots by tier

        init (id: String, name: String, runStart: UInt64, runEnd: UInt64, fatigueModeOn: Bool) {
            if let fastBreakRun = FastBreakV1.fastBreakRunByID[id] {
                self.id = fastBreakRun.id
                self.name = fastBreakRun.name
                self.status = fastBreakRun.status
                self.runStart = fastBreakRun.runStart
                self.runEnd = fastBreakRun.runEnd
                self.runWinCount = fastBreakRun.runWinCount
                self.fatigueModeOn = fastBreakRun.fatigueModeOn
            } else {
                self.id = id
                self.name = name
                self.status = FastBreakV1.RunStatus.SCHEDULED
                self.runStart = runStart
                self.runEnd = runEnd
                self.runWinCount = {}
                self.fatigueModeOn = fatigueModeOn
            }
        }

        /// Update status of the Fast Break Run
        ///
        access(contract) fun updateStatus(status: FastBreakV1.RunStatus) { self.status = status }

        /// Write a new win to the Fast Break Run runWinCount
        ///
        access(contract) fun incrementRunWinCount(playerId: UInt64) {
            self.runWinCount[playerId] = (self.runWinCount[playerId] ?? 0) + 1
        }
    }

    /// Get a Fast Break Run by Id
    ///
    access(all) view fun getFastBreakRun(id: String): FastBreakV1.FastBreakRun? {
        return FastBreakV1.fastBreakRunByID[id]
    }

    /// A single Game of Fast Break
    /// A Fast Break is played on any day NBA games are scheduled
    /// It is the intention of this contract to allow private & public Fast Break games
    /// A private Fast Break is visible on-chain but is restricted to private accounts
    /// A public Fast Break can be played by custodial and non-custodial accounts
    ///
    access(all) struct FastBreakGame {
        access(all) let id: String /// The off-chain uuid of the Fast Break
        access(all) let name: String /// The name of the Fast Break (eg FB0, FB1, FB2)
        access(all) let submissionDeadline: UInt64 /// The block timestamp restricting submission to the Fast Break
        access(all) let numPlayers: UInt64 /// The number of top shots a player should submit to the Fast Break
        access(all) var status: FastBreakV1.GameStatus /// The game status
        access(all) var winner: UInt64 /// The playerId of the winner of Fast Break
        access(all) var submissions: {UInt64: FastBreakV1.FastBreakSubmission} /// Map of player submission to the Fast Break
        access(all) let fastBreakRunID: String /// The off-chain uuid of the Fast Break Run containing this Fast Break
        access(all) var stats: [FastBreakStat] /// The NBA statistical requirements for this Fast Break

        init (
            id: String,
            name: String,
            fastBreakRunID: String,
            submissionDeadline: UInt64,
            numPlayers: UInt64
        ) {
            if let fb = FastBreakV1.fastBreakGameByID[id] {
                self.id = fb.id
                self.name = fb.name
                self.submissionDeadline = fb.submissionDeadline
                self.numPlayers = fb.numPlayers
                self.status = fb.status
                self.winner = fb.winner
                self.submissions = fb.submissions
                self.fastBreakRunID = fb.fastBreakRunID
                self.stats = fb.stats
            } else {
                self.id = id
                self.name = name
                self.submissionDeadline = submissionDeadline
                self.numPlayers = numPlayers
                self.status = FastBreakV1.GameStatus.SCHEDULED
                self.submissions = {}
                self.fastBreakRunID = fastBreakRunID
                self.stats = []
                self.winner = 0
            }
        }

        /// Get a account's active Fast Break Submission
        ///
        access(all) view fun getFastBreakSubmissionByPlayerId(playerId: UInt64): FastBreakV1.FastBreakSubmission? {
            return self.submissions[playerId]
        }

        /// Add a statistic to the Fast Break during game creation
        ///
        access(contract) fun addStat(stat: FastBreakV1.FastBreakStat) {
            self.stats.append(stat)
        }

        /// Update status and winner of a Fast Break
        ///
        access(contract) fun update(status: FastBreakV1.GameStatus, winner: UInt64) {
            self.status = status
            self.winner = winner
        }

        /// Submit a Fast Break
        ///
        access(contract) fun submitFastBreak(submission: FastBreakV1.FastBreakSubmission) {
            pre {
                FastBreakV1.isValidSubmission(submissionDeadline: self.submissionDeadline) : "Submission missed deadline"
            }

            self.submissions[submission.playerId] = submission
        }

        /// Update a Fast Break with new topshot moments
        ///
        access(contract) fun updateFastBreakTopshots(playerId: UInt64, topshotMoments: [UInt64]) {
            pre {
                FastBreakV1.isValidSubmission(submissionDeadline: self.submissionDeadline) : "Submission update missed deadline"
            }

            let submission = &self.submissions[playerId] as &FastBreakV1.FastBreakSubmission?
                ?? panic("Could not find submission for playerId: ".concat(playerId.toString()))

            submission.updateTopshots(topshotMomentIds: topshotMoments)
        }

        /// Update the Fast Break score of an account
        ///
        access(contract) fun updateScore(playerId: UInt64, points: UInt64, win: Bool): Bool {
            let submission: FastBreakV1.FastBreakSubmission = self.submissions[playerId]
                ?? panic("Unable to find fast break submission for playerId: ".concat(playerId.toString()))

            let isPrevSubmissionWin = submission.win

            submission.setPoints(points: points, win: win)

            self.submissions[playerId] = submission

            if win && !isPrevSubmissionWin {
                return true
            }

            return false
        }
    }

    /// Validate Fast Break Submission
    ///
    access(all) view fun isValidSubmission(submissionDeadline: UInt64): Bool {
        return submissionDeadline > UInt64(getCurrentBlock().timestamp) + 60
    }

    /// Get a Fast Break Game by Id
    ///
    access(all) view fun getFastBreakGame(id: String): FastBreakV1.FastBreakGame? {
        return FastBreakV1.fastBreakGameByID[id]
    }

    /// Get the game stats of a Fast Break
    ///
    access(all) view fun getFastBreakGameStats(id: String): [FastBreakV1.FastBreakStat] {
        if let fastBreak = FastBreakV1.getFastBreakGame(id: id) {
            return fastBreak.stats
        }
        return []
    }

    /// Get a Fast Break account by playerId
    ///
    access(all) view fun getFastBreakPlayer(id: UInt64): Address? {
        return FastBreakV1.playerAccountMapping[id]
    }

    /// A statistical structure used in Fast Break Games
    /// This structure names the NBA statistic top shots must match or exceed
    /// An example is points as the statistic and 30 as the value
    /// A top shot or group of top shots must meet or exceed 30 points
    ///
    access(all) struct FastBreakStat {
        access(all) let name: String
        access(all) let type: FastBreakV1.StatisticType
        access(all) let valueNeeded: UInt64

        init (
            name: String,
            type: FastBreakV1.StatisticType,
            valueNeeded: UInt64
        ) {
            self.name = name
            self.type = type
            self.valueNeeded = valueNeeded
        }
    }

    /// An account submission to a Fast Break
    ///
    access(all) struct FastBreakSubmission {
        access(all) let playerId: UInt64
        access(all) var submittedAt: UInt64
        access(all) let fastBreakGameID: String
        access(all) var topShots: [UInt64]
        access(all) var points: UInt64
        access(all) var win: Bool

        init (
            playerId: UInt64,
            fastBreakGameID: String,
            topShots: [UInt64],
        ) {
            self.playerId = playerId
            self.fastBreakGameID = fastBreakGameID
            self.topShots = topShots
            self.submittedAt = UInt64(getCurrentBlock().timestamp)
            self.points = 0
            self.win = false
        }

        /// Set the points of a submission
        ///
        access(contract) fun setPoints(points: UInt64, win: Bool) {
            self.points = points
            self.win = win
        }

        access(contract) fun updateTopshots(topshotMomentIds: [UInt64]) {
            self.topShots = topshotMomentIds
        }
    }

    /// Resource for playing Fast Break
    /// The Fast Break Player plays the game & mints game tokens
    ///
    access(all) resource Player: FastBreakPlayer, NonFungibleToken.NFT {

        access(all) let id: UInt64
        access(all) let playerName: String      /// username
        access(all) var tokensMinted: UInt64    /// num games played

        access(contract) var gameTokensPlayed: [UInt64]

        init(playerName: String) {
            self.id = FastBreakV1.nextPlayerId
            self.playerName = playerName
            self.gameTokensPlayed = []
            self.tokensMinted = 0

            FastBreakV1.fastBreakPlayerByID[self.id] = PlayerData(playerName: playerName)
        }

        /// Play the game of Fast Break with an array of Top Shots
        /// Each account must own a top shot collection to play fast break
        ///
        access(Play) fun play(
            fastBreakGameID: String,
            topShots: [UInt64]
        ): @FastBreakV1.NFT {
            pre {
                FastBreakV1.fastBreakGameByID.containsKey(fastBreakGameID): "No such fast break game with gameId: ".concat(fastBreakGameID)
            }

            /// Update player address mapping
            if let ownerAddress = self.owner?.address {
                FastBreakV1.playerAccountMapping[self.id] = ownerAddress
                FastBreakV1.accountPlayerMapping[ownerAddress] = self.id
            }

            /// Validate Top Shots
            let acct = getAccount(self.owner?.address!)
            let collectionRef = acct.capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)
                ?? panic("Player does not have top shot collection")
            let marketV3CollectionRef = acct.capabilities.borrow<&TopShotMarketV3.SaleCollection>(/public/topshotSalev3Collection)
            let marketV1CollectionRef = acct.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)

            /// Must own Top Shots to play Fast Break
            /// more efficient to borrow ref than to loop
            ///
            for flowId in topShots {
                let topShotRef = collectionRef.borrowMoment(id: flowId)
                if topShotRef == nil {
                    let hasMarketPlaceV3 = marketV3CollectionRef != nil && marketV3CollectionRef!.borrowMoment(id: flowId) != nil
                    let hasMarketV1 = marketV1CollectionRef != nil && marketV1CollectionRef!.borrowMoment(id: flowId) != nil
                    if !hasMarketPlaceV3 && !hasMarketV1{
                        panic("Top shot not owned in any collection with flowId: ".concat(flowId.toString()))
                    }
                }
            }

            let fastBreakGame = (&FastBreakV1.fastBreakGameByID[fastBreakGameID] as &FastBreakV1.FastBreakGame?)
                 ?? panic("Fast break does not exist with gameId: ".concat(fastBreakGameID))

            /// Cannot mint two tokens for the same Fast Break
            let existingSubmission = fastBreakGame.getFastBreakSubmissionByPlayerId(playerId: self.id)
            if existingSubmission != nil {
                panic("Account already submitted to fast break with playerId: ".concat(self.id.toString()))
            }

            let fastBreakSubmission = FastBreakV1.FastBreakSubmission(
                playerId: self.id,
                fastBreakGameID: fastBreakGameID,
                topShots: topShots
            )

            fastBreakGame.submitFastBreak(submission: fastBreakSubmission)

            let fastBreakNFT <- create NFT(
                fastBreakGameID: fastBreakGameID,
                serialNumber: self.tokensMinted + 1,
                topShots: topShots,
                mintedTo: self.id
            )

            self.tokensMinted = self.tokensMinted + 1
            self.gameTokensPlayed.append(fastBreakNFT.id)

            emit FastBreakGameTokenMinted(
                id: fastBreakNFT.id,
                fastBreakGameID: fastBreakNFT.fastBreakGameID,
                serialNumber: fastBreakNFT.serialNumber,
                mintingDate: fastBreakNFT.mintingDate,
                topShots: fastBreakNFT.topShots,
                mintedTo: fastBreakNFT.mintedTo
            )

            FastBreakV1.totalSupply = FastBreakV1.totalSupply + 1
            return <- fastBreakNFT
        }

        /// Update FastBreak Game Submission with an array of Top Shots
        /// Each account must have a submission before being able to update
        ///
        access(Update) fun updateSubmission(
            fastBreakGameID: String,
            topShots: [UInt64]
        ) {
            pre {
                FastBreakV1.fastBreakGameByID.containsKey(fastBreakGameID): "No such fast break game with gameId: ".concat(fastBreakGameID)
            }

            /// Update player address mapping
            if let ownerAddress = self.owner?.address {
                FastBreakV1.playerAccountMapping[self.id] = ownerAddress
                FastBreakV1.accountPlayerMapping[ownerAddress] = self.id
            }

            /// Validate Top Shots
            let acct = getAccount(self.owner?.address!)
            let collectionRef = acct.capabilities.borrow<&TopShot.Collection>(/public/MomentCollection)
                ?? panic("Player does not have top shot collection")
            let marketV3CollectionRef = acct.capabilities.borrow<&TopShotMarketV3.SaleCollection>(/public/topshotSalev3Collection)
            let marketV1CollectionRef = acct.capabilities.borrow<&Market.SaleCollection>(/public/topshotSaleCollection)

            /// Must own Top Shots to play Fast Break
            /// more efficient to borrow ref than to loop
            ///
            for flowId in topShots {
                let topShotRef = collectionRef.borrowMoment(id: flowId)
                if topShotRef == nil {
                    let hasMarketPlaceV3 = marketV3CollectionRef != nil && marketV3CollectionRef!.borrowMoment(id: flowId) != nil
                    let hasMarketV1 = marketV1CollectionRef != nil && marketV1CollectionRef!.borrowMoment(id: flowId) != nil
                    if !hasMarketPlaceV3 && !hasMarketV1{
                        panic("Top shot not owned in any collection with flowId: ".concat(flowId.toString()))
                    }
                }
            }

            let fastBreakGame = (&FastBreakV1.fastBreakGameByID[fastBreakGameID] as &FastBreakV1.FastBreakGame?)
                ?? panic("Fast break does not exist with gameId: ".concat(fastBreakGameID))

            /// Check that the user has a submission for Fast Break game we can update
            let pastSubmission = fastBreakGame.getFastBreakSubmissionByPlayerId(playerId: self.id)
                ?? panic("Account already with playerID: ".concat(self.id.toString())
                    .concat(" has not played FastBreak with ID: ".concat(fastBreakGameID)))

            fastBreakGame.updateFastBreakTopshots(playerId: self.id, topshotMoments: topShots)

            // Get the updated submission with new topshot moment Ids
            let updatedSubmission = fastBreakGame.getFastBreakSubmissionByPlayerId(playerId: self.id)
                ?? panic("Account already with playerID: ".concat(self.id.toString())
                    .concat(" has not played FastBreak with ID: ".concat(fastBreakGameID)))

            emit FastBreakGameSubmissionUpdated(
                playerId: self.id,
                fastBreakGameID: fastBreakGameID,
                topShots: updatedSubmission.topShots,
            )
        }

        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- FastBreakV1.createEmptyCollection(nftType: Type<@FastBreakV1.Player>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return FastBreakV1.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return FastBreakV1.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionDisplay>())
            }
            return nil
        }
    }

    access(all) struct PlayerData {

        access(all) let id: UInt64
        access(all) let playerName: String

        init(playerName: String) {
            self.id = FastBreakV1.nextPlayerId
            self.playerName = playerName
        }
    }

    /// Get a player id by account address
    ///
    access(all) view fun getPlayerIdByAccount(accountAddress: Address): UInt64 {
        return FastBreakV1.accountPlayerMapping[accountAddress]!
    }

    /// Validate Fast Break Submission topShots
    ///
    access(all) view fun validatePlaySubmission(fastBreakGame: FastBreakGame, topShots: [UInt64]): Bool {

        if (topShots.length < 1) {
            return false
        }

        if topShots.length > Int(fastBreakGame.numPlayers) {
            return false
        }

        return true
    }


    /// The Fast Break game token
    ///
    access(all) resource NFT: NonFungibleToken.NFT {
        access(all) let id: UInt64
        access(all) let fastBreakGameID: String /// The uuid of the Fast Break Game
        access(all) let serialNumber: UInt64 /// Each account mints game tokens from 1 => n
        access(all) let mintingDate: UInt64 /// The block timestamp of the tokens minting
        access(all) let mintedTo: UInt64 /// The playerId of the minter.
        access(all) let topShots: [UInt64] /// The top shot ids of the game tokens submission

        access(all) event ResourceDestroyed(
            id: UInt64 = self.id,
            serialNumber:  UInt64 = self.serialNumber
        )

        init(
            fastBreakGameID: String,
            serialNumber: UInt64,
            topShots: [UInt64],
            mintedTo: UInt64,
        ) {
            pre {
                FastBreakV1.fastBreakGameByID[fastBreakGameID] != nil: "No such fast break with gameId: ".concat(fastBreakGameID)
            }

            self.id = self.uuid
            self.fastBreakGameID = fastBreakGameID
            self.serialNumber = serialNumber
            self.mintingDate = UInt64(getCurrentBlock().timestamp)
            self.topShots = topShots
            self.mintedTo = mintedTo
        }

        access(all) view fun isWinner(): Bool {
            if let fastBreak = FastBreakV1.fastBreakGameByID[self.fastBreakGameID] {
                if let submission = fastBreak.submissions[self.mintedTo] {
                    return submission.win
                }
            }
            return false
        }

        access(all) view fun points(): UInt64 {
            if let fastBreak = FastBreakV1.fastBreakGameByID[self.fastBreakGameID] {
                if let submission = fastBreak.submissions[self.mintedTo] {
                    return submission.points
                }
            }
            return 0
        }

        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- FastBreakV1.createEmptyCollection(nftType: Type<@FastBreakV1.NFT>())
        }

        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return FastBreakV1.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return FastBreakV1.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionDisplay>())
            }
            return nil
        }
    }

    /// The Fast Break game token collection
    ///
    access(all) resource interface FastBreakNFTCollectionPublic : NonFungibleToken.CollectionPublic  {
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection})
        access(all) fun borrowFastBreakNFT(id: UInt64): &FastBreakV1.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Fast Break NFT reference: The ID of the returned reference is incorrect"
            }
        }
    }

    /// Capabilities of Fast Break Players
    ///
    access(all) resource interface FastBreakPlayer {
        access(Play) fun play(
            fastBreakGameID: String,
            topShots: [UInt64]
        ): @FastBreakV1.NFT
    }

    /// Fast Break game collection
    ///
    access(all) resource Collection:
        NonFungibleToken.Collection,
        FastBreakNFTCollectionPublic
    {

        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID) 
                ?? panic("Could not find a fast break with the given ID in the Fast Break collection. Fast break Id: ".concat(withdrawID.toString()))

            return <-token
        }

        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @FastBreakV1.NFT
            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token

            destroy oldToken
        }

        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection}) {
            let keys = tokens.getIDs()

            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            destroy tokens
        }

        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        access(all) view fun borrowFastBreakNFT(id: UInt64): &FastBreakV1.NFT? {
            return self.borrowNFT(id) as! &FastBreakV1.NFT?
        }

        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@FastBreakV1.NFT>()] = true
            return supportedTypes
        }

        // Return whether or not the given type is accepted by the collection
        // A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@FastBreakV1.NFT>() {
                return true
            }
            return false
        }

        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- FastBreakV1.createEmptyCollection(nftType: Type<@FastBreakV1.NFT>())
        }

        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        init() {
            self.ownedNFTs <- {}
        }
    }

    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        if nftType != Type<@FastBreakV1.NFT>() {
            panic("NFT type is not supported")
        }
        return <- create Collection()
    }

    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [Type<MetadataViews.NFTCollectionData>(), Type<MetadataViews.NFTCollectionDisplay>()]
    }

    access(all) view fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        post {
            result == nil || result!.getType() == viewType: "The returned view must be of the given type or nil"
        }
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: /storage/FastBreakGameV1,
                    publicPath: /public/FastBreakGameV1,
                    publicCollection: Type<&FastBreakV1.Collection>(),
                    publicLinkedType: Type<&FastBreakV1.Collection>(),
                    createEmptyCollectionFunction: (fun (): @{NonFungibleToken.Collection} {
                        return <-FastBreakV1.createEmptyCollection(nftType: Type<@FastBreakV1.NFT>())
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let bannerImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/fastbreak/fast-break-logo.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let squareImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://nbatopshot.com/static/fastbreak/fast-break-logo.svg"
                    ),
                    mediaType: "image/png"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "NBA Top Shot Fast Break",
                    description: "The game of Fast Break is very simple. Collectors will select five players every night for fifteen nights. Each night has different stats and different scores that your team must beat in order to get awarded a win.",
                    externalURL: MetadataViews.ExternalURL("https://nbatopshot.com/fastbreak"),
                    squareImage: squareImage,
                    bannerImage: bannerImage,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/nbatopshot"),
                        "discord": MetadataViews.ExternalURL("https://discord.com/invite/nbatopshot"),
                        "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nbatopshot")
                    }
                )
        }
        return nil
    }

    access(all)  fun createPlayer(playerName: String): @FastBreakV1.Player {
        FastBreakV1.nextPlayerId = FastBreakV1.nextPlayerId + UInt64(1)

        emit FastBreakPlayerCreated(
            id: FastBreakV1.nextPlayerId,
            playerName: playerName,
        )

        return <- create FastBreakV1.Player(playerName: playerName)
    }

    /// Capabilities of the Game Oracle
    ///
    access(all) resource interface GameOracle {
        access(Create) fun createFastBreakRun(id: String, name: String, runStart: UInt64, runEnd: UInt64, fatigueModeOn: Bool)
        access(Update) fun updateFastBreakRunStatus(id: String, status: UInt8)
        access(Create) fun createFastBreakGame(
            id: String,
            name: String,
            fastBreakRunID: String,
            submissionDeadline: UInt64,
            numPlayers: UInt64
        )
        access(Update) fun updateFastBreakGame(id: String, status: UInt8, winner: UInt64)
        access(Update) fun updateFastBreakScore(fastBreakGameID: String, playerId: UInt64, points: UInt64, win: Bool)
        access(Update) fun addStatToFastBreakGame(fastBreakGameID: String, name: String, rawType: UInt8, valueNeeded: UInt64)
    }

    /// Fast Break Daemon game oracle implementation
    ///
    access(all) resource FastBreakDaemon: GameOracle {

        /// Create a Fast Break Run
        ///
        access(Create) fun createFastBreakRun(id: String, name: String, runStart: UInt64, runEnd: UInt64, fatigueModeOn: Bool) {
            let fastBreakRun = FastBreakV1.FastBreakRun(
                id: id,
                name: name,
                runStart: runStart,
                runEnd: runEnd,
                fatigueModeOn: fatigueModeOn
            )
            FastBreakV1.fastBreakRunByID[fastBreakRun.id] = fastBreakRun
            emit FastBreakRunCreated(
                id: fastBreakRun.id,
                name: fastBreakRun.name,
                runStart: fastBreakRun.runStart,
                runEnd: fastBreakRun.runEnd,
                fatigueModeOn: fastBreakRun.fatigueModeOn
            )
        }

        /// Update the status of a Fast Break Run
        ///
        access(Update) fun updateFastBreakRunStatus(id: String, status: UInt8) {
            let fastBreakRun = (&FastBreakV1.fastBreakRunByID[id] as &FastBreakV1.FastBreakRun?)
                ?? panic("Fast break run does not exist with Id: ".concat(id))

            let runStatus: FastBreakV1.RunStatus = FastBreakV1.RunStatus(rawValue: status)
                ?? panic("Run status does not exist with rawValue: ".concat(status.toString()))

            fastBreakRun.updateStatus(status: runStatus)

            emit FastBreakRunStatusChange(id: fastBreakRun.id, newRawStatus: fastBreakRun.status.rawValue)
        }

        /// Create a game of Fast Break
        ///
        access(Create) fun createFastBreakGame(
            id: String,
            name: String,
            fastBreakRunID: String,
            submissionDeadline: UInt64,
            numPlayers: UInt64
        ) {
            let fastBreakGame: FastBreakV1.FastBreakGame = FastBreakV1.FastBreakGame(
                id: id,
                name: name,
                fastBreakRunID: fastBreakRunID,
                submissionDeadline: submissionDeadline,
                numPlayers: numPlayers
            )
            FastBreakV1.fastBreakGameByID[fastBreakGame.id] = fastBreakGame
            emit FastBreakGameCreated(
                id: fastBreakGame.id,
                name: fastBreakGame.name,
                fastBreakRunID: fastBreakGame.fastBreakRunID,
                submissionDeadline: fastBreakGame.submissionDeadline,
                numPlayers: fastBreakGame.numPlayers
            )
        }

        /// Add a Fast Break Statistic to a game of Fast Break during game creation
        ///
         access(Update) fun addStatToFastBreakGame(fastBreakGameID: String, name: String, rawType: UInt8, valueNeeded: UInt64) {

            let fastBreakGame: &FastBreakV1.FastBreakGame = (&FastBreakV1.fastBreakGameByID[fastBreakGameID] as &FastBreakV1.FastBreakGame?)
                ?? panic("Fast break does not exist with Id: ".concat(fastBreakGameID))

            let statType: FastBreakV1.StatisticType = FastBreakV1.StatisticType(rawValue: rawType)
                ?? panic("Fast break stat type does not exist with rawType: ".concat(rawType.toString()))

            let fastBreakStat : FastBreakV1.FastBreakStat = FastBreakV1.FastBreakStat(
                name: name,
                type: statType,
                valueNeeded: valueNeeded
            )

            fastBreakGame.addStat(stat: fastBreakStat)
            emit FastBreakGameStatAdded(
                fastBreakGameID: fastBreakGame.id,
                name: fastBreakStat.name,
                type: fastBreakStat.type.rawValue,
                valueNeeded: fastBreakStat.valueNeeded
            )

        }

        /// Update the status of a Fast Break
        ///
         access(Update) fun updateFastBreakGame(id: String, status: UInt8, winner: UInt64) {

            let fastBreakGame: &FastBreakV1.FastBreakGame = (&FastBreakV1.fastBreakGameByID[id] as &FastBreakV1.FastBreakGame?)
                ?? panic("Fast break does not exist with Id: ".concat(id))

            let fastBreakStatus: FastBreakV1.GameStatus = FastBreakV1.GameStatus(rawValue: status)
                ?? panic("Fast break status does not exist with rawValue: ".concat(status.toString()))

            fastBreakGame.update(status: fastBreakStatus, winner: winner)

            emit FastBreakGameStatusChange(id: fastBreakGame.id, newRawStatus: fastBreakGame.status.rawValue)

        }

        /// Updates the submission scores of a Fast Break
        ///
        access(Update) fun updateFastBreakScore(fastBreakGameID: String, playerId: UInt64, points: UInt64, win: Bool) {
            let fastBreakGame: &FastBreakV1.FastBreakGame = (&FastBreakV1.fastBreakGameByID[fastBreakGameID] as &FastBreakV1.FastBreakGame?)
                ?? panic("Fast break does not exist with Id: ".concat(fastBreakGameID))

            let isNewWin = fastBreakGame.updateScore(playerId: playerId, points: points, win: win)

            if isNewWin {
                let fastBreakRun = (&FastBreakV1.fastBreakRunByID[fastBreakGame.fastBreakRunID] as &FastBreakV1.FastBreakRun?)
                    ?? panic("Could not obtain reference to fast break run with Id: ".concat(fastBreakGame.fastBreakRunID))

                fastBreakRun.incrementRunWinCount(playerId: playerId)

                let submission = fastBreakGame.submissions[playerId]!

                emit FastBreakGameWinner(
                    playerId: playerId,
                    submittedAt: submission.submittedAt,
                    fastBreakGameID: submission.fastBreakGameID,
                    topShots: submission.topShots
                )

            }
        }
    }

    init() {
        self.CollectionStoragePath = /storage/FastBreakGameV1
        self.CollectionPublicPath = /public/FastBreakGameV1
        self.OracleStoragePath = /storage/FastBreakOracleV1
        self.PlayerStoragePath = /storage/FastBreakPlayerV1

        self.totalSupply = 0
        self.nextPlayerId = 0
        self.fastBreakRunByID = {}
        self.fastBreakGameByID = {}
        self.fastBreakPlayerByID = {}
        self.playerAccountMapping = {}
        self.accountPlayerMapping = {}

        let oracle <- create FastBreakDaemon()
        self.account.storage.save(<-oracle, to: self.OracleStoragePath)

    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/oracle/update_fast_break_game.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

transaction(id: String, status: UInt8, winner: UInt64) {

    let oracleRef: auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.oracleRef = acct.storage.borrow<auth(FastBreakV1.Update) &FastBreakV1.FastBreakDaemon>(from: FastBreakV1.OracleStoragePath)
            ?? panic("could not borrow a reference to the oracle resource")
    }

    execute {

        self.oracleRef.updateFastBreakGame(
            id: id,
            status: status,
            winner: winner
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/scripts/get_fast_break_stats.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS

access(all) fun main(fastBreakGameID: String): [FastBreakV1.FastBreakStat] {

    return FastBreakV1.getFastBreakGameStats(id: fastBreakGameID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/fastbreak/oracle/create_run.cdc

```
import FastBreakV1 from 0xFASTBREAKADDRESS


transaction(id: String, name: String, runStart: UInt64, runEnd: UInt64, fatigueModeOn: Bool) {

    let oracleRef: auth(FastBreakV1.Create) &FastBreakV1.FastBreakDaemon

    prepare(acct: auth(Storage, Capabilities) &Account) {
        self.oracleRef = acct.storage.borrow<auth(FastBreakV1.Create) &FastBreakV1.FastBreakDaemon>(from: FastBreakV1.OracleStoragePath)
            ?? panic("Could not borrow a reference to the oracle resource")
    }

    execute {
        self.oracleRef.createFastBreakRun(id: id, name: name, runStart: runStart, runEnd: runEnd, fatigueModeOn: fatigueModeOn)
    }

    post {
        FastBreakV1.getFastBreakRun(id: id)?.name! == name: "could not find fast break run"
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/transactions/scripts/collections/get_moment_series.cdc

```
import TopShot from 0xTOPSHOTADDRESS

// This script gets the series associated with a moment
// in a collection by getting a reference to the moment
// and then looking up its series

// Parameters:
//
// account: The Flow Address of the account whose moment data needs to be read
// id: The unique ID for the moment whose data needs to be read

// Returns: UInt32
// The series associated with a moment with a specified ID

access(all) fun main(account: Address, id: UInt64): UInt32 {

    let collectionRef = getAccount(account).capabilities.borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
        ?? panic("Could not get public moment collection reference")

    let token = collectionRef.borrowMoment(id: id)
        ?? panic("Could not borrow a reference to the specified moment")

    let data = token.data

    return TopShot.getSetSeries(setID: data.setID)!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nba-smart-contracts/blob/master/evm-bridging/src/lib/CrossVMBridgeERC721FulfillmentUpgradeable.sol

```
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.24;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ICrossVMBridgeERC721Fulfillment} from "../interfaces/ICrossVMBridgeERC721Fulfillment.sol";
import {ICrossVMBridgeCallable} from "../interfaces/ICrossVMBridgeCallable.sol";
import {CrossVMBridgeCallableUpgradeable} from "./CrossVMBridgeCallableUpgradeable.sol";

/**
 * @title CrossVMBridgeERC721Fulfillment
 * @dev Related to https://github.com/onflow/flips/issues/318[FLIP-318] Cross VM NFT implementations
 * on Flow in the context of Cadence-native NFTs. The following base contract should be implemented to
 * integrate with the Flow VM bridge connecting Cadence & EVM implementations so that the canonical
 * VM bridge may move the Cadence NFT into EVM in a mint/escrow pattern.
 */
abstract contract CrossVMBridgeERC721FulfillmentUpgradeable is ICrossVMBridgeERC721Fulfillment, CrossVMBridgeCallableUpgradeable, ERC721Upgradeable {

    /**
     * Initializes the bridge EVM address such that only the bridge COA can call privileged methods
     */
    function __CrossVMBridgeERC721Fulfillment_init(address vmBridgeAddress_) internal onlyInitializing {
        __CrossVMBridgeERC721Fulfillment_init_unchained(vmBridgeAddress_);
    }

    function __CrossVMBridgeERC721Fulfillment_init_unchained(address vmBridgeAddress_) internal onlyInitializing {
        _init_vm_bridge_address(vmBridgeAddress_);
    }

    /**
     * @dev Fulfills the bridge request, minting (if non-existent) or transferring (if escrowed) the
     * token with the given ID to the provided address. For dynamic metadata handling between
     * Cadence & EVM, implementations should override and assign metadata as encoded from Cadence
     * side. If overriding, be sure to preserve the mint/escrow pattern as shown in the default
     * implementation. See `_beforeFulfillment` and `_afterFulfillment` hooks to enable pre-and/or
     * post-processing without the need to override this function.
     * 
     * @param _to address of the token recipient
     * @param _id the id of the token being moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function fulfillToEVM(address _to, uint256 _id, bytes memory _data) external onlyVMBridge {
        _beforeFulfillment(_to, _id, _data); // hook allowing implementation to perform pre-fulfillment validation
        if (_ownerOf(_id) == address(0)) {
            _mint(_to, _id); // Doesn't exist, mint the token
        } else {
            // Should be escrowed under vm bridge - transfer from escrow to recipient
            _requireEscrowed(_id);
            safeTransferFrom(vmBridgeAddress(), _to, _id);
        }
        _afterFulfillment(_to, _id, _data); // hook allowing implementation to perform post-fulfillment processing
        emit FulfilledToEVM(_to, _id);
    }

    /**
     * @dev Returns whether the token is currently escrowed under custody of the designated VM bridge
     * 
     * @param _id the ID of the token in question
     */
    function isEscrowed(uint256 _id) public view returns (bool) {
        return _ownerOf(_id) == vmBridgeAddress();
    }

    /**
     * @dev Returns whether the token is exists or not defined positively by whether the owner of
     * the token is 0x0.
     * 
     * @param _id the ID of the token in question
     */
    function exists(uint256 _id) public view returns (bool) {
        return _ownerOf(_id) != address(0);
    }

    /**
     * @dev Allows a caller to determine the contract conforms to implemented interfaces
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(CrossVMBridgeCallableUpgradeable, ERC721Upgradeable, IERC165) returns (bool) {
        return interfaceId == type(ICrossVMBridgeERC721Fulfillment).interfaceId
            || interfaceId == type(ICrossVMBridgeCallable).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Internal method that reverts with FulfillmentFailedTokenNotEscrowed if the provided
     * token is not escrowed with the assigned vm bridge address as owner.
     * 
     * @param _id the token id that must be escrowed
     */
    function _requireEscrowed(uint256 _id) internal view {
        if (!isEscrowed(_id)) {
            revert FulfillmentFailedTokenNotEscrowed(_id, vmBridgeAddress());
        }
    }

    /**
     * @dev This internal method is included as a step implementations can override and have
     * executed in the default fullfillToEVM call.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _beforeFulfillment(address _to, uint256 _id, bytes memory _data) internal virtual {
        // No-op by default, meant to be overridden by implementations
    }

    /**
     * @dev This internal method is included as a step implementations can override and have
     * executed in the default fullfillToEVM call.
     * 
     * @param _to address of the pending token recipient
     * @param _id the id of the token to be moved into EVM from Cadence
     * @param _data any encoded metadata passed by the corresponding Cadence NFT at the time of
     *      bridging into EVM
     */
    function _afterFulfillment(address _to, uint256 _id, bytes memory _data) internal virtual {
        // No-op by default, meant to be overridden by implementations for things like processing
        // and setting metadata
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/editions/read_edition_by_id.cdc

```
import AllDay from "AllDay"

// This script returns an Edition for an id number, if it exists.

access(all) fun main(editionID: UInt64): AllDay.EditionData {
    return AllDay.getEditionData(id: editionID)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/sets/read_all_sets.cdc

```
import AllDay from "AllDay"

// This script returns all the Set structs.
// This will eventually be *long*.

access(all) fun main(): [AllDay.SetData] {
    let sets: [AllDay.SetData] = []
    var id: UInt64 = 1
    // Note < , as nextSetID has not yet been used
    while id < AllDay.nextSetID {
        sets.append(AllDay.getSetData(id: id))
        id = id + 1
    }
    return sets
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/plays/update_play_description.cdc

```
import AllDay from "AllDay"

transaction(playID: UInt64, description: String) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }


    execute {
        let id = self.admin.updatePlayDescription(
            playID: playID,
            description: description
        )
    }

    post {
        AllDay.getPlayData(id: playID).metadata["description"] == description :
            "play description update failed"
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/plays/update_play_dynamic_metadata.cdc

```
import AllDay from "AllDay"

transaction(playID: UInt64, optTeamName: String?, optPlayerFirstName: String?, optPlayerLastName: String?,
    optPlayerNumber: String?, optPlayerPosition: String?) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }


    execute {
        self.admin.updateDynamicMetadata(playID: playID, optTeamName: optTeamName,
            optPlayerFirstName: optPlayerFirstName, optPlayerLastName: optPlayerLastName,
            optPlayerNumber: optPlayerNumber, optPlayerPosition: optPlayerPosition)

        let play = AllDay.getPlayData(id: playID)
        if let teamName = optTeamName {
            assert(play.metadata["teamName"] == teamName, message: "team name update failed")
        }
        if let playerFirstName = optPlayerFirstName {
            assert(play.metadata["playerFirstName"] == playerFirstName, message: "player first name update failed")
        }
        if let playerLastName = optPlayerLastName {
            assert(play.metadata["playerLastName"] == playerLastName, message: "player last name update failed")
        }
        if let playerNumber = optPlayerNumber {
            assert(play.metadata["playerNumber"] == playerNumber, message: "player number update failed")
        }
        if let playerPosition = optPlayerPosition {
            assert(play.metadata["playerPosition"] == playerPosition, message: "player position update failed")
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/series/read_series_by_id.cdc

```
import AllDay from "AllDay"

// This script returns a Series struct for the given id,
// if it exists

access(all) fun main(id: UInt64): AllDay.SeriesData {
    return AllDay.getSeriesData(id: id)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/user/account_is_setup.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// Check to see if an account looks like it has been set up to hold AllDay NFTs.

access(all) fun main(address: Address): Bool {
    return getAccount(address).capabilities.borrow<
        &AllDay.Collection>(AllDay.CollectionPublicPath) != nil
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/editions/read_all_editions.cdc

```
import AllDay from "AllDay"

// This script returns all the Edition structs.
// This will be *long*.

access(all) fun main(): [AllDay.EditionData] {
    let editions: [AllDay.EditionData] = []
    var id: UInt64 = 1
    // Note < , as nextEditionID has not yet been used
    while id < AllDay.nextEditionID {
        editions.append(AllDay.getEditionData(id: id))
        id = id + 1
    }
    return editions
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/series/read_series_by_name.cdc

```
import AllDay from "AllDay"

// This script returns a Series struct for the given name,
// if it exists

access(all) fun main(seriesName: String): AllDay.SeriesData {
    return AllDay.getSeriesDataByName(name: seriesName)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/sets/read_sets_by_name.cdc

```
import AllDay from "AllDay"

// This script returns a Set struct for the given name,
// if it exists

access(all) fun main(setName: String): AllDay.SetData {
    return AllDay.getSetDataByName(name: setName)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/user/setup_all_collections.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"
import MetadataViews from "MetadataViews"
import PackNFT from "PackNFT"

/// This transaction sets up the signer's account to hold AllDay NFTs and PackNFTs if it hasn't already been configured.
///
transaction {
    prepare(signer: auth(Storage, Capabilities) &Account) {
        // Return early if the account already has a collection
        if signer.storage.borrow<&AllDay.Collection>(from: AllDay.CollectionStoragePath) != nil {
            return
        }

        // Create a new collection and save it to the account storage
        signer.storage.save(<- AllDay.createEmptyCollection(nftType: Type<@AllDay.NFT>()), to: AllDay.CollectionStoragePath)

        // Create a public capability for the collection
        signer.capabilities.unpublish(AllDay.CollectionPublicPath)
        signer.capabilities.publish(
            signer.capabilities.storage.issue<&AllDay.Collection>(AllDay.CollectionStoragePath),
            at: AllDay.CollectionPublicPath
        )

        // Return early if the account already has a collection
        if signer.storage.borrow<&PackNFT.Collection>(from: PackNFT.CollectionStoragePath) != nil {
            return
        }

        // Create a new collection and save it to the account storage
        signer.storage.save(<- PackNFT.createEmptyCollection(nftType: Type<@PackNFT.NFT>()), to: PackNFT.CollectionStoragePath)

        // Create a public capability for the collection
        signer.capabilities.unpublish(PackNFT.CollectionPublicPath)
        signer.capabilities.publish(
            signer.capabilities.storage.issue<&PackNFT.Collection>(PackNFT.CollectionStoragePath),
            at: PackNFT.CollectionPublicPath
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/editions/create_edition.cdc

```
import AllDay from "AllDay"

transaction(
    seriesID: UInt64,
    setID: UInt64,
    playID: UInt64,
    tier: String,
    maxMintSize: UInt64?,
   ) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.createEdition(
            seriesID: seriesID,
            setID: setID,
            playID: playID,
            maxMintSize: maxMintSize,
            tier: tier,
        )

        log("====================================")
        log("New Edition:")
        log("EditionID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/nfts/read_moment_nft_metadata.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"
import MetadataViews from "MetadataViews"

access(all) struct NFT {
    access(all) let name: String
    access(all) let description: String
    access(all) let thumbnail: String
    access(all) let owner: Address
    access(all) let type: String
    access(all) let externalURL: String
    access(all) let storagePath: String
    access(all) let publicPath: String
    access(all) let collectionName: String
    access(all) let collectionDescription: String
    access(all) let collectionSquareImage: String
    access(all) let collectionBannerImage: String
    access(all) let royaltyReceiversCount: UInt32
    access(all) let traitsCount: UInt32
    access(all) let videoURL: String

    init(
            name: String,
            description: String,
            thumbnail: String,
            owner: Address,
            type: String,
            externalURL: String,
            storagePath: String,
            publicPath: String,
            privatePath: String,
            collectionName: String,
            collectionDescription: String,
            collectionSquareImage: String,
            collectionBannerImage: String,
            royaltyReceiversCount: UInt32,
            traitsCount: UInt32,
            videoURL: String
    ) {
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.owner = owner
        self.type = type
        self.externalURL = externalURL
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.royaltyReceiversCount = royaltyReceiversCount
        self.traitsCount = traitsCount
        self.videoURL = videoURL
    }
}

access(all) fun main(address: Address, id: UInt64): [AnyStruct] {
    let account = getAccount(address)

    let collectionRef = getAccount(address).capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
            ?? panic("Could not borrow capability from public collection")

    let nft = collectionRef.borrowMomentNFT(id: id)
            ?? panic("Couldn't borrow momentNFT")

    // Get all core views for this NFT
    let displayView = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
    let editionsView = nft.resolveView(Type<MetadataViews.Editions>())! as! MetadataViews.Editions
    let externalURLView = nft.resolveView(Type<MetadataViews.ExternalURL>())! as! MetadataViews.ExternalURL
    let nftCollectionDataView = nft.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData
    let nftCollectionDisplayView = nft.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay
    let mediasView = nft.resolveView(Type<MetadataViews.Medias>())! as! MetadataViews.Medias
    let royaltiesView = nft.resolveView(Type<MetadataViews.Royalties>())! as! MetadataViews.Royalties
    let serialView = nft.resolveView(Type<MetadataViews.Serial>())! as! MetadataViews.Serial
    let traitsView = nft.resolveView(Type<MetadataViews.Traits>())! as! MetadataViews.Traits

    return [displayView, editionsView, externalURLView, mediasView, nftCollectionDisplayView, royaltiesView, serialView, traitsView]
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/nfts/read_collection_nft_length.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This script returns the size of an account's AllDay collection.

access(all) fun main(address: Address): Int {
    let account = getAccount(address)

    let collectionRef = getAccount(address).capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getIDs().length
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/series/read_all_series.cdc

```
import AllDay from "AllDay"

// This script returns all the Series structs.
// This will eventually be *long*.

access(all) fun main(): [AllDay.SeriesData] {
    let series: [AllDay.SeriesData] = []
    var id: UInt64 = 1
    // Note < , as nextSeriesID has not yet been used
    while id < AllDay.nextSeriesID {
        series.append(AllDay.getSeriesData(id: id))
        id = id + 1
    }
    return series
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/ViewResolver.cdc

```
// Taken from the NFT Metadata standard, this contract exposes an interface to let
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
access(all) contract interface ViewResolver {

    /// Function that returns all the Metadata Views implemented by the resolving contract.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there is an optional parameter to specify which resource type the caller
    /// is requesting views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type]

    /// Function that resolves a metadata view for this token.
    /// Some contracts may have multiple resource types that support metadata views
    /// so there there is an optional parameter for specify which resource type the caller
    /// is looking for views for.
    /// Some contract-level views may be type-agnostic. In that case, the contract
    /// should return the same views regardless of what type is passed in.
    ///
    /// @param resourceType: An optional resource type to return views for
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct?

    /// Provides access to a set of metadata views. A struct or
    /// resource (e.g. an NFT) can implement this interface to provide access to
    /// the views that it supports.
    ///
    access(all) resource interface Resolver {

        /// Same as getViews above, but on a specific NFT instead of a contract
        access(all) view fun getViews(): [Type]

        /// Same as resolveView above, but on a specific NFT instead of a contract
        access(all) fun resolveView(_ view: Type): AnyStruct?
    }

    /// A group of view resolvers indexed by ID.
    ///
    access(all) resource interface ResolverCollection {
        access(all) view fun borrowViewResolver(id: UInt64): &{Resolver}? {
            return nil
        }

        access(all) view fun getIDs(): [UInt64] {
            return []
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/FungibleToken.cdc

```
/**

# The Flow Fungible Token standard

## `FungibleToken` contract

The Fungible Token standard is no longer an interface
that all fungible token contracts would have to conform to.

If a users wants to deploy a new token contract, their contract
does not need to implement the FungibleToken interface, but their tokens
do need to implement the interfaces defined in this contract.

## `Vault` resource interface

Each fungible token resource type needs to implement the `Vault` resource interface.

## `Provider`, `Receiver`, and `Balance` resource interfaces

These interfaces declare pre-conditions and post-conditions that restrict
the execution of the functions in the Vault.

They are separate because it gives the user the ability to share
a reference to their Vault that only exposes the fields functions
in one or more of the interfaces.

It also gives users the ability to make custom resources that implement
these interfaces to do various things with the tokens.
For example, a faucet can be implemented by conforming
to the Provider interface.

*/

import "ViewResolver"
import "Burner"

/// FungibleToken
///
/// Fungible Token implementations are no longer required to implement the fungible token
/// interface. We still have it as an interface here because there are some useful
/// utility methods that many projects will still want to have on their contracts,
/// but they are by no means required. all that is required is that the token
/// implements the `Vault` interface
access(all) contract interface FungibleToken: ViewResolver {

    // An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// The event that is emitted when tokens are withdrawn from a Vault
    access(all) event Withdrawn(type: String, amount: UFix64, from: Address?, fromUUID: UInt64, withdrawnUUID: UInt64)

    /// The event that is emitted when tokens are deposited to a Vault
    access(all) event Deposited(type: String, amount: UFix64, to: Address?, toUUID: UInt64, depositedUUID: UInt64)

    /// Event that is emitted when the global burn method is called with a non-zero balance
    access(all) event Burned(type: String, amount: UFix64, fromUUID: UInt64)

    /// Balance
    ///
    /// The interface that provides standard functions\
    /// for getting balance information
    ///
    access(all) resource interface Balance {
        access(all) var balance: UFix64
    }

    /// Provider
    ///
    /// The interface that enforces the requirements for withdrawing
    /// tokens from the implementing type.
    ///
    /// It does not enforce requirements on `balance` here,
    /// because it leaves open the possibility of creating custom providers
    /// that do not necessarily need their own balance.
    ///
    access(all) resource interface Provider {

        /// Function to ask a provider if a specific amount of tokens
        /// is available to be withdrawn
        /// This could be useful to avoid panicing when calling withdraw
        /// when the balance is unknown
        /// Additionally, if the provider is pulling from multiple vaults
        /// it only needs to check some of the vaults until the desired amount
        /// is reached, potentially helping with performance.
        ///
        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool

        /// withdraw subtracts tokens from the implementing resource
        /// and returns a Vault with the removed tokens.
        ///
        /// The function's access level is `access(Withdraw)`
        /// So in order to access it, one would either need the object itself
        /// or an entitled reference with `Withdraw`.
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    "Withdrawal amount must be the same as the balance of the withdrawn Vault"
                emit Withdrawn(type: self.getType().identifier, amount: amount, from: self.owner?.address, fromUUID: self.uuid, withdrawnUUID: result.uuid)
            }
        }
    }

    /// Receiver
    ///
    /// The interface that enforces the requirements for depositing
    /// tokens into the implementing type.
    ///
    /// We do not include a condition that checks the balance because
    /// we want to give users the ability to make custom receivers that
    /// can do custom things with the tokens, like split them up and
    /// send them to different places.
    ///
    access(all) resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        access(all) fun deposit(from: @{Vault})

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        access(all) view fun getSupportedVaultTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the Receiver
        /// A vault that can accept any type should just return true by default
        access(all) view fun isSupportedVaultType(type: Type): Bool
    }

    /// Vault
    ///
    /// Ideally, this interface would also conform to Receiver, Balance, Transferor, Provider, and Resolver
    /// but that is not supported yet
    ///
    access(all) resource interface Vault: Receiver, Provider, Balance, ViewResolver.Resolver, Burner.Burnable {

        /// Field that tracks the balance of a vault
        access(all) var balance: UFix64

        /// Called when a fungible token is burned via the `Burner.burn()` method
        /// Implementations can do any bookkeeping or emit any events
        /// that should be emitted when a vault is destroyed.
        /// Many implementations will want to update the token's total supply
        /// to reflect that the tokens have been burned and removed from the supply.
        /// Implementations also need to set the balance to zero before the end of the function
        /// This is to prevent vault owners from spamming fake Burned events.
        access(contract) fun burnCallback() {
            pre {
                emit Burned(type: self.getType().identifier, amount: self.balance, fromUUID: self.uuid)
            }
            post {
                self.balance == 0.0: "The balance must be set to zero during the burnCallback method so that it cannot be spammed"
            }
            self.balance = 0.0
        }

        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts
        /// The default implementation is included here because vaults are expected
        /// to only accepted their own type, so they have no need to provide an implementation
        /// for this function
        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {
            // Below check is implemented to make sure that run-time type would
            // only get returned when the parent resource conforms with `FungibleToken.Vault`.
            if self.getType().isSubtype(of: Type<@{FungibleToken.Vault}>()) {
                return {self.getType(): true}
            } else {
                // Return an empty dictionary as the default value for resource who don't
                // implement `FungibleToken.Vault`, such as `FungibleTokenSwitchboard`, `TokenForwarder` etc.
                return {}
            }
        }

        /// Checks if the given type is supported by this Vault
        access(all) view fun isSupportedVaultType(type: Type): Bool {
            return self.getSupportedVaultTypes()[type] ?? false
        }

        /// withdraw subtracts `amount` from the Vault's balance
        /// and returns a new Vault with the subtracted balance
        ///
        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {
            pre {
                self.balance >= amount:
                    "Amount withdrawn must be less than or equal than the balance of the Vault"
            }
            post {
                result.getType() == self.getType(): "Must return the same vault type as self"
                // use the special function `before` to get the value of the `balance` field
                // at the beginning of the function execution
                //
                self.balance == before(self.balance) - amount:
                    "New Vault balance must be the difference of the previous balance and the withdrawn Vault balance"
            }
        }

        /// deposit takes a Vault and adds its balance to the balance of this Vault
        ///
        access(all) fun deposit(from: @{FungibleToken.Vault}) {
            // Assert that the concrete type of the deposited vault is the same
            // as the vault that is accepting the deposit
            pre {
                from.isInstance(self.getType()):
                    "Cannot deposit an incompatible token type"
                emit Deposited(type: from.getType().identifier, amount: from.balance, to: self.owner?.address, toUUID: self.uuid, depositedUUID: from.uuid)
            }
            post {
                self.balance == before(self.balance) + before(from.balance):
                    "New Vault balance must be the sum of the previous balance and the deposited Vault"
            }
        }

        /// createEmptyVault allows any user to create a new Vault that has a zero balance
        ///
        access(all) fun createEmptyVault(): @{Vault} {
            post {
                result.balance == 0.0: "The newly created Vault must have zero balance"
            }
        }
    }

    /// createEmptyVault allows any user to create a new Vault that has a zero balance
    ///
    access(all) fun createEmptyVault(vaultType: Type): @{FungibleToken.Vault} {
        post {
            result.getType() == vaultType: "The returned vault does not match the desired type"
            result.balance == 0.0: "The newly created Vault must have zero balance"
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/plays/read_all_plays.cdc

```
import AllDay from "AllDay"

// This script returns all the Set structs.
// This will eventually be *long*.

access(all) fun main(): [AllDay.PlayData] {
    let plays: [AllDay.PlayData] = []
    var id: UInt64 = 1
    // Note < , as nextPlayID has not yet been used
    while id < AllDay.nextPlayID {
        plays.append(AllDay.getPlayData(id: id))
        id = id + 1
    }
    return plays
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/series/read_all_series_names.cdc

```
import AllDay from "AllDay"

// This script returns all the names for Series.
// These can be related to Series structs via AllDay.getSeriesByName() .

access(all) fun main(): [String] {
    return AllDay.getAllSeriesNames()
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/plays/create_play.cdc

```
import AllDay from "AllDay"

transaction(
    name: String,
    metadata: {String: String}
   ) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.createPlay(
            classification: name,
            metadata: metadata
        )

        log("====================================")
        log("New Play:")
        log("PlayID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/user/batch_transfer_moment_nfts.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This transaction transfers a AllDay NFT from one account to another.

transaction(recipientAddress: Address, withdrawIDs: [UInt64]) {
    prepare(signer: auth(BorrowValue) &Account) {

        // get the recipients public account object
        let recipient = getAccount(recipientAddress)

        // borrow a reference to the signer's NFT collection
        let collectionRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &AllDay.Collection>(from: AllDay.CollectionStoragePath)
            ?? panic("Could not borrow a reference to the owner's collection")

        // borrow a public reference to the receivers collection
        let depositRef = recipient.capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
            ?? panic("Could not borrow a reference to the recipient's collection")

        for withdrawID in withdrawIDs {
            // withdraw the NFT from the owner's collection
            let nft <- collectionRef.withdraw(withdrawID: withdrawID)

            // Deposit the NFT in the recipient's collection
            depositRef.deposit(token: <-nft)
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/plays/read_play_by_id.cdc

```
import AllDay from "AllDay"

// This script returns a Play struct for the given id,
// if it exists

access(all) fun main(id: UInt64): AllDay.PlayData {
    return AllDay.getPlayData(id: id)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/series/close_series.cdc

```
import AllDay from "AllDay"

transaction(seriesID: UInt64) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.closeSeries(id: seriesID)

        log("====================================")
        log("Closed Series:")
        log("SeriesID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/MetadataViews.cdc

```
import "FungibleToken"
import "NonFungibleToken"
import "ViewResolver"

/// This contract implements the metadata standard proposed
/// in FLIP-0636.
///
/// Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata, such as a creator biography
/// or a JPEG image file.
///
access(all) contract MetadataViews {

    /// Display is a basic view that includes the name, description and
    /// thumbnail for an object. Most objects should implement this view.
    ///
    access(all) struct Display {

        /// The name of the object.
        ///
        /// This field will be displayed in lists and therefore should
        /// be short an concise.
        ///
        access(all) let name: String

        /// A written description of the object.
        ///
        /// This field will be displayed in a detailed view of the object,
        /// so can be more verbose (e.g. a paragraph instead of a single line).
        ///
        access(all) let description: String

        /// A small thumbnail representation of the object.
        ///
        /// This field should be a web-friendly file (i.e JPEG, PNG)
        /// that can be displayed in lists, link previews, etc.
        ///
        access(all) let thumbnail: {File}

        view init(
            name: String,
            description: String,
            thumbnail: {File}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }
    }

    /// Helper to get Display in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Display struct
    ///
    access(all) fun getDisplay(_ viewResolver: &{ViewResolver.Resolver}) : Display? {
        if let view = viewResolver.resolveView(Type<Display>()) {
            if let v = view as? Display {
                return v
            }
        }
        return nil
    }

    /// Generic interface that represents a file stored on or off chain. Files
    /// can be used to references images, videos and other media.
    ///
    access(all) struct interface File {
        access(all) view fun uri(): String
    }

    /// View to expose a file that is accessible at an HTTP (or HTTPS) URL.
    ///
    access(all) struct HTTPFile: File {
        access(all) let url: String

        view init(url: String) {
            self.url = url
        }

        access(all) view fun uri(): String {
            return self.url
        }
    }

    /// View to expose a file stored on IPFS.
    /// IPFS images are referenced by their content identifier (CID)
    /// rather than a direct URI. A client application can use this CID
    /// to find and load the image via an IPFS gateway.
    ///
    access(all) struct IPFSFile: File {

        /// CID is the content identifier for this IPFS file.
        ///
        /// Ref: https://docs.ipfs.io/concepts/content-addressing/
        ///
        access(all) let cid: String

        /// Path is an optional path to the file resource in an IPFS directory.
        ///
        /// This field is only needed if the file is inside a directory.
        ///
        /// Ref: https://docs.ipfs.io/concepts/file-systems/
        ///
        access(all) let path: String?

        view init(cid: String, path: String?) {
            self.cid = cid
            self.path = path
        }

        /// This function returns the IPFS native URL for this file.
        /// Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls
        ///
        /// @return The string containing the file uri
        ///
        access(all) view fun uri(): String {
            if let path = self.path {
                return "ipfs://".concat(self.cid).concat("/").concat(path)
            }

            return "ipfs://".concat(self.cid)
        }
    }

    /// View to represent a file with an correspoiding mediaType.
    ///
    access(all) struct Media {

        /// File for the media
        ///
        access(all) let file: {File}

        /// media-type comes on the form of type/subtype as described here
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
        ///
        access(all) let mediaType: String

        view init(file: {File}, mediaType: String) {
          self.file=file
          self.mediaType=mediaType
        }
    }

    /// Wrapper view for multiple media views
    ///
    access(all) struct Medias {

        /// An arbitrary-sized list for any number of Media items
        access(all) let items: [Media]

        view init(_ items: [Media]) {
            self.items = items
        }
    }

    /// Helper to get Medias in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Medias struct
    ///
    access(all) fun getMedias(_ viewResolver: &{ViewResolver.Resolver}) : Medias? {
        if let view = viewResolver.resolveView(Type<Medias>()) {
            if let v = view as? Medias {
                return v
            }
        }
        return nil
    }

    /// View to represent a license according to https://spdx.org/licenses/
    /// This view can be used if the content of an NFT is licensed.
    ///
    access(all) struct License {
        access(all) let spdxIdentifier: String

        view init(_ identifier: String) {
            self.spdxIdentifier = identifier
        }
    }

    /// Helper to get License in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional License struct
    ///
    access(all) fun getLicense(_ viewResolver: &{ViewResolver.Resolver}) : License? {
        if let view = viewResolver.resolveView(Type<License>()) {
            if let v = view as? License {
                return v
            }
        }
        return nil
    }

    /// View to expose a URL to this item on an external site.
    /// This can be used by applications like .find and Blocto to direct users
    /// to the original link for an NFT or a project page that describes the NFT collection.
    /// eg https://www.my-nft-project.com/overview-of-nft-collection
    ///
    access(all) struct ExternalURL {
        access(all) let url: String

        view init(_ url: String) {
            self.url=url
        }
    }

    /// Helper to get ExternalURL in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional ExternalURL struct
    ///
    access(all) fun getExternalURL(_ viewResolver: &{ViewResolver.Resolver}) : ExternalURL? {
        if let view = viewResolver.resolveView(Type<ExternalURL>()) {
            if let v = view as? ExternalURL {
                return v
            }
        }
        return nil
    }

    /// View that defines the composable royalty standard that gives marketplaces a
    /// unified interface to support NFT royalties.
    ///
    access(all) struct Royalty {

        /// Generic FungibleToken Receiver for the beneficiary of the royalty
        /// Can get the concrete type of the receiver with receiver.getType()
        /// Recommendation - Users should create a new link for a FlowToken
        /// receiver for this using `getRoyaltyReceiverPublicPath()`, and not
        /// use the default FlowToken receiver. This will allow users to update
        /// the capability in the future to use a more generic capability
        access(all) let receiver: Capability<&{FungibleToken.Receiver}>

        /// Multiplier used to calculate the amount of sale value transferred to
        /// royalty receiver. Note - It should be between 0.0 and 1.0
        /// Ex - If the sale value is x and multiplier is 0.56 then the royalty
        /// value would be 0.56 * x.
        /// Generally percentage get represented in terms of basis points
        /// in solidity based smart contracts while cadence offers `UFix64`
        /// that already supports the basis points use case because its
        /// operations are entirely deterministic integer operations and support
        /// up to 8 points of precision.
        access(all) let cut: UFix64

        /// Optional description: This can be the cause of paying the royalty,
        /// the relationship between the `wallet` and the NFT, or anything else
        /// that the owner might want to specify.
        access(all) let description: String

        view init(receiver: Capability<&{FungibleToken.Receiver}>, cut: UFix64, description: String) {
            pre {
                cut >= 0.0 && cut <= 1.0 : "Cut value should be in valid range i.e [0,1]"
            }
            self.receiver = receiver
            self.cut = cut
            self.description = description
        }
    }

    /// Wrapper view for multiple Royalty views.
    /// Marketplaces can query this `Royalties` struct from NFTs
    /// and are expected to pay royalties based on these specifications.
    ///
    access(all) struct Royalties {

        /// Array that tracks the individual royalties
        access(self) let cutInfos: [Royalty]

        access(all) view init(_ cutInfos: [Royalty]) {
            // Validate that sum of all cut multipliers should not be greater than 1.0
            var totalCut = 0.0
            for royalty in cutInfos {
                totalCut = totalCut + royalty.cut
            }
            assert(totalCut <= 1.0, message: "Sum of cutInfos multipliers should not be greater than 1.0")
            // Assign the cutInfos
            self.cutInfos = cutInfos
        }

        /// Return the cutInfos list
        ///
        /// @return An array containing all the royalties structs
        ///
        access(all) view fun getRoyalties(): [Royalty] {
            return self.cutInfos
        }
    }

    /// Helper to get Royalties in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Royalties struct
    ///
    access(all) fun getRoyalties(_ viewResolver: &{ViewResolver.Resolver}) : Royalties? {
        if let view = viewResolver.resolveView(Type<Royalties>()) {
            if let v = view as? Royalties {
                return v
            }
        }
        return nil
    }

    /// Get the path that should be used for receiving royalties
    /// This is a path that will eventually be used for a generic switchboard receiver,
    /// hence the name but will only be used for royalties for now.
    ///
    /// @return The PublicPath for the generic FT receiver
    ///
    access(all) view fun getRoyaltyReceiverPublicPath(): PublicPath {
        return /public/GenericFTReceiver
    }

    /// View to represent a single field of metadata on an NFT.
    /// This is used to get traits of individual key/value pairs along with some
    /// contextualized data about the trait
    ///
    access(all) struct Trait {
        // The name of the trait. Like Background, Eyes, Hair, etc.
        access(all) let name: String

        // The underlying value of the trait, the rest of the fields of a trait provide context to the value.
        access(all) let value: AnyStruct

        // displayType is used to show some context about what this name and value represent
        // for instance, you could set value to a unix timestamp, and specify displayType as "Date" to tell
        // platforms to consume this trait as a date and not a number
        access(all) let displayType: String?

        // Rarity can also be used directly on an attribute.
        //
        // This is optional because not all attributes need to contribute to the NFT's rarity.
        access(all) let rarity: Rarity?

        view init(name: String, value: AnyStruct, displayType: String?, rarity: Rarity?) {
            self.name = name
            self.value = value
            self.displayType = displayType
            self.rarity = rarity
        }
    }

    /// Wrapper view to return all the traits on an NFT.
    /// This is used to return traits as individual key/value pairs along with
    /// some contextualized data about each trait.
    access(all) struct Traits {
        access(all) let traits: [Trait]

        view init(_ traits: [Trait]) {
            self.traits = traits
        }

        /// Adds a single Trait to the Traits view
        ///
        /// @param Trait: The trait struct to be added
        ///
        access(all) fun addTrait(_ t: Trait) {
            self.traits.append(t)
        }
    }

    /// Helper to get Traits view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Traits struct
    ///
    access(all) fun getTraits(_ viewResolver: &{ViewResolver.Resolver}) : Traits? {
        if let view = viewResolver.resolveView(Type<Traits>()) {
            if let v = view as? Traits {
                return v
            }
        }
        return nil
    }

    /// Helper function to easily convert a dictionary to traits. For NFT
    /// collections that do not need either of the optional values of a Trait,
    /// this method should suffice to give them an array of valid traits.
    ///
    /// @param dict: The dictionary to be converted to Traits
    /// @param excludedNames: An optional String array specifying the `dict`
    ///         keys that are not wanted to become `Traits`
    /// @return The generated Traits view
    ///
    access(all) fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits {
        // Collection owners might not want all the fields in their metadata included.
        // They might want to handle some specially, or they might just not want them included at all.
        if excludedNames != nil {
            for k in excludedNames! {
                dict.remove(key: k)
            }
        }

        let traits: [Trait] = []
        for k in dict.keys {
            let trait = Trait(name: k, value: dict[k]!, displayType: nil, rarity: nil)
            traits.append(trait)
        }

        return Traits(traits)
    }

    /// Optional view for collections that issue multiple objects
    /// with the same or similar metadata, for example an X of 100 set. This
    /// information is useful for wallets and marketplaces.
    /// An NFT might be part of multiple editions, which is why the edition
    /// information is returned as an arbitrary sized array
    ///
    access(all) struct Edition {

        /// The name of the edition
        /// For example, this could be Set, Play, Series,
        /// or any other way a project could classify its editions
        access(all) let name: String?

        /// The edition number of the object.
        /// For an "24 of 100 (#24/100)" item, the number is 24.
        access(all) let number: UInt64

        /// The max edition number of this type of objects.
        /// This field should only be provided for limited-editioned objects.
        /// For an "24 of 100 (#24/100)" item, max is 100.
        /// For an item with unlimited edition, max should be set to nil.
        ///
        access(all) let max: UInt64?

        view init(name: String?, number: UInt64, max: UInt64?) {
            if max != nil {
                assert(number <= max!, message: "The number cannot be greater than the max number!")
            }
            self.name = name
            self.number = number
            self.max = max
        }
    }

    /// Wrapper view for multiple Edition views
    ///
    access(all) struct Editions {

        /// An arbitrary-sized list for any number of editions
        /// that the NFT might be a part of
        access(all) let infoList: [Edition]

        view init(_ infoList: [Edition]) {
            self.infoList = infoList
        }
    }

    /// Helper to get Editions in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Editions struct
    ///
    access(all) fun getEditions(_ viewResolver: &{ViewResolver.Resolver}) : Editions? {
        if let view = viewResolver.resolveView(Type<Editions>()) {
            if let v = view as? Editions {
                return v
            }
        }
        return nil
    }

    /// View representing a project-defined serial number for a specific NFT
    /// Projects have different definitions for what a serial number should be
    /// Some may use the NFTs regular ID and some may use a different
    /// classification system. The serial number is expected to be unique among
    /// other NFTs within that project
    ///
    access(all) struct Serial {
        access(all) let number: UInt64

        view init(_ number: UInt64) {
            self.number = number
        }
    }

    /// Helper to get Serial in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional Serial struct
    ///
    access(all) fun getSerial(_ viewResolver: &{ViewResolver.Resolver}) : Serial? {
        if let view = viewResolver.resolveView(Type<Serial>()) {
            if let v = view as? Serial {
                return v
            }
        }
        return nil
    }

    /// View to expose rarity information for a single rarity
    /// Note that a rarity needs to have either score or description but it can
    /// have both
    ///
    access(all) struct Rarity {
        /// The score of the rarity as a number
        access(all) let score: UFix64?

        /// The maximum value of score
        access(all) let max: UFix64?

        /// The description of the rarity as a string.
        ///
        /// This could be Legendary, Epic, Rare, Uncommon, Common or any other string value
        access(all) let description: String?

        view init(score: UFix64?, max: UFix64?, description: String?) {
            if score == nil && description == nil {
                panic("A Rarity needs to set score, description or both")
            }

            self.score = score
            self.max = max
            self.description = description
        }
    }

    /// Helper to get Rarity view in a typesafe way
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional Rarity struct
    ///
    access(all) fun getRarity(_ viewResolver: &{ViewResolver.Resolver}) : Rarity? {
        if let view = viewResolver.resolveView(Type<Rarity>()) {
            if let v = view as? Rarity {
                return v
            }
        }
        return nil
    }

    /// NFTView wraps all Core views along `id` and `uuid` fields, and is used
    /// to give a complete picture of an NFT. Most NFTs should implement this
    /// view.
    ///
    access(all) struct NFTView {
        access(all) let id: UInt64
        access(all) let uuid: UInt64
        access(all) let display: MetadataViews.Display?
        access(all) let externalURL: MetadataViews.ExternalURL?
        access(all) let collectionData: NFTCollectionData?
        access(all) let collectionDisplay: NFTCollectionDisplay?
        access(all) let royalties: Royalties?
        access(all) let traits: Traits?

        view init(
            id : UInt64,
            uuid : UInt64,
            display : MetadataViews.Display?,
            externalURL : MetadataViews.ExternalURL?,
            collectionData : NFTCollectionData?,
            collectionDisplay : NFTCollectionDisplay?,
            royalties : Royalties?,
            traits: Traits?
        ) {
            self.id = id
            self.uuid = uuid
            self.display = display
            self.externalURL = externalURL
            self.collectionData = collectionData
            self.collectionDisplay = collectionDisplay
            self.royalties = royalties
            self.traits = traits
        }
    }

    /// Helper to get an NFT view
    ///
    /// @param id: The NFT id
    /// @param viewResolver: A reference to the resolver resource
    /// @return A NFTView struct
    ///
    access(all) fun getNFTView(id: UInt64, viewResolver: &{ViewResolver.Resolver}) : NFTView {
        let nftView = viewResolver.resolveView(Type<NFTView>())
        if nftView != nil {
            return nftView! as! NFTView
        }

        return NFTView(
            id : id,
            uuid: viewResolver.uuid,
            display: MetadataViews.getDisplay(viewResolver),
            externalURL : MetadataViews.getExternalURL(viewResolver),
            collectionData : self.getNFTCollectionData(viewResolver),
            collectionDisplay : self.getNFTCollectionDisplay(viewResolver),
            royalties : self.getRoyalties(viewResolver),
            traits : self.getTraits(viewResolver)
        )
    }

    /// View to expose the information needed store and retrieve an NFT.
    /// This can be used by applications to setup a NFT collection with proper
    /// storage and public capabilities.
    ///
    access(all) struct NFTCollectionData {
        /// Path in storage where this NFT is recommended to be stored.
        access(all) let storagePath: StoragePath

        /// Public path which must be linked to expose public capabilities of this NFT
        /// including standard NFT interfaces and metadataviews interfaces
        access(all) let publicPath: PublicPath

        /// The concrete type of the collection that is exposed to the public
        /// now that entitlements exist, it no longer needs to be restricted to a specific interface
        access(all) let publicCollection: Type

        /// Type that should be linked at the aforementioned public path
        access(all) let publicLinkedType: Type

        /// Function that allows creation of an empty NFT collection that is intended to store
        /// this NFT.
        access(all) let createEmptyCollection: fun(): @{NonFungibleToken.Collection}

        view init(
            storagePath: StoragePath,
            publicPath: PublicPath,
            publicCollection: Type,
            publicLinkedType: Type,
            createEmptyCollectionFunction: fun(): @{NonFungibleToken.Collection}
        ) {
            pre {
                publicLinkedType.isSubtype(of: Type<&{NonFungibleToken.Collection}>()): "Public type must be a subtype of NonFungibleToken.Collection interface."
            }
            self.storagePath=storagePath
            self.publicPath=publicPath
            self.publicCollection=publicCollection
            self.publicLinkedType=publicLinkedType
            self.createEmptyCollection=createEmptyCollectionFunction
        }
    }

    /// Helper to get NFTCollectionData in a way that will return an typed Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollectionData struct
    ///
    access(all) fun getNFTCollectionData(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionData? {
        if let view = viewResolver.resolveView(Type<NFTCollectionData>()) {
            if let v = view as? NFTCollectionData {
                return v
            }
        }
        return nil
    }

    /// View to expose the information needed to showcase this NFT's
    /// collection. This can be used by applications to give an overview and
    /// graphics of the NFT collection this NFT belongs to.
    ///
    access(all) struct NFTCollectionDisplay {
        // Name that should be used when displaying this NFT collection.
        access(all) let name: String

        // Description that should be used to give an overview of this collection.
        access(all) let description: String

        // External link to a URL to view more information about this collection.
        access(all) let externalURL: MetadataViews.ExternalURL

        // Square-sized image to represent this collection.
        access(all) let squareImage: MetadataViews.Media

        // Banner-sized image for this collection, recommended to have a size near 1400x350.
        access(all) let bannerImage: MetadataViews.Media

        // Social links to reach this collection's social homepages.
        // Possible keys may be "instagram", "twitter", "discord", etc.
        access(all) let socials: {String: MetadataViews.ExternalURL}

        view init(
            name: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            squareImage: MetadataViews.Media,
            bannerImage: MetadataViews.Media,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.description = description
            self.externalURL = externalURL
            self.squareImage = squareImage
            self.bannerImage = bannerImage
            self.socials = socials
        }
    }

    /// Helper to get NFTCollectionDisplay in a way that will return a typed
    /// Optional
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional NFTCollection struct
    ///
    access(all) fun getNFTCollectionDisplay(_ viewResolver: &{ViewResolver.Resolver}) : NFTCollectionDisplay? {
        if let view = viewResolver.resolveView(Type<NFTCollectionDisplay>()) {
            if let v = view as? NFTCollectionDisplay {
                return v
            }
        }
        return nil
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/IPackNFT.cdc

```
import Crypto
import NonFungibleToken from "NonFungibleToken"

/// Contract interface for PackNFT contracts.
///
access(all) contract interface IPackNFT{

    /// Entitlement to perform operations on the PackNFT
    ///
    access(all) entitlement Operate

    /// StoragePath for Collection Resource
    ///
    access(all) let CollectionStoragePath: StoragePath

    /// PublicPath expected for deposit
    ///
    access(all) let CollectionPublicPath: PublicPath

    /// PublicPath for receiving PackNFT
    ///
    access(all) let CollectionIPackNFTPublicPath: PublicPath

    /// StoragePath for the PackNFT Operator Resource (issuer owns this)
    ///
    access(all) let OperatorStoragePath: StoragePath

    /// Request for Reveal
    ///
    access(all) event RevealRequest(id: UInt64, openRequest: Bool)

    /// Request for Open
    ///
    /// This is emitted when owner of a PackNFT request for the entitled NFT to be
    /// deposited to its account
    access(all) event OpenRequest(id: UInt64)

    /// Burned
    ///
    /// Emitted when a PackNFT has been burned
    access(all) event Burned(id: UInt64 )

    /// Opened
    ///
    /// Emitted when a packNFT has been opened
    access(all) event Opened(id: UInt64)

    // TODO: Clean up after enum handling/removal is clarified.
    // Enums cannot be declared anymore in interfaces in Cadence 1.0
    // access(all) enum Status: UInt8 {
    //     access(all) case Sealed
    //     access(all) case Revealed
    //     access(all) case Opened
    // }

    /// Struct interface for Collectible
    ///
    access(all) struct interface Collectible {
        access(all) let address: Address
        access(all) let contractName: String
        access(all) let id: UInt64
        access(all) fun hashString(): String
        view init(address: Address, contractName: String, id: UInt64)
    }

    /// Resource interface for PackNFT
    ///
    access(all) resource interface IPack {
        access(all) let issuer: Address
        // access(all) var status: Status

        access(all) fun verify(nftString: String): Bool

        access(contract) fun reveal(id: UInt64, nfts: [{IPackNFT.Collectible}], salt: String)
        access(contract) fun open(id: UInt64, nfts: [{IPackNFT.Collectible}])
        view init(commitHash: String, issuer: Address)
    }

    /// Resource interface for IOperator
    ///
    access(all) resource interface IOperator {
        access(Operate) fun mint(distId: UInt64, commitHash: String, issuer: Address): @{IPackNFT.NFT}
        access(Operate) fun reveal(id: UInt64, nfts: [{Collectible}], salt: String)
        access(Operate) fun open(id: UInt64, nfts: [{IPackNFT.Collectible}])
    }

    // Included for backwards compatibility
    access(all) resource interface PackNFTOperator: IOperator {}

    /// Resource interface for IPackNFTToken
    ///
    access(all) resource interface IPackNFTToken {
        access(all) let id: UInt64
        access(all) let issuer: Address
    }

    /// Resource interface for NFT
    ///
    access(all) resource interface NFT: NonFungibleToken.NFT, IPackNFTToken, IPackNFTOwnerOperator {
        access(all) let id: UInt64
        access(all) let issuer: Address
    }

    /// Resource interface for PackNFT Collection
    ///
    access(all) resource interface IPackNFTCollectionPublic: NonFungibleToken.Collection {
        access(NonFungibleToken.Update) fun emitRevealRequestEvent(id: UInt64, openRequest: Bool)
        access(NonFungibleToken.Update) fun emitOpenRequestEvent(id: UInt64)
    }

    // Included for backwards compatibility
    access(all) resource interface IPackNFTOwnerOperator{}

    /// Reveal a Sealed Pack NFT
    ///
    access(all) fun publicReveal(id: UInt64, nfts: [{IPackNFT.Collectible}], salt: String)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/nfts/mint_moment_nfts_multi.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

transaction(recipientAddress: Address, editionIDs: [UInt64], counts: [UInt64], serialNumbers: [UInt64?]) {
    
    // local variable for storing the minter reference
    let minter: auth(AllDay.Mint) &AllDay.Admin
    let recipient: &AllDay.Collection

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<auth(AllDay.Mint) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")

        // get the recipients public account object
        let recipientAccount = getAccount(recipientAddress)

        // borrow a public reference to the receivers collection
        self.recipient = recipientAccount.capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
            ?? panic("Could not borrow a reference to the collection receiver")

    }

    pre {
        editionIDs.length == counts.length: "must pass arrays of same length"
        editionIDs.length == serialNumbers.length: "must pass arrays of same length"
    }

    execute {
        var i = 0
        while i < editionIDs.length {
            var remaining = counts[i]
            while remaining > 0 {
                // mint the NFT and deposit it to the recipient's collection
                self.recipient.deposit(token: <- self.minter.mintNFT(editionID: editionIDs[i], serialNumber: serialNumbers[i]))
                remaining = remaining - 1
            }
            i = i + 1
        }
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/nfts/read_moment_nft_supply.cdc

```
import AllDay from "AllDay"

// This scripts returns the number of AllDay currently in existence.

access(all) fun main(): UInt64 {
    return AllDay.totalSupply
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/sets/read_set_by_id.cdc

```
import AllDay from "AllDay"

// This script returns a Set struct for the given id,
// if it exists

access(all) fun main(id: UInt64): AllDay.SetData {
    return AllDay.getSetData(id: id)
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/sets/create_set.cdc

```
import AllDay from "AllDay"

transaction(name: String) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.createSet(
            name: name,
        )

        log("====================================")
        log("New Set: ".concat(name))
        log("SetID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/NonFungibleToken.cdc

```
/**

## The Flow Non-Fungible Token standard

## `NonFungibleToken` contract

The interface that all Non-Fungible Token contracts should conform to.
If a user wants to deploy a new NFT contract, their contract should implement
The types defined here

## `NFT` resource interface

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource interface

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives developers the ability to define functions
that can use any type that implements these interfaces

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

import "ViewResolver"

/// The main NFT contract. Other NFT contracts will
/// import and implement the interfaces defined in this contract
///
access(all) contract interface NonFungibleToken: ViewResolver {

    /// An entitlement for allowing the withdrawal of tokens from a Vault
    access(all) entitlement Withdraw

    /// An entitlement for allowing updates and update events for an NFT
    access(all) entitlement Update

    /// entitlement for owner that grants Withdraw and Update
    access(all) entitlement Owner

    /// Event that contracts should emit when the metadata of an NFT is updated
    /// It can only be emitted by calling the `emitNFTUpdated` function
    /// with an `Updatable` entitled reference to the NFT that was updated
    /// The entitlement prevents spammers from calling this from other users' collections
    /// because only code within a collection or that has special entitled access
    /// to the collections methods will be able to get the entitled reference
    ///
    /// The event makes it so that third-party indexers can monitor the events
    /// and query the updated metadata from the owners' collections.
    ///
    access(all) event Updated(type: String, id: UInt64, uuid: UInt64, owner: Address?)
    access(contract) view fun emitNFTUpdated(_ nftRef: auth(Update | Owner) &{NonFungibleToken.NFT})
    {
        emit Updated(type: nftRef.getType().identifier, id: nftRef.id, uuid: nftRef.uuid, owner: nftRef.owner?.address)
    }


    /// Event that is emitted when a token is withdrawn,
    /// indicating the type, id, uuid, the owner of the collection that it was withdrawn from,
    /// and the UUID of the resource it was withdrawn from, usually a collection.
    ///
    /// If the collection is not in an account's storage, `from` will be `nil`.
    ///
    access(all) event Withdrawn(type: String, id: UInt64, uuid: UInt64, from: Address?, providerUUID: UInt64)

    /// Event that emitted when a token is deposited to a collection.
    /// Indicates the type, id, uuid, the owner of the collection that it was deposited to,
    /// and the UUID of the collection it was deposited to
    ///
    /// If the collection is not in an account's storage, `from`, will be `nil`.
    ///
    access(all) event Deposited(type: String, id: UInt64, uuid: UInt64, to: Address?, collectionUUID: UInt64)

    /// Included for backwards-compatibility
    access(all) resource interface INFT: NFT {}

    /// Interface that the NFTs must conform to
    ///
    access(all) resource interface NFT: ViewResolver.Resolver {

        /// unique ID for the NFT
        access(all) let id: UInt64

        /// Event that is emitted automatically every time a resource is destroyed
        /// The type information is included in the metadata event so it is not needed as an argument
        access(all) event ResourceDestroyed(id: UInt64 = self.id, uuid: UInt64 = self.uuid)

        /// createEmptyCollection creates an empty Collection that is able to store the NFT
        /// and returns it to the caller so that they can own NFTs
        /// @return A an empty collection that can store this NFT
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getLength() == 0: "The created collection must be empty!"
            }
        }

        /// Gets all the NFTs that this NFT directly owns
        /// @return A dictionary of all subNFTS keyed by type
        access(all) view fun getAvailableSubNFTS(): {Type: UInt64} {
            return {}
        }

        /// Get a reference to an NFT that this NFT owns
        /// Both arguments are optional to allow the NFT to choose
        /// how it returns sub NFTs depending on what arguments are provided
        /// For example, if `type` has a value, but `id` doesn't, the NFT
        /// can choose which NFT of that type to return if there is a "default"
        /// If both are `nil`, then NFTs that only store a single NFT can just return
        /// that. This helps callers who aren't sure what they are looking for
        ///
        /// @param type: The Type of the desired NFT
        /// @param id: The id of the NFT to borrow
        ///
        /// @return A structure representing the requested view.
        access(all) fun getSubNFT(type: Type, id: UInt64) : &{NonFungibleToken.NFT}? {
            return nil
        }
    }

    /// Interface to mediate withdrawals from a resource, usually a Collection
    ///
    access(all) resource interface Provider {

        // We emit withdraw events from the provider interface because conficting withdraw
        // events aren't as confusing to event listeners as conflicting deposit events

        /// withdraw removes an NFT from the collection and moves it to the caller
        /// It does not specify whether the ID is UUID or not
        /// @param withdrawID: The id of the NFT to withdraw from the collection
        access(Withdraw | Owner) fun withdraw(withdrawID: UInt64): @{NFT} {
            post {
                result.id == withdrawID: "The ID of the withdrawn token must be the same as the requested ID"
                emit Withdrawn(type: result.getType().identifier, id: result.id, uuid: result.uuid, from: self.owner?.address, providerUUID: self.uuid)
            }
        }
    }

    /// Interface to mediate deposits to the Collection
    ///
    access(all) resource interface Receiver {

        /// deposit takes an NFT as an argument and adds it to the Collection
        /// @param token: The NFT to deposit
        access(all) fun deposit(token: @{NFT})

        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts
        /// @return A dictionary of types mapped to booleans indicating if this
        ///         reciever supports it
        access(all) view fun getSupportedNFTTypes(): {Type: Bool}

        /// Returns whether or not the given type is accepted by the collection
        /// A collection that can accept any type should just return true by default
        /// @param type: An NFT type
        /// @return A boolean indicating if this receiver can recieve the desired NFT type
        access(all) view fun isSupportedNFTType(type: Type): Bool
    }

    /// Kept for backwards-compatibility reasons
    access(all) resource interface CollectionPublic {
        access(all) fun deposit(token: @{NFT})
        access(all) view fun getLength(): Int
        access(all) view fun getIDs(): [UInt64]
        access(all) view fun borrowNFT(_ id: UInt64): &{NFT}?
    }

    /// Requirement for the concrete resource type
    /// to be declared in the implementing contract
    ///
    access(all) resource interface Collection: Provider, Receiver, CollectionPublic, ViewResolver.ResolverCollection {

        /// deposit takes a NFT as an argument and stores it in the collection
        /// @param token: The NFT to deposit into the collection
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            pre {
                // We emit the deposit event in the `Collection` interface
                // because the `Collection` interface is almost always the final destination
                // of tokens and deposit emissions from custom receivers could be confusing
                // and hard to reconcile to event listeners
                emit Deposited(type: token.getType().identifier, id: token.id, uuid: token.uuid, to: self.owner?.address, collectionUUID: self.uuid)
            }
        }

        /// Gets the amount of NFTs stored in the collection
        /// @return An integer indicating the size of the collection
        access(all) view fun getLength(): Int

        /// Borrows a reference to an NFT stored in the collection
        /// If the NFT with the specified ID is not in the collection,
        /// the function should return `nil` and not panic.
        ///
        /// @param id: The desired nft id in the collection to return a referece for.
        /// @return An optional reference to the NFT
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: The ID of the returned reference does not match the ID that was specified"
            }
        }

        /// createEmptyCollection creates an empty Collection of the same type
        /// and returns it to the caller
        /// @return A an empty collection of the same type
        access(all) fun createEmptyCollection(): @{Collection} {
            post {
                result.getType() == self.getType(): "The created collection does not have the same type as this collection"
                result.getLength() == 0: "The created collection must be empty!"
            }
        }
    }

    /// createEmptyCollection creates an empty Collection for the specified NFT type
    /// and returns it to the caller so that they can own NFTs
    /// @param nftType: The desired nft type to return a collection for.
    /// @return An array of NFT Types that the implementing contract defines.
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        post {
            result.getIDs().length == 0: "The created collection must be empty!"
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/sets/read_all_set_names.cdc

```
import AllDay from "AllDay"

// This script returns all the names for Set.
// These can be related to Set structs via AllDay.getSetByName() .

access(all) fun main(): [String] {
    return AllDay.getAllSetNames()
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/editions/close_edition.cdc

```
import AllDay from "AllDay"

transaction(editionID: UInt64) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.closeEdition(id: editionID)

        log("====================================")
        log("Closed Edition:")
        log("EditionID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/user/setup_allday_account.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This transaction configures an account to hold AllDay NFTs.

transaction {
    prepare(signer: auth(Storage, Capabilities) &Account) {
        // if the account doesn't already have a collection
        if signer.storage.borrow<&AllDay.Collection>(from: AllDay.CollectionStoragePath) == nil {

            // create a new empty collection
            let collection <- AllDay.createEmptyCollection(nftType: Type<@AllDay.NFT>())
            
            // save it to the account
            signer.storage.save(<-collection, to: AllDay.CollectionStoragePath)

            // create a public capability for the collection
            signer.capabilities.unpublish(AllDay.CollectionPublicPath)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&AllDay.Collection>(AllDay.CollectionStoragePath),
                at: AllDay.CollectionPublicPath
            )
        }
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/README.md

# NFL Smart Contracts

## NFL Contract Addresses
| Network   | Address     |              |
| ----------|:-----------:| -------------|
| Testnet   |  4dfd62c88d1b6462   | [Flow View Source](https://flow-view-source.com/mainnet/account/0x4dfd62c88d1b6462) |
| Mainnet   |  e4cf4bdc1751c65d   | [Flow View Source](https://flow-view-source.com/testnet/account/0xe4cf4bdc1751c65d) |

## Entities

### Series
Series encompass periods of time and will be named using strings like: `Summer 2021` or `Series 3`. 
More that one series can be open at any given time, and in order for an Edition to be created, it must have a SeriesID.

**On Chain Fields**
- FlowID
- Name
- Active

**Transactions**
- CreateSeries: Mints a new series onto Flow
- CloseSeries: Stops any new Editions from using the specified series
### Sets
Sets are categories: `Greatest Touchdowns` or similar. Sets have a unique name.An Edition must have a SetID to be created.
Sets do not close and cannot be retired. Sets contain a dictionary of all the SetID/PlayID combinations that exist within
an Edition. This is checked everytime a new Edition is created to ensure they are unique.

**On Chain Fields**
- FlowID
- Name

**Transactions**
- CreateSet: Mints a new set onto Flow
### Plays
Plays contain the actual play metadata, including stats from NFL and Elias. 
This will contain Player, Team, and Game metadata some of which may be blank depending on the type of moment.

**On Chain Fields**
- FlowID
- Classification (Name TBC: example, PLAYER_GAME, TEAM_GAME, PLAYER_MELT, TEAM_MELT)
- Metadata (stored as a string map. This can technically be anything, but the agreeed upon fields are as follows)
  - PlayType
  - HomeTeamName
  - AwayTeamName
  - TeamName
  - GameDate
  - HomeTeamScore
  - AwayTeamScore
  - PlayerFirstName
  - PlayerLastName
  - PlayerPosition
  - PlayerNumber

**Transactions**
- CreatePlay: Mints a new Play on Flow
### Editions
Editions are the combination of a SeriesID, SetID, and PlayID and are what moments are minted out of.
They also have a Max and Current Edition size so we can specify how many moments can ever be minted from 
the edition. 

The MaxEditionSize is optional. If it is not set, moments can be minted unlimitedly. An Edition will close, if either of these things happen:
- The max number of moments are minted
- The CloseEdition transaction is used
- 
`MaxEditionSize` cannot be changed once it is set.

**Fields**
- FlowID
- SeriesID
- SetID
- PlayID
- MaxEditionSize
- Tier
- NumMinted

**Transactions**
- CreateEdition: Mints a new Edition on Flow.
- CloseEdition: Closes an Edition so no new moments can be minted from it. This is irreversible. The Edition is closed by setting the MaxEditionSize to the value of NumMinted.

### Moment NFT
Moments are minted out of editions. You can think of Editions as a "cookie cutter" for moments. The Serial Number is what makes each MomentNFT unique. These are the NFTs that will be sold in packs. 

**Fields**
- FlowID
- EditionID
- Serial Number

**Transactions**
- MintMomentNFT: Mints a moment out of an EditionID


## NFT Metadata Standard
The contract conforms to the Flow NFT Metadata standard and implements the Core NFT Views. See 
[Flow NFT Catalog](https://www.flow-nft-catalog.com/) for details.




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/user/account_is_all_setup.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"
import MetadataViews from "MetadataViews"
import PackNFT from "PackNFT"

/// Check if an account has been set up to hold AllDay NFTs.
///
access(all) fun main(address: Address): Bool {
    let account = getAccount(address)
    return account.capabilities.borrow<
        &AllDay.Collection>(AllDay.CollectionPublicPath) != nil &&
        account.capabilities.borrow<
        &PackNFT.Collection>(PackNFT.CollectionPublicPath) != nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/user/transfer_moment_nft.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This transaction transfers a AllDay NFT from one account to another.

transaction(recipientAddress: Address, withdrawID: UInt64) {
    prepare(signer: auth(BorrowValue) &Account) {
        
        // get the recipients public account object
        let recipient = getAccount(recipientAddress)

        // borrow a reference to the signer's NFT collection
        let collectionRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &AllDay.Collection>(from: AllDay.CollectionStoragePath)
            ?? panic("Could not borrow a reference to the owner's collection")

        // borrow a public reference to the receivers collection
        let depositRef = recipient.capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
            ?? panic("Could not borrow a reference to the recipient's collection")

        // withdraw the NFT from the owner's collection
        let nft <- collectionRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        depositRef.deposit(token: <-nft)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/imports/Burner.cdc

```
/// Burner is a contract that can facilitate the destruction of any resource on flow.
///
/// Contributors
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Bastian Müller - https://twitter.com/turbolent
access(all) contract Burner {
    /// When Crescendo (Cadence 1.0) is released, custom destructors will be removed from cadece.
    /// Burnable is an interface meant to replace this lost feature, allowing anyone to add a callback
    /// method to ensure they do not destroy something which is not meant to be,
    /// or to add logic based on destruction such as tracking the supply of a FT Collection
    ///
    /// NOTE: The only way to see benefit from this interface
    /// is to always use the burn method in this contract. Anyone who owns a resource can always elect **not**
    /// to destroy a resource this way
    access(all) resource interface Burnable {
        access(contract) fun burnCallback()
    }

    /// burn is a global method which will destroy any resource it is given.
    /// If the provided resource implements the Burnable interface,
    /// it will call the burnCallback method and then destroy afterwards.
    access(all) fun burn(_ r: @AnyResource) {
        if let s <- r as? @{Burnable} {
            s.burnCallback()
            destroy s
        } else if let arr <- r as? @[AnyResource] {
            while arr.length > 0 {
                let item <- arr.removeFirst()
                self.burn(<-item)
            }
            destroy arr
        } else if let dict <- r as? @{HashableStruct: AnyResource} {
            let keys = dict.keys
            while keys.length > 0 {
                let item <- dict.remove(key: keys.removeFirst())!
                self.burn(<-item)
            }
            destroy dict
        } else {
            destroy r
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/PackNFT.cdc

```
import Crypto
import NonFungibleToken from "NonFungibleToken"
import FungibleToken from "FungibleToken"
import IPackNFT from "IPackNFT"
import MetadataViews from "MetadataViews"
import ViewResolver from "ViewResolver"

/// Contract that defines Pack NFTs.
///
access(all) contract PackNFT: NonFungibleToken, IPackNFT {

    access(all) var totalSupply: UInt64
    access(all) let version: String
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath
    access(all) let CollectionIPackNFTPublicPath: PublicPath
    access(all) let OperatorStoragePath: StoragePath

    /// Dictionary that stores Pack resources in the contract state (i.e., Pack NFT representations to keep track of states).
    ///
    access(contract) let packs: @{UInt64: Pack}

    access(all) event RevealRequest(id: UInt64, openRequest: Bool)
    access(all) event OpenRequest(id: UInt64)
    access(all) event Revealed(id: UInt64, salt: String, nfts: String)
    access(all) event Opened(id: UInt64)
    access(all) event Mint(id: UInt64, commitHash: String, distId: UInt64)
    access(all) event ContractInitialized()

    // TODO: Consider removing 'Withdraw' and 'Deposit' events now that similar 'Withdrawn' and 'Deposited' events are emitted in NonFungibleToken contract interface
    access(all) event Withdraw(id: UInt64, from: Address?)
    access(all) event Deposit(id: UInt64, to: Address?)

    /// Enum that defines the status of a Pack resource.
    ///
    access(all) enum Status: UInt8 {
        access(all) case Sealed
        access(all) case Revealed
        access(all) case Opened
    }

    /// Resource that defines a Pack NFT Operator, responsible for:
    ///  - Minting Pack NFTs and the corresponding Pack resources that keep track of states,
    ///  - Revealing sealed Pack resources, and
    ///  - opening revealed Pack resources.
    ///
    access(all) resource PackNFTOperator: IPackNFT.IOperator {

        /// Mint a new Pack NFT resource and corresponding Pack resource; store the Pack resource in the contract's packs dictionary
        /// and return the Pack NFT resource to the caller.
        ///
        access(IPackNFT.Operate) fun mint(distId: UInt64, commitHash: String, issuer: Address): @{IPackNFT.NFT} {
            let nft <- create NFT(commitHash: commitHash, issuer: issuer)
            PackNFT.totalSupply = PackNFT.totalSupply + 1
            let p <- create Pack(commitHash: commitHash, issuer: issuer)
            PackNFT.packs[nft.id] <-! p
            emit Mint(id: nft.id, commitHash: commitHash, distId: distId)
            return <- nft
        }

        /// Reveal a Sealed Pack resource.
        ///
        access(IPackNFT.Operate) fun reveal(id: UInt64, nfts: [{IPackNFT.Collectible}], salt: String) {
            let p <- PackNFT.packs.remove(key: id) ?? panic("no such pack")
            p.reveal(id: id, nfts: nfts, salt: salt)
            PackNFT.packs[id] <-! p
        }

        /// Open a Revealed Pack NFT resource.
        ///
        access(IPackNFT.Operate) fun open(id: UInt64, nfts: [{IPackNFT.Collectible}]) {
            let p <- PackNFT.packs.remove(key: id) ?? panic("no such pack")
            p.open(id: id, nfts: nfts)
            PackNFT.packs[id] <-! p
        }

        /// PackNFTOperator resource initializer.
        ///
        view init() {}
    }

    /// Resource that defines a Pack NFT.
    ///
    access(all) resource Pack {
        access(all) let commitHash: String
        access(all) let issuer: Address
        access(all) var status: Status
        access(all) var salt: String?

        access(all) view fun verify(nftString: String): Bool {
            assert(self.status != Status.Sealed, message: "Pack not revealed yet")
            var hashString = self.salt!
            hashString = hashString.concat(",").concat(nftString)
            let hash = HashAlgorithm.SHA2_256.hash(hashString.utf8)
            assert(self.commitHash == String.encodeHex(hash), message: "CommitHash was not verified")
            return true
        }

        access(self) fun _verify(nfts: [{IPackNFT.Collectible}], salt: String, commitHash: String): String {
            var hashString = salt
            var nftString = nfts[0].hashString()
            var i = 1
            while i < nfts.length {
                let s = nfts[i].hashString()
                nftString = nftString.concat(",").concat(s)
                i = i + 1
            }
            hashString = hashString.concat(",").concat(nftString)
            let hash = HashAlgorithm.SHA2_256.hash(hashString.utf8)
            assert(self.commitHash == String.encodeHex(hash), message: "CommitHash was not verified")
            return nftString
        }

        access(contract) fun reveal(id: UInt64, nfts: [{IPackNFT.Collectible}], salt: String) {
            assert(self.status == Status.Sealed, message: "Pack status is not Sealed")
            let v = self._verify(nfts: nfts, salt: salt, commitHash: self.commitHash)
            self.salt = salt
            self.status = Status.Revealed
            emit Revealed(id: id, salt: salt, nfts: v)
        }

        access(contract) fun open(id: UInt64, nfts: [{IPackNFT.Collectible}]) {
            assert(self.status == Status.Revealed, message: "Pack status is not Revealed")
            self._verify(nfts: nfts, salt: self.salt!, commitHash: self.commitHash)
            self.status = Status.Opened
            emit Opened(id: id)
        }

        /// Pack resource initializer.
        ///
        view init(commitHash: String, issuer: Address) {
            // Set the hash and issuer from the arguments.
            self.commitHash = commitHash
            self.issuer = issuer

            // Initial status is Sealed.
            self.status = Status.Sealed

            // Salt is nil until reveal.
            self.salt = nil
        }
    }

    /// Resource that defines a Pack NFT.
    ///
    access(all) resource NFT: NonFungibleToken.NFT, ViewResolver.Resolver, IPackNFT.NFT, IPackNFT.IPackNFTToken, IPackNFT.IPackNFTOwnerOperator {
        /// This NFT's unique ID.
        ///
        access(all) let id: UInt64

        /// This NFT's commit hash, used to verify the IDs of the NFTs in the Pack.
        ///
        access(all) let commitHash: String

        /// This NFT's issuer.
        ///
        access(all) let issuer: Address

        /// Event emitted when a NFT is destroyed (replaces Burned event before Cadence 1.0 update)
        ///
        access(all) event ResourceDestroyed(id: UInt64 = self.id)

        /// Executed by calling the Burner contract's burn method (i.e., conforms to the Burnable interface)
        ///
        access(contract) fun burnCallback() {
            PackNFT.totalSupply = PackNFT.totalSupply - 1
            destroy <- PackNFT.packs.remove(key: self.id) ?? panic("no such pack")
        }

        /// NFT resource initializer.
        ///
        view init(commitHash: String, issuer: Address) {
            self.id = self.uuid
            self.commitHash = commitHash
            self.issuer = issuer
        }

        /// Create an empty Collection for Pinnacle NFTs and return it to the caller
        ///
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- PackNFT.createEmptyCollection(nftType: Type<@NFT>())
        }

        /// Return the metadata view types available for this NFT.
        ///
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Medias>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Serial>()
            ]
        }

        /// Resolve this NFT's metadata views.
        ///
        access(all) view fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: "NFL All Day Pack",
                        description: "Reveals official NFL All Day Moments when opened",
                        thumbnail: MetadataViews.HTTPFile(url: self.getImage(imageType: "image", format: "jpeg", width: 256))
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://nflallday.com/packnfts/".concat(self.id.toString())) // might have to make a URL that redirects to packs page based on packNFT id -> distribution id
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            )
                        ]
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: PackNFT.CollectionStoragePath,
                        publicPath: PackNFT.CollectionPublicPath,
                        publicCollection: Type<&Collection>(),
                        publicLinkedType: Type<&Collection>(),
                        createEmptyCollectionFunction: (fun (): @{NonFungibleToken.Collection} {
                            return <-PackNFT.createEmptyCollection(nftType: Type<@NFT>())
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.nflallday.com/flow/catalogue/NFLAD_BANNER.png"
                        ),
                        mediaType: "image/png"
                    )
                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.nflallday.com/flow/catalogue/NFLAD_SQUARE.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "NFL All Day Packs",
                        description: "Officially Licensed Digital Collectibles Featuring the NFL’s Best Highlights. Buy, Sell and Collect Your Favorite NFL Moments",
                        externalURL: MetadataViews.ExternalURL("https://nflallday.com/"),
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: {
                            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nflallday/"),
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/NFLAllDay"),
                            "discord": MetadataViews.ExternalURL("https://discord.com/invite/5K6qyTzj2k")
                        }
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount({{.RoyaltyAddress}}).capabilities.get<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())!
                    return MetadataViews.Royalties(
                        [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: 0.05,
                                description: "NFL All Day marketplace royalty"
                            )
                        ]
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(self.id)
            }
            return nil
        }

        /// Return an asset path.
        ///
        access(all) view fun assetPath(): String {
            return "https://media.nflallday.com/packnfts/".concat(self.id.toString()).concat("/media/")
        }

        /// Return an image path.
        ///
        access(all) view fun getImage(imageType: String, format: String, width: Int): String {
            return self.assetPath().concat(imageType).concat("?format=").concat(format).concat("&width=").concat(width.toString())
        }
    }

    /// Resource that defines a Collection of Pack NFTs.
    ///
    access(all) resource Collection: NonFungibleToken.Collection, ViewResolver.ResolverCollection, IPackNFT.IPackNFTCollectionPublic {
        /// Dictionary of NFT conforming tokens.
        /// NFT is a resource type with a UInt64 ID field.
        ///
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        /// Collection resource initializer,
        ///
        view init() {
            self.ownedNFTs <- {}
        }

        /// Remove an NFT from the collection and moves it to the caller.
        ///
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            // Withdrawn event emitted from NonFungibleToken contract interface.
            emit Withdraw(id: token.id, from: self.owner?.address) // TODO: Consider removing
            return <- token
        }

        /// Deposit an NFT into this Collection.
        ///
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @NFT
            let id: UInt64 = token.id
            // Add the new token to the dictionary which removes the old one.
            let oldToken <- self.ownedNFTs[id] <- token

            // Deposited event emitted from NonFungibleToken contract interface.
            emit Deposit(id: id, to: self.owner?.address)  // TODO: Consider removing
            destroy oldToken
        }

        /// Emit a RevealRequest event to signal a Sealed Pack NFT should be revealed.
        ///
        access(NonFungibleToken.Update) fun emitRevealRequestEvent(id: UInt64, openRequest: Bool) {
            pre {
                self.borrowNFT(id) != nil: "NFT with provided ID must exist in the collection"
                PackNFT.borrowPackRepresentation(id: id)!.status.rawValue == Status.Sealed.rawValue: "Pack status must be Sealed for reveal request"
            }
            emit RevealRequest(id: id, openRequest: openRequest)
        }

        /// Emit an OpenRequest event to signal a Revealed Pack NFT should be opened.
        ///
        access(NonFungibleToken.Update) fun emitOpenRequestEvent(id: UInt64) {
            pre {
                self.borrowNFT(id) != nil: "NFT with provided ID must exist in the collection"
                PackNFT.borrowPackRepresentation(id: id)!.status.rawValue == Status.Revealed.rawValue: "Pack status must be Revealed for open request"
            }
            emit OpenRequest(id: id)
        }

        /// Return an array of the IDs that are in the collection.
        ///
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Return the amount of NFTs stored in the collection.
        ///
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.length
        }

        /// Return a list of NFT types that this receiver accepts.
        ///
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@NFT>()] = true
            return supportedTypes
        }

        /// Return whether or not the given type is accepted by the collection.
        ///
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@NFT>() {
                return true
            }
            return false
        }

        /// Return a reference to an NFT in the Collection.
        ///
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        /// Create an empty Collection of the same type and returns it to the caller.
        ///
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <-PackNFT.createEmptyCollection(nftType: Type<@NFT>())
        }
    }

    access(all) fun publicReveal(id: UInt64, nfts: [{IPackNFT.Collectible}], salt: String) {
        let p = PackNFT.borrowPackRepresentation(id: id) ?? panic ("No such pack")
        p.reveal(id: id, nfts: nfts, salt: salt)
    }

    /// Return a reference to a Pack resource stored in the contract state.
    ///
    access(all) view fun borrowPackRepresentation(id: UInt64): &Pack? {
        return (&self.packs[id] as &Pack?)!
    }

    /// Create an empty Collection for Pack NFTs and return it to the caller.
    ///
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        if nftType != Type<@NFT>() {
            panic("NFT type is not supported")
        }
        return <- create Collection()
    }

    /// Return the metadata views implemented by this contract.
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    access(all) view fun getContractViews(resourceType: Type?): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

    /// Resolve a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    access(all) view fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
        switch viewType {
            case Type<MetadataViews.NFTCollectionData>():
                let collectionData = MetadataViews.NFTCollectionData(
                    storagePath: PackNFT.CollectionStoragePath,
                    publicPath: PackNFT.CollectionPublicPath,
                    publicCollection: Type<&Collection>(),
                    publicLinkedType: Type<&Collection>(),
                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {
                        return <-PackNFT.createEmptyCollection(nftType: Type<@NFT>())
                    })
                )
                return collectionData
            case Type<MetadataViews.NFTCollectionDisplay>():
                let bannerImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.nflallday.com/flow/catalogue/NFLAD_BANNER.png"
                    ),
                    mediaType: "image/png"
                )
                let squareImage = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.nflallday.com/flow/catalogue/NFLAD_SQUARE.png"
                    ),
                    mediaType: "image/png"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "NFL All Day Packs",
                    description: "Officially Licensed Digital Collectibles Featuring the NFL’s Best Highlights. Buy, Sell and Collect Your Favorite NFL Moments",
                    externalURL: MetadataViews.ExternalURL("https://nflallday.com/"),
                    squareImage: squareImage,
                    bannerImage: bannerImage,
                    socials: {
                            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nflallday/"),
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/NFLAllDay"),
                            "discord": MetadataViews.ExternalURL("https://discord.com/invite/5K6qyTzj2k")
                    }
                )
        }
        return nil
    }

    /// PackNFT contract initializer.
    ///
    init(
        CollectionStoragePath: StoragePath,
        CollectionPublicPath: PublicPath,
        CollectionIPackNFTPublicPath: PublicPath,
        OperatorStoragePath: StoragePath,
        version: String
    ) {
        self.totalSupply = 0
        self.packs <- {}
        self.CollectionStoragePath = CollectionStoragePath
        self.CollectionPublicPath = CollectionPublicPath
        self.CollectionIPackNFTPublicPath = CollectionIPackNFTPublicPath
        self.OperatorStoragePath = OperatorStoragePath
        self.version = version

        // Create a collection to receive Pack NFTs and publish public receiver capabilities.
        self.account.storage.save(<- create Collection(), to: self.CollectionStoragePath)
        self.account.capabilities.publish(
            self.account.capabilities.storage.issue<&{NonFungibleToken.CollectionPublic}>(self.CollectionStoragePath),
            at: self.CollectionPublicPath
        )
        self.account.capabilities.publish(
            self.account.capabilities.storage.issue<&{IPackNFT.IPackNFTCollectionPublic}>(self.CollectionStoragePath),
            at: self.CollectionIPackNFTPublicPath
        )

        // Create a Pack NFT operator to share mint capability with proxy.
        self.account.storage.save(<- create PackNFTOperator(), to: self.OperatorStoragePath)
        self.account.capabilities.storage.issue<&{IPackNFT.IOperator}>(self.OperatorStoragePath)
    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/nfts/read_moment_nft_properties.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This script returns the size of an account's AllDay collection.

access(all) fun main(address: Address, id: UInt64): [AnyStruct] {
    let account = getAccount(address)

    let collectionRef = getAccount(address).capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    let nft = collectionRef.borrowMomentNFT(id: id)
        ?? panic("Couldn't borrow momentNFT")

    return [nft.id, nft.editionID, nft.serialNumber, nft.mintingDate]
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/series/create_series.cdc

```
import AllDay from "AllDay"

transaction(name: String) {
    // local variable for the admin reference
    let admin: auth(AllDay.Operate) &AllDay.Admin

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the Admin resource
        self.admin = signer.storage.borrow<auth(AllDay.Operate) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the AllDay Admin capability")
    }

    execute {
        let id = self.admin.createSeries(
            name: name,
        )

        log("====================================")
        log("New Series: ".concat(name))
        log("SeriesID: ".concat(id.toString()))
        log("====================================")
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/admin/nfts/mint_moment_nft.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

transaction(recipientAddress: Address, editionID: UInt64, serialNumber: UInt64?) {
    
    // local variable for storing the minter reference
    let minter: auth(AllDay.Mint) &AllDay.Admin
    let recipient: &AllDay.Collection

    prepare(signer: auth(BorrowValue) &Account) {
        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.storage.borrow<auth(AllDay.Mint) &AllDay.Admin>(from: AllDay.AdminStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")

        // get the recipients public account object
        let recipientAccount = getAccount(recipientAddress)

        // borrow a public reference to the receivers collection
        self.recipient = recipientAccount.capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
            ?? panic("Could not borrow a reference to the collection receiver")
    }

    execute {
        // mint the NFT and deposit it to the recipient's collection
        let momentNFT <- self.minter.mintNFT(editionID: editionID, serialNumber: serialNumber)
        self.recipient.deposit(token: <- (momentNFT as @{NonFungibleToken.NFT}))
    }
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/transactions/user/setup_switchboard_account.cdc

```
import FungibleTokenSwitchboard from "FungibleTokenSwitchboard"
import FungibleToken from "FungibleToken"

// This transaction is a template for a transaction that could be used by
// anyone to to add a Switchboard resource to their account so that they can
// receive multiple fungible tokens using a single {FungibleToken.Receiver}
transaction {

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {

        // Check if the account already has a Switchboard resource, return early if so
        if signer.storage.borrow<&FungibleTokenSwitchboard.Switchboard>(from: FungibleTokenSwitchboard.StoragePath) != nil {
            return
        }

        // Create a new Switchboard resource and put it into storage
        signer.storage.save(
            <- FungibleTokenSwitchboard.createSwitchboard(),
            to: FungibleTokenSwitchboard.StoragePath
        )

        // Clear existing Capabilities at canonical paths
        signer.capabilities.unpublish(FungibleTokenSwitchboard.ReceiverPublicPath)
        signer.capabilities.unpublish(FungibleTokenSwitchboard.PublicPath)

        // Create a public capability to the Switchboard exposing the deposit
        // function through the {FungibleToken.Receiver} interface
        let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(receiverCap, at: FungibleTokenSwitchboard.ReceiverPublicPath)

        // Create a public capability to the Switchboard exposing both the
        // {FungibleTokenSwitchboard.SwitchboardPublic} and the
        // {FungibleToken.Receiver} interfaces
        let switchboardPublicCap = signer.capabilities.storage.issue<&{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}>(
                FungibleTokenSwitchboard.StoragePath
            )
        signer.capabilities.publish(switchboardPublicCap, at: FungibleTokenSwitchboard.PublicPath)

    }

}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/contracts/AllDay.cdc

```
/*
    Adapted from: Genies.cdc
    Author: Rhea Myers rhea.myers@dapperlabs.com
    Author: Sadie Freeman sadie.freeman@dapperlabs.com
*/

import NonFungibleToken from "NonFungibleToken"
import FungibleToken from "FungibleToken"
import MetadataViews from "MetadataViews"
import ViewResolver from "ViewResolver"

/*
    AllDay is structured similarly to Genies and TopShot.
    Unlike TopShot, we use resources for all entities and manage access to their data
    by copying it to structs (this simplifies access control, in particular write access).
    We also encapsulate resource creation for the admin in member functions on the parent type.

    There are 5 levels of entity:
    1. Series
    2. Sets
    3. Plays
    4. Editions
    4. Moment NFT (an NFT)

    An Edition is created with a combination of a Series, Set, and Play
    Moment NFTs are minted out of Editions.

    Note that we cache some information (Series names/ids, counts of entities) rather
    than calculate it each time.
    This is enabled by encapsulation and saves gas for entity lifecycle operations.
 */

// The AllDay NFTs and metadata contract
//
access(all) contract AllDay: NonFungibleToken {
    //------------------------------------------------------------
    // Events
    //------------------------------------------------------------

    // Contract Events
    //
    access(all) event ContractInitialized()

    // NFT Collection Events
    //
    access(all) event Withdraw(id: UInt64, from: Address?)
    access(all) event Deposit(id: UInt64, to: Address?)

    // Series Events
    //
    // Emitted when a new series has been created by an admin
    access(all) event SeriesCreated(id: UInt64, name: String)
    // Emitted when a series is closed by an admin
    access(all) event SeriesClosed(id: UInt64)

    // Set Events
    //
    // Emitted when a new set has been created by an admin
    access(all) event SetCreated(id: UInt64, name: String)

    // Play Events
    //
    // Emitted when a new play has been created by an admin
    access(all) event PlayCreated(id: UInt64, classification: String, metadata: {String: String})

    // Edition Events
    //
    // Emitted when a new edition has been created by an admin
    access(all) event EditionCreated(
        id: UInt64,
        seriesID: UInt64,
        setID: UInt64,
        playID: UInt64,
        maxMintSize: UInt64?,
        tier: String,
    )
    // Emitted when an edition is either closed by an admin, or the max amount of moments have been minted
    access(all) event EditionClosed(id: UInt64)

    // NFT Events
    //
    access(all) event MomentNFTMinted(id: UInt64, editionID: UInt64, serialNumber: UInt64)
    access(all) event MomentNFTBurned(id: UInt64)

    //------------------------------------------------------------
    // Named values
    //------------------------------------------------------------

    // Named Paths
    //
    access(all) let CollectionStoragePath:  StoragePath
    access(all) let CollectionPublicPath:   PublicPath
    access(all) let AdminStoragePath:       StoragePath

    //------------------------------------------------------------
    // Publicly readable contract state
    //------------------------------------------------------------

    // Entity Counts
    //
    access(all) var totalSupply:        UInt64
    access(all) var nextSeriesID:       UInt64
    access(all) var nextSetID:          UInt64
    access(all) var nextPlayID:         UInt64
    access(all) var nextEditionID:      UInt64

    //------------------------------------------------------------
    // Internal contract state
    //------------------------------------------------------------

    // Metadata Dictionaries
    //
    // This is so we can find Series by their names (via seriesByID)
    access(self) let seriesIDByName:    {String: UInt64}
    access(self) let seriesByID:        @{UInt64: Series}
    access(self) let setIDByName:       {String: UInt64}
    access(self) let setByID:           @{UInt64: Set}
    access(self) let playByID:          @{UInt64: Play}
    access(self) let editionByID:       @{UInt64: Edition}

    //------------------------------------------------------------
    // Series
    //------------------------------------------------------------

    // A public struct to access Series data
    //
    access(all) struct SeriesData {
        access(all) let id: UInt64
        access(all) let name: String
        access(all) let active: Bool

        // initializer
        //
        view init (id: UInt64) {
            if let series = &AllDay.seriesByID[id] as &AllDay.Series? {
                self.id = series.id
                self.name = series.name
                self.active = series.active
            } else {
                panic("series does not exist")
            }
        }
    }

    // A top-level Series with a unique ID and name
    //
    access(all) resource Series {
        access(all) let id: UInt64
        access(all) let name: String
        access(all) var active: Bool

        // Close this series
        //
        access(all) fun close() {
            pre {
                self.active == true: "not active"
            }

            self.active = false

            emit SeriesClosed(id: self.id)
        }

        // initializer
        //
        init (name: String) {
            pre {
                !AllDay.seriesIDByName.containsKey(name): "A Series with that name already exists"
            }
            self.id = AllDay.nextSeriesID
            self.name = name
            self.active = true

            // Cache the new series's name => ID
            AllDay.seriesIDByName[name] = self.id
            // Increment for the nextSeriesID
            AllDay.nextSeriesID = self.id + 1 as UInt64

            emit SeriesCreated(id: self.id, name: self.name)
        }
    }

    // Get the publicly available data for a Series by id
    //
    access(all) view fun getSeriesData(id: UInt64): AllDay.SeriesData {
        pre {
            AllDay.seriesByID[id] != nil: "Cannot borrow series, no such id"
        }

        return AllDay.SeriesData(id: id)
    }

    // Get the publicly available data for a Series by name
    //
    access(all) view fun getSeriesDataByName(name: String): AllDay.SeriesData {
        pre {
            AllDay.seriesIDByName[name] != nil: "Cannot borrow series, no such name"
        }

        let id = AllDay.seriesIDByName[name]!

        return AllDay.SeriesData(id: id)
    }

    // Get all series names (this will be *long*)
    //
    access(all) view fun getAllSeriesNames(): [String] {
        return AllDay.seriesIDByName.keys
    }

    // Get series id for name
    //
    access(all) view fun getSeriesIDByName(name: String): UInt64? {
        return AllDay.seriesIDByName[name]
    }

    //------------------------------------------------------------
    // Set
    //------------------------------------------------------------

    // A public struct to access Set data
    //
    access(all) struct SetData {
        access(all) let id: UInt64
        access(all) let name: String
        access(all) var setPlaysInEditions: &{UInt64: Bool}

        // member function to check the setPlaysInEditions to see if this Set/Play combination already exists
        access(all) view fun setPlayExistsInEdition(playID: UInt64): Bool {
           return self.setPlaysInEditions.containsKey(playID)
        }

        // initializer
        //
        view init (id: UInt64) {
            if let set = &AllDay.setByID[id] as &AllDay.Set? {
            self.id = id
            self.name = set.name
            self.setPlaysInEditions = set.setPlaysInEditions
            } else {
               panic("set does not exist")
            }
        }
    }

    // A top level Set with a unique ID and a name
    //
    access(all) resource Set {
        access(all) let id: UInt64
        access(all) let name: String
        // Store a dictionary of all the Plays which are paired with the Set inside Editions
        // This enforces only one Set/Play unique pair can be used for an Edition
        access(all) var setPlaysInEditions: {UInt64: Bool}

        // member function to insert a new Play to the setPlaysInEditions dictionary
        access(all) fun insertNewPlay(playID: UInt64) {
            self.setPlaysInEditions[playID] = true
        }

        // initializer
        //
        init (name: String) {
            pre {
                !AllDay.setIDByName.containsKey(name): "A Set with that name already exists"
            }
            self.id = AllDay.nextSetID
            self.name = name
            self.setPlaysInEditions = {}

            // Cache the new set's name => ID
            AllDay.setIDByName[name] = self.id
            // Increment for the nextSeriesID
            AllDay.nextSetID = self.id + 1 as UInt64

            emit SetCreated(id: self.id, name: self.name)
        }
    }

    // Get the publicly available data for a Set
    //
    access(all) view fun getSetData(id: UInt64): AllDay.SetData {
        pre {
            AllDay.setByID[id] != nil: "Cannot borrow set, no such id"
        }

        return AllDay.SetData(id: id)
    }

    // Get the publicly available data for a Set by name
    //
    access(all) view fun getSetDataByName(name: String): AllDay.SetData {
        pre {
            AllDay.setIDByName[name] != nil: "Cannot borrow set, no such name"
        }

        let id = AllDay.setIDByName[name]!

        return AllDay.SetData(id: id)
    }

    // Get all set names (this will be *long*)
    //
    access(all) view fun getAllSetNames(): [String] {
        return AllDay.setIDByName.keys
    }


    //------------------------------------------------------------
    // Play
    //------------------------------------------------------------

    // A public struct to access Play data
    //
    access(all) struct PlayData {
        access(all) let id: UInt64
        access(all) let classification: String
        access(all) let metadata: &{String: String}

        // initializer
        //
        view init (id: UInt64) {
            if let play = &AllDay.playByID[id] as &AllDay.Play? {
            self.id = id
            self.classification = play.classification
            self.metadata = play.metadata
            } else {
                panic("play does not exist")
            }
        }
    }

    // A top level Play with a unique ID and a classification
    //
    access(all) resource Play {
        access(all) let id: UInt64
        access(all) let classification: String
        // Contents writable if borrowed!
        // This is deliberate, as it allows admins to update the data.
        access(all) let metadata: {String: String}

        // initializer
        //
        init (classification: String, metadata: {String: String}) {
            self.id = AllDay.nextPlayID
            self.classification = classification
            self.metadata = metadata

            AllDay.nextPlayID = self.id + 1 as UInt64

            emit PlayCreated(id: self.id, classification: self.classification, metadata: self.metadata)
        }

        access(contract) fun updateDescription(description: String) {
            self.metadata["description"] = description
        }

        access(contract) fun updateDynamicMetadata(optTeamName: String?, optPlayerFirstName: String?,
            optPlayerLastName: String?, optPlayerNumber: String?, optPlayerPosition: String?) {
            if let teamName = optTeamName {
                self.metadata["teamName"] = teamName
            }
            if let playerFirstName = optPlayerFirstName {
                self.metadata["playerFirstName"] = playerFirstName
            }
            if let playerLastName = optPlayerLastName {
                self.metadata["playerLastName"] = playerLastName
            }
            if let playerNumber = optPlayerNumber {
                self.metadata["playerNumber"] = playerNumber
            }
            if let playerPosition = optPlayerPosition {
                self.metadata["playerPosition"] = playerPosition
            }
        }
    }

    // Get the publicly available data for a Play
    //
    access(all) view fun getPlayData(id: UInt64): AllDay.PlayData {
        pre {
            AllDay.playByID[id] != nil: "Cannot borrow play, no such id"
        }

        return AllDay.PlayData(id: id)
    }

    //------------------------------------------------------------
    // Edition
    //------------------------------------------------------------

    // A public struct to access Edition data
    //
    access(all) struct EditionData {
        access(all) let id: UInt64
        access(all) let seriesID: UInt64
        access(all) let setID: UInt64
        access(all) let playID: UInt64
        access(all) var maxMintSize: UInt64?
        access(all) let tier: String
        access(all) var numMinted: UInt64

       // member function to check if max edition size has been reached
       access(all) view fun maxEditionMintSizeReached(): Bool {
            return self.numMinted == self.maxMintSize
        }

        // initializer
        //
        view init (id: UInt64) {
           if let edition = &AllDay.editionByID[id] as &AllDay.Edition? {
            self.id = id
            self.seriesID = edition.seriesID
            self.playID = edition.playID
            self.setID = edition.setID
            self.maxMintSize = edition.maxMintSize
            self.tier = edition.tier
            self.numMinted = edition.numMinted
           } else {
               panic("edition does not exist")
           }
        }
    }

    // A top level Edition that contains a Series, Set, and Play
    //
    access(all) resource Edition {
        access(all) let id: UInt64
        access(all) let seriesID: UInt64
        access(all) let setID: UInt64
        access(all) let playID: UInt64
        access(all) let tier: String
        // Null value indicates that there is unlimited minting potential for the Edition
        access(all) var maxMintSize: UInt64?
        // Updates each time we mint a new moment for the Edition to keep a running total
        access(all) var numMinted: UInt64

        // Close this edition so that no more Moment NFTs can be minted in it
        //
        access(contract) fun close() {
            pre {
                self.numMinted != self.maxMintSize: "max number of minted moments has already been reached"
            }

            self.maxMintSize = self.numMinted

            emit EditionClosed(id: self.id)
        }

        // Mint a Moment NFT in this edition, with the given minting mintingDate.
        // Note that this will panic if the max mint size has already been reached.
        //
        access(all) fun mint(serialNumber: UInt64?): @AllDay.NFT {
            pre {
                self.numMinted != self.maxMintSize: "max number of minted moments has been reached"
            }

            var serial = self.numMinted + 1 as UInt64

            // Create the Moment NFT, filled out with our information
            let momentNFT <- create NFT(
                id: AllDay.totalSupply + 1,
                editionID: self.id,
                serialNumber: serial
            )
            AllDay.totalSupply = AllDay.totalSupply + 1
            // Keep a running total (you'll notice we used this as the serial number for closed editions)
            self.numMinted = self.numMinted + 1 as UInt64

            return <- momentNFT
        }

        // initializer
        //
        init (
            seriesID: UInt64,
            setID: UInt64,
            playID: UInt64,
            maxMintSize: UInt64?,
            tier: String,
        ) {
            pre {
                maxMintSize != 0: "max mint size is zero, must either be null or greater than 0"
                AllDay.seriesByID.containsKey(seriesID): "seriesID does not exist"
                AllDay.setByID.containsKey(setID): "setID does not exist"
                AllDay.playByID.containsKey(playID): "playID does not exist"
                SeriesData(id: seriesID).active == true: "cannot create an Edition with a closed Series"
                AllDay.getPlayTierExistsInEdition(setID, playID, tier) == false: "set play tier combination already exists in an edition"
            }

            self.id = AllDay.nextEditionID
            self.seriesID = seriesID
            self.setID = setID
            self.playID = playID

            // If an edition size is not set, it has unlimited minting potential
            if maxMintSize == 0 {
                self.maxMintSize = nil
            } else {
                self.maxMintSize = maxMintSize
            }

            self.tier = tier
            self.numMinted = 0 as UInt64

            AllDay.nextEditionID = AllDay.nextEditionID + 1 as UInt64
            AllDay.setByID[setID]?.insertNewPlay(playID: playID)
            AllDay.insertSetPlayTierMap(setID, playID, tier)

            emit EditionCreated(
                id: self.id,
                seriesID: self.seriesID,
                setID: self.setID,
                playID: self.playID,
                maxMintSize: self.maxMintSize,
                tier: self.tier,
            )
        }
    }

    // Get the publicly available data for an Edition
    //
    access(all) view fun getEditionData(id: UInt64): EditionData {
        pre {
            AllDay.editionByID[id] != nil: "Cannot borrow edition, no such id"
        }

        return AllDay.EditionData(id: id)
    }

    //------------------------------------------------------------
    // Internal functions for tracking Editions minted with Set + Play + Tier combinations
    //------------------------------------------------------------

    // Get storage path for SetPlayTierMap
    //
    access(contract) view fun getSetPlayTierMapStorage(): StoragePath {
        return /storage/AllDayAdminSetPlayTierMap
    }

    // Get composite key used to read/write SetPlayTierMap
    //
    access(contract) view fun getSetPlayTierMapKey(_ setID: UInt64,_ playID: UInt64,_ tier: String): String {
        return setID.toString().concat("-").concat(playID.toString()).concat("-").concat(tier)
    }

    // Check if the given set, play, tier has already been minted in an Edition
    //
    access(contract) view fun getPlayTierExistsInEdition(_ setID: UInt64, _ playID: UInt64, _ tier: String): Bool {
        let setPlayTierMap = AllDay.account.storage.borrow<&{String: Bool}>(from: AllDay.getSetPlayTierMapStorage())!
        return setPlayTierMap.containsKey(AllDay.getSetPlayTierMapKey(setID, playID, tier))
    }

    // Insert new entry into SetPlayTierMap
    //
    access(contract) fun insertSetPlayTierMap(_ setID: UInt64, _ playID: UInt64, _ tier: String) {
        let setPlayTierMap = AllDay.account.storage.load<{String: Bool}>(from: AllDay.getSetPlayTierMapStorage())!
        setPlayTierMap.insert(key: AllDay.getSetPlayTierMapKey(setID, playID, tier), true)
        AllDay.account.storage.save(setPlayTierMap, to: /storage/AllDayAdminSetPlayTierMap)
    }

    //------------------------------------------------------------
    // NFT
    //------------------------------------------------------------

    // A Moment NFT
    //
    access(all) resource NFT: NonFungibleToken.NFT {
        access(all) let id: UInt64
        access(all) let editionID: UInt64
        access(all) let serialNumber: UInt64
        access(all) let mintingDate: UFix64

        access(all) event ResourceDestroyed(
            id: UInt64 = self.id,
            editionID: UInt64 = self.editionID,
            serialNumber: UInt64 = self.serialNumber,
            mintingDate: UFix64 = self.mintingDate
        )

        // NFT initializer
        //
        init(

            id: UInt64,
            editionID: UInt64,
            serialNumber: UInt64
        ) {
            pre {
                AllDay.editionByID[editionID] != nil: "no such editionID"
                EditionData(id: editionID).maxEditionMintSizeReached() != true: "max edition size already reached"
            }

            self.id = id
            self.editionID = editionID
            self.serialNumber = serialNumber
            self.mintingDate = getCurrentBlock().timestamp

            emit MomentNFTMinted(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)
        }

        // All supported metadata views for the Moment including the Core NFT Views
        //
        access(all) view fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Medias>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.getName(),
                        description: self.getDescription(),
                        thumbnail: MetadataViews.HTTPFile(url: self.getImage(imageType: "image", format: "jpeg", width: 256))
                    )
                case Type<MetadataViews.Editions>():
                    let editionList: [MetadataViews.Edition] = [self.getEditionInfo()]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://nflallday.com/moments/".concat(self.id.toString()))
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image-details", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image-logo", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image-legal", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image-player", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "image-scores", format: "jpeg", width: 512)),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "video")),
                                mediaType: "video/mp4"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "video-idle")),
                                mediaType: "video/mp4"
                            )
                        ]
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return AllDay.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>())
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return AllDay.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionDisplay>())
                case Type<MetadataViews.Royalties>():
                    return AllDay.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.Royalties>())
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(self.serialNumber)
                case Type<MetadataViews.Traits>():
                    let excludedNames: [String] = []
                    let fullDictionary = self.getTraits()
                    return MetadataViews.dictToTraits(dict: fullDictionary, excludedNames: excludedNames)
            }
            return nil
        }

        access(all) view fun getName(): String {
            let edition: EditionData = AllDay.getEditionData(id: self.editionID)
            let play: PlayData = AllDay.getPlayData(id: edition.playID)
            let firstName: String = play.metadata["playerFirstName"] ?? ""
            let lastName: String = play.metadata["playerLastName"] ?? ""
            let playType: String = play.metadata["playType"] ?? ""
            return firstName.concat(" ").concat(lastName).concat(" ").concat(playType)
        }

        access(all) view fun getDescription(): String {
            let edition: EditionData = AllDay.getEditionData(id: self.editionID)
            let play: PlayData = AllDay.getPlayData(id: edition.playID)
            let description: String = play.metadata["description"] ?? ""
            if description != "" {
                return description
            }

            let series: SeriesData = AllDay.getSeriesData(id: edition.seriesID)
            let set: SetData = AllDay.getSetData(id: edition.setID)
            return series.name.concat(" ").concat(set.name).concat(" moment with serial number ").concat(self.serialNumber.toString())
        }

        access(all) view fun assetPath(): String {
            return "https://media.nflallday.com/editions/".concat(self.editionID.toString()).concat("/media/")
        }

        access(all) view fun getImage(imageType: String, format: String, width: Int): String {
            return self.assetPath().concat(imageType).concat("?format=").concat(format).concat("&width=").concat(width.toString())
        }

        access(all) view fun getVideo(videoType: String): String {
            return self.assetPath().concat(videoType)
        }

        access(all) view fun getMomentURL(): String {
            return "https://nflallday.com/moments/".concat(self.id.toString())
        }

        access(all) view fun getEditionInfo() : MetadataViews.Edition {
            let edition: EditionData = AllDay.getEditionData(id: self.editionID)
            let set: SetData = AllDay.getSetData(id: edition.setID)
            let name: String = set.name.concat(": #").concat(edition.playID.toString())

            return MetadataViews.Edition(name: name, number: UInt64(self.serialNumber), max: edition.maxMintSize ?? nil)
        }

        access(all) fun getTraits() : {String: AnyStruct} {
            let edition: EditionData = AllDay.getEditionData(id: self.editionID)
            let play: PlayData = AllDay.getPlayData(id: edition.playID)
            let series: SeriesData = AllDay.getSeriesData(id: edition.seriesID)
            let set: SetData = AllDay.getSetData(id: edition.setID)

            let traitDictionary: {String: AnyStruct} = {
                "editionID": self.editionID,
                "editionTier": edition.tier,
                "seriesName": series.name,
                "setName": set.name,
                "serialNumber": self.serialNumber
            }

            for name in play.metadata.keys {
                let value = play.metadata[name] ?? ""
                if value != "" {
                    traitDictionary.insert(key: name, value)
                }
            }
            return traitDictionary
        }

        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- AllDay.createEmptyCollection(nftType: Type<@AllDay.NFT>())
        }
    }

    //------------------------------------------------------------
    // Collection
    //------------------------------------------------------------

    // A public collection interface that allows Moment NFTs to be borrowed
    //
    /// Deprecated: This is no longer used for defining access control anymore.
    access(all) resource interface MomentNFTCollectionPublic : NonFungibleToken.CollectionPublic {}

    // An NFT Collection
    //
    access(all) resource Collection:
        NonFungibleToken.Collection,
        MomentNFTCollectionPublic
    {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an UInt64 ID field
        //
        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}

        // Return a list of NFT types that this receiver accepts
        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {
            let supportedTypes: {Type: Bool} = {}
            supportedTypes[Type<@AllDay.NFT>()] = true
            return supportedTypes
        }

        // Return whether or not the given type is accepted by the collection
        // A collection that can accept any type should just return true by default
        access(all) view fun isSupportedNFTType(type: Type): Bool {
            if type == Type<@AllDay.NFT>() {
                return true
            }
            return false
        }

        // Return the amount of NFTs stored in the collection
        access(all) view fun getLength(): Int {
            return self.ownedNFTs.keys.length
        }

        // Create an empty Collection for AllDay NFTs and return it to the caller
        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {
            return <- AllDay.createEmptyCollection(nftType: Type<@AllDay.NFT>())
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        //
        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        //
        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {
            let token <- token as! @AllDay.NFT
            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        //
        access(all) fun batchDeposit(tokens: @{NonFungibleToken.Collection}) {
            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the collection
        //
        access(all) view fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        //
        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {
            return &self.ownedNFTs[id]
        }

        // borrowMomentNFT gets a reference to an NFT in the collection
        //
        access(all) view fun borrowMomentNFT(id: UInt64): &AllDay.NFT? {
            return self.borrowNFT(id) as! &AllDay.NFT?
        }

        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {
            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {
                return nft as &{ViewResolver.Resolver}
            }
            return nil
        }

        // Collection initializer
        //
        init() {
            self.ownedNFTs <- {}
        }
    }

    // public function that anyone can call to create a new empty collection
    //
    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {
        if nftType != Type<@AllDay.NFT>() {
            panic("NFT type is not supported")
        }
        return <- create Collection()
    }

    //------------------------------------------------------------
    // Admin
    //------------------------------------------------------------

    /// Entitlement that grants the ability to mint AllDay NFTs
    access(all) entitlement Mint

    /// Entitlement that grants the ability to operate admin functions
    access(all) entitlement Operate

    // This is no longer used for defining access control anymore.
    // Keeping this because removing it is not a valid change for contract update
    access(all) resource interface NFTMinter {}

    // A resource that allows managing metadata and minting NFTs
    //
    access(all) resource Admin: NFTMinter {
        // Borrow a Series
        //
        access(self) view fun borrowSeries(id: UInt64): &AllDay.Series {
            pre {
                AllDay.seriesByID[id] != nil: "Cannot borrow series, no such id"
            }

            return (&AllDay.seriesByID[id] as &AllDay.Series?)!
        }

        // Borrow a Set
        //
        access(self) view fun borrowSet(id: UInt64): &AllDay.Set {
            pre {
                AllDay.setByID[id] != nil: "Cannot borrow Set, no such id"
            }

            return (&AllDay.setByID[id] as &AllDay.Set?)!
        }

        // Borrow a Play
        //
        access(self) view fun borrowPlay(id: UInt64): &AllDay.Play {
            pre {
                AllDay.playByID[id] != nil: "Cannot borrow Play, no such id"
            }

            return (&AllDay.playByID[id] as &AllDay.Play?)!
        }

        // Borrow an Edition
        //
        access(self) fun borrowEdition(id: UInt64): &AllDay.Edition {
            pre {
                AllDay.editionByID[id] != nil: "Cannot borrow edition, no such id"
            }

            return (&AllDay.editionByID[id] as &AllDay.Edition?)!
        }

        // Create a Series
        //
        access(Operate) fun createSeries(name: String): UInt64 {
            // Create and store the new series
            let series <- create AllDay.Series(
                name: name,
            )
            let seriesID = series.id
            AllDay.seriesByID[series.id] <-! series

            // Return the new ID for convenience
            return seriesID
        }

        // Close a Series
        //
        access(Operate) fun closeSeries(id: UInt64): UInt64 {
            if let series = &AllDay.seriesByID[id] as &AllDay.Series? {
                series.close()
                return series.id
            }
            panic("series does not exist")
        }

        // Create a Set
        //
        access(Operate) fun createSet(name: String): UInt64 {
            // Create and store the new set
            let set <- create AllDay.Set(
                name: name,
            )
            let setID = set.id
            AllDay.setByID[set.id] <-! set

            // Return the new ID for convenience
            return setID
        }

        // Create a Play
        //
        access(Operate) fun createPlay(classification: String, metadata: {String: String}): UInt64 {
            // Create and store the new play
            let play <- create AllDay.Play(
                classification: classification,
                metadata: metadata,
            )
            let playID = play.id
            AllDay.playByID[play.id] <-! play

            // Return the new ID for convenience
            return playID
        }

        // Update a play's description metadata
        //
        access(Operate) fun updatePlayDescription(playID: UInt64, description: String): Bool {
            if let play = &AllDay.playByID[playID] as &AllDay.Play? {
                play.updateDescription(description: description)
            } else {
                panic("play does not exist")
            }
            return true
        }

        // Update a dynamic moment/play's metadata
        //
        access(Operate) fun updateDynamicMetadata(playID: UInt64, optTeamName: String?, optPlayerFirstName: String?,
            optPlayerLastName: String?, optPlayerNumber: String?, optPlayerPosition: String?): Bool {
            if let play = &AllDay.playByID[playID] as &AllDay.Play? {
                play.updateDynamicMetadata(optTeamName: optTeamName, optPlayerFirstName: optPlayerFirstName,
                    optPlayerLastName: optPlayerLastName, optPlayerNumber: optPlayerNumber, optPlayerPosition: optPlayerPosition)
            } else {
                panic("play does not exist")
            }
            return true
        }

        // Create an Edition
        //
         access(Operate) fun createEdition(
            seriesID: UInt64,
            setID: UInt64,
            playID: UInt64,
            maxMintSize: UInt64?,
            tier: String): UInt64 {
            let edition <- create Edition(
                seriesID: seriesID,
                setID: setID,
                playID: playID,
                maxMintSize: maxMintSize,
                tier: tier,
            )
            let editionID = edition.id
            AllDay.editionByID[edition.id] <-! edition

            return editionID
        }

        // Close an Edition
        //
        access(Operate) fun closeEdition(id: UInt64): UInt64 {
            if let edition = &AllDay.editionByID[id] as &AllDay.Edition? {
                edition.close()
                return edition.id
            }
            panic("edition does not exist")
        }

        // Mint a single NFT
        // The Edition for the given ID must already exist
        //
        access(Mint) fun mintNFT(editionID: UInt64, serialNumber: UInt64?): @AllDay.NFT {
            pre {
                // Make sure the edition we are creating this NFT in exists
                AllDay.editionByID.containsKey(editionID): "No such EditionID"
            }
            return <- self.borrowEdition(id: editionID).mint(serialNumber: serialNumber)
        }
    }

        /// Return the metadata view types available for this contract
        ///
        access(all) view fun getContractViews(resourceType: Type?): [Type] {
            return [Type<MetadataViews.NFTCollectionData>(), Type<MetadataViews.NFTCollectionDisplay>(), Type<MetadataViews.Royalties>()]
        }

        /// Resolve this contract's metadata views
        ///
        access(all) view fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {
            post {
                result == nil || result!.getType() == viewType: "The returned view must be of the given type or nil"
            }
            switch viewType {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: /storage/AllDayNFTCollection,
                        publicPath: /public/AllDayNFTCollection,
                        publicCollection: Type<&AllDay.Collection>(),
                        publicLinkedType: Type<&AllDay.Collection>(),
                        createEmptyCollectionFunction: (fun (): @{NonFungibleToken.Collection} {
                            return <-AllDay.createEmptyCollection(nftType: Type<@AllDay.NFT>())
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.nflallday.com/flow/catalogue/NFLAD_BANNER.png"
                        ),
                        mediaType: "image/png"
                    )
                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.nflallday.com/flow/catalogue/NFLAD_SQUARE.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "NFL All Day",
                        description: "Officially Licensed Digital Collectibles Featuring the NFL’s Best Highlights. Buy, Sell and Collect Your Favorite NFL Moments",
                        externalURL: MetadataViews.ExternalURL("https://nflallday.com/"),
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: {
                            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nflallday/"),
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/NFLAllDay"),
                            "discord": MetadataViews.ExternalURL("https://discord.com/invite/5K6qyTzj2k")
                        }
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount(0xALLDAYROYALTYADDRESS).capabilities.get<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())!
                    return MetadataViews.Royalties(
                        [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: 0.05,
                                description: "NFL All Day marketplace royalty"
                            )
                        ]
                    )
            }
            return nil
        }

    //------------------------------------------------------------
    // Contract lifecycle
    //------------------------------------------------------------

    // AllDay contract initializer
    //
    init() {
        // Set the named paths
        self.CollectionStoragePath = /storage/AllDayNFTCollection
        self.CollectionPublicPath = /public/AllDayNFTCollection
        self.AdminStoragePath = /storage/AllDayAdmin
        // Initialize the entity counts
        self.totalSupply = 0
        self.nextSeriesID = 1
        self.nextSetID = 1
        self.nextPlayID = 1
        self.nextEditionID = 1

        // Initialize the metadata lookup dictionaries
        self.seriesByID <- {}
        self.seriesIDByName = {}
        self.setIDByName = {}
        self.setByID <- {}
        self.playByID <- {}
        self.editionByID <- {}

        // Create an Admin resource and save it to storage
        let admin <- create Admin()
        self.account.storage.save(<-admin, to: self.AdminStoragePath)

        //Initialize map to keep track of set+play+tier(edition) combinations that have been minted
        let setPlayTierMap: {String: Bool} = {}
        self.account.storage.save(setPlayTierMap, to: AllDay.getSetPlayTierMapStorage())

        // Let the world know we are here
        emit ContractInitialized()
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/dapperlabs/nfl-smart-contracts/blob/main/scripts/nfts/read_collection_nft_ids.cdc

```
import NonFungibleToken from "NonFungibleToken"
import AllDay from "AllDay"

// This script returns an array of all the NFT IDs in an account's collection.

access(all) fun main(address: Address): [UInt64] {
    let account = getAccount(address)

    let collectionRef = getAccount(address).capabilities.borrow<&AllDay.Collection>(AllDay.CollectionPublicPath)
        ?? panic("Could not borrow capability from public collection")
    
    return collectionRef.getIDs()
}


```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_from_evm.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken
import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftContractAddress: The Flow account address hosting the NFT-defining Cadence contract
/// @param nftContractName: The name of the NFT-defining Cadence contract
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftContractAddress: Address, nftContractName: String, id: UInt256) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        // Get the ERC721 contract address for the given NFT type
        self.nftType = FlowEVMBridgeUtils.buildCompositeType(
                address: nftContractAddress,
                contractName: nftContractName,
                resourceName: "NFT"
            ) ?? panic("Could not construct NFT type")

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow collection from storage path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Deposit the bridged NFT into the signer's collection
        self.collection.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_to_evm_address_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// Bridges an NFT from the signer's collection in Cadence to the named recipient in EVM.
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
/// @param recipient: The hex-encoded EVM address to receive the NFT
///
transaction(nftIdentifier: String, id: UInt64, recipient: String) {
    let nft: @{NonFungibleToken.NFT}
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        let currentStorageUsage = signer.storage.used
        self.nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + FlowEVMBridgeConfig.baseFee
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.nft.getType().identifier == nftIdentifier:
            "Attempting to send invalid nft type - requested: ".concat(nftIdentifier)
            .concat(", sending: ").concat(self.nft.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge transaction
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeNFTToEVM(
            token: <-self.nft,
            to: EVM.addressFromString(recipient),
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_onboard_by_evm_address.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the NFT type to the bridge, configuring the bridge to move NFTs between environments
/// NOTE: This must be done before bridging a Cadence-native NFT to EVM
///
/// @param addressesAsHex: Array of EVM contract addresses (as hex string without 0x prefix) defining the 
///     bridgeable asset to be onboarded
///
transaction(addressesAsHex: [String]) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        // Set a withdrawal limit for the provider
        let providerLimit = FlowEVMBridgeConfig.onboardFee * UFix64(addressesAsHex.length)
        let providerFilter = ScopedFTProviders.AllowanceFilter(providerLimit)
        // Create ScopedFTProvider to expire just after this transaction
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Iterate over provided array
        for addressHex in addressesAsHex {
            // Convert hex string to EVMAddress
            let address = EVMUtils.getEVMAddressFromHexString(address: addressHex)
            // Continue if the hex is not a valid EVM address or if the address is already onboarded
            if address == nil || FlowEVMBridge.evmAddressRequiresOnboarding(address!) != true {
                continue
            }

            FlowEVMBridge.onboardByEVMAddress(
                address!,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_from_evm_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftIdentifier: String, id: UInt256) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow collection from storage path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged nft is the correct type
        assert(
            nft.getType() == self.nftType,
            message: "Bridged nft type mismatch - requeswted: ".concat(self.nftType.identifier)
                .concat(", received: ").concat(nft.getType().identifier)
        )
        // Deposit the bridged NFT into the signer's collection
        self.collection.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_balance.cdc

```
import EVM from 0xEVM

access(all)
fun main(hexEncodedAddress: String): UInt {
    let addressBytes = hexEncodedAddress.decodeHex().toConstantSized<[UInt8; 20]>()!
    let address = EVM.EVMAddress(bytes: addressBytes)

    return address.balance().inAttoFLOW()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/README.md

# outblock/frw-transactions

## Execute transction with script path

```javascript
// with fcl config

import * as fcl from '@onflow/fcl'
import * as t from '@onflow/types'
import { send as httpSend } from '@onflow/transport-http'

import { executeTransaction } from '@outblock/frw-transactions'

const fclInit = () => {
  return fcl
    .config()
    .put('sdk.transport', httpSend)
    .put('accessNode.api', 'https://rest-mainnet.onflow.org')
    .put('0xNonFungibleToken', '0x1d7e57aa55817448')
    .put('0xMetadataViews', '0x1d7e57aa55817448')
    .put('0xFungibleToken', '0xf233dcee88fe0abe')
    .put('0xFlowToken', '0x1654653399040a61')
}

// ....

// script path is folder/scriptName.cdc with CamelCase
const res = await executeTransaction(
  'basic/temp',
  [], // args
  { authz: fcl.authz }, // authz
  {
    // address mapping
    '0xFlowIDTableStaking': '0x8624b52f9ddcd04a',
  },
)
console.log(res) // txId

```

## Export scripts

```javascript
import { exportScripts } from '@outblock/frw-transactions'

// export all transactions mapping
const scripts = await exportScripts()
// or with address mapping
const scripts = await exportScripts({
  '0xFlowIDTableStaking': '0x8624b52f9ddcd04a', // FlowIDTableStaking address replace
  // ....
})

// return {folder: {scriptName: scriptContent}}

// export single script
const script = await exportScript('bridges/onboardByTypeIdentifier', {
  '0xFlowEVMBridge': '0x1e4aa0b87d10b141', // FlowIDTableStaking address replace
})

// return scriptContent
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_nft_to_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter



transaction(nftIdentifier: String, id: UInt64, child: Address) {
    
    let nft: @{NonFungibleToken.NFT}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
         // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")


        let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let collectionRef = providerCap.borrow()!
        let childNft <- collectionRef.withdraw(withdrawID: id)
        collection.deposit(token: <-childNft)
        // // Withdraw tokens from the signer's stored vault
        let currentStorageUsage = signer.storage.used
        self.nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            )
       
        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        self.coa.depositNFT(
            nft: <-self.nft,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/is_keys_has_full_auth.cdc

```

access(all) fun main(address: Address, publicKeys: [String]): Bool {
  let account = getAccount(address)
  var weight: UFix64 = 0.0
  fun accountFn(accountKey: AccountKey): Bool {
    let key = String.encodeHex(accountKey.publicKey.publicKey)
    if publicKeys.contains(key) && !accountKey.isRevoked {
      weight = weight + accountKey.weight 
    }
    return false
  }
  account.keys.forEach(accountFn)

  return weight >= UFix64(1000)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/transfer_child_ft.cdc

```
import HybridCustody from 0xHybridCustody

// HC-owned imports
import CapabilityFactory from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody

import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>



transaction(address: Address, path: String, amount: UFix64 ) {

  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: address) ?? panic("child account not found")
    
    let vaultData = <Token>.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
        ?? panic("Could not get the vault data view for <Token> ")

    //get Ft cap from child account
    let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: vaultData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    
    // Get a reference to the child's stored vault
    let vaultRef = providerCap.borrow()!

    // Withdraw tokens from the signer's stored vault
    let paymentVault <- vaultRef.withdraw(amount: amount)
    let receiverRef =  signer.capabilities.get<&{FungibleToken.Receiver}>(vaultData.receiverPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")
    receiverRef.deposit(from: <-paymentVault)
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/bridges/get_associated_evm_address.cdc

```
import EVM from 0xEVM

import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// Returns the EVM address associated with the given Cadence type (as its identifier String)
///
/// @param typeIdentifier The Cadence type identifier String
///
/// @return The EVM address as a hex string if the type has an associated EVMAddress, otherwise nil
///
access(all)
fun main(identifier: String): String? {
    if let type = CompositeType(identifier) {
        if let address = FlowEVMBridgeConfig.getEVMAddressAssociated(with: type) {
            return EVMUtils.getEVMAddressAsHexString(address: address)
        }
    }
    return nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_tokens_from_evm_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction bridges fungible tokens from EVM to Cadence assuming it has already been onboarded to the
/// FlowEVMBridge.
///
/// NOTE: The ERC20 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM
///
transaction(vaultIdentifier: String, amount: UInt256) {
    let vaultType: Type
    let receiver: &{FungibleToken.Vault}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        self.vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: self.vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Reference the signer's Vault --- */
        //
        // Borrow a reference to the FungibleToken Vault, configuring if necessary
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: self.vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        // If the vault does not exist, create it and publish according to the contract's defined configuration
        if signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath) == nil {
            signer.storage.save(<-vaultData.createEmptyVault(), to: vaultData.storagePath)

            signer.capabilities.unpublish(vaultData.receiverPath)
            signer.capabilities.unpublish(vaultData.metadataPath)

            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)
            let metadataCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)

            signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
            signer.capabilities.publish(metadataCap, at: vaultData.metadataPath)
        }
        self.receiver = signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath)
            ?? panic("Could not borrow Vault from storage path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge request
        let vault: @{FungibleToken.Vault} <- self.coa.withdrawTokens(
            type: self.vaultType,
            amount: amount,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged vault is the correct type
        assert(vault.getType() == self.vaultType, message: "Bridged vault type mismatch")
        // Deposit the bridged token into the signer's vault
        self.receiver.deposit(from: <-vault)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_bridge_nft_to_evm_address.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


/// Bridges an NFT from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftIdentifier: String, ids: [UInt64], recipient: String) {
    let nft: @{NonFungibleToken.NFT}
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let collection: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        self.collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        let currentStorageUsage = signer.storage.used
        self.nft <- self.collection.withdraw(withdrawID: ids[0])
        let withdrawnStorageUsage = signer.storage.used
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))

        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.nft.getType().identifier == nftIdentifier:
            "Attempting to send invalid nft type - requested: ".concat(nftIdentifier)
            .concat(", sending: ").concat(self.nft.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge transaction
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeNFTToEVM(
            token: <-self.nft,
            to: recipientEVMAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        var idx = 0

        for id in ids {
            if idx == 0 {
                idx = idx + 1
                continue
            }

            FlowEVMBridge.bridgeNFTToEVM(
                token: <- self.collection.withdraw(withdrawID: id),
                to: recipientEVMAddress,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
       
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_from_evm_to_flow.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken
import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftContractAddress: The Flow account address hosting the NFT-defining Cadence contract
/// @param nftContractName: The name of the NFT-defining Cadence contract
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftContractAddress: Address, nftContractName: String, id: UInt256, receiver: Address) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        // Get the ERC721 contract address for the given NFT type
        self.nftType = FlowEVMBridgeUtils.buildCompositeType(
                address: nftContractAddress,
                contractName: nftContractName,
                resourceName: "NFT"
            ) ?? panic("Could not construct NFT type")

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }

        let receiverAcct = getAccount(receiver)
        self.collection = receiverAcct.capabilities.borrow<&{NonFungibleToken.Collection}>(collectionData.publicPath)
            ?? panic("Could not borrow collection capabilities from public path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Deposit the bridged NFT into the signer's collection
        self.collection.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/ft/transfer_tokens.cdc

```
import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>


transaction(amount: UFix64, recipient: Address) {

    // The Vault resource that holds the tokens that are being transfered
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(Storage, BorrowValue) &Account) {
         // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &<Token>.Vault>(from: <TokenStoragePath>)
            ?? panic("Could not borrow reference to the owner's Vault!")

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {
        // Get the recipient's public account object
        let recipientAccount = getAccount(recipient)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipientAccount.capabilities.borrow<&{FungibleToken.Vault}>(<TokenReceiverPath>)!
            
        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_tokens_from_evm_to_flow_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


/// This transaction bridges fungible tokens from EVM to Cadence assuming it has already been onboarded to the
/// FlowEVMBridge. The full amount to be transferred is sourced from EVM, so it's assumed the signer has sufficient
/// balance of the ERC20 to bridging into Cadence. Also know that the recipient Flow account must have a Receiver
/// capable of receiving the bridged tokens accessible via published Capability at the token's standard path.
///
/// NOTE: The ERC20 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM and transfer to the recipient
/// @param recipient: The Flow account address to receive the bridged tokens
///
transaction(vaultIdentifier: String, amount: UInt256, recipient: Address) {

    let vaultType: Type
    let receiver: &{FungibleToken.Receiver}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount

    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        self.vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: self.vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Reference the signer's Vault --- */
        //
        // Borrow a reference to the FungibleToken Vault, configuring if necessary
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: self.vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        // If the vault does not exist, create it and publish according to the contract's defined configuration
        if signer.storage.borrow<&{FungibleToken.Vault}>(from: vaultData.storagePath) == nil {
            signer.storage.save(<-vaultData.createEmptyVault(), to: vaultData.storagePath)

            signer.capabilities.unpublish(vaultData.receiverPath)
            signer.capabilities.unpublish(vaultData.metadataPath)

            let receiverCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)
            let metadataCap = signer.capabilities.storage.issue<&{FungibleToken.Vault}>(vaultData.storagePath)

            signer.capabilities.publish(receiverCap, at: vaultData.receiverPath)
            signer.capabilities.publish(metadataCap, at: vaultData.metadataPath)
        }
        self.receiver = getAccount(recipient).capabilities.borrow<&{FungibleToken.Receiver}>(vaultData.receiverPath)
            ?? panic("Could not borrow Vault from recipient's account")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge request
        let vault: @{FungibleToken.Vault} <- self.coa.withdrawTokens(
            type: self.vaultType,
            amount: amount,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged vault is the correct type
        assert(vault.getType() == self.vaultType, message: "Bridged vault type mismatch")
        // Deposit the bridged token into the signer's vault
        self.receiver.deposit(from: <-vault)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_send_child_nft.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews

import <NFT> from <NFTAddress>


transaction(childAddr: Address, receiver: Address, identifier: String, ids: [UInt64]) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    
    // Get a reference to the child's stored vault
    let collectionRef = providerCap.borrow()!

   
    let receiverAcc = getAccount(receiver)
    let receiverRef =  receiverAcc.capabilities.get<&{NonFungibleToken.Receiver}>(collectionData.publicPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")
    
    for id in ids {
        // Withdraw tokens from the signer's stored vault
        let nft <- collectionRef.withdraw(withdrawID: id)
        receiverRef.deposit(token: <- nft)
    }
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_staking_info.cdc

```
import LockedTokens from 0xLockedTokens
import FlowIDTableStaking from 0xFlowIDTableStaking
import FlowEpoch from 0xFlowEpoch

access(all)struct EpochInfo {
  access(all)let currentEpochCounter: UInt64
  access(all)let currentEpochPhase: UInt8

  init(
      currentEpochCounter: UInt64,
      currentEpochPhase: UInt8
  ) {
      self.currentEpochCounter = currentEpochCounter
      self.currentEpochPhase = currentEpochPhase
  }
}

access(all)struct Result {
  access(all)let stakingInfo: StakingInfo?

  init(stakingInfo: StakingInfo?) {
    self.stakingInfo = stakingInfo
  }
}

access(all)struct StakingInfo {
  access(all)let epochInfo: EpochInfo
  access(all)let lockedAddress: Address   
  access(all)let lockedBalance: UFix64
  access(all)let unlockLimit: UFix64
  access(all)let nodeInfo: NodeInfo?
  access(all)let delegatorNodeInfo: NodeInfo?
  access(all)let delegatorInfo: DelegatorInfo?

  init(
    epochInfo: EpochInfo,
    lockedAddress: Address,
    lockedBalance: UFix64,
    unlockLimit: UFix64,
    nodeInfo: NodeInfo?,
    delegatorNodeInfo: NodeInfo?,
    delegatorInfo: DelegatorInfo?,
  ) {
    self.epochInfo = epochInfo
    self.lockedAddress = lockedAddress
    self.lockedBalance = lockedBalance
    self.unlockLimit = unlockLimit
    self.nodeInfo = nodeInfo
    self.delegatorNodeInfo = delegatorNodeInfo
    self.delegatorInfo = delegatorInfo
  }
}

access(all)struct NodeInfo {
  access(all)let id: String
  access(all)let networkingAddress: String
  access(all)let role: UInt8
  access(all)let tokensStaked: UFix64
  access(all)let tokensCommitted: UFix64
  access(all)let tokensUnstaking: UFix64
  access(all)let tokensUnstaked: UFix64
  access(all)let tokensRewarded: UFix64
  
  access(all)let delegatorIDCounter: UInt32
  access(all)let tokensRequestedToUnstake: UFix64
  access(all)let initialWeight: UInt64

  init(nodeID: String) {
    let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: nodeID) 

    self.id = nodeInfo.id
    self.networkingAddress = nodeInfo.networkingAddress
    self.role = nodeInfo.role
    self.tokensStaked = nodeInfo.tokensStaked
    self.tokensCommitted = nodeInfo.tokensCommitted
    self.tokensUnstaking = nodeInfo.tokensUnstaking
    self.tokensUnstaked = nodeInfo.tokensUnstaked
    self.tokensRewarded = nodeInfo.tokensRewarded
    self.delegatorIDCounter = nodeInfo.delegatorIDCounter
    self.tokensRequestedToUnstake = nodeInfo.tokensRequestedToUnstake
    self.initialWeight = nodeInfo.initialWeight
  }
}

access(all)struct DelegatorInfo {
  access(all)let id: UInt32
  access(all)let nodeID: String
  access(all)let tokensCommitted: UFix64
  access(all)let tokensStaked: UFix64
  access(all)let tokensUnstaking: UFix64
  access(all)let tokensRewarded: UFix64
  access(all)let tokensUnstaked: UFix64
  access(all)let tokensRequestedToUnstake: UFix64

  init(nodeID: String, delegatorID: UInt32) {
    let delegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)

    self.id = delegatorInfo.id
    self.nodeID = delegatorInfo.nodeID
    self.tokensCommitted = delegatorInfo.tokensCommitted
    self.tokensStaked = delegatorInfo.tokensStaked
    self.tokensUnstaking = delegatorInfo.tokensUnstaking
    self.tokensRewarded = delegatorInfo.tokensRewarded
    self.tokensUnstaked = delegatorInfo.tokensUnstaked
    self.tokensRequestedToUnstake = delegatorInfo.tokensRequestedToUnstake
  }
}

access(all)fun main(address: Address): Result {
  let tokenHolderRef = 
      getAuthAccount(address)
          .borrow<&LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)

  var stakingInfo: StakingInfo? = nil
  if let tokenHolder = tokenHolderRef {
    let lockedAddress = tokenHolder.getLockedAccountAddress()       
    let lockedBalance = tokenHolder.getLockedAccountBalance()
    let unlockLimit = tokenHolder.getUnlockLimit()
    
    var nodeInfo: NodeInfo? = nil
    if let nodeID = tokenHolder.getNodeID() {
      nodeInfo = NodeInfo(nodeID: nodeID)
    }

    var delegatorNodeInfo: NodeInfo? = nil
    var delegatorInfo: DelegatorInfo? = nil
    if let delegatorNodeID = tokenHolder.getDelegatorNodeID() {
      if let delegatorID = tokenHolder.getDelegatorID() {
        delegatorNodeInfo = NodeInfo(nodeID: delegatorNodeID)
        delegatorInfo = DelegatorInfo(nodeID: delegatorNodeID, delegatorID: delegatorID)
      } 
    } 

    let epochInfo: EpochInfo = EpochInfo(
      currentEpochCounter: FlowEpoch.currentEpochCounter,
      currentEpochPhase: FlowEpoch.currentEpochPhase.rawValue
    )

    stakingInfo = StakingInfo(
      epochInfo: epochInfo,
      lockedAddress: lockedAddress,
      lockedBalance: lockedBalance,
      unlockLimit: unlockLimit,
      nodeInfo: nodeInfo,
      delegatorNodeInfo: delegatorNodeInfo,
      delegatorInfo: delegatorInfo 
    )
  }

  return Result(stakingInfo: stakingInfo)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_storage_info.cdc

```
 access(all) fun main(addr: Address): {String: UInt64} {
    let acct = getAccount(addr)
    let ret: {String: UInt64} = {}
    ret["capacity"] = acct.storage.capacity
    ret["used"] = acct.storage.used
    if acct.storage.capacity > 0 {
        ret["available"] = acct.storage.capacity -  acct.storage.used
    } else {
        ret["available"] = 0
    }
    
    return ret
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/transfer_child_nft.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>


transaction(address: Address, path: String,  id: UInt64 ) {

  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: address) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    
    // Get a reference to the child's stored vault
    let collectionRef = providerCap.borrow()!

    // Withdraw tokens from the signer's stored vault
    let nft <- collectionRef.withdraw(withdrawID: id)
    let receiverRef =  signer.capabilities.get<&{NonFungibleToken.Receiver}>(collectionData.publicPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")
    receiverRef.deposit(token: <- nft)
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/is_key_has_full_auth.cdc

```

access(all) fun main(address: Address, publicKey: String): Bool {
  let account = getAccount(address)
  var flag = false
  fun accountFn(accountKey: AccountKey): Bool {
    let key = String.encodeHex(accountKey.publicKey.publicKey)
    if publicKey == key {
      flag = accountKey.weight >= UFix64(1000) && !accountKey.isRevoked
    }
    return false
  }
  account.keys.forEach(accountFn)

  return flag
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/send_child_ft_with_parent.cdc

```
import FungibleToken from 0xFungibleToken

import <Token> from <TokenAddress>

import HybridCustody from 0xHybridCustody
import FungibleTokenMetadataViews from 0xFungibleToken

transaction(amount: UFix64, to: Address, child: Address) {

    // The Vault resource that holds the tokens that are being transferred
    let paymentVault: @{FungibleToken.Vault}
    let vaultData: FungibleTokenMetadataViews.FTVaultData

    prepare(signer: auth(Storage) &Account) {
        // signer is the parent account
        // get the manager resource and borrow childAccount
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
        self.vaultData = ExampleToken.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
            ?? panic("Could not get the vault data view for ExampleToken")

        //get Ft cap from child account
        let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: self.vaultData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let vaultRef = providerCap.borrow()!

        // Withdraw tokens from the signer's stored vault
        self.paymentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipient.capabilities.get<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)!.borrow()
			?? panic("Could not borrow receiver reference to the recipient's Vault")

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.paymentVault)
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/ft/enable_token_storage.cdc

```
import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>

transaction {

    prepare(signer: auth(Storage, Capabilities) &Account) {

        if signer.storage.borrow<&<Token>.Vault>(from: <TokenStoragePath> ) == nil {
            signer.storage.save(<- <Token>.createEmptyVault(vaultType: Type<@<Token>.Vault>()), to: <TokenStoragePath>)
        }

        if signer.capabilities.exists(<TokenReceiverPath>) == false {
            let receiverCapability = signer.capabilities.storage.issue<&<Token>.Vault>(<TokenStoragePath>)
            signer.capabilities.publish(receiverCapability, at: <TokenReceiverPath>)
        
        }
       
        if signer.capabilities.exists(<TokenBalancePath>) == false {
            let balanceCapability = signer.capabilities.storage.issue<&<Token>.Vault>(<TokenStoragePath>)
            signer.capabilities.publish(balanceCapability, at: <TokenBalancePath>)
        }
    
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/is_locked_flow_enable.cdc

```
import LockedTokens from 0xLockedTokens

access(all) fun main(address: Address): Bool {
    let account = getAccount(address)
    return account.capabilities.exists(LockedTokens.LockedAccountInfoPublicPath)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/deploy_contract.cdc

```
import EVM from 0x8c5303eaa26202d6


transaction(code: String) {
    let coa: auth(EVM.Deploy) &EVM.CadenceOwnedAccount

    prepare(signer: auth(Storage) &Account) {
        self.coa = signer.storage.borrow<auth(EVM.Deploy) &EVM.CadenceOwnedAccount>(
        from: /storage/evm) ?? panic("Could not borrow reference to the COA!")

    }

    execute {
      self.coa.deploy(code: code.decodeHex(),  gasLimit: 15000000, value: EVM.Balance(attoflow: 0))
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/check_coa_link.cdc

```
import EVM from 0xEVM

/// Returns whether a COA is stored and its public capability is published
///
/// @param flowAddress: The Flow address to check for a COA
///
/// @return Bool: Whether a COA is stored and its public capability is published, nil if no COA is stored
///
access(all) fun main(flowAddress: Address): Bool? {
    // Borrow the COA to check if one is stored
    if let address: EVM.EVMAddress = getAuthAccount<auth(BorrowValue) &Account>(flowAddress)
        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)?.address() {
        // COA found - check if the public capability is published
        return getAccount(flowAddress).capabilities.borrow<&EVM.CadenceOwnedAccount>(/public/evm) != nil
    }
    // No COA found - return nil
    return nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/check_child_recieve_vaults.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import FungibleToken from 0xFungibleToken

access(all) fun main(parent: Address, child: Address, path: String): Bool {
  let account = getAuthAccount<auth(Storage) &Account>(parent)
  let manager = getAuthAccount<auth(Storage) &Account>(parent).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")
  
  let receiverType = Type<&{FungibleToken.Receiver}>()

  let addr = getAuthAccount<auth(Storage, Capabilities) &Account>(child)
  
  let childAcct = manager.borrowAccount(addr: child) ?? panic("child account not found")

  let controllers = addr.capabilities.storage.getControllers(forPath: StoragePath(identifier: path)!)
  var flag = false

  for c in controllers {
    if !c.borrowType.isSubtype(of: receiverType) {
      continue
    }

    if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: receiverType) {
      let providerCap = cap as! Capability<&{FungibleToken.Receiver}> 

      if !providerCap.check(){
        continue
      }

      flag = true
      break
    }
  }

  return flag
} 
    
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/create_coa.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM


/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM
transaction(amount: UFix64) {
    let sentVault: @FlowToken.Vault
    let auth: auth(IssueStorageCapabilityController, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")

        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault
        self.auth = signer
    }

    execute {
        let coa <- EVM.createCadenceOwnedAccount()
        coa.deposit(from: <-self.sentVault)

        log(coa.balance().inFLOW())
        let storagePath = StoragePath(identifier: "evm")!
        let publicPath = PublicPath(identifier: "evm")!
        self.auth.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)
        let addressableCap = self.auth.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)
        self.auth.capabilities.unpublish(publicPath)
        self.auth.capabilities.publish(addressableCap, at: publicPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/transfer_coa.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

transaction(amount: UFix64, address: Address) {
    let sentVault: @FlowToken.Vault

    prepare(signer: auth(Storage, EVM.Withdraw) &Account) {
        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(
            from: /storage/evm
        ) ?? panic("Could not borrow reference to the COA!")

        self.sentVault <- coa.withdraw(balance: EVM.Balance(attoflow: UInt(amount) * 100000000000000000)) as! @FlowToken.Vault
    }

    execute {
        let account = getAccount(address)
        let receiver = account.capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)!
        receiver.deposit(from: <-self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_send_child_nft_to_child.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>


transaction(childAddr: Address, receiver: Address, identifier: String, ids: [UInt64]) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    let collectionRef = providerCap.borrow()!


    let receiverChildAcct = m.borrowAccount(addr: receiver) ?? panic("child account not found")
    let receiverControllerId = receiverChildAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    let receiverCap = receiverChildAcct.getCapability(controllerID: receiverControllerId, type: capType) ?? panic("no cap found") 
    let publicCap = receiverCap as! Capability<&{NonFungibleToken.CollectionPublic}>
    let receiverRef =  publicCap.borrow()!

    for id in ids {
      let nft <- collectionRef.withdraw(withdrawID: id)
      receiverRef.deposit(token: <- nft)
    }
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_evm_address_requires_onboarding.cdc

```
import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge

/// Returns whether a EVM contract needs to be onboarded to the FlowEVMBridge
///
/// @param evmAddresses: Array of hex-encoded address of the EVM contract as a String without 0x prefix to check for
///     onboarding status
///
/// @return Whether the contract requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///     indexed on the hex-encoded address of the EVM contract without 0x prefix
///
access(all) fun main(evmAddresses: [String]): {String: Bool?} {
    let results: {String: Bool?} = {}
    for addressHex in evmAddresses {
        if results[addressHex] != nil {
            continue
        }
        if let address = EVMUtils.getEVMAddressFromHexString(address: addressHex) {
            let requiresOnboarding = FlowEVMBridge.evmAddressRequiresOnboarding(address)
            results.insert(key: addressHex, requiresOnboarding)
        }
    }
    return results
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_bridge_nft_from_evm_v2.cdc

```

import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
///
transaction(nftIdentifier: String, ids: [UInt256]) {

    let nftType: Type
    let collection: &{NonFungibleToken.Collection}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the signer's NFT Collection --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.collection = signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath)
            ?? panic("Could not borrow collection from storage path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
            provider: providerCapCopy,
            filters: [ providerFilter ],
            expiration: getCurrentBlock().timestamp + 1.0
        )
    }

    execute {
        // Execute the bridge
        var idx = 0
        while idx < ids.length {
            let nftId = ids[idx]!
                // Execute the bridge
            let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
                type: self.nftType,
                id: nftId,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            // Ensure the bridged nft is the correct type
            assert(
                nft.getType() == self.nftType,
                message: "Bridged nft type mismatch - requeswted: ".concat(self.nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )
            // Deposit the bridged NFT into the signer's collection
            self.collection.deposit(token: <-nft)
            idx = idx + 1
        }
       
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_delegates_info_array.cdc

```

import FlowStakingCollection from 0xFlowStakingCollection
import FlowIDTableStaking from 0xFlowIDTableStaking
import LockedTokens from 0xLockedTokens
        
access(all) fun main(address: Address): [FlowIDTableStaking.DelegatorInfo] {
    return FlowStakingCollection.getAllDelegatorInfo(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/verify_user_signature.cdc

```
import Crypto

access(all) fun main(
    message: String,
    rawPublicKeys: [String],
    weights: [UFix64],
    signAlgos: [UInt8],
    hashAlgos: [UInt8],
    signatures: [String],
): Bool {

    let keyList = Crypto.KeyList()

    var i = 0
    for rawPublicKey in rawPublicKeys {
    keyList.add(
        PublicKey(
        publicKey: rawPublicKey.decodeHex(),
        signatureAlgorithm: SignatureAlgorithm(rawValue: signAlgos[i])!
        ),
        hashAlgorithm: HashAlgorithm(rawValue: hashAlgos[i])!,
        weight: weights[i],
    )
    i = i + 1
    }

    let signatureSet: [Crypto.KeyListSignature] = []

    var j = 0
    for signature in signatures {
    signatureSet.append(
        Crypto.KeyListSignature(
            keyIndex: j,
            signature: signature.decodeHex()
        )
    )
        j = j + 1
    }

    let signedData = message.decodeHex()

    return keyList.verify(
        signatureSet: signatureSet,
        signedData: signedData,
        domainSeparationTag: "FLOW-V0.0-user"
    )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/collection/enable_nft_storage.cdc

```
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>

transaction {

    prepare(signer: auth(Capabilities, SaveValue) &Account) {
        if signer.capabilities.borrow<&<NFT>.Collection>(<CollectionPublicPath>) == nil {
            let collection <- <NFT>.createEmptyCollection(nftType: Type<@<NFT>.NFT>())
            signer.storage.save(<-collection, to: <CollectionStoragePath>)
        }
        if (signer.capabilities.borrow<&<NFT>.Collection>(<CollectionPublicPath>) == nil) {
            signer.capabilities.unpublish(<CollectionPublicPath>)
            let cap = signer.capabilities.storage.issue<&<NFT>.Collection>(<CollectionStoragePath>)            
            signer.capabilities.publish(cap, at: <CollectionPublicPath>)

        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_accessible_child_account_nfts.cdc

```
import HybridCustody from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews


// This script iterates through a parent's child accounts, 
// identifies private paths with an accessible NonFungibleToken.Provider, and returns the corresponding typeIds
access(all) fun main(addr: Address): AnyStruct {
  let manager = getAuthAccount<auth(Storage) &Account>(addr).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")

  var typeIdsWithProvider = {} as {Address: [String]}

  // Address -> nft UUID -> Display
  var nftViews = {} as {Address: {String: [UInt64]}} 

  
  let providerType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
  let collectionType: Type = Type<@{NonFungibleToken.CollectionPublic}>()

  // Iterate through child accounts
  for address in manager.getChildAddresses() {
    let acct = getAuthAccount<auth(Storage, Capabilities) &Account>(address)
    let foundTypes: [String] = []
    let views: {String: [UInt64]} = {}
    let childAcct = manager.borrowAccount(addr: address) ?? panic("child account not found")
     
    // typeIdsWithProvider[address] = foundTypes

    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {

      let controllers = acct.capabilities.storage.getControllers(forPath: path!)
      for c in controllers {
        if !c.borrowType.isSubtype(of: providerType) {
          continue
        }

        if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: providerType) {
          let providerCap = cap as! Capability<&{NonFungibleToken.Provider}> 

          if !providerCap.check(){
            continue
          }
          foundTypes.append(cap.borrow<&AnyResource>()!.getType().identifier)
        }
      }
      return true
    })

    typeIdsWithProvider[address] = foundTypes
    

    // iterate storage, check if typeIdsWithProvider contains the typeId, if so, add to views
    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
      
      if typeIdsWithProvider[address] == nil {
        return true
      }

      for key in typeIdsWithProvider.keys {
        for idx, value in typeIdsWithProvider[key]! {
          let value = typeIdsWithProvider[key]!

          if value[idx] != type.identifier {
            continue
          } else {
            if type.isInstance(collectionType) {
              continue
            }
            if let collection = acct.storage.borrow<&{NonFungibleToken.CollectionPublic, ViewResolver.ResolverCollection}>(from: path) { 
              // Iterate over IDs & resolve the view
             
              for id in collection.getIDs() {
                let nft = collection.borrowNFT(id)!

                views[nft.getType().identifier] = collection.getIDs()
                break;
              }
            }
            continue
          }
        }
      }
      return true
    })
    nftViews[address] = views
  }
  return nftViews
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/check_setup.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

/// Determines if an account is set up with a Staking Collection

access(all) fun main(address: Address): Bool {
    return FlowStakingCollection.doesAccountHaveStakingCollection(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/check_staking_enabled.cdc

```
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) fun main():Bool {
    return FlowIDTableStaking.stakingEnabled()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/account_storage.cdc

```
 access(all) struct StorageInfo {
    access(all)  let capacity: UInt64
    access(all)  let used: UInt64
    access(all)  let available: UInt64

    init(capacity: UInt64, used: UInt64, available: UInt64) {
        self.capacity = capacity
        self.used = used
        self.available = available
    }
}

access(all) fun main(addr: Address): StorageInfo {
    let acct = getAccount(addr)
    var available: UInt64 = 0
    if acct.storage.capacity > 0 {
        available = acct.storage.capacity - acct.storage.used
    }
    return StorageInfo(capacity: acct.storage.capacity,
            used: acct.storage.used,
            available: available)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_transfer_nft_to_child.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>

transaction(childAddr: Address, identifier: String, ids: [UInt64]) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let childCap = cap as! Capability<&{NonFungibleToken.CollectionPublic}>
    assert(childCap.check(), message: "invalid provider capability")
    
    let parentRef =  signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from : collectionData.storagePath)!
    let childRef = childCap.borrow()!

    for id in ids {     
        // Withdraw tokens from the signer's stored vault
        let nft <- parentRef!.withdraw(withdrawID: id)!
        childRef.deposit(token: <- nft)
    }
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/create_account_sdk.cdc

```
import Crypto

transaction(publicKey: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64, contracts: {String: String}) {
    prepare(signer: auth(BorrowValue | Storage) &Account) {
        let account = Account(payer: signer)

        let key = PublicKey(
            publicKey: publicKey.decodeHex(),
            signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!
        )

        account.keys.add(
            publicKey: key,
            hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!,
            weight: weight
        )

        for contract in contracts.keys {
            account.contracts.add(name: contract, code: contracts[contract]!.decodeHex())
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_tokens_to_evm_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge
/// Bridges a Vault from the signer's storage to the signer's COA in EVM.Account.
///
/// NOTE: This transaction also onboards the Vault to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param vaultIdentifier: The Cadence type identifier of the FungibleToken Vault to bridge
///     - e.g. vault.getType().identifier
/// @param amount: The amount of tokens to bridge from EVM
///
transaction(vaultIdentifier: String, amount: UFix64) {
    let sentVault: @{FungibleToken.Vault}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: vaultType,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not access signer's FungibleToken Vault")

        // Withdraw the requested balance & calculate the approximate bridge fee based on storage usage
        let currentStorageUsage = signer.storage.used
        self.sentVault <- vault.withdraw(amount: amount)
        let withdrawnStorageUsage = signer.storage.used
        // Approximate the bridge fee based on the difference in storage usage with some buffer
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: currentStorageUsage - withdrawnStorageUsage
            ) * 1.10
        // Determine if the Vault requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.sentVault.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.sentVault.getType().identifier == vaultIdentifier:
            "Attempting to send invalid vault type - requested: ".concat(vaultIdentifier)
            .concat(", sending: ").concat(self.sentVault.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the Vault to the bridge
            FlowEVMBridge.onboardByType(
                self.sentVault.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge
        self.coa.depositTokens(
            vault: <-self.sentVault,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/transfer_flow_to_evm_address.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

/// Transfers $FLOW from the signer's account Cadence Flow balance to the recipient's hex-encoded EVM address.
/// Note that a COA must have a $FLOW balance in EVM before transferring value to another EVM address.
///
transaction(recipientEVMAddressHex: String, amount: UFix64, gasLimit: UInt64) {

    let coa: auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount
    let recipientEVMAddress: EVM.EVMAddress
    var sentVault: @FlowToken.Vault

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        if signer.storage.type(at: /storage/evm) == nil {
            signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: /storage/evm)
        }
        self.coa = signer.storage.borrow<auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow reference to the signer's bridged account")

        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")
        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault

        self.recipientEVMAddress = EVM.addressFromString(recipientEVMAddressHex)
    }

    execute {
        self.coa.deposit(from: <-self.sentVault)
        
        let valueBalance = EVM.Balance(attoflow: 0)
        valueBalance.setFLOW(flow: amount)
        let txResult = self.coa.call(
            to: self.recipientEVMAddress,
            data: [],
            gasLimit: gasLimit,
            value: valueBalance
        )
        assert(
            txResult.status == EVM.Status.failed || txResult.status == EVM.Status.successful,
            message: "evm_error=".concat(txResult.errorMessage).concat("\n")
        )

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/create_coa_empty.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM


/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM
transaction() {
    let auth: auth(IssueStorageCapabilityController, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account

    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
                from: /storage/flowTokenVault
            ) ?? panic("Could not borrow reference to the owner's Vault!")
        self.auth = signer
    }

    execute {
        let coa <- EVM.createCadenceOwnedAccount()
        let storagePath = StoragePath(identifier: "evm")!
        let publicPath = PublicPath(identifier: "evm")!
        self.auth.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)
        let addressableCap = self.auth.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)
        self.auth.capabilities.unpublish(publicPath)
        self.auth.capabilities.publish(addressableCap, at: publicPath)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/onboard_by_type.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param type: The Cadence type of the bridgeable asset to onboard to the bridge
///
transaction(type: Type) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the asset Type
        FlowEVMBridge.onboardByType(
            type,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_tokens_to_evm_address_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


transaction(vaultIdentifier: String, amount: UFix64, recipient: String) {
    let sentVault: @{FungibleToken.Vault}
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct the Vault type --- */
        //
        // Construct the Vault type from the provided identifier
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))
        
        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not access signer's FungibleToken Vault")

        // Withdraw the requested balance & calculate the approximate bridge fee based on storage usage
        let currentStorageUsage = signer.storage.used
        self.sentVault <- vault.withdraw(amount: amount)
        let withdrawnStorageUsage = signer.storage.used
        // Approximate the bridge fee based on the difference in storage usage with some buffer
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: currentStorageUsage - withdrawnStorageUsage
            ) * 1.10
        // Determine if the Vault requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.sentVault.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.sentVault.getType().identifier == vaultIdentifier:
            "Attempting to send invalid vault type - requested: ".concat(vaultIdentifier)
            .concat(", sending: ").concat(self.sentVault.getType().identifier)
        self.sentVault.balance == amount: "Amount to be transferred does not match the requested amount"
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the Vault to the bridge
            FlowEVMBridge.onboardByType(
                self.sentVault.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge transaction
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeTokensToEVM(
            vault: <-self.sentVault,
            to: recipientEVMAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_code.cdc

```
import EVM from 0xEVM

access(all)
fun main(hexEncodedAddress: String): String {
    let addressBytes = hexEncodedAddress.decodeHex().toConstantSized<[UInt8; 20]>()!
    let address = EVM.EVMAddress(bytes: addressBytes)

    return String.encodeHex(address.code())
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_onboard_by_type.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param types: The Cadence types of the bridgeable asset to onboard to the bridge
///
transaction(types: [Type]) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        // Set a withdrawal limit for the provider
        let providerLimit = FlowEVMBridgeConfig.onboardFee * UFix64(types.length)
        let providerFilter = ScopedFTProviders.AllowanceFilter(providerLimit)
        // Create ScopedFTProvider to expire just after this transaction
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        for type in types { 
            // Continue on if the type does not require onboarding
            if FlowEVMBridge.typeRequiresOnboarding(type) != true {
                continue
            }
            // Onboard the asset Type
            FlowEVMBridge.onboardByType(
                type,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/create_stake.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

/// Commits new tokens to stake for the specified node or delegator in the staking collection
/// The tokens from the locked vault are used first, if it exists
/// followed by the tokens from the unlocked vault

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/collection/send_nft.cdc

```
import NonFungibleToken from 0xNonFungibleToken
import <NFT> from <NFTAddress>

// This transaction is for transferring and NFT from
// one account to another

transaction(recipientAddr: Address, withdrawID: UInt64) {

    prepare(signer: auth(Storage, BorrowValue) &Account) {
        // get the recipients public account object
        let recipient = getAccount(recipientAddr)

        // borrow a reference to the signer's NFT collection
        let collectionRef = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: <CollectionStoragePath>)
            ?? panic("Could not borrow a reference to the owner's collection")

        // borrow a public reference to the receivers collection
        let depositRef = recipient
            .capabilities
            .borrow<&{NonFungibleToken.Collection}>(<CollectionPublicPath>)
            ?? panic("Could not borrow a reference to the receiver's collection")

        // withdraw the NFT from the owner's collection
        let nft <- collectionRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        depositRef.deposit(token: <-nft)

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_delegator_info.cdc

```
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) fun main(nodeID: String, delegatorID: UInt32): FlowIDTableStaking.DelegatorInfo {
  return FlowIDTableStaking.DelegatorInfo(nodeID: nodeID, delegatorID: delegatorID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/bridges/get_bridge_coa_address.cdc

```
import EVM from 0xEVM

import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

access(all) fun main(): String {
    let address: EVM.EVMAddress = FlowEVMBridge.getBridgeCOAEVMAddress()
    return EVMUtils.getEVMAddressAsHexString(address: address)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/edit_child_account.cdc

```
import HybridCustody from 0xHybridCustody
import MetadataViews from 0xMetadataViews

transaction(childAddress: Address, name: String, description: String, thumbnail: String) {
    prepare(acct: AuthAccount) {
        let m = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager not found")
        
        let d = MetadataViews.Display(
            name: name,
            description: description,
            thumbnail: MetadataViews.HTTPFile(url: thumbnail)
        )

        m.setChildAccountDisplay(address: childAddress, d)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/send_child_ft.cdc

```
import HybridCustody from 0xHybridCustody

// HC-owned imports
import CapabilityFactory from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody

import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>


transaction(address: Address, receiver: Address, path: String, amount: UFix64 ) {

  // The Vault resource that holds the tokens that are being transferred
  let paymentVault: @{FungibleToken.Vault}
  let vaultData: FungibleTokenMetadataViews.FTVaultData

  prepare(signer: auth(Storage) &Account) {
      // signer is the parent account
      // get the manager resource and borrow childAccount
      let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
          ?? panic("manager does not exist")
      let childAcct = m.borrowAccount(addr: address) ?? panic("child account not found")
      
      self.vaultData = <Token>.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
          ?? panic("Could not get the vault data view for <Token> ")

      //get Ft cap from child account
      let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
      let controllerID = childAcct.getControllerIDForType(type: capType, forPath: self.vaultData.storagePath)
          ?? panic("no controller found for capType")
      
      let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
      let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
      assert(providerCap.check(), message: "invalid provider capability")
      
      // Get a reference to the child's stored vault
      let vaultRef = providerCap.borrow()!

      // Withdraw tokens from the signer's stored vault
      self.paymentVault <- vaultRef.withdraw(amount: amount)
  }

  execute {

      // Get the recipient's public account object
      let recipient = getAccount(receiver)

      // Get a reference to the recipient's Receiver
      let receiverRef = recipient.capabilities.get<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")

      // Deposit the withdrawn tokens in the recipient's receiver
      receiverRef.deposit(from: <-self.paymentVault)
  }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/ft/transfer_evm_tokens.cdc

```
import EVM from 0xEVM

/// Transfers $FLOW from the signer's account Cadence Flow balance to the recipient's hex-encoded EVM address.
/// Note that a COA must have a $FLOW balance in EVM before transferring value to another EVM address.
///
transaction(toEVMAddressHex: String, amount: UInt256, gasLimit: UInt64) {

    let coa: auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount
    let recipientEVMAddress: EVM.EVMAddress

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        if signer.storage.type(at: /storage/evm) == nil {
            signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: /storage/evm)
        }
        self.coa = signer.storage.borrow<auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow reference to the signer's bridged account")

        self.recipientEVMAddress = EVM.addressFromString(toEVMAddressHex)
    }

    execute {
        // if self.recipientEVMAddress.bytes == self.coa.address().bytes {
        //     return
        // }
        let data = ""
        let txResult = self.coa.call(
            to: self.recipientEVMAddress,
            data: data,
            gasLimit: gasLimit,
            value: valueBalance
        )
        assert(
            txResult.status == EVM.Status.failed || txResult.status == EVM.Status.successful,
            message: "evm_error=".concat(txResult.errorMessage).concat("\n")
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/withdraw_coa.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

transaction(amount: UFix64, address: Address) {
    let sentVault: @FlowToken.Vault

    prepare(signer: auth(Storage, EVM.Withdraw) &Account) {
        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(
            from: /storage/evm
        ) ?? panic("Could not borrow reference to the COA!")
        let withdrawBalance = EVM.Balance(attoflow: 0)
        withdrawBalance.setFLOW(flow: amount)
        self.sentVault <- coa.withdraw(balance: withdrawBalance) as! @FlowToken.Vault
    }

    execute {
        let account = getAccount(address)
        let receiver = account.capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)!
        receiver.deposit(from: <-self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_identifier_requires_onboarding.cdc

```
import FlowEVMBridge from 0xFlowEVMBridge

/// Returns whether a type needs to be onboarded to the FlowEVMBridge
///
/// @param Types: The array of types to check for onboarding status
///
/// @return Whether the type requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil indexed
///     on the type
///
access(all) fun main(identifiers: [String]): {String: Bool?} {
    let results: {String: Bool?} = {}

    for identifier in identifiers {
        if results[identifier] != nil {
            continue
        }
        let type: Type = CompositeType(identifier) ?? panic("Invalid type identifier")
        results.insert(key: identifier, FlowEVMBridge.typeRequiresOnboarding(type))
    }
    return results
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/README.md

# outblock/frw-scripts

## Query script with script path

```javascript
// with fcl config

import * as fcl from '@onflow/fcl'
import * as t from '@onflow/types'
import { send as httpSend } from '@onflow/transport-http'

import { queryScripts } from '@outblock/frw-scripts'

const fclInit = () => {
  return fcl
    .config()
    .put('sdk.transport', httpSend)
    .put('accessNode.api', 'https://rest-mainnet.onflow.org')
    .put('0xNonFungibleToken', '0x1d7e57aa55817448')
    .put('0xMetadataViews', '0x1d7e57aa55817448')
    .put('0xFungibleToken', '0xf233dcee88fe0abe')
    .put('0xFlowToken', '0x1654653399040a61')
}

// ....

// script path is folder/scriptName.cdc with CamelCase
const res = await queryScripts('staking/getApr', [], {})
console.log(res)
```

## Export scripts

```javascript
import { exportScripts } from '@outblock/frw-scripts'

// export all query scripts mapping
const scripts = await exportScripts()
// or with address mapping
const scripts = await exportScripts({
  '0xFlowIDTableStaking': '0x8624b52f9ddcd04a', // FlowIDTableStaking address replace
  // ....
})

// return {folder: {scriptName: scriptContent}}

// export single script
const script = await exportScript('bridges/calculateBridgeFee', {
  '0xFlowEVMBridge': '0x1e4aa0b87d10b141', // FlowIDTableStaking address replace
})

// return scriptContent
```





---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_epoch_metadata.cdc

```
import FlowEpoch from 0xFlowEpoch

access(all) fun main(epochCounter: UInt64): FlowEpoch.EpochMetadata {
    return FlowEpoch.getEpochMetadata(epochCounter)!
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_nodes_info.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) struct SummaryStakeDelegateInfo {

    access(all) var nodeCount: UInt64
    access(all) var delegateCount: UInt64

    access(all) var totalTokensStaked: UFix64
    access(all) var totalTokensCommitted: UFix64
    access(all) var totalTokensUnstaking: UFix64
    access(all) var totalTokensUnstaked: UFix64
    access(all) var totalTokensRewarded: UFix64
    access(all) var totalTokensRequestedToUnstake: UFix64

    access(all) var stakeTokensStaked: UFix64
    access(all) var stakeTokensCommitted: UFix64
    access(all) var stakeTokensUnstaking: UFix64
    access(all) var stakeTokensUnstaked: UFix64
    access(all) var stakeTokensRewarded: UFix64
    access(all) var stakeTokensRequestedToUnstake: UFix64

    access(all) var delegateTokensStaked: UFix64
    access(all) var delegateTokensCommitted: UFix64
    access(all) var delegateTokensUnstaking: UFix64
    access(all) var delegateTokensUnstaked: UFix64
    access(all) var delegateTokensRewarded: UFix64
    access(all) var delegateTokensRequestedToUnstake: UFix64

    init(allNodeInfo: [FlowIDTableStaking.NodeInfo], allDelegateInfo: [FlowIDTableStaking.DelegatorInfo]) {

        self.nodeCount = UInt64(0)
        self.delegateCount = UInt64(0)

        self.totalTokensStaked = UFix64(0)
        self.totalTokensCommitted = UFix64(0)
        self.totalTokensUnstaking = UFix64(0)
        self.totalTokensUnstaked = UFix64(0)
        self.totalTokensRewarded = UFix64(0)
        self.totalTokensRequestedToUnstake = UFix64(0)

        self.stakeTokensStaked = UFix64(0)
        self.stakeTokensCommitted = UFix64(0)
        self.stakeTokensUnstaking = UFix64(0)
        self.stakeTokensUnstaked = UFix64(0)
        self.stakeTokensRewarded = UFix64(0)
        self.stakeTokensRequestedToUnstake = UFix64(0)

        self.delegateTokensStaked = UFix64(0)
        self.delegateTokensCommitted = UFix64(0)
        self.delegateTokensUnstaking = UFix64(0)
        self.delegateTokensUnstaked = UFix64(0)
        self.delegateTokensRewarded = UFix64(0)
        self.delegateTokensRequestedToUnstake = UFix64(0)

        for nodeInfo in allNodeInfo {
            self.nodeCount = self.nodeCount + 1

            self.totalTokensStaked = self.totalTokensStaked + nodeInfo.tokensStaked
            self.totalTokensCommitted = self.totalTokensCommitted + nodeInfo.tokensCommitted
            self.totalTokensUnstaking = self.totalTokensUnstaking + nodeInfo.tokensUnstaking
            self.totalTokensUnstaked = self.totalTokensUnstaked + nodeInfo.tokensUnstaked
            self.totalTokensRewarded = self.totalTokensRewarded + nodeInfo.tokensRewarded
            self.totalTokensRequestedToUnstake = self.totalTokensRequestedToUnstake + nodeInfo.tokensRequestedToUnstake

            self.stakeTokensStaked = self.stakeTokensStaked + nodeInfo.tokensStaked
            self.stakeTokensCommitted = self.stakeTokensCommitted + nodeInfo.tokensCommitted
            self.stakeTokensUnstaking = self.stakeTokensUnstaking + nodeInfo.tokensUnstaking
            self.stakeTokensUnstaked = self.stakeTokensUnstaked + nodeInfo.tokensUnstaked
            self.stakeTokensRewarded = self.stakeTokensRewarded + nodeInfo.tokensRewarded
            self.stakeTokensRequestedToUnstake = self.stakeTokensRequestedToUnstake + nodeInfo.tokensRequestedToUnstake
        }

        for delegateInfo in allDelegateInfo {
            self.delegateCount = self.delegateCount + 1

            self.totalTokensStaked = self.totalTokensStaked + delegateInfo.tokensStaked
            self.totalTokensCommitted = self.totalTokensCommitted + delegateInfo.tokensCommitted
            self.totalTokensUnstaking = self.totalTokensUnstaking + delegateInfo.tokensUnstaking
            self.totalTokensUnstaked = self.totalTokensUnstaked + delegateInfo.tokensUnstaked
            self.totalTokensRewarded = self.totalTokensRewarded + delegateInfo.tokensRewarded
            self.totalTokensRequestedToUnstake = self.totalTokensRequestedToUnstake + delegateInfo.tokensRequestedToUnstake

            self.delegateTokensStaked = self.delegateTokensStaked + delegateInfo.tokensStaked
            self.delegateTokensCommitted = self.delegateTokensCommitted + delegateInfo.tokensCommitted
            self.delegateTokensUnstaking = self.delegateTokensUnstaking + delegateInfo.tokensUnstaking
            self.delegateTokensUnstaked = self.delegateTokensUnstaked + delegateInfo.tokensUnstaked
            self.delegateTokensRewarded = self.delegateTokensRewarded + delegateInfo.tokensRewarded
            self.delegateTokensRequestedToUnstake = self.delegateTokensRequestedToUnstake + delegateInfo.tokensRequestedToUnstake
        }

    }
}

access(all) fun main(account: Address): SummaryStakeDelegateInfo? {
    let doesAccountHaveStakingCollection = FlowStakingCollection.doesAccountHaveStakingCollection(address: account)
    if (!doesAccountHaveStakingCollection) {
        return nil
    }

    let allNodeInfo: [FlowIDTableStaking.NodeInfo] = FlowStakingCollection.getAllNodeInfo(address: account)
    let allDelegateInfo: [FlowIDTableStaking.DelegatorInfo] = FlowStakingCollection.getAllDelegatorInfo(address: account)

    return SummaryStakeDelegateInfo(allNodeInfo: allNodeInfo, allDelegateInfo: allDelegateInfo)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_delegates_info.cdc

```

import FlowStakingCollection from 0xFlowStakingCollection
import FlowIDTableStaking from 0xFlowIDTableStaking
import LockedTokens from 0xLockedTokens

access(all) struct DelegateInfo {
    access(all) let delegatorID: UInt32
    access(all) let nodeID: String
    access(all) let tokensCommitted: UFix64
    access(all) let tokensStaked: UFix64
    access(all) let tokensUnstaking: UFix64
    access(all) let tokensRewarded: UFix64
    access(all) let tokensUnstaked: UFix64
    access(all) let tokensRequestedToUnstake: UFix64

    // Projected Values

    access(all) let id: String
    access(all) let role: UInt8
    access(all) let unstakableTokens: UFix64
    access(all) let delegatedNodeInfo: FlowIDTableStaking.NodeInfo
    access(all) let restakableUnstakedTokens: UFix64

    init(delegatorInfo: FlowIDTableStaking.DelegatorInfo) {
        self.delegatorID = delegatorInfo.id
        self.nodeID = delegatorInfo.nodeID
        self.tokensCommitted = delegatorInfo.tokensCommitted
        self.tokensStaked = delegatorInfo.tokensStaked
        self.tokensUnstaking = delegatorInfo.tokensUnstaking
        self.tokensUnstaked = delegatorInfo.tokensUnstaked
        self.tokensRewarded = delegatorInfo.tokensRewarded
        self.tokensRequestedToUnstake = delegatorInfo.tokensRequestedToUnstake

        // Projected Values
        let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: delegatorInfo.nodeID)
        self.delegatedNodeInfo = nodeInfo
        self.id = nodeInfo.id
        self.role = nodeInfo.role
        self.unstakableTokens = self.tokensStaked + self.tokensCommitted
        self.restakableUnstakedTokens = self.tokensUnstaked + self.tokensRequestedToUnstake
    }
}

access(all) fun main(account: Address): {String: {UInt32: DelegateInfo}}? {
    let doesAccountHaveStakingCollection = FlowStakingCollection.doesAccountHaveStakingCollection(address: account)
    if (!doesAccountHaveStakingCollection) {
        return nil
    }

    let delegatorIDs: [FlowStakingCollection.DelegatorIDs] = FlowStakingCollection.getDelegatorIDs(address: account)

    let formattedDelegatorInfo: {String: {UInt32: DelegateInfo}} = {}

    for delegatorID in delegatorIDs {
        if let _formattedDelegatorInfo = formattedDelegatorInfo[delegatorID.delegatorNodeID] {
            let delegatorInfo: FlowIDTableStaking.DelegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegatorID.delegatorNodeID, delegatorID: delegatorID.delegatorID)
            _formattedDelegatorInfo[delegatorID.delegatorID] = DelegateInfo(delegatorInfo: delegatorInfo)
        } else {
            let delegatorInfo: FlowIDTableStaking.DelegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegatorID.delegatorNodeID, delegatorID: delegatorID.delegatorID)
            formattedDelegatorInfo[delegatorID.delegatorNodeID] = { delegatorID.delegatorID: DelegateInfo(delegatorInfo: delegatorInfo)}
        }
    }

    return formattedDelegatorInfo
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_transfer_child_nft.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>


transaction(address: Address, path: String,  ids: [UInt64] ) {

  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: address) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    
    // Get a reference to the child's stored vault
    let collectionRef = providerCap.borrow()!
    let receiverRef =  signer.capabilities.get<&{NonFungibleToken.Receiver}>(collectionData.publicPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")

    for id in ids {     
        // Withdraw tokens from the signer's stored vault
        let nft <- collectionRef.withdraw(withdrawID: id)
        receiverRef.deposit(token: <- nft)
    }
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_child_addresses.cdc

```
import HybridCustody from 0xHybridCustody

access(all) fun main(parent: Address): [Address] {
    let acct = getAuthAccount<auth(Storage) &Account>(parent)
    let manager = acct.storage.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager not found")
    return  manager.getChildAddresses()
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/publish_to_parent.cdc

```
#allowAccountLinking

import HybridCustody from 0xHybridCustody
import CapabilityFactory from 0xCapabilityFactory
import CapabilityFilter from 0xCapabilityFilter
import CapabilityDelegator from 0xCapabilityDelegator

transaction(parent: Address, factoryAddress: Address, filterAddress: Address) {
    prepare(acct: auth(Storage) &Account) {
        let owned = acct.storage.borrow<auth(HybridCustody.Owner) &HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")

        let factory = getAccount(factoryAddress).capabilities.get<&CapabilityFactory.Manager>(CapabilityFactory.PublicPath)
        assert(factory.check(), message: "factory address is not configured properly")

        let filter = getAccount(filterAddress).capabilities.get<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filter.check(), message: "capability filter is not configured properly")

        owned.publishToParent(parentAddress: parent, factory: factory, filter: filter)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_delegates_indo.cdc

```

import FlowStakingCollection from 0xFlowStakingCollection
import FlowIDTableStaking from 0xFlowIDTableStaking
import LockedTokens from 0xLockedTokens

access(all) struct DelegateInfo {
    access(all) let delegatorID: UInt32
    access(all) let nodeID: String
    access(all) let tokensCommitted: UFix64
    access(all) let tokensStaked: UFix64
    access(all) let tokensUnstaking: UFix64
    access(all) let tokensRewarded: UFix64
    access(all) let tokensUnstaked: UFix64
    access(all) let tokensRequestedToUnstake: UFix64

    // Projected Values

    access(all) let id: String
    access(all) let role: UInt8
    access(all) let unstakableTokens: UFix64
    access(all) let delegatedNodeInfo: FlowIDTableStaking.NodeInfo
    access(all) let restakableUnstakedTokens: UFix64

    init(delegatorInfo: FlowIDTableStaking.DelegatorInfo) {
        self.delegatorID = delegatorInfo.id
        self.nodeID = delegatorInfo.nodeID
        self.tokensCommitted = delegatorInfo.tokensCommitted
        self.tokensStaked = delegatorInfo.tokensStaked
        self.tokensUnstaking = delegatorInfo.tokensUnstaking
        self.tokensUnstaked = delegatorInfo.tokensUnstaked
        self.tokensRewarded = delegatorInfo.tokensRewarded
        self.tokensRequestedToUnstake = delegatorInfo.tokensRequestedToUnstake

        // Projected Values
        let nodeInfo = FlowIDTableStaking.NodeInfo(nodeID: delegatorInfo.nodeID)
        self.delegatedNodeInfo = nodeInfo
        self.id = nodeInfo.id
        self.role = nodeInfo.role
        self.unstakableTokens = self.tokensStaked + self.tokensCommitted
        self.restakableUnstakedTokens = self.tokensUnstaked + self.tokensRequestedToUnstake
    }
}

access(all) fun main(account: Address): {String: {UInt32: DelegateInfo}}? {
    let doesAccountHaveStakingCollection = FlowStakingCollection.doesAccountHaveStakingCollection(address: account)
    if (!doesAccountHaveStakingCollection) {
        return nil
    }

    let delegatorIDs: [FlowStakingCollection.DelegatorIDs] = FlowStakingCollection.getDelegatorIDs(address: account)

    let formattedDelegatorInfo: {String: {UInt32: DelegateInfo}} = {}

    for delegatorID in delegatorIDs {
        if let _formattedDelegatorInfo = formattedDelegatorInfo[delegatorID.delegatorNodeID] {
            let delegatorInfo: FlowIDTableStaking.DelegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegatorID.delegatorNodeID, delegatorID: delegatorID.delegatorID)
            _formattedDelegatorInfo[delegatorID.delegatorID] = DelegateInfo(delegatorInfo: delegatorInfo)
        } else {
            let delegatorInfo: FlowIDTableStaking.DelegatorInfo = FlowIDTableStaking.DelegatorInfo(nodeID: delegatorID.delegatorNodeID, delegatorID: delegatorID.delegatorID)
            formattedDelegatorInfo[delegatorID.delegatorNodeID] = { delegatorID.delegatorID: DelegateInfo(delegatorInfo: delegatorInfo)}
        }
    }

    return formattedDelegatorInfo
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/bridges/calculate_bridge_fee.cdc

```
import FlowEVMBridgeUtils from 0xFlowEVMBridge

access(all)
fun main(bytes used: UInt64): UFix64 {
    return FlowEVMBridgeUtils.calculateBridgeFee(bytes: used)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_coa_addr.cdc

```
import EVM from 0xEVM

access(all)
fun main(address: Address): String {
    let account = getAuthAccount<auth(Storage) &Account>(address)

    let coa = account.storage.borrow<&EVM.CadenceOwnedAccount>(
        from: /storage/evm
    )

    if coa == nil { 
        return ""
    } else {
        let coaAddr = coa?.address() 

        let addrByte: [UInt8] = []

        for byte in coaAddr?.bytes! {
            addrByte.append(byte)
        }

        return String.encodeHex(addrByte)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/setup_owned_account.cdc

```
#allowAccountLinking

import ViewResolver from 0xViewResolver
import MetadataViews from 0xMetadataViews
import HybridCustody from 0xHybridCustody
/// This transaction configures an OwnedAccount in the signer if needed and configures its Capabilities per
/// HybridCustody's intended design. If Display values are specified (as recommended), they will be set on the
/// signer's OwnedAccount.
///
transaction(name: String?, desc: String?, thumbnailURL: String?) {
    prepare(acct: auth(Storage, Capabilities) &Account) {
        let acctCap = acct.capabilities.account.issue<auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account>()

        if acct.storage.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) == nil {
            let ownedAccount <- HybridCustody.createOwnedAccount(acct: acctCap)
            acct.storage.save(<-ownedAccount, to: HybridCustody.OwnedAccountStoragePath)
        }

        let owned = acct.storage.borrow<auth(HybridCustody.Owner) &HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")
        
        // Set the display metadata for the OwnedAccount
        if name != nil && desc != nil && thumbnailURL != nil {
            let thumbnail = MetadataViews.HTTPFile(url: thumbnailURL!)
            let display = MetadataViews.Display(name: name!, description: desc!, thumbnail: thumbnail)
            owned.setDisplay(display)
        }

        // check that paths are all configured properly
        for c in acct.capabilities.storage.getControllers(forPath: HybridCustody.OwnedAccountStoragePath) {
            c.delete()
        }

        acct.capabilities.storage.issue<&{HybridCustody.BorrowableAccount, HybridCustody.OwnedAccountPublic, ViewResolver.Resolver}>(HybridCustody.OwnedAccountStoragePath)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&{HybridCustody.OwnedAccountPublic, ViewResolver.Resolver}>(HybridCustody.OwnedAccountStoragePath),
            at: HybridCustody.OwnedAccountPublicPath
        )
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/withdraw_unstaked.cdc

```
 import FlowStakingCollection from 0xFlowStakingCollection

/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection
/// The tokens are automatically deposited to the unlocked account vault first,
/// And then any locked tokens are deposited into the locked account vault if it is there

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_ft_to_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter


transaction(vaultIdentifier: String, child: Address, amount: UFix64) {

    // The Vault resource that holds the tokens that are being transferred
    let paymentVault: @{FungibleToken.Vault}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(Storage, CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not access signer's FungibleToken Vault")

        // signer is the parent account
        // get the manager resource and borrow childAccount
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
     
        //get Ft cap from child account
        let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: vaultData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let vaultRef = providerCap.borrow()!

        // Withdraw tokens from the signer's stored vault

        vault.deposit(from: <- vaultRef.withdraw(amount: amount))
           // Withdraw the requested balance & calculate the approximate bridge fee based on storage usage
        let currentStorageUsage = signer.storage.used
        self.paymentVault <- vault.withdraw(amount: amount)
        let withdrawnStorageUsage = signer.storage.used
        // Approximate the bridge fee based on the difference in storage usage with some buffer
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            )

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
            provider: providerCapCopy,
            filters: [ providerFilter ],
            expiration: getCurrentBlock().timestamp + 1.0
        )

    }

    execute {

         self.coa.depositTokens(
            vault: <-self.paymentVault,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/unlink_child_account.cdc

```
import HybridCustody from 0xHybridCustody

transaction(child: Address) {
    prepare (acct: AuthAccount) {
        let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager not found")
        manager.removeChild(addr: child)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_contract_names.cdc

```
access(all) fun main(address: Address): &[String] {
  let account = getAccount(address)
  return account.contracts.names
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/collection/get_nft_displays.cdc

```
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews

access(all) struct ViewInfo {
access(all) let name: String
access(all) let description: String
access(all) let thumbnail: {MetadataViews.File}
access(all) let rarity: String?
access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay?

init(name: String, description: String, thumbnail: {MetadataViews.File}, rarity: String?, collectionDisplay: MetadataViews.NFTCollectionDisplay?) {
    self.name = name
    self.description = description
    self.thumbnail = thumbnail
    self.rarity = rarity
    self.collectionDisplay = collectionDisplay
  }
}

access(all) fun main(address: Address, pathID: String, tokenIDs: [UInt64]): {UInt64: ViewInfo} {
  let account = getAccount(address)
  let res: {UInt64: ViewInfo} = {}
  var collectionDisplayFetched = false

  if tokenIDs.length == 0 {
    return res
  }

  let storagePath = StoragePath(identifier: pathID)!
  let publicPath = PublicPath(identifier: pathID)!
  let type = account.storage.type(at: storagePath)
  if type == nil {
    return res
  }

  let metadataViewType = Type<@{ViewResolver.ResolverCollection}>()

  let conformedMetadataViews = type!.isSubtype(of: metadataViewType)
  if !conformedMetadataViews {
    for tokenID in tokenIDs {
      res[tokenID] = ViewInfo(
        name: pathID,
        description: "",
        thumbnail: MetadataViews.HTTPFile(url: ""),
        rarity: nil,
        collectionDisplay: nil
      )
    }
    return res
  }

  let collectionRef = account.capabilities.borrow<&{ViewResolver.ResolverCollection, NonFungibleToken.Receiver}>(publicPath)
  for tokenID in tokenIDs {
    let resolver = collectionRef!.borrowViewResolver(id: tokenID)
    if resolver != nil {
      if let display = MetadataViews.getDisplay(resolver!) {
      var rarityDesc: String? = nil
      if let rarityView = MetadataViews.getRarity(resolver!) {
          rarityDesc = rarityView.description
        }

        var collectionDisplay: MetadataViews.NFTCollectionDisplay? = nil
        if (!collectionDisplayFetched) {
          if let cDisplay = MetadataViews.getNFTCollectionDisplay(resolver!) {
            collectionDisplay = cDisplay
            collectionDisplayFetched = true
          }
        }

        res[tokenID] = ViewInfo(
          name: display.name,
          description: display.description,
          thumbnail: display.thumbnail,
          rarity: rarityDesc,
          collectionDisplay: collectionDisplay
        )
      }
    } else {
      res[tokenID] = ViewInfo(
        name: pathID,
        description: "",
        thumbnail: MetadataViews.HTTPFile(url: ""),
        rarity: nil,
        collectionDisplay: nil
      )
    }
  }
  return res
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_type_requires_onboarding.cdc

```
import FlowEVMBridge from 0xFlowEVMBridge

/// Returns whether a type needs to be onboarded to the FlowEVMBridge
///
/// @param Types: The array of types to check for onboarding status
///
/// @return Whether the type requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil indexed
///     on the type
///
access(all) fun main(types: [Type]): {Type: Bool?} {
    let results: {Type: Bool?} = {}
    for type in types {
        if results[type] != nil {
            continue
        }
        results.insert(key: type, FlowEVMBridge.typeRequiresOnboarding(type))
    }
    return results
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/restake_unstaked.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/remove_account_key_by_index.cdc

```
transaction(keyIndex: Int) {
    prepare(signer: auth(Keys) &Account) {
        signer.keys.revoke(keyIndex: keyIndex)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_addr.cdc

```
import EVM from 0xEVM

access(all) fun main(flowAddress: Address): String? {
    if let address: EVM.EVMAddress = getAuthAccount<auth(BorrowValue) &Account>(flowAddress)
        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)?.address() {
        let bytes: [UInt8] = []
        for byte in address.bytes {
            bytes.append(byte)
        }
        return String.encodeHex(bytes)
    }
    return nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/remove_contract_from_account.cdc

```
transaction(name: String) {
    prepare(signer: auth(RemoveContract) &Account) {
        signer.contracts.remove(name: name)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/estimate_gas.cdc

```
import EVM from 0xEVM

access(all)
fun main(hexEncodedTx: String, address: Address): [UInt64; 2] {
    let account = getAuthAccount<auth(Storage) &Account>(address)

    let coa = account.storage.borrow<&EVM.CadenceOwnedAccount>(
        from: /storage/evm
    ) ?? panic("Could not borrow reference to the COA!")
    let txResult = EVM.run(tx: hexEncodedTx.decodeHex(), coinbase: coa.address())

    assert(
        txResult.status == EVM.Status.failed || txResult.status == EVM.Status.successful,
        message: "evm_error=".concat(txResult.errorMessage).concat("\n")
    )

    return [txResult.errorCode, txResult.gasUsed]
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/send_child_nft_to_child.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>

transaction(childAddr: Address, receiver: Address, identifier: String, id: UInt64) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    let collectionRef = providerCap.borrow()!


    let receiverChildAcct = m.borrowAccount(addr: receiver) ?? panic("child account not found")
    let receiverControllerId = receiverChildAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    let receiverCap = receiverChildAcct.getCapability(controllerID: receiverControllerId, type: capType) ?? panic("no cap found") 
    let publicCap = receiverCap as! Capability<&{NonFungibleToken.CollectionPublic}>
    let receiverRef =  publicCap.borrow()!

    // Withdraw tokens from the signer's stored vault
    let nft <- collectionRef.withdraw(withdrawID: id)
    
    receiverRef.deposit(token: <- nft)
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_apr.cdc

```
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) fun main(): UFix64 {
    let apr = FlowIDTableStaking.getEpochTokenPayout() / FlowIDTableStaking.getTotalStaked() / 7.0 * 365.0 * (1.0 - FlowIDTableStaking.getRewardCutPercentage())
    return apr
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/restake_reward.cdc

```
 import FlowStakingCollection from 0xFlowStakingCollection

/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_accessible_coin_info.cdc

```
 import HybridCustody from 0xHybridCustody
import MetadataViews from 0xMetadataViews
import FungibleToken from 0xFungibleToken
import NonFungibleToken from 0xNonFungibleToken

access(all) struct TokenInfo {
access(all) let id: String
access(all) let balance: UFix64

init(id: String, balance: UFix64) {
    self.id = id
    self.balance = balance
}
}

access(all) fun main(parent: Address, childAddress: Address): [TokenInfo] {
    let manager = getAuthAccount<auth(Storage) &Account>(parent).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")

    var typeIdsWithProvider: {Address: [String]} = {}

    var coinInfoList: [TokenInfo] = []
    let providerType = Type<Capability<&{FungibleToken.Provider}>>()
    let vaultType: Type = Type<@{FungibleToken.Vault}>()

    // Iterate through child accounts

    let acct = getAuthAccount<auth(Storage, Capabilities) &Account> (childAddress)
    let foundTypes: [String] = []
    let vaultBalances: {String: UFix64} = {}
    let childAcct = manager.borrowAccount(addr: childAddress) ?? panic("child account not found")
    // get all private paths
    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
        // Check which private paths have NFT Provider AND can be borrowed
        if !type.isSubtype(of: providerType){
            return true
        }

        let controllers = acct.capabilities.storage.getControllers(forPath: path)

        // let providerCap = cap as! Capability<&{FungibleToken.Provider}> 

        for c in controllers {
            if !c.borrowType.isSubtype(of: providerType) {
                continue
            }

            if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: providerType) {
                let providerCap = cap as! Capability<&{NonFungibleToken.Provider}> 

                if !providerCap.check(){
                    continue
                }
                foundTypes.append(cap.borrow<&AnyResource>()!.getType().identifier)
            }
        }
        return true
    })
    typeIdsWithProvider[childAddress] = foundTypes

    
    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
    
    if typeIdsWithProvider[childAddress] == nil {
        return true
    }

    for key in typeIdsWithProvider.keys {
        for idx, value in typeIdsWithProvider[key]! {
            let value = typeIdsWithProvider[key]!

            if value[idx] != type.identifier {
                continue
            } else {
                if type.isInstance(vaultType) {
                continue
                }
                if let vault = acct.storage.borrow<&{FungibleToken.Balance}>(from: path) { 
                // Iterate over IDs & resolve the view
                    coinInfoList.append(
                    TokenInfo(id: type.identifier, balance: vault.balance))
                }
                continue
            }
        }
        }
      return true
    })

    
    return coinInfoList
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/send_child_nft.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews

import <NFT> from <NFTAddress>


transaction(childAddr: Address, receiver: Address, identifier: String, id: UInt64) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT>.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
    assert(providerCap.check(), message: "invalid provider capability")
    
    // Get a reference to the child's stored vault
    let collectionRef = providerCap.borrow()!

    // Withdraw tokens from the signer's stored vault
    let nft <- collectionRef.withdraw(withdrawID: id)
    let receiverAcc = getAccount(receiver)
    let receiverRef =  receiverAcc.capabilities.get<&{NonFungibleToken.Receiver}>(collectionData.publicPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")
    
    receiverRef.deposit(token: <- nft)
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_nft_from_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody

transaction(nftIdentifier: String, child: Address, id: UInt256) {
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        let coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
       
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        
        // let receiver = getAccount(child).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
        //     ?? panic("Could not borrow Receiver from recipient's public capability path")



        let capType = Type<&{NonFungibleToken.CollectionPublic}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let publicCap = cap as! Capability<&{NonFungibleToken.CollectionPublic}>
        assert(publicCap.check(), message: "invalid public capability")
        
        // Get a reference to the child's stored vault
        let collectionRef = publicCap.borrow()!

      
        // // Withdraw tokens from the signer's stored vault
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )

        let nft: @{NonFungibleToken.NFT} <- coa.withdrawNFT(
            type: nftType,
            id: id,
            feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )

        assert(
            nft.getType() == nftType,
            message: "Bridged nft type mismatch - requeswted: ".concat(nftType.identifier)
                .concat(", received: ").concat(nft.getType().identifier)
        )

        collectionRef.deposit(token: <- nft)
        // Destroy the ScopedFTProvider
        destroy scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/update_contract_of_account.cdc

```
transaction(name: String, code: String) {
    prepare(signer: auth(UpdateContract) &Account) {
        signer.contracts.update(name: name, code: code.utf8)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_ft_to_evm_address.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter


transaction(vaultIdentifier: String, child: Address, amount: UFix64, recipient:String) {
    // The Vault resource that holds the tokens that are being transferred
    let paymentVault: @{FungibleToken.Vault}
    // let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider

    prepare(signer: auth(Storage, CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        // self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
        //     ?? panic("Could not borrow COA from provided gateway address")

        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")
        let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(
                from: vaultData.storagePath
            ) ?? panic("Could not access signer's FungibleToken Vault")

        // signer is the parent account
        // get the manager resource and borrow childAccount
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
     
        //get Ft cap from child account
        let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: vaultData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let vaultRef = providerCap.borrow()!

        // Withdraw tokens from the signer's stored vault

        vault.deposit(from: <- vaultRef.withdraw(amount: amount))
           // Withdraw the requested balance & calculate the approximate bridge fee based on storage usage
        let currentStorageUsage = signer.storage.used
        self.paymentVault <- vault.withdraw(amount: amount)
        let withdrawnStorageUsage = signer.storage.used
        // Approximate the bridge fee based on the difference in storage usage with some buffer
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            )

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
            provider: providerCapCopy,
            filters: [ providerFilter ],
            expiration: getCurrentBlock().timestamp + 1.0
        )

    }

    execute {
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeTokensToEVM(
            vault: <-self.paymentVault,
            to: recipientEVMAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_account_info.cdc

```
access(all) struct Result {
  access(all) let address: Address
  access(all) let balance: UFix64
  access(all) let availableBalance: UFix64
  access(all) let storageUsed: UInt64
  access(all) let storageCapacity: UInt64
  access(all) let storageFlow: UFix64

  init(
    address: Address,
    balance: UFix64,
    availableBalance: UFix64,
    storageUsed: UInt64,
    storageCapacity: UInt64,
    storageFlow: UFix64,
  ) {
    self.address = address
    self.balance = balance
    self.availableBalance = availableBalance
    self.storageUsed = storageUsed
    self.storageCapacity = storageCapacity
    self.storageFlow = storageFlow
  }
}

access(all) fun main(address: Address): Result {
  let account = getAccount(address)
  return Result(
    address: account.address,
    balance: account.balance,
    availableBalance: account.availableBalance,
    storageUsed: account.storage.used,
    storageCapacity: account.storage.capacity,
    storageFlow: account.balance - account.availableBalance
  )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_child_account_allow_types.cdc

```
import HybridCustody from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import FungibleToken from 0xFungibleToken

// This script iterates through a parent's child accounts, 
// identifies private paths with an accessible NonFungibleToken.Provider, and returns the corresponding typeIds
access(all) fun main(addr: Address, child: Address): [String]? {
  let account = getAuthAccount<auth(Storage) &Account>(addr)
  let manager = getAuthAccount<auth(Storage) &Account>(addr).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")


  
  let nftProviderType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
  let ftProviderType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()

  // Iterate through child accounts
  let addr = getAuthAccount<auth(Storage, Capabilities) &Account>(child)
  let foundTypes: [String] = []
  let childAcct = manager.borrowAccount(addr: child) ?? panic("child account not found")
  // get all private paths

  for s in addr.storage.storagePaths {
    let controllers = addr.capabilities.storage.getControllers(forPath: s)
    for c in controllers {
      // if !c.borrowType.isSubtype(of: providerType) {
      //   continue
      // }

      if let nftCap = childAcct.getCapability(controllerID: c.capabilityID, type: nftProviderType) {
        let providerCap = nftCap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}> 

        if !providerCap.check(){
          continue
        }

        foundTypes.append(nftCap.borrow<&AnyResource>()!.getType().identifier)
        break
      }
      if let ftCap = childAcct.getCapability(controllerID: c.capabilityID, type: ftProviderType) {
        let providerCap = ftCap as! Capability<&{FungibleToken.Provider}> 

        if !providerCap.check(){
          continue
        }

        foundTypes.append(ftCap.borrow<&AnyResource>()!.getType().identifier)
        break
      }
    }
  }

  return foundTypes
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/onboard_by_type_identifier.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param identifer: The Cadence type identifier of the bridgeable asset to onboarded to the bridge
///
transaction(identifier: String) {

    let type: Type
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct the type from identifier --- */
        //
        self.type = CompositeType(identifier) ?? panic("Invalid type identifier")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the asset Type
        FlowEVMBridge.onboardByType(
            self.type,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/create_delegator.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

/// Registers a delegator in the staking collection resource
/// for the specified nodeID and the amount of tokens to commit

transaction(id: String, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/collection/send_nba_nft.cdc

```
import NonFungibleToken from 0xNonFungibleToken

import <NFT> from <NFTAddress>

transaction(recipientAddr: Address, withdrawID: UInt64) {
    prepare(signer: auth(Storage, BorrowValue) &Account) {
        // get the recipients public account object
        let recipient = getAccount(recipientAddr)
        // borrow a reference to the signer''s NFT collection
        let collectionRef = signer.storage
        .borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(from: /storage/MomentCollection)
        ?? panic("Could not borrow a reference to the owner''s collection")
        let senderRef = signer
        .capabilities
        .borrow<&{NonFungibleToken.CollectionPublic}>(/public/MomentCollection)
        // borrow a public reference to the receivers collection
        let recipientRef = recipient
        .capabilities
        .borrow<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection) ?? panic("Unable to borrow receiver reference")
        
        // withdraw the NFT from the owner''s collection
        let nft <- collectionRef.withdraw(withdrawID: withdrawID)
        // Deposit the NFT in the recipient''s collection
        recipientRef!.deposit(token: <-nft)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/create_account.cdc

```
import Crypto
import FlowToken from 0x1654653399040a61
import FungibleToken from 0xf233dcee88fe0abe

 transaction(publicKeys: [Crypto.KeyListEntry], contracts: {String: String}, fundAmount: UFix64) {
    let tokenReceiver: &{FungibleToken.Receiver}
    let sentVault: @FungibleToken.Vault

    prepare(signer: auth(BorrowValue | Storage) &Account) {
        let account = Account(payer: signer)
        for key in publicKeys {
            account.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)
        }
        for contract in contracts.keys {
            account.contracts.add(name: contract, code: contracts[contract]!.decodeHex())
        }
        self.tokenReceiver = account.capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver) ?? panic("Unable to borrow receiver reference")
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault) ?? panic("Could not borrow reference to the owner''s Vault!")
        self.sentVault <- vaultRef.withdraw(amount: fundAmount)
    }
    execute {
        self.tokenReceiver.deposit(from: <-self.sentVault)
    }
 }
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/fund_coa.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

transaction(amount: UFix64) {
    let sentVault: @FlowToken.Vault
    let auth: auth(Storage) &Account
    let coa: &EVM.CadenceOwnedAccount

    prepare(signer: auth(Storage) &Account) {
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(
            from: /storage/flowTokenVault
        ) ?? panic("Could not borrow reference to the owner's Vault!")


        let coa = signer.storage.borrow<&EVM.CadenceOwnedAccount>(
            from: /storage/evm
        ) ?? panic("Could not borrow reference to the COA!")

        self.sentVault <- vaultRef.withdraw(amount: amount) as! @FlowToken.Vault
        self.auth = signer
        self.coa = coa
    }

    execute {
        self.coa.deposit(from: <-self.sentVault)
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/evm_address_requires_onboarding.cdc

```
import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge

/// Returns whether a EVM contract needs to be onboarded to the FlowEVMBridge
///
/// @param evmAddressHex: The hex-encoded address of the EVM contract as a String without 0x prefix
///
/// @return Whether the contract requires onboarding to the FlowEVMBridge if the type is bridgeable, otherwise nil
///
access(all) fun main(evmAddressHex: String): Bool? {
    if let address = EVMUtils.getEVMAddressFromHexString(address: evmAddressHex) {
        return FlowEVMBridge.evmAddressRequiresOnboarding(address)
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/send_child_ft_to_child.cdc

```
import HybridCustody from 0xHybridCustody

// HC-owned imports
import CapabilityFactory from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody

import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>


transaction(address: Address, receiver: Address, path: String, amount: UFix64 ) {

  // The Vault resource that holds the tokens that are being transferred
  let paymentVault: @{FungibleToken.Vault}
  let vaultData: FungibleTokenMetadataViews.FTVaultData

  prepare(signer: auth(Storage) &Account) {
      // signer is the parent account
      // get the manager resource and borrow childAccount
      let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
          ?? panic("manager does not exist")
      let childAcct = m.borrowAccount(addr: address) ?? panic("child account not found")
      
      self.vaultData = <Token>.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
          ?? panic("Could not get the vault data view for <Token> ")

      //get Ft cap from child account
      let capType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()
      let controllerID = childAcct.getControllerIDForType(type: capType, forPath: self.vaultData.storagePath)
          ?? panic("no controller found for capType")
      
      let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
      let providerCap = cap as! Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>
      assert(providerCap.check(), message: "invalid provider capability")
      
      // Get a reference to the child's stored vault
      let vaultRef = providerCap.borrow()!

      // Withdraw tokens from the signer's stored vault
      self.paymentVault <- vaultRef.withdraw(amount: amount)
  }

  execute {

      // Get the recipient's public account object
      let recipient = getAccount(receiver)

      // Get a reference to the recipient's Receiver
      let receiverRef = recipient.capabilities.get<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)!.borrow()
    ?? panic("Could not borrow receiver reference to the recipient's Vault")

      // Deposit the withdrawn tokens in the recipient's receiver
      receiverRef.deposit(from: <-self.paymentVault)
  }
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/collection/get_nft.cdc

```
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews


access(all) struct ViewInfo {
  access(all) let name: String
  access(all) let description: String
  access(all) let thumbnail: {MetadataViews.File}
  access(all) let rarity: String?

  init(name: String, description: String, thumbnail: {MetadataViews.File}, rarity: String?) {
    self.name = name
    self.description = description
    self.thumbnail = thumbnail
    self.rarity = rarity
  }
}

access(all) fun main(address: Address, pathId: String, tokenIDs: [UInt64]): {UInt64: ViewInfo} {
  let account = getAccount(address)
  let res: {UInt64: ViewInfo} = {}
  var collectionDisplayFetched = false

  if tokenIDs.length == 0 {
    return res
  }

  let storagePath = StoragePath(identifier: pathId)!
  let publicPath = PublicPath(identifier: pathId)!
  let type = account.storage.type(at: storagePath)
  if type == nil {
    return res
  }

  let metadataViewType = Type<@{ViewResolver.ResolverCollection}>()

  let conformedMetadataViews = type!.isSubtype(of: metadataViewType)
  if !conformedMetadataViews {
    for tokenID in tokenIDs {
      res[tokenID] = ViewInfo(
        name: pathId,
        description: "",
        thumbnail: MetadataViews.HTTPFile(url: ""),
        rarity: nil
      )
    }
    return res
  }

  let collectionRef = account.capabilities.borrow<&{ViewResolver.ResolverCollection, NonFungibleToken.Collection}>(publicPath)
  for tokenID in tokenIDs {
    let resolver = collectionRef!.borrowViewResolver(id: tokenID)
    if resolver != nil {
       if let display = MetadataViews.getDisplay(resolver!) {
        var rarityDesc: String? = nil
        if let rarityView = MetadataViews.getRarity(resolver!) {
          rarityDesc = rarityView.description
        }

        res[tokenID] = ViewInfo(
          name: display.name,
          description: display.description,
          thumbnail: display.thumbnail,
          rarity: rarityDesc
        )
      } 
    }
   else {
      res[tokenID] = ViewInfo(
        name: pathId,
        description: "",
        thumbnail: MetadataViews.HTTPFile(url: ""),
        rarity: nil
      )
    }
  }
  return res
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/add_key.cdc

```
import Crypto

transaction(publicKey: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64) {
    prepare(signer: auth(Keys) &Account) {
        let key = PublicKey(
            publicKey: publicKey.decodeHex(),
            signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!
        )

        signer.keys.add(
            publicKey: key,
            hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!,
            weight: weight
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_bridge_child_nft_to_evm_address.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter



transaction(nftIdentifier: String, child: Address, ids: [UInt64], recipient:String) {
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        // let coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
        //     ?? panic("Could not borrow COA from provided gateway address")
        
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
         // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")


        let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        let id = ids[0]
        // Get a reference to the child's stored vault
        let collectionRef = providerCap.borrow()!
        let childNft <- collectionRef.withdraw(withdrawID: id)
        collection.deposit(token: <-childNft)
        // // Withdraw tokens from the signer's stored vault
        let currentStorageUsage = signer.storage.used
        let nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        let approxFee =FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
            
        let recipientEVMAddress = EVM.addressFromString(recipient)

        FlowEVMBridge.bridgeNFTToEVM(
            token: <- nft,
            to: recipientEVMAddress,
            feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        var idx = 0
        for nftId in ids {
            if idx == 0 {
                idx = idx + 1
                continue
            }

            FlowEVMBridge.bridgeNFTToEVM(
                token: <- collectionRef.withdraw(withdrawID: nftId),
                to: recipientEVMAddress,
                feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            idx = idx + 1
        }
        // Destroy the ScopedFTProvider
        destroy scopedProvider
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/withdraw_locked.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import LockedTokens from 0xLockedTokens

transaction(amount: UFix64) {

    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder
    let vaultRef: auth(FungibleToken.Withdraw) &FlowToken.Vault

    prepare(acct: auth(BorrowValue) &Account) {
        self.holderRef = acct.storage.borrow<auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) &LockedTokens.TokenHolder>(from: LockedTokens.TokenHolderStoragePath)
            ?? panic("The primary user account does not have an associated locked account")

        self.vaultRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic("Could not borrow flow token vault ref")
    }

    execute {
        self.vaultRef.deposit(from: <-self.holderRef.withdraw(amount: amount))
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/withdraw_reward.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection
/// The tokens are automatically deposited to the unlocked account vault first,
/// And then any locked tokens are deposited into the locked account vault

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/setup.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import LockedTokens from 0xLockedTokens
import FlowIDTableStaking from 0xFlowIDTableStaking
import FlowStakingCollection from 0xFlowStakingCollection

/// This transaction sets up an account to use a staking collection
/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,
/// or staking objects stored in the unlocked account

transaction {
    prepare(signer: auth(BorrowValue, Storage, Capabilities) &Account) {

        // If there isn't already a staking collection
        if signer.storage.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {

            // Create private capabilities for the token holder and unlocked vault
            let lockedHolder = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw, LockedTokens.TokenOperations) &LockedTokens.TokenHolder>(LockedTokens.TokenHolderStoragePath)!
            let flowToken = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &FlowToken.Vault>(/storage/flowTokenVault)!

            // Create a new Staking Collection and put it in storage
            if lockedHolder.check() {
                signer.storage.save(
                    <- FlowStakingCollection.createStakingCollection(
                        unlockedVault: flowToken,
                        tokenHolder: lockedHolder
                    ),
                    to: FlowStakingCollection.StakingCollectionStoragePath
                )
            } else {
                signer.storage.save(
                    <- FlowStakingCollection.createStakingCollection(
                        unlockedVault: flowToken,
                        tokenHolder: nil
                    ),
                    to: FlowStakingCollection.StakingCollectionStoragePath
                )
            }

            // Publish a capability to the created staking collection.
            let stakingCollectionCap = signer.capabilities.storage.issue<&FlowStakingCollection.StakingCollection>(
                FlowStakingCollection.StakingCollectionStoragePath
            )

            signer.capabilities.publish(
                stakingCollectionCap,
                at: FlowStakingCollection.StakingCollectionPublicPath
            )
        }

        // borrow a reference to the staking collection
        let collectionRef = signer.storage.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow staking collection reference")

        // If there is a node staker object in the account, put it in the staking collection
        if signer.storage.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {
            let node <- signer.storage.load<@FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)!
            collectionRef.addNodeObject(<-node, machineAccountInfo: nil)
        }

        // If there is a delegator object in the account, put it in the staking collection
        if signer.storage.borrow<&FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath) != nil {
            let delegator <- signer.storage.load<@FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)!
            collectionRef.addDelegatorObject(<-delegator)
        }
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/basic/revoke_key.cdc

```
transaction(index: Int) {
    prepare(signer: auth(Keys) &Account) {
        // Get a key from an auth account.
        let keyA = signer.keys.revoke(keyIndex: index)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/setup_owned_account_and_publish_to_parent.cdc

```
#allowAccountLinking

import MetadataViews from 0xMetadataViews
import ViewResolver from 0xViewResolver


import HybridCustody from 0xHybridCustody
import CapabilityFactory from 0xCapabilityFactory
import CapabilityFilter from 0xCapabilityFilter
import CapabilityDelegator from 0xCapabilityDelegator
/// This transaction configures an OwnedAccount in the signer if needed, and proceeds to create a ChildAccount 
/// using CapabilityFactory.Manager and CapabilityFilter.Filter Capabilities from the given addresses. A
/// Capability on the ChildAccount is then published to the specified parent account. 
///
transaction(
    parent: Address,
    factoryAddress: Address,
    filterAddress: Address,
    name: String,
    desc: String,
    thumbnailURL: String
) {
    prepare(acct: auth(Storage, Capabilities) &Account) {
        // Configure OwnedAccount if it doesn't exist
        if acct.storage.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) == nil {
            var acctCap = acct.capabilities.account.issue<auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account>()
            let ownedAccount <- HybridCustody.createOwnedAccount(acct: acctCap)
            acct.storage.save(<-ownedAccount, to: HybridCustody.OwnedAccountStoragePath)
        }

        for c in acct.capabilities.storage.getControllers(forPath: HybridCustody.OwnedAccountStoragePath) {
            c.delete()
        }


        acct.capabilities.storage.issue<&{HybridCustody.BorrowableAccount, HybridCustody.OwnedAccountPublic, ViewResolver.Resolver}>(HybridCustody.OwnedAccountStoragePath)
        acct.capabilities.publish(
            acct.capabilities.storage.issue<&{HybridCustody.OwnedAccountPublic, ViewResolver.Resolver}>(HybridCustody.OwnedAccountStoragePath),
            at: HybridCustody.OwnedAccountPublicPath
        )

        let owned = acct.storage.borrow<auth(HybridCustody.Owner) &HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")
        
        // Set the display metadata for the OwnedAccount
        if name != nil && desc != nil && thumbnailURL != nil {
            let thumbnail = MetadataViews.HTTPFile(url: thumbnailURL!)
            let display = MetadataViews.Display(name: name!, description: desc!, thumbnail: thumbnail)
            owned.setDisplay(display)
        }

        // Get CapabilityFactory & CapabilityFilter Capabilities
        let factory = getAccount(factoryAddress).capabilities.get<&CapabilityFactory.Manager>(CapabilityFactory.PublicPath)
        assert(factory.check(), message: "factory address is not configured properly")

        let filter = getAccount(filterAddress).capabilities.get<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filter.check(), message: "capability filter is not configured properly")

        // Finally publish a ChildAccount capability on the signing account to the specified parent
        owned.publishToParent(parentAddress: parent, factory: factory, filter: filter)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_child_account_ft_capabilities.cdc

```
import HybridCustody from 0xHybridCustody
import FungibleToken from 0xFungibleToken

// This script iterates through a parent's child accounts, 
// identifies private paths with an accessible FungibleToken.Provider, and returns the corresponding typeIds
access(all) fun main(addr: Address):AnyStruct {
  let account = getAuthAccount<auth(Storage) &Account>(addr)
  let manager = getAuthAccount<auth(Storage) &Account>(addr).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
    ?? panic ("manager does not exist")

  var typeIdsWithProvider: {Address: [String]} = {}
  
  let providerType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()

  // Iterate through child accounts
  for address in manager.getChildAddresses() {
    let addr = getAuthAccount<auth(Storage, Capabilities) &Account>(address)
    let foundTypes: [String] = []
    let childAcct = manager.borrowAccount(addr: address) ?? panic("child account not found")
    // get all private paths

    for s in addr.storage.storagePaths {
      for c in addr.capabilities.storage.getControllers(forPath: s) {
        if !c.borrowType.isSubtype(of: providerType){
          continue
        }

        if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: providerType) {
          let providerCap = cap as! Capability<&{FungibleToken.Provider}> 

          if !providerCap.check(){
            continue
          }

          foundTypes.append(cap.borrow<&AnyResource>()!.getType().identifier)
          typeIdsWithProvider[address] = foundTypes
          break
        }
      }
    }      
  }

  return typeIdsWithProvider
}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/close_stake.cdc

```
import FlowStakingCollection from 0xFlowStakingCollection

// Closes out a staking object in the staking collection
// This does not remove the record from the identity table,
// but it does mean that the account that closes it cannot ever access it again

transaction(nodeID: String, delegatorID: UInt32?) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_nonce.cdc

```
import EVM from 0xEVM

access(all)
fun main(hexEncodedAddress: String): UInt64 {
    let addressBytes = hexEncodedAddress.decodeHex().toConstantSized<[UInt8; 20]>()!
    let address = EVM.EVMAddress(bytes: addressBytes)

    return address.nonce()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_account_total_flow_balance.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import LockedTokens from 0xLockedTokens
// import FungibleToken from 0xee82856bf20e2aa6
// import FlowToken from 0x0ae53cb6e3f42a79
// import LockedTokens from 0xf8d6e0586b0a20c7

access(all) fun main(address: Address): UFix64 {
    let account = getAccount(address)
    let unlockedVault = account
      .capabilities.get<&{FungibleToken.Balance}>(/public/flowTokenBalance)!
      .borrow()
        ?? panic("Could not borrow Balance reference to the Vault")
    let unlockedBalance = unlockedVault.balance
        
    let lockedAccountInfoCap = account
      .capabilities.get
      <&LockedTokens.TokenHolder>
      (LockedTokens.LockedAccountInfoPublicPath)
    if lockedAccountInfoCap == nil || !(lockedAccountInfoCap!.check()) {
        return unlockedBalance
    }
    
    let lockedAccountInfoRef = lockedAccountInfoCap!.borrow()!
    let lockedBalance = lockedAccountInfoRef.getLockedAccountBalance()
    
    return lockedBalance + unlockedBalance
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_bridge_child_nft_to_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter

transaction(nftIdentifier: String, child: Address, ids: [UInt64]) {
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        let coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
         // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")


        let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        let id = ids[0]
        // Get a reference to the child's stored vault
        let collectionRef = providerCap.borrow()!
        let childNft <- collectionRef.withdraw(withdrawID: id)
        collection.deposit(token: <-childNft)
        // // Withdraw tokens from the signer's stored vault
        let currentStorageUsage = signer.storage.used
        let nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            ) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
       
        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )

        // Execute the bridge
        coa.depositNFT(
            nft: <- nft,
            feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        var idx = 0
        for nftId in ids {
            if idx == 0 {
                idx = idx + 1
                continue
            }

            let nft <- collectionRef.withdraw(withdrawID: nftId)
            coa.depositNFT(
                nft: <- nft,
                feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            idx = idx + 1
        }
        // Destroy the ScopedFTProvider
        destroy scopedProvider
    }

}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_bridge_nft_to_evm_v2.cdc

```

import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge



/// Bridges an NFT from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftIdentifier: String, ids: [UInt64]) {
    
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        let currentStorageUsage = signer.storage.used
        let nft <- collection.withdraw(withdrawID: ids[0])
        let withdrawnStorageUsage = signer.storage.used
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(nftType)
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
        )
        self.coa.depositNFT(
            nft: <- nft,
            feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )

        var idx = 0
        while idx < ids.length {
             if idx == 0 {
                idx = idx + 1
                continue
            }
            let nftId = ids[idx]!
            let nft <- collection.withdraw(withdrawID: nftId)! as @{NonFungibleToken.NFT}
            self.coa.depositNFT(
                nft: <- nft,
                feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
            idx = idx + 1
        }
       
        // Destroy the ScopedFTProvider
        destroy scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/onboard_by_evm_address.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the NFT type to the bridge, configuring the bridge to move NFTs between environments
/// NOTE: This must be done before bridging a Cadence-native NFT to EVM
///
/// @param contractAddressHex: The EVM address of the contract (as hex string without 0x prefix) defining the 
///     bridgeable asset to be onboarded
///
transaction(contractAddressHex: String) {

    let contractAddress: EVM.EVMAddress
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Construct EVMAddress from hex string (no leading `"0x"`) --- */
        //
        self.contractAddress = EVMUtils.getEVMAddressFromHexString(address: contractAddressHex)
            ?? panic("Invalid EVM address string provided")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Onboard the EVM contract
        FlowEVMBridge.onboardByEVMAddress(
            self.contractAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/collection/get_nft_metadata_views.cdc

```
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews


access(all) struct CollectionData {
  access(all) let storagePath: StoragePath
  access(all) let publicPath: PublicPath
  access(all) let providerPath: PrivatePath
  access(all) let publicCollection: Type
  access(all) let publicLinkedType: Type
  access(all) let providerLinkedType: Type

  init(
    storagePath: StoragePath,
    publicPath: PublicPath,
    providerPath: PrivatePath,
    publicCollection: Type,
    publicLinkedType: Type,
    providerLinkedType: Type
  ) {
    self.storagePath = storagePath
    self.publicPath = publicPath
    self.providerPath = providerPath
    self.publicCollection = publicCollection
    self.publicLinkedType = publicLinkedType
    self.providerLinkedType = providerLinkedType
  }
}

access(all) fun main(address: Address, pathId: String, tokenID: UInt64): {String: AnyStruct} {
  let account = getAccount(address)
  let res: {String: AnyStruct} = {}

  let storagePath = StoragePath(identifier: pathId)!
  let publicPath = PublicPath(identifier: pathId)!
  let collectionRef = account.capabilities.borrow<&{NonFungibleToken.Collection, ViewResolver.ResolverCollection}>(publicPath)
  if collectionRef == nil {
    panic("Get Collection Failed")
  }

  let type = account.storage.type(at: storagePath)
  if type == nil {
    return res
  }

  let metadataViewType = Type<@{ViewResolver.ResolverCollection}>()
  let conformedMetadataViews = type!.isSubtype(of: metadataViewType)

  if (!conformedMetadataViews) {
    return res
  }

  collectionRef!.borrowNFT(tokenID)

  let resolver = collectionRef!.borrowViewResolver(id: tokenID)!
  if resolver != nil {
    if let rarity = MetadataViews.getRarity(resolver) {
      res["rarity"] = rarity
    }

    if let display = MetadataViews.getDisplay(resolver) {
      res["display"] = display
    }

    if let editions = MetadataViews.getEditions(resolver) {
      res["editions"] = editions
    }

    if let serial = MetadataViews.getSerial(resolver) {
      res["serial"] = serial
    }

    if let royalties = MetadataViews.getRoyalties(resolver) {
      res["royalties"] = royalties
    }

    if let license = MetadataViews.getLicense(resolver) {
      res["license"] = license
    }

    if let medias = MetadataViews.getMedias(resolver) {
      res["medias"] = medias
    }

    if let externalURL = MetadataViews.getExternalURL(resolver) {
      res["externalURL"] = externalURL
    }

    if let traits = MetadataViews.getTraits(resolver) {
      res["traits"] = traits
    }

    if let collectionDisplay = MetadataViews.getNFTCollectionDisplay(resolver) {
      res["collectionDisplay"] = collectionDisplay
    }

    if let collectionData = MetadataViews.getNFTCollectionData(resolver) {
      let data = CollectionData(
        storagePath: collectionData.storagePath,
        publicPath: collectionData.publicPath,
        providerPath: collectionData.providerPath,
        publicCollection: collectionData.publicCollection,
        publicLinkedType: collectionData.publicLinkedType,
        providerLinkedType: collectionData.providerLinkedType
      )
      res["collectionData"] = data
    }
  }
  res["tokenId"] = tokenID

  return res
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/check_child_linked_collections.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken

access(all) fun main(parent: Address, child: Address, identifier: String): Bool {
    let mgr = getAuthAccount(parent).borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("Could not borrow manager from parent")
    let child = mgr.borrowAccount(addr: child) ?? panic("Child account not found")

    let cap = child.getCapability(
            path: PrivatePath(identifier: identifier)! as CapabilityPath,
            type: Type<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>()
        ) as! Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>?

    
    return cap != nil
}   
    
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/batch_bridge_child_nft_from_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter


transaction(nftIdentifier: String, child: Address, ids: [UInt256]) {
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        let coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
       
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        
        // let receiver = getAccount(child).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
        //     ?? panic("Could not borrow Receiver from recipient's public capability path")



        let capType = Type<&{NonFungibleToken.CollectionPublic}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let publicCap = cap as! Capability<&{NonFungibleToken.CollectionPublic}>
        assert(publicCap.check(), message: "invalid public capability")
        
        // Get a reference to the child's stored vault
        let collectionRef = publicCap.borrow()!

      
        // // Withdraw tokens from the signer's stored vault
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + (FlowEVMBridgeConfig.baseFee * UFix64(ids.length))

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )

        for id in ids {
            let nft: @{NonFungibleToken.NFT} <- coa.withdrawNFT(
                type: nftType,
                id: id,
                feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )

            assert(
                nft.getType() == nftType,
                message: "Bridged nft type mismatch - requeswted: ".concat(nftType.identifier)
                    .concat(", received: ").concat(nft.getType().identifier)
            )

            collectionRef.deposit(token: <- nft)
        }
      

        
        // Destroy the ScopedFTProvider
        destroy scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_ft_from_evm.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge


import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody

transaction(vaultIdentifier: String, child: Address, amount: UInt256) {
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        // Borrow a reference to the signer's COA
        let coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        let vaultType = CompositeType(vaultIdentifier)
            ?? panic("Could not construct Vault type from identifier: ".concat(vaultIdentifier))
        // Parse the Vault identifier into its components
        let tokenContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: vaultType)
            ?? panic("Could not get contract address from identifier: ".concat(vaultIdentifier))
        let tokenContractName = FlowEVMBridgeUtils.getContractName(fromType: vaultType)
            ?? panic("Could not get contract name from identifier: ".concat(vaultIdentifier))

        /* --- Retrieve the funds --- */
        //
        // Borrow a reference to the FungibleToken Vault
        let viewResolver = getAccount(tokenContractAddress).contracts.borrow<&{ViewResolver}>(name: tokenContractName)
            ?? panic("Could not borrow ViewResolver from FungibleToken contract")
        let vaultData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<FungibleTokenMetadataViews.FTVaultData>()
            ) as! FungibleTokenMetadataViews.FTVaultData? ?? panic("Could not resolve FTVaultData view")

        // signer is the parent account
        // get the manager resource and borrow childAccount
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
     
        //get Ft cap from child account
        let capType = Type<&{FungibleToken.Receiver}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: vaultData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<&{FungibleToken.Receiver}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let vaultRef = providerCap.borrow()!

      
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        let scopedProvider <- ScopedFTProviders.createScopedFTProvider(
            provider: providerCapCopy,
            filters: [ providerFilter ],
            expiration: getCurrentBlock().timestamp + 1.0
        )

        let vault: @{FungibleToken.Vault} <- coa.withdrawTokens(
            type: vaultType,
            amount: amount,
            feeProvider: &scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )

        vaultRef.deposit(from: <- vault)
        destroy scopedProvider
    }

}
 
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/batch_onboard_by_identifier.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// This transaction onboards the asset type to the bridge, configuring the bridge to move assets between environments
/// NOTE: This must be done before bridging a Cadence-native asset to EVM
///
/// @param types: The Cadence types of the bridgeable asset to onboard to the bridge
///
transaction(identifiers: [String]) {

    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        // Set a withdrawal limit for the provider
        let providerLimit = FlowEVMBridgeConfig.onboardFee * UFix64(types.length)
        let providerFilter = ScopedFTProviders.AllowanceFilter(providerLimit)
        // Create ScopedFTProvider to expire just after this transaction
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        for identifiers in identifiers { 
            let type = CompositeType(identifier) ?? panic("Invalid type identifier")
            // Continue on if the type does not require onboarding
            if FlowEVMBridge.typeRequiresOnboarding(type) != true {
                continue
            }
            // Onboard the asset Type
            FlowEVMBridge.onboardByType(
                type,
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/bridges/evm_address_requires_onboarding.cdc

```
import EVMUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge

access(all) fun main(evmAddressHex: String): Bool? {
    if let address = EVMUtils.getEVMAddressFromHexString(address: evmAddressHex) {
        return FlowEVMBridge.evmAddressRequiresOnboarding(address)
    }
    return nil
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/README.md

# FRW-utils

Monorepo for Flow utils build by Outblock

- scripts: Utils for query scripts [@outblock/frw-scripts](https://github.com/Outblock/FRW-utils/tree/dev/scripts)
- scriptTest: Test scripts for `@outblock/frw-scripts`
- transactions: Utils for transactions scripts [@outblock/frw-transactions](https://github.com/Outblock/FRW-utils/tree/dev/transactions)
- transactionTest: Test scripts for `@outblock/frw-transactions`


## how to use

See the README.md in each package for usage.

- [@outblock/frw-scripts](https://github.com/Outblock/FRW-utils/blob/dev/scripts/README.md)
- [@outblock/frw-transactions](https://github.com/Outblock/FRW-utils/blob/dev/transactions/README.md)






---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/collection/get_nft_collection.cdc

```
import NonFungibleToken from 0xNonFungibleToken	
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews


access(all) struct CollectionDisplay {
  access(all) let name: String
  access(all) let squareImage: String
  access(all) let mediaType: String

  init(name: String, squareImage: String, mediaType: String) {
    self.name = name
    self.squareImage = squareImage
    self.mediaType = mediaType
  }
}

access(all) struct NFTCollection {
  access(all) let id: String
  access(all) let path: String
  access(all) let display: CollectionDisplay?
  access(all) let idList: [UInt64]

  init(id:String, path: String, display: CollectionDisplay?, idList: [UInt64]) {
    self.id = id
    self.path = path
    self.display = display
    self.idList = idList
  }
}

access(all) fun getDisplay(address: Address, storagePath: StoragePath, publicPath: PublicPath): CollectionDisplay? {
  let account = getAccount(address)
  let resourceType = Type<@AnyResource>()
  let collectionType = Type<@{NonFungibleToken.Collection}>()
  let metadataViewType = Type<@{ViewResolver.ResolverCollection}>()
  var item: CollectionDisplay? =  nil

    if let type = account.storage.type(at: storagePath) {
      let isResource = type.isSubtype(of: resourceType)
      let isNFTCollection = type.isSubtype(of: collectionType)
      let conformedMetadataViews = type.isSubtype(of: metadataViewType)

      var tokenIDs: [UInt64] = []
      if isNFTCollection && conformedMetadataViews {
        if let collectionRef = account.capabilities.borrow<&{ViewResolver.ResolverCollection, NonFungibleToken.Receiver}>(publicPath) {
          tokenIDs = collectionRef.getIDs()

          // TODO: move to a list
          if tokenIDs.length > 0 {
            let resolver = collectionRef.borrowViewResolver(id: tokenIDs[0])
            if resolver != nil {
                if let display = MetadataViews.getNFTCollectionDisplay(resolver!) {
                item = CollectionDisplay(
                  name: display.name,
                  squareImage: display.squareImage.file.uri(),
                  mediaType: display.squareImage.mediaType
                )
              }
            }
            
          }
        }
      }
    }

  return item
}


access(all) fun main(address: Address, pathID: String): NFTCollection {
  let account = getAccount(address)
  let storagePath = StoragePath(identifier: pathID)!
  let publicPath = PublicPath(identifier: pathID)!
  let collection = account.capabilities.borrow<&{ViewResolver.ResolverCollection}>(publicPath)!
  return NFTCollection(
    id: account.storage.type(at: storagePath)!.identifier,
    path: storagePath.toString(),
    display: getDisplay(address: address, storagePath: storagePath, publicPath: publicPath),
    idList: collection.getIDs()
  )
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/call.cdc

```
import EVM from 0xEVM

access(all)
fun main(hexEncodedData: String, hexEncodedAddress: String): String {
    let account = getAuthAccount<auth(Storage) &Account>(Address(0xCOA))

    let coa = account.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(
        from: /storage/evm
    ) ?? panic("Could not borrow reference to the COA!")
    let addressBytes = hexEncodedAddress.decodeHex().toConstantSized<[UInt8; 20]>()!

    let txResult = coa.call(
        to: EVM.EVMAddress(bytes: addressBytes),
        data: hexEncodedData.decodeHex(),
        gasLimit: 15000000, // todo make it configurable, max for now
        value: EVM.Balance(attoflow: 0)
    )

    assert(
        txResult.status == EVM.Status.failed || txResult.status == EVM.Status.successful,
        message: "evm_error=".concat(txResult.errorMessage).concat("\n")
    )

    return String.encodeHex(callResult.data)
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_node_info.cdc

```
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) fun main(nodeID: String): FlowIDTableStaking.NodeInfo {
  return FlowIDTableStaking.NodeInfo(nodeID: nodeID)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/fund_evm_addr.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

transaction(evmAddr: String, amount: UFix64) {

    // The Vault resource that holds the tokens that are being transfered
    let sentVault: @{FungibleToken.Vault}

    prepare(signer: auth(Storage, BorrowValue) &Account) {
         // Get a reference to the signer's stored vault
        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &<Token>.Vault>(from: <TokenStoragePath>)
            ?? panic("Could not borrow reference to the owner's Vault!")

        // Withdraw tokens from the signer's stored vault
        self.sentVault <- vaultRef.withdraw(amount: amount)
    }

    execute {
        // Get the recipient's public account object
        let recipientAccount = getAccount(recipient)

        // Get a reference to the recipient's Receiver
        let receiverRef = recipientAccount.capabilities.borrow<&{FungibleToken.Receiver}>(<TokenReceiverPath>)!
            
        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.sentVault)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_accessible_collection_and_ids_display.cdc

```
import HybridCustody from 0xHybridCustody
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import FungibleToken from 0xFungibleToken
import NonFungibleToken from 0xNonFungibleToken


access(all) struct CollectionDisplay {
  access(all) let name: String
  access(all) let squareImage: MetadataViews.Media

  init(name: String, squareImage: MetadataViews.Media) {
    self.name = name
    self.squareImage = squareImage
  }
}

access(all) struct NFTCollection {
  access(all) let id: String
  access(all) let display: CollectionDisplay?
  access(all) let idList: [UInt64]

  init(id:String, display: CollectionDisplay?, idList: [UInt64]) {
    self.id = id
    self.display = display
    self.idList = idList
  }
}

access(all) fun getDisplay(address: Address, path: StoragePath): CollectionDisplay? {
  let account = getAuthAccount<auth(Storage, Capabilities) &Account>(address)

  let resourceType = Type<@AnyResource>()
  // let vaultType = Type<@{FungibleToken.Vault}>()
  let collectionType = Type<@{NonFungibleToken.Collection}>()
  let metadataViewType = Type<&{ViewResolver.ResolverCollection}>()
  var item: CollectionDisplay? =  nil

    if let type = account.storage.type(at: path) {
      let isResource = type.isSubtype(of: resourceType)
      let isNFTCollection = type.isSubtype(of: collectionType)
      let conformedMetadataViews = type.isSubtype(of: metadataViewType)

      var tokenIDs: [UInt64] = []
      if isNFTCollection && conformedMetadataViews {
        if let collectionRef = account.storage.borrow<&{ViewResolver.ResolverCollection, NonFungibleToken.CollectionPublic}>(from: path) {
          tokenIDs = collectionRef.getIDs()

          // TODO: move to a list
          if tokenIDs.length > 0 
          && path != /storage/RaribleNFTCollection 
          && path != /storage/ARTIFACTPackV3Collection
          && path != /storage/ArleeScene {
            let resolver = collectionRef.borrowViewResolver(id: tokenIDs[0])!
            if let display = MetadataViews.getNFTCollectionDisplay(resolver) {
              item = CollectionDisplay(
                name: display.name,
                squareImage: display.squareImage
              )
            }
          }
        }
      }
    }

  return item
}

access(all) fun main(parent: Address, childAccount: Address): [NFTCollection] {
    let manager =  getAuthAccount<auth(Storage) &Account>(parent).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")

    // Address -> Collection Type -> ownedNFTs

    let providerType = Type<Capability<&{NonFungibleToken.Provider}>>()
    let collectionType: Type = Type<@{NonFungibleToken.CollectionPublic}>()

    // Iterate through child accounts

    let acct = getAuthAccount<auth(Storage, Capabilities) &Account>(childAccount)
    let foundTypes: [Type] = []
    let nfts: {String: [UInt64]} = {}
    let collectionList: [NFTCollection] = []
    let childAcct = manager.borrowAccount(addr: childAccount) ?? panic("child account not found")
    
    // get all private paths
    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
        // Check which private paths have NFT Provider AND can be borrowed
        // if !type.isSubtype(of: providerType){
        //     return true
        // }
        // if let cap = childAcct.getCapability(path: path, type: Type<&{NonFungibleToken.Provider}>()) {
        //     let providerCap = cap as! Capability<&{NonFungibleToken.Provider}> 

        //     if !providerCap.check(){
        //         // if this isn't a provider capability, exit the account iteration function for this path
        //         return true
        //     }
        //     foundTypes.append(cap.borrow<&AnyResource>()!.getType())
        // }

        let controllers = acct.capabilities.storage.getControllers(forPath: path!)
        for c in controllers {
          if !c.borrowType.isSubtype(of: providerType) {
            continue
          }

          if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: providerType) {
            let providerCap = cap as! Capability<&{NonFungibleToken.Provider}> 

            if !providerCap.check(){
              continue
            }
            foundTypes.append(cap.borrow<&AnyResource>()!.getType())
          }
        }
        return true
    })

    // iterate storage, check if typeIdsWithProvider contains the typeId, if so, add to nfts
    acct.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {

        if foundTypes == nil {
            return true
        }

        for idx, value in foundTypes {
            let value = foundTypes!

            if value[idx] != type {
                continue
            } else {
                if type.isInstance(collectionType) {
                    continue
                }
                if let collection = acct.storage.borrow<&{NonFungibleToken.CollectionPublic}>(from: path) { 
                    nfts.insert(key: type.identifier, collection.getIDs())
                    collectionList.append(
                      NFTCollection(
                        id: type.identifier,
                        display: getDisplay(address: childAccount, path: path),
                        idList: collection.getIDs()
                      )
                    )
                }
                continue
            }
        }
        return true
    })

    return collectionList
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/staking/unstake.cdc

```
 import FlowStakingCollection from 0xFlowStakingCollection

/// Requests unstaking for the specified node or delegator in the staking collection

transaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {
    
    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection

    prepare(account: auth(BorrowValue) &Account) {
        self.stakingCollectionRef = account.storage.borrow<auth(FlowStakingCollection.CollectionOwner) &FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)
            ?? panic("Could not borrow a reference to a StakingCollection in the primary user's account")
    }

    execute {
        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/evm/get_coa_balance.cdc

```
import EVM from 0xEVM

access(all)
fun main(address: Address): UFix64 {
     let account = getAuthAccount<auth(Storage) &Account>(address)

    let coa = account.storage.borrow<&EVM.CadenceOwnedAccount>(
        from: /storage/evm
    ) ?? panic("Could not borrow reference to the COA!")
    
    return coa.balance().inFLOW()
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_stake_info.cdc

```

import FlowStakingCollection from 0xFlowStakingCollection
import FlowIDTableStaking from 0xFlowIDTableStaking
import LockedTokens from 0xLockedTokens

access(all) struct StakeInfo {
    access(all) let id: String
    access(all) let role: UInt8
    access(all) let networkingAddress: String
    access(all) let networkingKey: String
    access(all) let stakingKey: String
    access(all) let tokensStaked: UFix64
    access(all) let totalTokensStaked: UFix64
    access(all) let tokensCommitted: UFix64
    access(all) let tokensUnstaking: UFix64
    access(all) let tokensUnstaked: UFix64
    access(all) let tokensRewarded: UFix64

    access(all) let delegatorsCnt: Int
    access(all) let delegatorIDCounter: UInt32
    access(all) let tokensRequestedToUnstake: UFix64
    access(all) let initialWeight: UInt64

    // Projected Values
    access(all) let nodeID: String
    access(all) let unstakableTokens: UFix64
    access(all) let tokensDelegated: UFix64
    access(all) let restakableUnstakedTokens: UFix64

    access(all) let machineAccountAddress: Address?
    access(all) let machineAccountBalance: UFix64?

    init(nodeInfo: FlowIDTableStaking.NodeInfo, machineAccountInfo: FlowStakingCollection.MachineAccountInfo?) {
        self.id = nodeInfo.id
        self.role = nodeInfo.role
        self.networkingAddress = nodeInfo.networkingAddress
        self.networkingKey = nodeInfo.networkingKey
        self.stakingKey = nodeInfo.stakingKey
        self.tokensStaked = nodeInfo.tokensStaked
        self.totalTokensStaked = nodeInfo.totalStakedWithDelegators()
        self.tokensCommitted = nodeInfo.tokensCommitted
        self.tokensUnstaking = nodeInfo.tokensUnstaking
        self.tokensUnstaked = nodeInfo.tokensUnstaked
        self.tokensRewarded = nodeInfo.tokensRewarded

        self.delegatorsCnt = nodeInfo.delegators.length 
        self.delegatorIDCounter = nodeInfo.delegatorIDCounter
        self.tokensRequestedToUnstake = nodeInfo.tokensRequestedToUnstake
        self.initialWeight = nodeInfo.initialWeight

        // Projected Values
        self.nodeID = nodeInfo.id
        self.unstakableTokens = self.tokensStaked + self.tokensCommitted
        let nodeStakedBalanceWithDelegators = nodeInfo.totalStakedWithDelegators()
        self.tokensDelegated = nodeStakedBalanceWithDelegators - nodeInfo.tokensStaked
        self.restakableUnstakedTokens = self.tokensUnstaked + self.tokensRequestedToUnstake

        if let _machineAccountInfo = machineAccountInfo {
            let _machineAccountAddress = _machineAccountInfo.getAddress()

            let machineAccount = getAccount(_machineAccountAddress)

            self.machineAccountAddress = _machineAccountAddress
            self.machineAccountBalance = machineAccount.balance
        } else {
            self.machineAccountAddress = nil
            self.machineAccountBalance = nil
        }
    }
}

access(all) fun main(account: Address): {String: StakeInfo}? {
    let doesAccountHaveStakingCollection = FlowStakingCollection.doesAccountHaveStakingCollection(address: account)
    if (!doesAccountHaveStakingCollection) {
        return nil
    }

    let formattedNodeInfo: {String: StakeInfo} = {}
    let allNodeInfo: [FlowIDTableStaking.NodeInfo] = FlowStakingCollection.getAllNodeInfo(address: account)
    let machineAccounts: {String: FlowStakingCollection.MachineAccountInfo} = FlowStakingCollection.getMachineAccounts(address: account)

    for nodeInfo in allNodeInfo {
        formattedNodeInfo[nodeInfo.id] = StakeInfo(nodeInfo: nodeInfo, machineAccountInfo: machineAccounts[nodeInfo.id])
    }

    return formattedNodeInfo
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/bridge_child_nft_to_evm_address.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter



transaction(nftIdentifier: String, child: Address, id: UInt64, recipient:String) {
    
    let nft: @{NonFungibleToken.NFT}
    // let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        // self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
        //     ?? panic("Could not borrow COA from provided gateway address")
        
        let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager does not exist")
        let childAcct = m.borrowAccount(addr: child) ?? panic("child account not found")
        
         // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        
        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nil,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")


        let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
        let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
            ?? panic("no controller found for capType")
        
        let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
        let providerCap = cap as! Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>
        assert(providerCap.check(), message: "invalid provider capability")
        
        // Get a reference to the child's stored vault
        let collectionRef = providerCap.borrow()!
        let childNft <- collectionRef.withdraw(withdrawID: id)
        collection.deposit(token: <-childNft)
        // // Withdraw tokens from the signer's stored vault
        let currentStorageUsage = signer.storage.used
        self.nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(
                bytes: 400_000
            )
       
        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        // self.coa.depositNFT(
        //     nft: <-self.nft,
        //     feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        // )
        let recipientEVMAddress = EVM.addressFromString(recipient)
        FlowEVMBridge.bridgeNFTToEVM(
            token: <-self.nft,
            to: recipientEVMAddress,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}

```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_account_min_flow.cdc

```
access(all) fun main(address: Address): UFix64 {
  let account = getAccount(address)
  return account.balance - account.availableBalance
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/transfer_nft_to_child.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xHybridCustody
import NonFungibleToken from 0xNonFungibleToken
import MetadataViews from 0xMetadataViews
import <NFT> from <NFTAddress>

transaction(childAddr: Address, identifier: String, id: UInt64) {
  prepare(signer: auth(Storage) &Account) {
    // signer is the parent account
    // get the manager resource and borrow childAccount
    let m = signer.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager does not exist")
    let childAcct = m.borrowAccount(addr: childAddr) ?? panic("child account not found")
    
    let collectionData = <NFT> .resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?
        ?? panic("Could not get the vault data view for <NFT> ")

    //get Ft cap from child account
    let capType = Type<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>()
    let controllerID = childAcct.getControllerIDForType(type: capType, forPath: collectionData.storagePath)
        ?? panic("no controller found for capType")
    
    let cap = childAcct.getCapability(controllerID: controllerID, type: capType) ?? panic("no cap found")
    let childCap = cap as! Capability<&{NonFungibleToken.CollectionPublic}>
    assert(childCap.check(), message: "invalid provider capability")
    
    let parentRef =  signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from : collectionData.storagePath)!
    let childRef = childCap.borrow()!
    // Withdraw tokens from the signer's stored vault
    let nft <- parentRef!.withdraw(withdrawID: id)!
    
    childRef.deposit(token: <- nft)
  }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_to_evm_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge

/// Bridges an NFT from the signer's collection in Cadence to the signer's COA in FlowEVM
///
/// NOTE: This transaction also onboards the NFT to the bridge if necessary which may incur additional fees
///     than bridging an asset that has already been onboarded.
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The Cadence NFT.id of the NFT to bridge to EVM
///
transaction(nftIdentifier: String, id: UInt64) {
    
    let nft: @{NonFungibleToken.NFT}
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    let requiresOnboarding: Bool
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    
    prepare(signer: auth(CopyValue, BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")
        
        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        let nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Retrieve the NFT --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        let collection = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(
                from: collectionData.storagePath
            ) ?? panic("Could not access signer's NFT Collection")

        // Withdraw the requested NFT & calculate the approximate bridge fee based on NFT storage usage
        let currentStorageUsage = signer.storage.used
        self.nft <- collection.withdraw(withdrawID: id)
        let withdrawnStorageUsage = signer.storage.used
        var approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000) + FlowEVMBridgeConfig.baseFee
        // Determine if the NFT requires onboarding - this impacts the fee required
        self.requiresOnboarding = FlowEVMBridge.typeRequiresOnboarding(self.nft.getType())
            ?? panic("Bridge does not support this asset type")
        if self.requiresOnboarding {
            approxFee = approxFee + FlowEVMBridgeConfig.onboardFee
        }

        /* --- Configure a ScopedFTProvider --- */
        //
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    pre {
        self.nft.getType().identifier == nftIdentifier:
            "Attempting to send invalid nft type - requested: ".concat(nftIdentifier)
            .concat(", sending: ").concat(self.nft.getType().identifier)
    }

    execute {
        if self.requiresOnboarding {
            // Onboard the NFT to the bridge
            FlowEVMBridge.onboardByType(
                self.nft.getType(),
                feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
            )
        }
        // Execute the bridge
        self.coa.depositNFT(
            nft: <-self.nft,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/bridges/bridge_nft_from_evm_to_flow_v2.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xMetadataViews
import NonFungibleToken from 0xNonFungibleToken

import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import FungibleTokenMetadataViews from 0xFungibleToken

import ScopedFTProviders from 0xFlowEVMBridge

import EVM from 0xEVM

import FlowEVMBridgeUtils from 0xFlowEVMBridge
import FlowEVMBridge from 0xFlowEVMBridge
import FlowEVMBridgeConfig from 0xFlowEVMBridge



/// This transaction bridges an NFT from EVM to Cadence assuming it has already been onboarded to the FlowEVMBridge.
/// Also know that the recipient Flow account must have a Receiver capable of receiving the this bridged NFT accessible
/// via published Capability at the token's standard path.
/// NOTE: The ERC721 must have first been onboarded to the bridge. This can be checked via the method
///     FlowEVMBridge.evmAddressRequiresOnboarding(address: self.evmContractAddress)
///
/// @param nftIdentifier: The Cadence type identifier of the NFT to bridge - e.g. nft.getType().identifier
/// @param id: The ERC721 id of the NFT to bridge to Cadence from EVM
/// @param recipient: The Flow account address to receive the bridged NFT
///
transaction(nftIdentifier: String, id: UInt256, recipient: Address) {
    let nftType: Type
    let receiver: &{NonFungibleToken.Receiver}
    let scopedProvider: @ScopedFTProviders.ScopedFTProvider
    let coa: auth(EVM.Bridge) &EVM.CadenceOwnedAccount
    
    prepare(signer: auth(BorrowValue, CopyValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {
        /* --- Reference the signer's CadenceOwnedAccount --- */
        //
        // Borrow a reference to the signer's COA
        self.coa = signer.storage.borrow<auth(EVM.Bridge) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow COA from provided gateway address")

        /* --- Construct the NFT type --- */
        //
        // Construct the NFT type from the provided identifier
        self.nftType = CompositeType(nftIdentifier)
            ?? panic("Could not construct NFT type from identifier: ".concat(nftIdentifier))
        // Parse the NFT identifier into its components
        let nftContractAddress = FlowEVMBridgeUtils.getContractAddress(fromType: self.nftType)
            ?? panic("Could not get contract address from identifier: ".concat(nftIdentifier))
        let nftContractName = FlowEVMBridgeUtils.getContractName(fromType: self.nftType)
            ?? panic("Could not get contract name from identifier: ".concat(nftIdentifier))

        /* --- Reference the recipient's NFT Receiver --- */
        //
        // Borrow a reference to the NFT collection, configuring if necessary
        let viewResolver = getAccount(nftContractAddress).contracts.borrow<&{ViewResolver}>(name: nftContractName)
            ?? panic("Could not borrow ViewResolver from NFT contract")
        let collectionData = viewResolver.resolveContractView(
                resourceType: self.nftType,
                viewType: Type<MetadataViews.NFTCollectionData>()
            ) as! MetadataViews.NFTCollectionData? ?? panic("Could not resolve NFTCollectionData view")
        // Configure the signer's account for this NFT
        if signer.storage.borrow<&{NonFungibleToken.Collection}>(from: collectionData.storagePath) == nil {
            signer.storage.save(<-collectionData.createEmptyCollection(), to: collectionData.storagePath)
            signer.capabilities.unpublish(collectionData.publicPath)
            let collectionCap = signer.capabilities.storage.issue<&{NonFungibleToken.Collection}>(collectionData.storagePath)
            signer.capabilities.publish(collectionCap, at: collectionData.publicPath)
        }
        self.receiver = getAccount(recipient).capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)
            ?? panic("Could not borrow Receiver from recipient's public capability path")

        /* --- Configure a ScopedFTProvider --- */
        //
        // Calculate the bridge fee - bridging from EVM consumes no storage, so flat fee
        let approxFee = FlowEVMBridgeUtils.calculateBridgeFee(bytes: 400_000)
        // Issue and store bridge-dedicated Provider Capability in storage if necessary
        if signer.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {
            let providerCap = signer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(
                /storage/flowTokenVault
            )
            signer.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)
        }
        // Copy the stored Provider capability and create a ScopedFTProvider
        let providerCapCopy = signer.storage.copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(
                from: FlowEVMBridgeConfig.providerCapabilityStoragePath
            ) ?? panic("Invalid Provider Capability found in storage.")
        let providerFilter = ScopedFTProviders.AllowanceFilter(approxFee)
        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(
                provider: providerCapCopy,
                filters: [ providerFilter ],
                expiration: getCurrentBlock().timestamp + 1.0
            )
    }

    execute {
        // Execute the bridge
        let nft: @{NonFungibleToken.NFT} <- self.coa.withdrawNFT(
            type: self.nftType,
            id: id,
            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}
        )
        // Ensure the bridged nft is the correct type
        assert(
            nft.getType() == self.nftType,
            message: "Bridged nft type mismatch - requeswted: ".concat(self.nftType.identifier)
                .concat(", received: ").concat(nft.getType().identifier)
        )
        // Deposit the bridged NFT into the signer's collection
        self.receiver.deposit(token: <-nft)
        // Destroy the ScopedFTProvider
        destroy self.scopedProvider

    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/is_token_storage_enabled.cdc

```
import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>

access(all) fun main(address: Address) : Bool {
    let account = getAccount(address)
   
    let receiver = account.capabilities.exists(<TokenReceiverPath>)
    let balance = account.capabilities.exists(<TokenBalancePath>)

    return receiver && balance
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/get_contract_by_name.cdc

```
access(all) fun main(address: Address, contractName: String): String? {
  let account = getAccount(address)
  let deployedContract = account.contracts.get(name: contractName)

  return String.fromUTF8(deployedContract?.code!)
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/check_child_linked_vaults.cdc

```
import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter
import FungibleToken from 0xFungibleToken

access(all) fun main(parent: Address, child: Address, path: String): Bool {
  let account = getAuthAccount<auth(Storage) &Account>(parent)
  let manager = getAuthAccount<auth(Storage) &Account>(parent).storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) ?? panic ("manager does not exist")
  
  let providerType = Type<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>()

  let addr = getAuthAccount<auth(Storage, Capabilities) &Account>(child)
  
  let childAcct = manager.borrowAccount(addr: child) ?? panic("child account not found")

  let controllers = addr.capabilities.storage.getControllers(forPath: StoragePath(identifier: path)!)
  var flag = false

  for c in controllers {
    if !c.borrowType.isSubtype(of: providerType) {
      continue
    }

    if let cap = childAcct.getCapability(controllerID: c.capabilityID, type: providerType) {
      let providerCap = cap as! Capability<&{FungibleToken.Provider}> 

      if !providerCap.check(){
        continue
      }

      flag = true
      break
    }
  }

  return flag
} 
    
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/bridges/get_associated_flow_identifier.cdc

```
import EVM from 0xEVM
import FlowEVMBridgeConfig from 0xFlowEVMBridge

access(all)
fun main(address: String): String? {
    if let typeInfo = FlowEVMBridgeConfig.getTypeAssociated(with: EVM.addressFromString(address)) {
        return typeInfo.identifier
    }
    return nil
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/hybridCustody/get_child_account_meta.cdc

```
import HybridCustody from 0xHybridCustody
import MetadataViews from 0xMetadataViews

access(all) fun main(parent: Address): {Address: AnyStruct} {
    let acct = getAuthAccount<auth(Storage) &Account>(parent)
    let m = acct.storage.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)

    if m == nil {
        return {}
    } else {
        var data: {Address: AnyStruct} = {}
        for address in m?.getChildAddresses()! {
            let c = m?.getChildAccountDisplay(address: address) 
            data.insert(key: address, c)
        }
        return data
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/evm/call_contract.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken
import EVM from 0xEVM

/// Transfers $FLOW from the signer's account Cadence Flow balance to the recipient's hex-encoded EVM address.
/// Note that a COA must have a $FLOW balance in EVM before transferring value to another EVM address.
///
transaction(toEVMAddressHex: String, amount: UFix64, data: [UInt8], gasLimit: UInt64) {

    let coa: auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount
    let recipientEVMAddress: EVM.EVMAddress

    prepare(signer: auth(BorrowValue, SaveValue) &Account) {
        if signer.storage.type(at: /storage/evm) == nil {
            signer.storage.save(<-EVM.createCadenceOwnedAccount(), to: /storage/evm)
        }
        self.coa = signer.storage.borrow<auth(EVM.Withdraw, EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)
            ?? panic("Could not borrow reference to the signer's bridged account")

        self.recipientEVMAddress = EVM.addressFromString(toEVMAddressHex)
    }

    execute {
        if self.recipientEVMAddress.bytes == self.coa.address().bytes {
            return
        }
        let valueBalance = EVM.Balance(attoflow: 0)
        valueBalance.setFLOW(flow: amount)
        let txResult = self.coa.call(
            to: self.recipientEVMAddress,
            data: data,
            gasLimit: gasLimit,
            value: valueBalance
        )
        assert(
            txResult.status == EVM.Status.failed || txResult.status == EVM.Status.successful,
            message: "evm_error=".concat(txResult.errorMessage).concat("\n")
        )
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/ft/add_token.cdc

```
import FungibleToken from 0xFungibleToken
import <Token> from <TokenAddress>

transaction {

    prepare(signer: auth(Storage, Capabilities) &Account) {

        if signer.storage.borrow<&<Token>.Vault>(from: <TokenStoragePath> ) == nil {
            signer.storage.save(<- <Token>.createEmptyVault(vaultType: Type<@<Token>.Vault>()), to: <TokenStoragePath>)
        }

        if signer.capabilities.exists(<TokenReceiverPath>) == false {
            let receiverCapability = signer.capabilities.storage.issue<&<Token>.Vault>(<TokenStoragePath>)
            signer.capabilities.publish(receiverCapability, at: <TokenReceiverPath>)
        
        }
       
        if signer.capabilities.exists(<TokenBalancePath>) == false {
            let balanceCapability = signer.capabilities.storage.issue<&<Token>.Vault>(<TokenStoragePath>)
            signer.capabilities.publish(balanceCapability, at: <TokenBalancePath>)
        }
    
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/basic/query_flow_balance.cdc

```
import FungibleToken from 0xFungibleToken
import FlowToken from 0xFlowToken

access(all) fun checkFlowTokenBalance(address: Address) : UFix64 {
    let account = getAccount(address)
    let vaultRef = account.capabilities.borrow<&{FungibleToken.Balance}>(/public/flowTokenBalance)
    ?? nil

    
    if vaultRef != nil {
        return vaultRef!.balance
    }
    
    return 0.0
}

access(all) fun main(addrs: [Address]): [UFix64] {
    let bals: [UFix64] = []

    for addr in addrs {
        let bal = checkFlowTokenBalance(address: addr)
        bals.append(bal)
    }
    
    return bals
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/transactions/src/cadence/hybridCustody/redeem_account.cdc

```
import MetadataViews from 0xMetadataViews
import ViewResolver from 0xViewResolver

import HybridCustody from 0xHybridCustody
import CapabilityFilter from 0xCapabilityFilter

transaction(childAddress: Address, filterAddress: Address?, filterPath: PublicPath?) {
    prepare(acct: auth(Storage, Capabilities, Inbox) &Account) {
        var filter: Capability<&{CapabilityFilter.Filter}>? = nil
        if filterAddress != nil && filterPath != nil {
            filter = getAccount(filterAddress!).capabilities.get<&{CapabilityFilter.Filter}>(filterPath!)
        }

        if acct.storage.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {
            let m <- HybridCustody.createManager(filter: filter)
            acct.storage.save(<- m, to: HybridCustody.ManagerStoragePath)

            for c in acct.capabilities.storage.getControllers(forPath: HybridCustody.ManagerStoragePath) {
                c.delete()
            }

            acct.capabilities.unpublish(HybridCustody.ManagerPublicPath)

            acct.capabilities.publish(
                acct.capabilities.storage.issue<&{HybridCustody.ManagerPublic}>(HybridCustody.ManagerStoragePath),
                at: HybridCustody.ManagerPublicPath
            )

            acct.capabilities.storage.issue<auth(HybridCustody.Manage) &{HybridCustody.ManagerPrivate, HybridCustody.ManagerPublic}>(HybridCustody.ManagerStoragePath)
        }

        let inboxName = HybridCustody.getChildAccountIdentifier(acct.address)
        let cap = acct.inbox.claim<auth(HybridCustody.Child) &{HybridCustody.AccountPrivate, HybridCustody.AccountPublic, ViewResolver.Resolver}>(inboxName, provider: childAddress)
            ?? panic("child account cap not found")

        let manager = acct.storage.borrow<auth(HybridCustody.Manage) &HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager no found")

        manager.addAccount(cap: cap)
    }
}
```




---

------------ FILE_DIVIDER ------------

---




# Source: https://github.com/Outblock/FRW-scripts/blob/main/scripts/src/cadence/staking/get_apy_weekly.cdc

```
import FlowIDTableStaking from 0xFlowIDTableStaking

access(all) fun main(): UFix64 {
    let apr = FlowIDTableStaking.getEpochTokenPayout() / FlowIDTableStaking.getTotalStaked() * 54.0 * (1.0 - FlowIDTableStaking.getRewardCutPercentage())
    return apr
}
```




---

------------ FILE_DIVIDER ------------

---




